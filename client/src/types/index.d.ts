export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** The day, does not include a time. */
  Date: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any;
};

export type AgendaItem = Node & {
  __typename?: 'AgendaItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  content: Scalars['String'];
  itemDate: Scalars['Date'];
  sortOrder: Scalars['Int'];
};

/**
 * A condition to be used against `AgendaItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AgendaItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `content` field. */
  content?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `itemDate` field. */
  itemDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `AgendaItem` object types. All fields are combined with a logical ‘and.’ */
export type AgendaItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `itemDate` field. */
  itemDate?: Maybe<DateFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AgendaItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AgendaItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<AgendaItemFilter>;
};

/** An input for mutations affecting `AgendaItem` */
export type AgendaItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  content: Scalars['String'];
  itemDate: Scalars['Date'];
  sortOrder: Scalars['Int'];
};

/** Represents an update to a `AgendaItem`. Fields that are set will be updated. */
export type AgendaItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  content?: Maybe<Scalars['String']>;
  itemDate?: Maybe<Scalars['Date']>;
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `AgendaItem` values. */
export type AgendaItemsConnection = {
  __typename?: 'AgendaItemsConnection';
  /** A list of `AgendaItem` objects. */
  nodes: Array<Maybe<AgendaItem>>;
  /** A list of edges which contains the `AgendaItem` and cursor to aid in pagination. */
  edges: Array<AgendaItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgendaItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AgendaItem` edge in the connection. */
export type AgendaItemsEdge = {
  __typename?: 'AgendaItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AgendaItem` at the end of the edge. */
  node?: Maybe<AgendaItem>;
};

/** Methods to use when ordering `AgendaItem`. */
export enum AgendaItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  ItemDateAsc = 'ITEM_DATE_ASC',
  ItemDateDesc = 'ITEM_DATE_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `batchCreateChileDepartureInspectionPallet` mutation. */
export type BatchCreateChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<ChileDepartureInspectionPalletInput>>;
};

/** The output of our `batchCreateChileDepartureInspectionPallet` mutation. */
export type BatchCreateChileDepartureInspectionPalletPayload = {
  __typename?: 'BatchCreateChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  chileDepartureInspectionPallets?: Maybe<Array<Maybe<ChileDepartureInspectionPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaApplePallet` mutation. */
export type BatchCreatePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaApplePalletInput>>;
};

/** The output of our `batchCreatePsaApplePallet` mutation. */
export type BatchCreatePsaApplePalletPayload = {
  __typename?: 'BatchCreatePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaApplePallets?: Maybe<Array<Maybe<PsaApplePallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaCherryPallet` mutation. */
export type BatchCreatePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaCherryPalletInput>>;
};

/** The output of our `batchCreatePsaCherryPallet` mutation. */
export type BatchCreatePsaCherryPalletPayload = {
  __typename?: 'BatchCreatePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaCherryPallets?: Maybe<Array<Maybe<PsaCherryPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaCitrusPallet` mutation. */
export type BatchCreatePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaCitrusPalletInput>>;
};

/** The output of our `batchCreatePsaCitrusPallet` mutation. */
export type BatchCreatePsaCitrusPalletPayload = {
  __typename?: 'BatchCreatePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaCitrusPallets?: Maybe<Array<Maybe<PsaCitrusPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaGrapePallet` mutation. */
export type BatchCreatePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaGrapePalletInput>>;
};

/** The output of our `batchCreatePsaGrapePallet` mutation. */
export type BatchCreatePsaGrapePalletPayload = {
  __typename?: 'BatchCreatePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaGrapePallets?: Maybe<Array<Maybe<PsaGrapePallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaLemonPallet` mutation. */
export type BatchCreatePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaLemonPalletInput>>;
};

/** The output of our `batchCreatePsaLemonPallet` mutation. */
export type BatchCreatePsaLemonPalletPayload = {
  __typename?: 'BatchCreatePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaLemonPallets?: Maybe<Array<Maybe<PsaLemonPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaPearPallet` mutation. */
export type BatchCreatePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaPearPalletInput>>;
};

/** The output of our `batchCreatePsaPearPallet` mutation. */
export type BatchCreatePsaPearPalletPayload = {
  __typename?: 'BatchCreatePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaPearPallets?: Maybe<Array<Maybe<PsaPearPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaPersimmonPallet` mutation. */
export type BatchCreatePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaPersimmonPalletInput>>;
};

/** The output of our `batchCreatePsaPersimmonPallet` mutation. */
export type BatchCreatePsaPersimmonPalletPayload = {
  __typename?: 'BatchCreatePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaPersimmonPallets?: Maybe<Array<Maybe<PsaPersimmonPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaPomegranatePallet` mutation. */
export type BatchCreatePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaPomegranatePalletInput>>;
};

/** The output of our `batchCreatePsaPomegranatePallet` mutation. */
export type BatchCreatePsaPomegranatePalletPayload = {
  __typename?: 'BatchCreatePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaPomegranatePallets?: Maybe<Array<Maybe<PsaPomegranatePallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `batchCreatePsaStoneFruitPallet` mutation. */
export type BatchCreatePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  newPallets: Array<Maybe<PsaStoneFruitPalletInput>>;
};

/** The output of our `batchCreatePsaStoneFruitPallet` mutation. */
export type BatchCreatePsaStoneFruitPalletPayload = {
  __typename?: 'BatchCreatePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  psaStoneFruitPallets?: Maybe<Array<Maybe<PsaStoneFruitPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigFloat']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigFloat']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigFloat']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigFloat']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
};


/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigInt']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigInt']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigInt']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigInt']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigInt']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
};

/** All input for the `bulkAddContactsToGroup` mutation. */
export type BulkAddContactsToGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  items: Array<Maybe<ContactGroupPersonContactInput>>;
};

/** The output of our `bulkAddContactsToGroup` mutation. */
export type BulkAddContactsToGroupPayload = {
  __typename?: 'BulkAddContactsToGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  contactGroupPersonContacts?: Maybe<Array<Maybe<ContactGroupPersonContact>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkCreateUserMessage` mutation. */
export type BulkCreateUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  messages: Array<Maybe<UserMessageInput>>;
};

/** The output of our `bulkCreateUserMessage` mutation. */
export type BulkCreateUserMessagePayload = {
  __typename?: 'BulkCreateUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  userMessages?: Maybe<Array<Maybe<UserMessage>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteActiveInventoryItem` mutation. */
export type BulkDeleteActiveInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteActiveInventoryItem` mutation. */
export type BulkDeleteActiveInventoryItemPayload = {
  __typename?: 'BulkDeleteActiveInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteCheckHeader` mutation. */
export type BulkDeleteCheckHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteCheckHeader` mutation. */
export type BulkDeleteCheckHeaderPayload = {
  __typename?: 'BulkDeleteCheckHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteCountry` mutation. */
export type BulkDeleteCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteCountry` mutation. */
export type BulkDeleteCountryPayload = {
  __typename?: 'BulkDeleteCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteCustomer` mutation. */
export type BulkDeleteCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteCustomer` mutation. */
export type BulkDeleteCustomerPayload = {
  __typename?: 'BulkDeleteCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteCustomerPayment` mutation. */
export type BulkDeleteCustomerPaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteCustomerPayment` mutation. */
export type BulkDeleteCustomerPaymentPayload = {
  __typename?: 'BulkDeleteCustomerPaymentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteCustomerProgram` mutation. */
export type BulkDeleteCustomerProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteCustomerProgram` mutation. */
export type BulkDeleteCustomerProgramPayload = {
  __typename?: 'BulkDeleteCustomerProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteCustomerVolumeDiscount` mutation. */
export type BulkDeleteCustomerVolumeDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteCustomerVolumeDiscount` mutation. */
export type BulkDeleteCustomerVolumeDiscountPayload = {
  __typename?: 'BulkDeleteCustomerVolumeDiscountPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteExpenseHeader` mutation. */
export type BulkDeleteExpenseHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteExpenseHeader` mutation. */
export type BulkDeleteExpenseHeaderPayload = {
  __typename?: 'BulkDeleteExpenseHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteExpenseItem` mutation. */
export type BulkDeleteExpenseItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteExpenseItem` mutation. */
export type BulkDeleteExpenseItemPayload = {
  __typename?: 'BulkDeleteExpenseItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteInventoryItem` mutation. */
export type BulkDeleteInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteInventoryItem` mutation. */
export type BulkDeleteInventoryItemPayload = {
  __typename?: 'BulkDeleteInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteInvoiceHeader` mutation. */
export type BulkDeleteInvoiceHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteInvoiceHeader` mutation. */
export type BulkDeleteInvoiceHeaderPayload = {
  __typename?: 'BulkDeleteInvoiceHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteInvoiceItemHistory` mutation. */
export type BulkDeleteInvoiceItemHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteInvoiceItemHistory` mutation. */
export type BulkDeleteInvoiceItemHistoryPayload = {
  __typename?: 'BulkDeleteInvoiceItemHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteInvoiceItem` mutation. */
export type BulkDeleteInvoiceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteInvoiceItem` mutation. */
export type BulkDeleteInvoiceItemPayload = {
  __typename?: 'BulkDeleteInvoiceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteOrderComment` mutation. */
export type BulkDeleteOrderCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteOrderComment` mutation. */
export type BulkDeleteOrderCommentPayload = {
  __typename?: 'BulkDeleteOrderCommentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteOrderItem` mutation. */
export type BulkDeleteOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteOrderItem` mutation. */
export type BulkDeleteOrderItemPayload = {
  __typename?: 'BulkDeleteOrderItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteOrderMaster` mutation. */
export type BulkDeleteOrderMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteOrderMaster` mutation. */
export type BulkDeleteOrderMasterPayload = {
  __typename?: 'BulkDeleteOrderMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteOrderPallet` mutation. */
export type BulkDeleteOrderPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteOrderPallet` mutation. */
export type BulkDeleteOrderPalletPayload = {
  __typename?: 'BulkDeleteOrderPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeletePackMaster` mutation. */
export type BulkDeletePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeletePackMaster` mutation. */
export type BulkDeletePackMasterPayload = {
  __typename?: 'BulkDeletePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeletePallet` mutation. */
export type BulkDeletePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeletePallet` mutation. */
export type BulkDeletePalletPayload = {
  __typename?: 'BulkDeletePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeletePalletSection` mutation. */
export type BulkDeletePalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeletePalletSection` mutation. */
export type BulkDeletePalletSectionPayload = {
  __typename?: 'BulkDeletePalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteProductMaster` mutation. */
export type BulkDeleteProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteProductMaster` mutation. */
export type BulkDeleteProductMasterPayload = {
  __typename?: 'BulkDeleteProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteProductSize` mutation. */
export type BulkDeleteProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteProductSize` mutation. */
export type BulkDeleteProductSizePayload = {
  __typename?: 'BulkDeleteProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteProductSpecies` mutation. */
export type BulkDeleteProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteProductSpecies` mutation. */
export type BulkDeleteProductSpeciesPayload = {
  __typename?: 'BulkDeleteProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteProductVariety` mutation. */
export type BulkDeleteProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteProductVariety` mutation. */
export type BulkDeleteProductVarietyPayload = {
  __typename?: 'BulkDeleteProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteRepackHeader` mutation. */
export type BulkDeleteRepackHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteRepackHeader` mutation. */
export type BulkDeleteRepackHeaderPayload = {
  __typename?: 'BulkDeleteRepackHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteRepackItem` mutation. */
export type BulkDeleteRepackItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteRepackItem` mutation. */
export type BulkDeleteRepackItemPayload = {
  __typename?: 'BulkDeleteRepackItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteRepackQueue` mutation. */
export type BulkDeleteRepackQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteRepackQueue` mutation. */
export type BulkDeleteRepackQueuePayload = {
  __typename?: 'BulkDeleteRepackQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteRepackStyle` mutation. */
export type BulkDeleteRepackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteRepackStyle` mutation. */
export type BulkDeleteRepackStylePayload = {
  __typename?: 'BulkDeleteRepackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteShipper` mutation. */
export type BulkDeleteShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteShipper` mutation. */
export type BulkDeleteShipperPayload = {
  __typename?: 'BulkDeleteShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteShipperProgramEntryCustomerProgramEntry` mutation. */
export type BulkDeleteShipperProgramEntryCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteShipperProgramEntryCustomerProgramEntry` mutation. */
export type BulkDeleteShipperProgramEntryCustomerProgramEntryPayload = {
  __typename?: 'BulkDeleteShipperProgramEntryCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteShipperProgram` mutation. */
export type BulkDeleteShipperProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteShipperProgram` mutation. */
export type BulkDeleteShipperProgramPayload = {
  __typename?: 'BulkDeleteShipperProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteShipperProjectionEntry` mutation. */
export type BulkDeleteShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteShipperProjectionEntry` mutation. */
export type BulkDeleteShipperProjectionEntryPayload = {
  __typename?: 'BulkDeleteShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteTruckLoad` mutation. */
export type BulkDeleteTruckLoadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigFloat']>>;
};

/** The output of our `bulkDeleteTruckLoad` mutation. */
export type BulkDeleteTruckLoadPayload = {
  __typename?: 'BulkDeleteTruckLoadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteVendor` mutation. */
export type BulkDeleteVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteVendor` mutation. */
export type BulkDeleteVendorPayload = {
  __typename?: 'BulkDeleteVendorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteVessel` mutation. */
export type BulkDeleteVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['BigInt']>>;
};

/** The output of our `bulkDeleteVessel` mutation. */
export type BulkDeleteVesselPayload = {
  __typename?: 'BulkDeleteVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkDeleteWarehouse` mutation. */
export type BulkDeleteWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  idsToDelete: Array<Maybe<Scalars['String']>>;
};

/** The output of our `bulkDeleteWarehouse` mutation. */
export type BulkDeleteWarehousePayload = {
  __typename?: 'BulkDeleteWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  strings?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkRemoveContactGroupPersonContact` mutation. */
export type BulkRemoveContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  items: Array<Maybe<ContactGroupPersonContactInput>>;
};

/** The output of our `bulkRemoveContactGroupPersonContact` mutation. */
export type BulkRemoveContactGroupPersonContactPayload = {
  __typename?: 'BulkRemoveContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  contactGroupPersonContacts?: Maybe<Array<Maybe<ContactGroupPersonContact>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertAgendaItem` mutation. */
export type BulkUpsertAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  items: Array<Maybe<AgendaItemInput>>;
};

/** The output of our `bulkUpsertAgendaItem` mutation. */
export type BulkUpsertAgendaItemPayload = {
  __typename?: 'BulkUpsertAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  agendaItems?: Maybe<Array<Maybe<AgendaItem>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertCheckHeader` mutation. */
export type BulkUpsertCheckHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  checkHeaders: Array<Maybe<CheckHeaderInput>>;
};

/** The output of our `bulkUpsertCheckHeader` mutation. */
export type BulkUpsertCheckHeaderPayload = {
  __typename?: 'BulkUpsertCheckHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  checkHeaders?: Maybe<Array<Maybe<CheckHeader>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertContainer` mutation. */
export type BulkUpsertContainerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  containers: Array<Maybe<ContainerInput>>;
};

/** The output of our `bulkUpsertContainer` mutation. */
export type BulkUpsertContainerPayload = {
  __typename?: 'BulkUpsertContainerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  containers?: Maybe<Array<Maybe<Container>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertCountry` mutation. */
export type BulkUpsertCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  countries: Array<Maybe<CountryInput>>;
};

/** The output of our `bulkUpsertCountry` mutation. */
export type BulkUpsertCountryPayload = {
  __typename?: 'BulkUpsertCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  countries?: Maybe<Array<Maybe<Country>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertCustomer` mutation. */
export type BulkUpsertCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customers: Array<Maybe<CustomerInput>>;
};

/** The output of our `bulkUpsertCustomer` mutation. */
export type BulkUpsertCustomerPayload = {
  __typename?: 'BulkUpsertCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customers?: Maybe<Array<Maybe<Customer>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertCustomerPayment` mutation. */
export type BulkUpsertCustomerPaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerPayments: Array<Maybe<CustomerPaymentInput>>;
};

/** The output of our `bulkUpsertCustomerPayment` mutation. */
export type BulkUpsertCustomerPaymentPayload = {
  __typename?: 'BulkUpsertCustomerPaymentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerPayments?: Maybe<Array<Maybe<CustomerPayment>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertCustomerProgramEntry` mutation. */
export type BulkUpsertCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  entries: Array<Maybe<CustomerProgramEntryInput>>;
};

/** The output of our `bulkUpsertCustomerProgramEntry` mutation. */
export type BulkUpsertCustomerProgramEntryPayload = {
  __typename?: 'BulkUpsertCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerProgramEntries?: Maybe<Array<Maybe<CustomerProgramEntry>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertCustomerProgram` mutation. */
export type BulkUpsertCustomerProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  programs: Array<Maybe<CustomerProgramInput>>;
};

/** The output of our `bulkUpsertCustomerProgram` mutation. */
export type BulkUpsertCustomerProgramPayload = {
  __typename?: 'BulkUpsertCustomerProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerPrograms?: Maybe<Array<Maybe<CustomerProgram>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertCustomerVolumeDiscount` mutation. */
export type BulkUpsertCustomerVolumeDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerVolumeDiscounts: Array<Maybe<CustomerVolumeDiscountInput>>;
};

/** The output of our `bulkUpsertCustomerVolumeDiscount` mutation. */
export type BulkUpsertCustomerVolumeDiscountPayload = {
  __typename?: 'BulkUpsertCustomerVolumeDiscountPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerVolumeDiscounts?: Maybe<Array<Maybe<CustomerVolumeDiscount>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertExpenseHeader` mutation. */
export type BulkUpsertExpenseHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  expenseHeaders: Array<Maybe<ExpenseHeaderInput>>;
};

/** The output of our `bulkUpsertExpenseHeader` mutation. */
export type BulkUpsertExpenseHeaderPayload = {
  __typename?: 'BulkUpsertExpenseHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  expenseHeaders?: Maybe<Array<Maybe<ExpenseHeader>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertExpenseHeaderReview` mutation. */
export type BulkUpsertExpenseHeaderReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  reviews: Array<Maybe<ExpenseHeaderReviewInput>>;
};

/** The output of our `bulkUpsertExpenseHeaderReview` mutation. */
export type BulkUpsertExpenseHeaderReviewPayload = {
  __typename?: 'BulkUpsertExpenseHeaderReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  expenseHeaderReviews?: Maybe<Array<Maybe<ExpenseHeaderReview>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertExpenseItem` mutation. */
export type BulkUpsertExpenseItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  expenseItems: Array<Maybe<ExpenseItemInput>>;
};

/** The output of our `bulkUpsertExpenseItem` mutation. */
export type BulkUpsertExpenseItemPayload = {
  __typename?: 'BulkUpsertExpenseItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  expenseItems?: Maybe<Array<Maybe<ExpenseItem>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertInventoryItem` mutation. */
export type BulkUpsertInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  inventoryItems: Array<Maybe<InventoryItemInput>>;
};

/** The output of our `bulkUpsertInventoryItem` mutation. */
export type BulkUpsertInventoryItemPayload = {
  __typename?: 'BulkUpsertInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  inventoryItems?: Maybe<Array<Maybe<InventoryItem>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertInvoiceHeader` mutation. */
export type BulkUpsertInvoiceHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  invoiceHeaders: Array<Maybe<InvoiceHeaderInput>>;
};

/** The output of our `bulkUpsertInvoiceHeader` mutation. */
export type BulkUpsertInvoiceHeaderPayload = {
  __typename?: 'BulkUpsertInvoiceHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  invoiceHeaders?: Maybe<Array<Maybe<InvoiceHeader>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertInvoiceItemHistory` mutation. */
export type BulkUpsertInvoiceItemHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  invoiceItemHistories: Array<Maybe<InvoiceItemHistoryInput>>;
};

/** The output of our `bulkUpsertInvoiceItemHistory` mutation. */
export type BulkUpsertInvoiceItemHistoryPayload = {
  __typename?: 'BulkUpsertInvoiceItemHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  invoiceItemHistories?: Maybe<Array<Maybe<InvoiceItemHistory>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertInvoiceItem` mutation. */
export type BulkUpsertInvoiceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  invoiceItems: Array<Maybe<InvoiceItemInput>>;
};

/** The output of our `bulkUpsertInvoiceItem` mutation. */
export type BulkUpsertInvoiceItemPayload = {
  __typename?: 'BulkUpsertInvoiceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  invoiceItems?: Maybe<Array<Maybe<InvoiceItem>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertLoadNumber` mutation. */
export type BulkUpsertLoadNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  loadNumbers: Array<Maybe<LoadNumberInput>>;
  coast: Scalars['String'];
};

/** The output of our `bulkUpsertLoadNumber` mutation. */
export type BulkUpsertLoadNumberPayload = {
  __typename?: 'BulkUpsertLoadNumberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  loadNumbers?: Maybe<Array<Maybe<LoadNumber>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertOrderComment` mutation. */
export type BulkUpsertOrderCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderComments: Array<Maybe<OrderCommentInput>>;
};

/** The output of our `bulkUpsertOrderComment` mutation. */
export type BulkUpsertOrderCommentPayload = {
  __typename?: 'BulkUpsertOrderCommentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderComments?: Maybe<Array<Maybe<OrderComment>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertOrderItem` mutation. */
export type BulkUpsertOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderItems: Array<Maybe<OrderItemInput>>;
};

/** The output of our `bulkUpsertOrderItem` mutation. */
export type BulkUpsertOrderItemPayload = {
  __typename?: 'BulkUpsertOrderItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderItems?: Maybe<Array<Maybe<OrderItem>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertOrderMaster` mutation. */
export type BulkUpsertOrderMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderMasters: Array<Maybe<OrderMasterInput>>;
};

/** The output of our `bulkUpsertOrderMaster` mutation. */
export type BulkUpsertOrderMasterPayload = {
  __typename?: 'BulkUpsertOrderMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderMasters?: Maybe<Array<Maybe<OrderMaster>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertOrderPallet` mutation. */
export type BulkUpsertOrderPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderPallets: Array<Maybe<OrderPalletInput>>;
};

/** The output of our `bulkUpsertOrderPallet` mutation. */
export type BulkUpsertOrderPalletPayload = {
  __typename?: 'BulkUpsertOrderPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  orderPallets?: Maybe<Array<Maybe<OrderPallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackAtmosphere` mutation. */
export type BulkUpsertPackAtmosphereInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packAtmospheres: Array<Maybe<PackAtmosphereInput>>;
};

/** The output of our `bulkUpsertPackAtmosphere` mutation. */
export type BulkUpsertPackAtmospherePayload = {
  __typename?: 'BulkUpsertPackAtmospherePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packAtmospheres?: Maybe<Array<Maybe<PackAtmosphere>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackBoxStyle` mutation. */
export type BulkUpsertPackBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packBoxStyles: Array<Maybe<PackBoxStyleInput>>;
};

/** The output of our `bulkUpsertPackBoxStyle` mutation. */
export type BulkUpsertPackBoxStylePayload = {
  __typename?: 'BulkUpsertPackBoxStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packBoxStyles?: Maybe<Array<Maybe<PackBoxStyle>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackBoxType` mutation. */
export type BulkUpsertPackBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packBoxTypes: Array<Maybe<PackBoxTypeInput>>;
};

/** The output of our `bulkUpsertPackBoxType` mutation. */
export type BulkUpsertPackBoxTypePayload = {
  __typename?: 'BulkUpsertPackBoxTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packBoxTypes?: Maybe<Array<Maybe<PackBoxType>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackDestination` mutation. */
export type BulkUpsertPackDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packDestinations: Array<Maybe<PackDestinationInput>>;
};

/** The output of our `bulkUpsertPackDestination` mutation. */
export type BulkUpsertPackDestinationPayload = {
  __typename?: 'BulkUpsertPackDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packDestinations?: Maybe<Array<Maybe<PackDestination>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackGrade` mutation. */
export type BulkUpsertPackGradeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packGrades: Array<Maybe<PackGradeInput>>;
};

/** The output of our `bulkUpsertPackGrade` mutation. */
export type BulkUpsertPackGradePayload = {
  __typename?: 'BulkUpsertPackGradePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packGrades?: Maybe<Array<Maybe<PackGrade>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackHold` mutation. */
export type BulkUpsertPackHoldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packHolds: Array<Maybe<PackHoldInput>>;
};

/** The output of our `bulkUpsertPackHold` mutation. */
export type BulkUpsertPackHoldPayload = {
  __typename?: 'BulkUpsertPackHoldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packHolds?: Maybe<Array<Maybe<PackHold>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackLabel` mutation. */
export type BulkUpsertPackLabelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packLabels: Array<Maybe<PackLabelInput>>;
};

/** The output of our `bulkUpsertPackLabel` mutation. */
export type BulkUpsertPackLabelPayload = {
  __typename?: 'BulkUpsertPackLabelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packLabels?: Maybe<Array<Maybe<PackLabel>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackLiner` mutation. */
export type BulkUpsertPackLinerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packLiners: Array<Maybe<PackLinerInput>>;
};

/** The output of our `bulkUpsertPackLiner` mutation. */
export type BulkUpsertPackLinerPayload = {
  __typename?: 'BulkUpsertPackLinerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packLiners?: Maybe<Array<Maybe<PackLiner>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackMaster` mutation. */
export type BulkUpsertPackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packMasters: Array<Maybe<PackMasterInput>>;
};

/** The output of our `bulkUpsertPackMaster` mutation. */
export type BulkUpsertPackMasterPayload = {
  __typename?: 'BulkUpsertPackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packMasters?: Maybe<Array<Maybe<PackMaster>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackOut` mutation. */
export type BulkUpsertPackOutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packOuts: Array<Maybe<PackOutInput>>;
};

/** The output of our `bulkUpsertPackOut` mutation. */
export type BulkUpsertPackOutPayload = {
  __typename?: 'BulkUpsertPackOutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packOuts?: Maybe<Array<Maybe<PackOut>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackPalletType` mutation. */
export type BulkUpsertPackPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packPalletTypes: Array<Maybe<PackPalletTypeInput>>;
};

/** The output of our `bulkUpsertPackPalletType` mutation. */
export type BulkUpsertPackPalletTypePayload = {
  __typename?: 'BulkUpsertPackPalletTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packPalletTypes?: Maybe<Array<Maybe<PackPalletType>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackProduction` mutation. */
export type BulkUpsertPackProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packProductions: Array<Maybe<PackProductionInput>>;
};

/** The output of our `bulkUpsertPackProduction` mutation. */
export type BulkUpsertPackProductionPayload = {
  __typename?: 'BulkUpsertPackProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packProductions?: Maybe<Array<Maybe<PackProduction>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackSpecial` mutation. */
export type BulkUpsertPackSpecialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packSpecials: Array<Maybe<PackSpecialInput>>;
};

/** The output of our `bulkUpsertPackSpecial` mutation. */
export type BulkUpsertPackSpecialPayload = {
  __typename?: 'BulkUpsertPackSpecialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packSpecials?: Maybe<Array<Maybe<PackSpecial>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackStyle` mutation. */
export type BulkUpsertPackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packStyles: Array<Maybe<PackStyleInput>>;
};

/** The output of our `bulkUpsertPackStyle` mutation. */
export type BulkUpsertPackStylePayload = {
  __typename?: 'BulkUpsertPackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packStyles?: Maybe<Array<Maybe<PackStyle>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPackTreeRipe` mutation. */
export type BulkUpsertPackTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packTreeRipes: Array<Maybe<PackTreeRipeInput>>;
};

/** The output of our `bulkUpsertPackTreeRipe` mutation. */
export type BulkUpsertPackTreeRipePayload = {
  __typename?: 'BulkUpsertPackTreeRipePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  packTreeRipes?: Maybe<Array<Maybe<PackTreeRipe>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPallet` mutation. */
export type BulkUpsertPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  pallets: Array<Maybe<PalletInput>>;
};

/** The output of our `bulkUpsertPallet` mutation. */
export type BulkUpsertPalletPayload = {
  __typename?: 'BulkUpsertPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  pallets?: Maybe<Array<Maybe<Pallet>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPalletSection` mutation. */
export type BulkUpsertPalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  palletSections: Array<Maybe<PalletSectionInput>>;
};

/** The output of our `bulkUpsertPalletSection` mutation. */
export type BulkUpsertPalletSectionPayload = {
  __typename?: 'BulkUpsertPalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  palletSections?: Maybe<Array<Maybe<PalletSection>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceCategory` mutation. */
export type BulkUpsertPriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  categories: Array<Maybe<PriceCategoryInput>>;
};

/** The output of our `bulkUpsertPriceCategory` mutation. */
export type BulkUpsertPriceCategoryPayload = {
  __typename?: 'BulkUpsertPriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceCategories?: Maybe<Array<Maybe<PriceCategory>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceEntry` mutation. */
export type BulkUpsertPriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  entries: Array<Maybe<PriceEntryInput>>;
};

/** The output of our `bulkUpsertPriceEntry` mutation. */
export type BulkUpsertPriceEntryPayload = {
  __typename?: 'BulkUpsertPriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceEntries?: Maybe<Array<Maybe<PriceEntry>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceProduct` mutation. */
export type BulkUpsertPriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  products: Array<Maybe<PriceProductInput>>;
};

/** The output of our `bulkUpsertPriceProduct` mutation. */
export type BulkUpsertPriceProductPayload = {
  __typename?: 'BulkUpsertPriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceProducts?: Maybe<Array<Maybe<PriceProduct>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertPriceSize` mutation. */
export type BulkUpsertPriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  sizes: Array<Maybe<PriceSizeInput>>;
};

/** The output of our `bulkUpsertPriceSize` mutation. */
export type BulkUpsertPriceSizePayload = {
  __typename?: 'BulkUpsertPriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  priceSizes?: Maybe<Array<Maybe<PriceSize>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertProductMaster` mutation. */
export type BulkUpsertProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  productMasters: Array<Maybe<ProductMasterInput>>;
};

/** The output of our `bulkUpsertProductMaster` mutation. */
export type BulkUpsertProductMasterPayload = {
  __typename?: 'BulkUpsertProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  productMasters?: Maybe<Array<Maybe<ProductMaster>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertProductSize` mutation. */
export type BulkUpsertProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  sizes: Array<Maybe<ProductSizeInput>>;
};

/** The output of our `bulkUpsertProductSize` mutation. */
export type BulkUpsertProductSizePayload = {
  __typename?: 'BulkUpsertProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  productSizes?: Maybe<Array<Maybe<ProductSize>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertProductSpecies` mutation. */
export type BulkUpsertProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  specieses: Array<Maybe<ProductSpeciesInput>>;
};

/** The output of our `bulkUpsertProductSpecies` mutation. */
export type BulkUpsertProductSpeciesPayload = {
  __typename?: 'BulkUpsertProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  productSpecies?: Maybe<Array<Maybe<ProductSpecies>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertProductVariety` mutation. */
export type BulkUpsertProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  varieties: Array<Maybe<ProductVarietyInput>>;
};

/** The output of our `bulkUpsertProductVariety` mutation. */
export type BulkUpsertProductVarietyPayload = {
  __typename?: 'BulkUpsertProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  productVarieties?: Maybe<Array<Maybe<ProductVariety>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertRepackHeader` mutation. */
export type BulkUpsertRepackHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackHeaders: Array<Maybe<RepackHeaderInput>>;
};

/** The output of our `bulkUpsertRepackHeader` mutation. */
export type BulkUpsertRepackHeaderPayload = {
  __typename?: 'BulkUpsertRepackHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackHeaders?: Maybe<Array<Maybe<RepackHeader>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertRepackItem` mutation. */
export type BulkUpsertRepackItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackItems: Array<Maybe<RepackItemInput>>;
};

/** The output of our `bulkUpsertRepackItem` mutation. */
export type BulkUpsertRepackItemPayload = {
  __typename?: 'BulkUpsertRepackItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackItems?: Maybe<Array<Maybe<RepackItem>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertRepackQueue` mutation. */
export type BulkUpsertRepackQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackQueues: Array<Maybe<RepackQueueInput>>;
};

/** The output of our `bulkUpsertRepackQueue` mutation. */
export type BulkUpsertRepackQueuePayload = {
  __typename?: 'BulkUpsertRepackQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackQueues?: Maybe<Array<Maybe<RepackQueue>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertRepackStyle` mutation. */
export type BulkUpsertRepackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackStyles: Array<Maybe<RepackStyleInput>>;
};

/** The output of our `bulkUpsertRepackStyle` mutation. */
export type BulkUpsertRepackStylePayload = {
  __typename?: 'BulkUpsertRepackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  repackStyles?: Maybe<Array<Maybe<RepackStyle>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipper` mutation. */
export type BulkUpsertShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shippers: Array<Maybe<ShipperInput>>;
};

/** The output of our `bulkUpsertShipper` mutation. */
export type BulkUpsertShipperPayload = {
  __typename?: 'BulkUpsertShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shippers?: Maybe<Array<Maybe<Shipper>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProgramEntryCustomerProgramEntry` mutation. */
export type BulkUpsertShipperProgramEntryCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  allocations: Array<Maybe<ShipperProgramEntryCustomerProgramEntryInput>>;
};

/** The output of our `bulkUpsertShipperProgramEntryCustomerProgramEntry` mutation. */
export type BulkUpsertShipperProgramEntryCustomerProgramEntryPayload = {
  __typename?: 'BulkUpsertShipperProgramEntryCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProgramEntryCustomerProgramEntries?: Maybe<Array<Maybe<ShipperProgramEntryCustomerProgramEntry>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProgramEntry` mutation. */
export type BulkUpsertShipperProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  entries: Array<Maybe<ShipperProgramEntryInput>>;
};

/** The output of our `bulkUpsertShipperProgramEntry` mutation. */
export type BulkUpsertShipperProgramEntryPayload = {
  __typename?: 'BulkUpsertShipperProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProgramEntries?: Maybe<Array<Maybe<ShipperProgramEntry>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProgram` mutation. */
export type BulkUpsertShipperProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  programs: Array<Maybe<ShipperProgramInput>>;
};

/** The output of our `bulkUpsertShipperProgram` mutation. */
export type BulkUpsertShipperProgramPayload = {
  __typename?: 'BulkUpsertShipperProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperPrograms?: Maybe<Array<Maybe<ShipperProgram>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProjectionProduct` mutation. */
export type BulkUpsertShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  products: Array<Maybe<ShipperProjectionProductInput>>;
};

/** The output of our `bulkUpsertShipperProjectionProduct` mutation. */
export type BulkUpsertShipperProjectionProductPayload = {
  __typename?: 'BulkUpsertShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProjectionProducts?: Maybe<Array<Maybe<ShipperProjectionProduct>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertShipperProjectionVessel` mutation. */
export type BulkUpsertShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vessels: Array<Maybe<ShipperProjectionVesselInput>>;
};

/** The output of our `bulkUpsertShipperProjectionVessel` mutation. */
export type BulkUpsertShipperProjectionVesselPayload = {
  __typename?: 'BulkUpsertShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperProjectionVessels?: Maybe<Array<Maybe<ShipperProjectionVessel>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertTruckLoad` mutation. */
export type BulkUpsertTruckLoadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  truckLoads: Array<Maybe<TruckLoadInput>>;
};

/** The output of our `bulkUpsertTruckLoad` mutation. */
export type BulkUpsertTruckLoadPayload = {
  __typename?: 'BulkUpsertTruckLoadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  truckLoads?: Maybe<Array<Maybe<TruckLoad>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertUnpaid` mutation. */
export type BulkUpsertUnpaidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  unpaids: Array<Maybe<UnpaidInput>>;
};

/** The output of our `bulkUpsertUnpaid` mutation. */
export type BulkUpsertUnpaidPayload = {
  __typename?: 'BulkUpsertUnpaidPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  unpaids?: Maybe<Array<Maybe<Unpaid>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertUserBookmark` mutation. */
export type BulkUpsertUserBookmarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  userBookmarks: Array<Maybe<UserBookmarkInput>>;
};

/** The output of our `bulkUpsertUserBookmark` mutation. */
export type BulkUpsertUserBookmarkPayload = {
  __typename?: 'BulkUpsertUserBookmarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  userBookmarks?: Maybe<Array<Maybe<UserBookmark>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertVendor` mutation. */
export type BulkUpsertVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vendors: Array<Maybe<VendorInput>>;
};

/** The output of our `bulkUpsertVendor` mutation. */
export type BulkUpsertVendorPayload = {
  __typename?: 'BulkUpsertVendorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vendors?: Maybe<Array<Maybe<Vendor>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertVesselControl` mutation. */
export type BulkUpsertVesselControlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vesselControls: Array<Maybe<VesselControlInput>>;
};

/** The output of our `bulkUpsertVesselControl` mutation. */
export type BulkUpsertVesselControlPayload = {
  __typename?: 'BulkUpsertVesselControlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vesselControls?: Maybe<Array<Maybe<VesselControl>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertVessel` mutation. */
export type BulkUpsertVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vessels: Array<Maybe<VesselInput>>;
};

/** The output of our `bulkUpsertVessel` mutation. */
export type BulkUpsertVesselPayload = {
  __typename?: 'BulkUpsertVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vessels?: Maybe<Array<Maybe<Vessel>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpsertWarehouse` mutation. */
export type BulkUpsertWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  warehouses: Array<Maybe<WarehouseInput>>;
};

/** The output of our `bulkUpsertWarehouse` mutation. */
export type BulkUpsertWarehousePayload = {
  __typename?: 'BulkUpsertWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  warehouses?: Maybe<Array<Maybe<Warehouse>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type CalendarEvent = Node & {
  __typename?: 'CalendarEvent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  title?: Maybe<Scalars['String']>;
  eventDescription?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['Datetime']>;
  allDay?: Maybe<Scalars['Boolean']>;
  rrule?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `CalendarEvent` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CalendarEventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventDescription` field. */
  eventDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `allDay` field. */
  allDay?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `rrule` field. */
  rrule?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CalendarEvent` object types. All fields are combined with a logical ‘and.’ */
export type CalendarEventFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `eventDescription` field. */
  eventDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `startDate` field. */
  startDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `endDate` field. */
  endDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `allDay` field. */
  allDay?: Maybe<BooleanFilter>;
  /** Filter by the object’s `rrule` field. */
  rrule?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CalendarEventFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CalendarEventFilter>>;
  /** Negates the expression. */
  not?: Maybe<CalendarEventFilter>;
};

/** An input for mutations affecting `CalendarEvent` */
export type CalendarEventInput = {
  id?: Maybe<Scalars['BigInt']>;
  title?: Maybe<Scalars['String']>;
  eventDescription?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['Datetime']>;
  allDay?: Maybe<Scalars['Boolean']>;
  rrule?: Maybe<Scalars['String']>;
};

/** Represents an update to a `CalendarEvent`. Fields that are set will be updated. */
export type CalendarEventPatch = {
  id?: Maybe<Scalars['BigInt']>;
  title?: Maybe<Scalars['String']>;
  eventDescription?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['Datetime']>;
  allDay?: Maybe<Scalars['Boolean']>;
  rrule?: Maybe<Scalars['String']>;
};

/** A connection to a list of `CalendarEvent` values. */
export type CalendarEventsConnection = {
  __typename?: 'CalendarEventsConnection';
  /** A list of `CalendarEvent` objects. */
  nodes: Array<Maybe<CalendarEvent>>;
  /** A list of edges which contains the `CalendarEvent` and cursor to aid in pagination. */
  edges: Array<CalendarEventsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CalendarEvent` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CalendarEvent` edge in the connection. */
export type CalendarEventsEdge = {
  __typename?: 'CalendarEventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CalendarEvent` at the end of the edge. */
  node?: Maybe<CalendarEvent>;
};

/** Methods to use when ordering `CalendarEvent`. */
export enum CalendarEventsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  EventDescriptionAsc = 'EVENT_DESCRIPTION_ASC',
  EventDescriptionDesc = 'EVENT_DESCRIPTION_DESC',
  StartDateAsc = 'START_DATE_ASC',
  StartDateDesc = 'START_DATE_DESC',
  EndDateAsc = 'END_DATE_ASC',
  EndDateDesc = 'END_DATE_DESC',
  AllDayAsc = 'ALL_DAY_ASC',
  AllDayDesc = 'ALL_DAY_DESC',
  RruleAsc = 'RRULE_ASC',
  RruleDesc = 'RRULE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type CheckHeader = Node & {
  __typename?: 'CheckHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  isReconciled?: Maybe<Scalars['Boolean']>;
  checkStatus: Scalars['String'];
  checkNumber: Scalars['String'];
  vendorId: Scalars['String'];
  remitToCode?: Maybe<Scalars['BigFloat']>;
  invoiceAmount: Scalars['BigFloat'];
  discountAmount: Scalars['BigFloat'];
  checkAmount: Scalars['BigFloat'];
  checkDate?: Maybe<Scalars['Date']>;
  bankId: Scalars['String'];
  invoiceId: Scalars['String'];
  isVoid?: Maybe<Scalars['Boolean']>;
  entryDate?: Maybe<Scalars['Date']>;
  searchText?: Maybe<Scalars['String']>;
  vendor?: Maybe<Vendor>;
};

/**
 * A condition to be used against `CheckHeader` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CheckHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isReconciled` field. */
  isReconciled?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `checkStatus` field. */
  checkStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `checkNumber` field. */
  checkNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `remitToCode` field. */
  remitToCode?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `invoiceAmount` field. */
  invoiceAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `discountAmount` field. */
  discountAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `checkAmount` field. */
  checkAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `checkDate` field. */
  checkDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `bankId` field. */
  bankId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isVoid` field. */
  isVoid?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `entryDate` field. */
  entryDate?: Maybe<Scalars['Date']>;
};

/** A filter to be used against `CheckHeader` object types. All fields are combined with a logical ‘and.’ */
export type CheckHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `isReconciled` field. */
  isReconciled?: Maybe<BooleanFilter>;
  /** Filter by the object’s `checkStatus` field. */
  checkStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `checkNumber` field. */
  checkNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `remitToCode` field. */
  remitToCode?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `invoiceAmount` field. */
  invoiceAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `discountAmount` field. */
  discountAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `checkAmount` field. */
  checkAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `checkDate` field. */
  checkDate?: Maybe<DateFilter>;
  /** Filter by the object’s `bankId` field. */
  bankId?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<StringFilter>;
  /** Filter by the object’s `isVoid` field. */
  isVoid?: Maybe<BooleanFilter>;
  /** Filter by the object’s `entryDate` field. */
  entryDate?: Maybe<DateFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CheckHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CheckHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<CheckHeaderFilter>;
};

/** An input for mutations affecting `CheckHeader` */
export type CheckHeaderInput = {
  id?: Maybe<Scalars['BigInt']>;
  isReconciled?: Maybe<Scalars['Boolean']>;
  checkStatus: Scalars['String'];
  checkNumber: Scalars['String'];
  vendorId: Scalars['String'];
  remitToCode?: Maybe<Scalars['BigFloat']>;
  invoiceAmount: Scalars['BigFloat'];
  discountAmount: Scalars['BigFloat'];
  checkAmount: Scalars['BigFloat'];
  checkDate?: Maybe<Scalars['Date']>;
  bankId: Scalars['String'];
  invoiceId: Scalars['String'];
  isVoid?: Maybe<Scalars['Boolean']>;
  entryDate?: Maybe<Scalars['Date']>;
};

/** Represents an update to a `CheckHeader`. Fields that are set will be updated. */
export type CheckHeaderPatch = {
  id?: Maybe<Scalars['BigInt']>;
  isReconciled?: Maybe<Scalars['Boolean']>;
  checkStatus?: Maybe<Scalars['String']>;
  checkNumber?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  remitToCode?: Maybe<Scalars['BigFloat']>;
  invoiceAmount?: Maybe<Scalars['BigFloat']>;
  discountAmount?: Maybe<Scalars['BigFloat']>;
  checkAmount?: Maybe<Scalars['BigFloat']>;
  checkDate?: Maybe<Scalars['Date']>;
  bankId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  isVoid?: Maybe<Scalars['Boolean']>;
  entryDate?: Maybe<Scalars['Date']>;
};

/** A connection to a list of `CheckHeader` values. */
export type CheckHeadersConnection = {
  __typename?: 'CheckHeadersConnection';
  /** A list of `CheckHeader` objects. */
  nodes: Array<Maybe<CheckHeader>>;
  /** A list of edges which contains the `CheckHeader` and cursor to aid in pagination. */
  edges: Array<CheckHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CheckHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CheckHeader` edge in the connection. */
export type CheckHeadersEdge = {
  __typename?: 'CheckHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CheckHeader` at the end of the edge. */
  node?: Maybe<CheckHeader>;
};

/** Methods to use when ordering `CheckHeader`. */
export enum CheckHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsReconciledAsc = 'IS_RECONCILED_ASC',
  IsReconciledDesc = 'IS_RECONCILED_DESC',
  CheckStatusAsc = 'CHECK_STATUS_ASC',
  CheckStatusDesc = 'CHECK_STATUS_DESC',
  CheckNumberAsc = 'CHECK_NUMBER_ASC',
  CheckNumberDesc = 'CHECK_NUMBER_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  RemitToCodeAsc = 'REMIT_TO_CODE_ASC',
  RemitToCodeDesc = 'REMIT_TO_CODE_DESC',
  InvoiceAmountAsc = 'INVOICE_AMOUNT_ASC',
  InvoiceAmountDesc = 'INVOICE_AMOUNT_DESC',
  DiscountAmountAsc = 'DISCOUNT_AMOUNT_ASC',
  DiscountAmountDesc = 'DISCOUNT_AMOUNT_DESC',
  CheckAmountAsc = 'CHECK_AMOUNT_ASC',
  CheckAmountDesc = 'CHECK_AMOUNT_DESC',
  CheckDateAsc = 'CHECK_DATE_ASC',
  CheckDateDesc = 'CHECK_DATE_DESC',
  BankIdAsc = 'BANK_ID_ASC',
  BankIdDesc = 'BANK_ID_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  IsVoidAsc = 'IS_VOID_ASC',
  IsVoidDesc = 'IS_VOID_DESC',
  EntryDateAsc = 'ENTRY_DATE_ASC',
  EntryDateDesc = 'ENTRY_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ChileDepartureInspection = {
  __typename?: 'ChileDepartureInspection';
  lotNumber?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  packingDate?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  avgBunchesCount?: Maybe<Scalars['BigFloat']>;
  brixAvg?: Maybe<Scalars['BigFloat']>;
  brixMin?: Maybe<Scalars['BigFloat']>;
  brixMax?: Maybe<Scalars['BigFloat']>;
  searchText?: Maybe<Scalars['String']>;
  imageUrls?: Maybe<Array<Scalars['String']>>;
};

/** A filter to be used against `ChileDepartureInspection` object types. All fields are combined with a logical ‘and.’ */
export type ChileDepartureInspectionFilter = {
  /** Filter by the object’s `lotNumber` field. */
  lotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<DateFilter>;
  /** Filter by the object’s `packingDate` field. */
  packingDate?: Maybe<StringFilter>;
  /** Filter by the object’s `shipper` field. */
  shipper?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `avgNetWeight` field. */
  avgNetWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `avgBunchesCount` field. */
  avgBunchesCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixAvg` field. */
  brixAvg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ChileDepartureInspectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ChileDepartureInspectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ChileDepartureInspectionFilter>;
};

export type ChileDepartureInspectionPallet = Node & {
  __typename?: 'ChileDepartureInspectionPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  lotId?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  locationName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  productName?: Maybe<Scalars['String']>;
  packingType?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  supervisor?: Maybe<Scalars['String']>;
  palletNumber?: Maybe<Scalars['String']>;
  boxesCount?: Maybe<Scalars['BigFloat']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  grower?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  packingDate?: Maybe<Scalars['Date']>;
  label?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  openAppearance?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  stem?: Maybe<Scalars['String']>;
  texture?: Maybe<Scalars['String']>;
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  diameterMin?: Maybe<Scalars['BigFloat']>;
  diameterMax?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  scoreName?: Maybe<Scalars['String']>;
  reportLink?: Maybe<Scalars['String']>;
  imagesLink?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `ChileDepartureInspectionPallet` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type ChileDepartureInspectionPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotId` field. */
  lotId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotNumber` field. */
  lotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `locationName` field. */
  locationName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipper` field. */
  shipper?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `productName` field. */
  productName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packingType` field. */
  packingType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productType` field. */
  productType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `supervisor` field. */
  supervisor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletNumber` field. */
  palletNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxesCount` field. */
  boxesCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `netWeight` field. */
  netWeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `grower` field. */
  grower?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packingDate` field. */
  packingDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `temperature` field. */
  temperature?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `openAppearance` field. */
  openAppearance?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stem` field. */
  stem?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `texture` field. */
  texture?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bunchesCount` field. */
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `diameterMin` field. */
  diameterMin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `diameterMax` field. */
  diameterMax?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `shatterPct` field. */
  shatterPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `qualityScore` field. */
  qualityScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `conditionScore` field. */
  conditionScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `scoreName` field. */
  scoreName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `reportLink` field. */
  reportLink?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imagesLink` field. */
  imagesLink?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ChileDepartureInspectionPallet` object types. All fields are combined with a logical ‘and.’ */
export type ChileDepartureInspectionPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `lotId` field. */
  lotId?: Maybe<StringFilter>;
  /** Filter by the object’s `lotNumber` field. */
  lotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `locationName` field. */
  locationName?: Maybe<StringFilter>;
  /** Filter by the object’s `shipper` field. */
  shipper?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<DateFilter>;
  /** Filter by the object’s `productName` field. */
  productName?: Maybe<StringFilter>;
  /** Filter by the object’s `packingType` field. */
  packingType?: Maybe<StringFilter>;
  /** Filter by the object’s `productType` field. */
  productType?: Maybe<StringFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `supervisor` field. */
  supervisor?: Maybe<StringFilter>;
  /** Filter by the object’s `palletNumber` field. */
  palletNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `boxesCount` field. */
  boxesCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `netWeight` field. */
  netWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `grower` field. */
  grower?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `packingDate` field. */
  packingDate?: Maybe<DateFilter>;
  /** Filter by the object’s `label` field. */
  label?: Maybe<StringFilter>;
  /** Filter by the object’s `temperature` field. */
  temperature?: Maybe<StringFilter>;
  /** Filter by the object’s `openAppearance` field. */
  openAppearance?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `stem` field. */
  stem?: Maybe<StringFilter>;
  /** Filter by the object’s `texture` field. */
  texture?: Maybe<StringFilter>;
  /** Filter by the object’s `bunchesCount` field. */
  bunchesCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `diameterMin` field. */
  diameterMin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `diameterMax` field. */
  diameterMax?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `shatterPct` field. */
  shatterPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `scoreName` field. */
  scoreName?: Maybe<StringFilter>;
  /** Filter by the object’s `reportLink` field. */
  reportLink?: Maybe<StringFilter>;
  /** Filter by the object’s `imagesLink` field. */
  imagesLink?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ChileDepartureInspectionPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ChileDepartureInspectionPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<ChileDepartureInspectionPalletFilter>;
};

/** An input for mutations affecting `ChileDepartureInspectionPallet` */
export type ChileDepartureInspectionPalletInput = {
  id: Scalars['String'];
  lotId?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  locationName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  productName?: Maybe<Scalars['String']>;
  packingType?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  supervisor?: Maybe<Scalars['String']>;
  palletNumber?: Maybe<Scalars['String']>;
  boxesCount?: Maybe<Scalars['BigFloat']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  grower?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  packingDate?: Maybe<Scalars['Date']>;
  label?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  openAppearance?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  stem?: Maybe<Scalars['String']>;
  texture?: Maybe<Scalars['String']>;
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  diameterMin?: Maybe<Scalars['BigFloat']>;
  diameterMax?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  scoreName?: Maybe<Scalars['String']>;
  reportLink?: Maybe<Scalars['String']>;
  imagesLink?: Maybe<Scalars['String']>;
};

/** Represents an update to a `ChileDepartureInspectionPallet`. Fields that are set will be updated. */
export type ChileDepartureInspectionPalletPatch = {
  id?: Maybe<Scalars['String']>;
  lotId?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  locationName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  productName?: Maybe<Scalars['String']>;
  packingType?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  supervisor?: Maybe<Scalars['String']>;
  palletNumber?: Maybe<Scalars['String']>;
  boxesCount?: Maybe<Scalars['BigFloat']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  grower?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  packingDate?: Maybe<Scalars['Date']>;
  label?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  openAppearance?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  stem?: Maybe<Scalars['String']>;
  texture?: Maybe<Scalars['String']>;
  bunchesCount?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  diameterMin?: Maybe<Scalars['BigFloat']>;
  diameterMax?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  scoreName?: Maybe<Scalars['String']>;
  reportLink?: Maybe<Scalars['String']>;
  imagesLink?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ChileDepartureInspectionPallet` values. */
export type ChileDepartureInspectionPalletsConnection = {
  __typename?: 'ChileDepartureInspectionPalletsConnection';
  /** A list of `ChileDepartureInspectionPallet` objects. */
  nodes: Array<Maybe<ChileDepartureInspectionPallet>>;
  /** A list of edges which contains the `ChileDepartureInspectionPallet` and cursor to aid in pagination. */
  edges: Array<ChileDepartureInspectionPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChileDepartureInspectionPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ChileDepartureInspectionPallet` edge in the connection. */
export type ChileDepartureInspectionPalletsEdge = {
  __typename?: 'ChileDepartureInspectionPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ChileDepartureInspectionPallet` at the end of the edge. */
  node?: Maybe<ChileDepartureInspectionPallet>;
};

/** Methods to use when ordering `ChileDepartureInspectionPallet`. */
export enum ChileDepartureInspectionPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LotIdAsc = 'LOT_ID_ASC',
  LotIdDesc = 'LOT_ID_DESC',
  LotNumberAsc = 'LOT_NUMBER_ASC',
  LotNumberDesc = 'LOT_NUMBER_DESC',
  LocationNameAsc = 'LOCATION_NAME_ASC',
  LocationNameDesc = 'LOCATION_NAME_DESC',
  ShipperAsc = 'SHIPPER_ASC',
  ShipperDesc = 'SHIPPER_DESC',
  InspectionDateAsc = 'INSPECTION_DATE_ASC',
  InspectionDateDesc = 'INSPECTION_DATE_DESC',
  ProductNameAsc = 'PRODUCT_NAME_ASC',
  ProductNameDesc = 'PRODUCT_NAME_DESC',
  PackingTypeAsc = 'PACKING_TYPE_ASC',
  PackingTypeDesc = 'PACKING_TYPE_DESC',
  ProductTypeAsc = 'PRODUCT_TYPE_ASC',
  ProductTypeDesc = 'PRODUCT_TYPE_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  SupervisorAsc = 'SUPERVISOR_ASC',
  SupervisorDesc = 'SUPERVISOR_DESC',
  PalletNumberAsc = 'PALLET_NUMBER_ASC',
  PalletNumberDesc = 'PALLET_NUMBER_DESC',
  BoxesCountAsc = 'BOXES_COUNT_ASC',
  BoxesCountDesc = 'BOXES_COUNT_DESC',
  NetWeightAsc = 'NET_WEIGHT_ASC',
  NetWeightDesc = 'NET_WEIGHT_DESC',
  GrowerAsc = 'GROWER_ASC',
  GrowerDesc = 'GROWER_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  PackingDateAsc = 'PACKING_DATE_ASC',
  PackingDateDesc = 'PACKING_DATE_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  TemperatureAsc = 'TEMPERATURE_ASC',
  TemperatureDesc = 'TEMPERATURE_DESC',
  OpenAppearanceAsc = 'OPEN_APPEARANCE_ASC',
  OpenAppearanceDesc = 'OPEN_APPEARANCE_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  StemAsc = 'STEM_ASC',
  StemDesc = 'STEM_DESC',
  TextureAsc = 'TEXTURE_ASC',
  TextureDesc = 'TEXTURE_DESC',
  BunchesCountAsc = 'BUNCHES_COUNT_ASC',
  BunchesCountDesc = 'BUNCHES_COUNT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  DiameterMinAsc = 'DIAMETER_MIN_ASC',
  DiameterMinDesc = 'DIAMETER_MIN_DESC',
  DiameterMaxAsc = 'DIAMETER_MAX_ASC',
  DiameterMaxDesc = 'DIAMETER_MAX_DESC',
  StragglyTightPctAsc = 'STRAGGLY_TIGHT_PCT_ASC',
  StragglyTightPctDesc = 'STRAGGLY_TIGHT_PCT_DESC',
  SurfaceDiscPctAsc = 'SURFACE_DISC_PCT_ASC',
  SurfaceDiscPctDesc = 'SURFACE_DISC_PCT_DESC',
  RussetScarsPctAsc = 'RUSSET_SCARS_PCT_ASC',
  RussetScarsPctDesc = 'RUSSET_SCARS_PCT_DESC',
  SunburnPctAsc = 'SUNBURN_PCT_ASC',
  SunburnPctDesc = 'SUNBURN_PCT_DESC',
  UndersizedBunchesPctAsc = 'UNDERSIZED_BUNCHES_PCT_ASC',
  UndersizedBunchesPctDesc = 'UNDERSIZED_BUNCHES_PCT_DESC',
  OtherDefectsPctAsc = 'OTHER_DEFECTS_PCT_ASC',
  OtherDefectsPctDesc = 'OTHER_DEFECTS_PCT_DESC',
  StemDehyPctAsc = 'STEM_DEHY_PCT_ASC',
  StemDehyPctDesc = 'STEM_DEHY_PCT_DESC',
  GlassyWeakPctAsc = 'GLASSY_WEAK_PCT_ASC',
  GlassyWeakPctDesc = 'GLASSY_WEAK_PCT_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  SplitCrushedPctAsc = 'SPLIT_CRUSHED_PCT_ASC',
  SplitCrushedPctDesc = 'SPLIT_CRUSHED_PCT_DESC',
  DrySplitPctAsc = 'DRY_SPLIT_PCT_ASC',
  DrySplitPctDesc = 'DRY_SPLIT_PCT_DESC',
  WetStickyPctAsc = 'WET_STICKY_PCT_ASC',
  WetStickyPctDesc = 'WET_STICKY_PCT_DESC',
  WaterberriesPctAsc = 'WATERBERRIES_PCT_ASC',
  WaterberriesPctDesc = 'WATERBERRIES_PCT_DESC',
  ShatterPctAsc = 'SHATTER_PCT_ASC',
  ShatterPctDesc = 'SHATTER_PCT_DESC',
  TotalQualityDefectsPctAsc = 'TOTAL_QUALITY_DEFECTS_PCT_ASC',
  TotalQualityDefectsPctDesc = 'TOTAL_QUALITY_DEFECTS_PCT_DESC',
  TotalConditionDefectsPctAsc = 'TOTAL_CONDITION_DEFECTS_PCT_ASC',
  TotalConditionDefectsPctDesc = 'TOTAL_CONDITION_DEFECTS_PCT_DESC',
  QualityScoreAsc = 'QUALITY_SCORE_ASC',
  QualityScoreDesc = 'QUALITY_SCORE_DESC',
  ConditionScoreAsc = 'CONDITION_SCORE_ASC',
  ConditionScoreDesc = 'CONDITION_SCORE_DESC',
  ScoreNameAsc = 'SCORE_NAME_ASC',
  ScoreNameDesc = 'SCORE_NAME_DESC',
  ReportLinkAsc = 'REPORT_LINK_ASC',
  ReportLinkDesc = 'REPORT_LINK_DESC',
  ImagesLinkAsc = 'IMAGES_LINK_ASC',
  ImagesLinkDesc = 'IMAGES_LINK_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `ChileDepartureInspection` values. */
export type ChileDepartureInspectionsConnection = {
  __typename?: 'ChileDepartureInspectionsConnection';
  /** A list of `ChileDepartureInspection` objects. */
  nodes: Array<Maybe<ChileDepartureInspection>>;
  /** A list of edges which contains the `ChileDepartureInspection` and cursor to aid in pagination. */
  edges: Array<ChileDepartureInspectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChileDepartureInspection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ChileDepartureInspection` edge in the connection. */
export type ChileDepartureInspectionsEdge = {
  __typename?: 'ChileDepartureInspectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ChileDepartureInspection` at the end of the edge. */
  node?: Maybe<ChileDepartureInspection>;
};

/** A connection to a list of `CommonCategory` values. */
export type CommonCategoriesConnection = {
  __typename?: 'CommonCategoriesConnection';
  /** A list of `CommonCategory` objects. */
  nodes: Array<Maybe<CommonCategory>>;
  /** A list of edges which contains the `CommonCategory` and cursor to aid in pagination. */
  edges: Array<CommonCategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonCategory` edge in the connection. */
export type CommonCategoriesEdge = {
  __typename?: 'CommonCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonCategory` at the end of the edge. */
  node?: Maybe<CommonCategory>;
};

/** Methods to use when ordering `CommonCategory`. */
export enum CommonCategoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CategoryNameAsc = 'CATEGORY_NAME_ASC',
  CategoryNameDesc = 'CATEGORY_NAME_DESC',
  CategoryDescriptionAsc = 'CATEGORY_DESCRIPTION_ASC',
  CategoryDescriptionDesc = 'CATEGORY_DESCRIPTION_DESC',
  UiColorAsc = 'UI_COLOR_ASC',
  UiColorDesc = 'UI_COLOR_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonCategoryIdCountAsc = 'COMMON_SPECIES_BY_COMMON_CATEGORY_ID__COUNT_ASC',
  CommonSpeciesByCommonCategoryIdCountDesc = 'COMMON_SPECIES_BY_COMMON_CATEGORY_ID__COUNT_DESC'
}

export type CommonCategory = Node & {
  __typename?: 'CommonCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  categoryName?: Maybe<Scalars['String']>;
  categoryDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpecieses: CommonSpeciesConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `ProductSpecies`. */
  productSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesId: CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdManyToManyConnection;
};


export type CommonCategoryCommonSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
  condition?: Maybe<ProductSpeciesCondition>;
  filter?: Maybe<ProductSpeciesFilter>;
};

/** The fields on `commonCategory` to look up the row to connect. */
export type CommonCategoryCommonCategoryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonCategory` to look up the row to delete. */
export type CommonCategoryCommonCategoryPkeyDelete = {
  id: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `categoryName` field. */
  categoryName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `categoryDescription` field. */
  categoryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `uiColor` field. */
  uiColor?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CommonCategory` object types. All fields are combined with a logical ‘and.’ */
export type CommonCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `categoryName` field. */
  categoryName?: Maybe<StringFilter>;
  /** Filter by the object’s `categoryDescription` field. */
  categoryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `uiColor` field. */
  uiColor?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpecieses` relation. */
  commonSpecieses?: Maybe<CommonCategoryToManyCommonSpeciesFilter>;
  /** Some related `commonSpecieses` exist. */
  commonSpeciesesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonCategoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonCategoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonCategoryFilter>;
};

/** An input for mutations affecting `CommonCategory` */
export type CommonCategoryInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  categoryDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonCategoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonCategory` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonCategoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonCategoryOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `commonCategory` to look up the row to update. */
export type CommonCategoryOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyUsingCommonCategoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonCategory` being updated. */
  patch: UpdateCommonCategoryOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `CommonCategory`. Fields that are set will be updated. */
export type CommonCategoryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  categoryDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInverseInput>;
};

/** A connection to a list of `ProductSpecies` values, with data from `CommonSpecies`. */
export type CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdManyToManyConnection = {
  __typename?: 'CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdManyToManyConnection';
  /** A list of `ProductSpecies` objects. */
  nodes: Array<Maybe<ProductSpecies>>;
  /** A list of edges which contains the `ProductSpecies`, info from the `CommonSpecies`, and the cursor to aid in pagination. */
  edges: Array<CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSpecies` edge in the connection, with data from `CommonSpecies`. */
export type CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdManyToManyEdge = {
  __typename?: 'CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSpecies` at the end of the edge. */
  node?: Maybe<ProductSpecies>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpecieses: CommonSpeciesConnection;
};


/** A `ProductSpecies` edge in the connection, with data from `CommonSpecies`. */
export type CommonCategoryProductSpeciesByCommonSpeciesCommonCategoryIdAndProductSpeciesIdManyToManyEdgeCommonSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};

/** A filter to be used against many `CommonSpecies` object types. All fields are combined with a logical ‘and.’ */
export type CommonCategoryToManyCommonSpeciesFilter = {
  /** Every related `CommonSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSpeciesFilter>;
  /** Some related `CommonSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSpeciesFilter>;
  /** No related `CommonSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSpeciesFilter>;
};

export type CommonPackType = Node & {
  __typename?: 'CommonPackType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  /** Reads a single `CommonSpecies` that is related to this `CommonPackType`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `PackMaster` that is related to this `CommonPackType`. */
  packMaster?: Maybe<PackMaster>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
  /** Reads and enables pagination through a set of `CommonPackTypeTag`. */
  commonPackTypeTags: CommonPackTypeTagsConnection;
  /** Reads and enables pagination through a set of `CommonPackTypePackMaster`. */
  commonPackTypePackMasters: CommonPackTypePackMastersConnection;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
  repackStyle?: Maybe<RepackStyle>;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionProductCommonPackTypeIdAndShipperId: CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesId: CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyId: CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeId: CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProjectionProductCommonPackTypeIdAndCustomerId: CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PackMaster`. */
  packMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterId: CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesId: CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyId: CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProgramCommonPackTypeIdAndCommonSizeId: CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProgramCommonPackTypeIdAndShipperId: CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProgramCommonPackTypeIdAndCustomerId: CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesId: CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyId: CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeId: CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByCustomerProgramCommonPackTypeIdAndCustomerId: CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdManyToManyConnection;
};


export type CommonPackTypeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type CommonPackTypeCommonPackTypeTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypeTagsOrderBy>>;
  condition?: Maybe<CommonPackTypeTagCondition>;
  filter?: Maybe<CommonPackTypeTagFilter>;
};


export type CommonPackTypeCommonPackTypePackMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
  condition?: Maybe<CommonPackTypePackMasterCondition>;
  filter?: Maybe<CommonPackTypePackMasterFilter>;
};


export type CommonPackTypeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};


export type CommonPackTypeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};


export type CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
  condition?: Maybe<PackMasterCondition>;
  filter?: Maybe<PackMasterFilter>;
};


export type CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};

/** The fields on `commonPackType` to look up the row to connect. */
export type CommonPackTypeCommonPackTypePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonPackType` to look up the row to delete. */
export type CommonPackTypeCommonPackTypePkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `CommonSize` values, with data from `CustomerProgram`. */
export type CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCommonSizesByCustomerProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProgram`. */
export type CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCommonSizesByShipperProgramCommonPackTypeIdAndCommonSizeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonSizesByShipperProjectionProductCommonPackTypeIdAndCommonSizeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `CustomerProgram`. */
export type CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCommonSpeciesByCustomerProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProgram`. */
export type CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCommonSpeciesByShipperProgramCommonPackTypeIdAndCommonSpeciesIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonSpeciesByShipperProjectionProductCommonPackTypeIdAndCommonSpeciesIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** The `commonPackType` to be created by this mutation. */
export type CommonPackTypeCommonSpeciesIdFkeyCommonPackTypeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CommonPackTypeCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `CommonPackTypeInput` mutation. */
export type CommonPackTypeCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonPackTypeOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CommonPackTypeCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `commonPackType` in the `CommonSpeciesInput` mutation. */
export type CommonPackTypeCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonPackType` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonPackTypeCommonPackTypePkeyConnect>>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonPackTypeNodeIdConnect>>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonPackTypeCommonPackTypePkeyDelete>>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonPackTypeNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonPackTypeOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyUsingCommonPackTypePkeyUpdate>>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CommonPackTypeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonPackTypeCommonSpeciesIdFkeyCommonPackTypeCreateInput>>;
};

/** A connection to a list of `CommonVariety` values, with data from `CustomerProgram`. */
export type CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCommonVarietiesByCustomerProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProgram`. */
export type CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCommonVarietiesByShipperProgramCommonPackTypeIdAndCommonVarietyIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCommonVarietiesByShipperProjectionProductCommonPackTypeIdAndCommonVarietyIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/**
 * A condition to be used against `CommonPackType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonPackTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `packTypeName` field. */
  packTypeName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packTypeDescription` field. */
  packTypeDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `packMasterId` field. */
  packMasterId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletWeight` field. */
  palletWeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxCount` field. */
  boxCount?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `repackStyleId` field. */
  repackStyleId?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Customer` values, with data from `CustomerProgram`. */
export type CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonPackTypeCustomersByCustomerProgramCommonPackTypeIdAndCustomerIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProgram`. */
export type CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeCustomersByShipperProgramCommonPackTypeIdAndCustomerIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeCustomersByShipperProjectionProductCommonPackTypeIdAndCustomerIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against `CommonPackType` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `packTypeName` field. */
  packTypeName?: Maybe<StringFilter>;
  /** Filter by the object’s `packTypeDescription` field. */
  packTypeDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `packMasterId` field. */
  packMasterId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<StringFilter>;
  /** Filter by the object’s `palletWeight` field. */
  palletWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxCount` field. */
  boxCount?: Maybe<BigIntFilter>;
  /** Filter by the object’s `repackStyleId` field. */
  repackStyleId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionProducts` relation. */
  shipperProjectionProducts?: Maybe<CommonPackTypeToManyShipperProjectionProductFilter>;
  /** Some related `shipperProjectionProducts` exist. */
  shipperProjectionProductsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonPackTypeTags` relation. */
  commonPackTypeTags?: Maybe<CommonPackTypeToManyCommonPackTypeTagFilter>;
  /** Some related `commonPackTypeTags` exist. */
  commonPackTypeTagsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonPackTypePackMasters` relation. */
  commonPackTypePackMasters?: Maybe<CommonPackTypeToManyCommonPackTypePackMasterFilter>;
  /** Some related `commonPackTypePackMasters` exist. */
  commonPackTypePackMastersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPrograms` relation. */
  shipperPrograms?: Maybe<CommonPackTypeToManyShipperProgramFilter>;
  /** Some related `shipperPrograms` exist. */
  shipperProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerPrograms` relation. */
  customerPrograms?: Maybe<CommonPackTypeToManyCustomerProgramFilter>;
  /** Some related `customerPrograms` exist. */
  customerProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** A related `commonSpecies` exists. */
  commonSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `packMaster` relation. */
  packMaster?: Maybe<PackMasterFilter>;
  /** A related `packMaster` exists. */
  packMasterExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonPackTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonPackTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonPackTypeFilter>;
};

/** An input for mutations affecting `CommonPackType` */
export type CommonPackTypeInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonPackTypeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonPackTypeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `commonPackType` to look up the row to update. */
export type CommonPackTypeOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyUsingCommonPackTypePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: UpdateCommonPackTypeOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeOnCommonPackTypeForCommonPackTypePackMasterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `packMaster` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `packMaster` being updated. */
  patch: PackMasterPatch;
};

/** The fields on `commonPackType` to look up the row to update. */
export type CommonPackTypeOnCommonPackTypeForCommonPackTypePackMasterIdFkeyUsingCommonPackTypePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: UpdateCommonPackTypeOnCommonPackTypeForCommonPackTypePackMasterIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackTypePackMaster` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackTypePackMaster` being updated. */
  patch: CommonPackTypePackMasterPatch;
};

/** The fields on `commonPackType` to look up the row to update. */
export type CommonPackTypeOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: UpdateCommonPackTypeOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackTypeTag` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackTypeTag` being updated. */
  patch: CommonPackTypeTagPatch;
};

/** The fields on `commonPackType` to look up the row to update. */
export type CommonPackTypeOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: UpdateCommonPackTypeOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: CustomerProgramPatch;
};

/** The fields on `commonPackType` to look up the row to update. */
export type CommonPackTypeOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: UpdateCommonPackTypeOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeOnShipperProgramForShipperProgramCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** The fields on `commonPackType` to look up the row to update. */
export type CommonPackTypeOnShipperProgramForShipperProgramCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: UpdateCommonPackTypeOnShipperProgramForShipperProgramCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The fields on `commonPackType` to look up the row to update. */
export type CommonPackTypeOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: UpdateCommonPackTypeOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

export type CommonPackTypePackMaster = Node & {
  __typename?: 'CommonPackTypePackMaster';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypePackMaster`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `PackMaster` that is related to this `CommonPackTypePackMaster`. */
  packMaster?: Maybe<PackMaster>;
};

/** The `commonPackType` to be created by this mutation. */
export type CommonPackTypePackMasterCommonPackTypeIdFkeyCommonPackTypeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** The `commonPackTypePackMaster` to be created by this mutation. */
export type CommonPackTypePackMasterCommonPackTypeIdFkeyCommonPackTypePackMasterCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInput>;
};

/** Input for the nested mutation of `commonPackType` in the `CommonPackTypePackMasterInput` mutation. */
export type CommonPackTypePackMasterCommonPackTypeIdFkeyInput = {
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectById?: Maybe<CommonPackTypeCommonPackTypePkeyConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonPackTypeNodeIdConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteById?: Maybe<CommonPackTypeCommonPackTypePkeyDelete>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonPackTypeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateById?: Maybe<CommonPackTypeOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyNodeIdUpdate>;
  /** A `CommonPackTypeInput` object that will be created and connected to this object. */
  create?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyCommonPackTypeCreateInput>;
};

/** Input for the nested mutation of `commonPackTypePackMaster` in the `CommonPackTypeInput` mutation. */
export type CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonPackTypePackMaster` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonPackTypePackMasterCommonPackTypePackMasterPkeyConnect>>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonPackTypePackMasterNodeIdConnect>>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonPackTypePackMasterCommonPackTypePackMasterPkeyDelete>>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonPackTypePackMasterNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonPackTypePackMaster` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyUsingCommonPackTypePackMasterPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonPackTypePackMaster` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonPackTypeOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyNodeIdUpdate>>;
  /** A `CommonPackTypePackMasterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonPackTypePackMasterCommonPackTypeIdFkeyCommonPackTypePackMasterCreateInput>>;
};

/** The fields on `commonPackTypePackMaster` to look up the row to connect. */
export type CommonPackTypePackMasterCommonPackTypePackMasterPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonPackTypePackMaster` to look up the row to delete. */
export type CommonPackTypePackMasterCommonPackTypePackMasterPkeyDelete = {
  id: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonPackTypePackMaster` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type CommonPackTypePackMasterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `packMasterId` field. */
  packMasterId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CommonPackTypePackMaster` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypePackMasterFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `packMasterId` field. */
  packMasterId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonPackType` relation. */
  commonPackType?: Maybe<CommonPackTypeFilter>;
  /** A related `commonPackType` exists. */
  commonPackTypeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `packMaster` relation. */
  packMaster?: Maybe<PackMasterFilter>;
  /** A related `packMaster` exists. */
  packMasterExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonPackTypePackMasterFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonPackTypePackMasterFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonPackTypePackMasterFilter>;
};

/** The `commonPackType` to be created by this mutation. */
export type CommonPackTypePackMasterIdFkeyCommonPackTypeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `packMaster` in the `CommonPackTypeInput` mutation. */
export type CommonPackTypePackMasterIdFkeyInput = {
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  connectById?: Maybe<PackMasterPackMasterPkeyConnect>;
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  connectByNodeId?: Maybe<PackMasterNodeIdConnect>;
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  deleteById?: Maybe<PackMasterPackMasterPkeyDelete>;
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PackMasterNodeIdDelete>;
  /** The primary key(s) and patch data for `packMaster` for the far side of the relationship. */
  updateById?: Maybe<PackMasterOnCommonPackTypeForCommonPackTypePackMasterIdFkeyUsingPackMasterPkeyUpdate>;
  /** The primary key(s) and patch data for `packMaster` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonPackTypeOnCommonPackTypeForCommonPackTypePackMasterIdFkeyNodeIdUpdate>;
  /** A `PackMasterInput` object that will be created and connected to this object. */
  create?: Maybe<CommonPackTypePackMasterIdFkeyPackMasterCreateInput>;
};

/** Input for the nested mutation of `commonPackType` in the `PackMasterInput` mutation. */
export type CommonPackTypePackMasterIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonPackType` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonPackTypeCommonPackTypePkeyConnect>>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonPackTypeNodeIdConnect>>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonPackTypeCommonPackTypePkeyDelete>>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonPackTypeNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonPackTypeOnCommonPackTypeForCommonPackTypePackMasterIdFkeyUsingCommonPackTypePkeyUpdate>>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PackMasterOnCommonPackTypeForCommonPackTypePackMasterIdFkeyNodeIdUpdate>>;
  /** A `CommonPackTypeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonPackTypePackMasterIdFkeyCommonPackTypeCreateInput>>;
};

/** The `packMaster` to be created by this mutation. */
export type CommonPackTypePackMasterIdFkeyPackMasterCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  commonPackTypesUsingId?: Maybe<CommonPackTypePackMasterIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInverseInput>;
};

/** An input for mutations affecting `CommonPackTypePackMaster` */
export type CommonPackTypePackMasterInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonPackTypePackMasterNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonPackTypePackMaster` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonPackTypePackMasterNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonPackTypePackMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** The fields on `commonPackTypePackMaster` to look up the row to update. */
export type CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyUsingCommonPackTypePackMasterPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackTypePackMaster` being updated. */
  patch: UpdateCommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `packMaster` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `packMaster` being updated. */
  patch: PackMasterPatch;
};

/** The fields on `commonPackTypePackMaster` to look up the row to update. */
export type CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyUsingCommonPackTypePackMasterPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackTypePackMaster` being updated. */
  patch: UpdateCommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The `commonPackTypePackMaster` to be created by this mutation. */
export type CommonPackTypePackMasterPackMasterIdFkeyCommonPackTypePackMasterCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInput>;
};

/** Input for the nested mutation of `packMaster` in the `CommonPackTypePackMasterInput` mutation. */
export type CommonPackTypePackMasterPackMasterIdFkeyInput = {
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  connectById?: Maybe<PackMasterPackMasterPkeyConnect>;
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  connectByNodeId?: Maybe<PackMasterNodeIdConnect>;
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  deleteById?: Maybe<PackMasterPackMasterPkeyDelete>;
  /** The primary key(s) for `packMaster` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PackMasterNodeIdDelete>;
  /** The primary key(s) and patch data for `packMaster` for the far side of the relationship. */
  updateById?: Maybe<PackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyUsingPackMasterPkeyUpdate>;
  /** The primary key(s) and patch data for `packMaster` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyNodeIdUpdate>;
  /** A `PackMasterInput` object that will be created and connected to this object. */
  create?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyPackMasterCreateInput>;
};

/** Input for the nested mutation of `commonPackTypePackMaster` in the `PackMasterInput` mutation. */
export type CommonPackTypePackMasterPackMasterIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonPackTypePackMaster` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonPackTypePackMasterCommonPackTypePackMasterPkeyConnect>>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonPackTypePackMasterNodeIdConnect>>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonPackTypePackMasterCommonPackTypePackMasterPkeyDelete>>;
  /** The primary key(s) for `commonPackTypePackMaster` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonPackTypePackMasterNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonPackTypePackMaster` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyUsingCommonPackTypePackMasterPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonPackTypePackMaster` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyNodeIdUpdate>>;
  /** A `CommonPackTypePackMasterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonPackTypePackMasterPackMasterIdFkeyCommonPackTypePackMasterCreateInput>>;
};

/** The `packMaster` to be created by this mutation. */
export type CommonPackTypePackMasterPackMasterIdFkeyPackMasterCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  commonPackTypesUsingId?: Maybe<CommonPackTypePackMasterIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInverseInput>;
};

/** Represents an update to a `CommonPackTypePackMaster`. Fields that are set will be updated. */
export type CommonPackTypePackMasterPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInput>;
};

/** A connection to a list of `PackMaster` values, with data from `CommonPackTypePackMaster`. */
export type CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdManyToManyConnection = {
  __typename?: 'CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdManyToManyConnection';
  /** A list of `PackMaster` objects. */
  nodes: Array<Maybe<PackMaster>>;
  /** A list of edges which contains the `PackMaster`, info from the `CommonPackTypePackMaster`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackMaster` edge in the connection, with data from `CommonPackTypePackMaster`. */
export type CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdManyToManyEdge = {
  __typename?: 'CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackMaster` at the end of the edge. */
  node?: Maybe<PackMaster>;
  /** Reads and enables pagination through a set of `CommonPackTypePackMaster`. */
  commonPackTypePackMasters: CommonPackTypePackMastersConnection;
};


/** A `PackMaster` edge in the connection, with data from `CommonPackTypePackMaster`. */
export type CommonPackTypePackMastersByCommonPackTypePackMasterCommonPackTypeIdAndPackMasterIdManyToManyEdgeCommonPackTypePackMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
  condition?: Maybe<CommonPackTypePackMasterCondition>;
  filter?: Maybe<CommonPackTypePackMasterFilter>;
};

/** A connection to a list of `CommonPackTypePackMaster` values. */
export type CommonPackTypePackMastersConnection = {
  __typename?: 'CommonPackTypePackMastersConnection';
  /** A list of `CommonPackTypePackMaster` objects. */
  nodes: Array<Maybe<CommonPackTypePackMaster>>;
  /** A list of edges which contains the `CommonPackTypePackMaster` and cursor to aid in pagination. */
  edges: Array<CommonPackTypePackMastersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackTypePackMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackTypePackMaster` edge in the connection. */
export type CommonPackTypePackMastersEdge = {
  __typename?: 'CommonPackTypePackMastersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackTypePackMaster` at the end of the edge. */
  node?: Maybe<CommonPackTypePackMaster>;
};

/** Methods to use when ordering `CommonPackTypePackMaster`. */
export enum CommonPackTypePackMastersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommonPackTypeIdAsc = 'COMMON_PACK_TYPE_ID_ASC',
  CommonPackTypeIdDesc = 'COMMON_PACK_TYPE_ID_DESC',
  PackMasterIdAsc = 'PACK_MASTER_ID_ASC',
  PackMasterIdDesc = 'PACK_MASTER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_ASC',
  CommonPackTypeByCommonPackTypeIdIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_DESC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_ASC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_ASC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_DESC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdPalletWeightAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_ASC',
  CommonPackTypeByCommonPackTypeIdPalletWeightDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_DESC',
  CommonPackTypeByCommonPackTypeIdBoxCountAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_ASC',
  CommonPackTypeByCommonPackTypeIdBoxCountDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_DESC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_ASC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_DESC',
  PackMasterByPackMasterIdIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__ID_ASC',
  PackMasterByPackMasterIdIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__ID_DESC',
  PackMasterByPackMasterIdShipperIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__SHIPPER_ID_ASC',
  PackMasterByPackMasterIdShipperIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__SHIPPER_ID_DESC',
  PackMasterByPackMasterIdLabelCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__LABEL_CODE_ID_ASC',
  PackMasterByPackMasterIdLabelCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__LABEL_CODE_ID_DESC',
  PackMasterByPackMasterIdCustomerCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__CUSTOMER_CODE_ID_ASC',
  PackMasterByPackMasterIdCustomerCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__CUSTOMER_CODE_ID_DESC',
  PackMasterByPackMasterIdBoxTypeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_TYPE_ID_ASC',
  PackMasterByPackMasterIdBoxTypeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_TYPE_ID_DESC',
  PackMasterByPackMasterIdBoxStyleIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_STYLE_ID_ASC',
  PackMasterByPackMasterIdBoxStyleIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_STYLE_ID_DESC',
  PackMasterByPackMasterIdPackStyleIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_STYLE_ID_ASC',
  PackMasterByPackMasterIdPackStyleIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_STYLE_ID_DESC',
  PackMasterByPackMasterIdOutCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_CODE_ID_ASC',
  PackMasterByPackMasterIdOutCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_CODE_ID_DESC',
  PackMasterByPackMasterIdOutQuantityAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_QUANTITY_ASC',
  PackMasterByPackMasterIdOutQuantityDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_QUANTITY_DESC',
  PackMasterByPackMasterIdOutWeightAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_WEIGHT_ASC',
  PackMasterByPackMasterIdOutWeightDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_WEIGHT_DESC',
  PackMasterByPackMasterIdProductionCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PRODUCTION_CODE_ID_ASC',
  PackMasterByPackMasterIdProductionCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PRODUCTION_CODE_ID_DESC',
  PackMasterByPackMasterIdTreeRipeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__TREE_RIPE_ID_ASC',
  PackMasterByPackMasterIdTreeRipeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__TREE_RIPE_ID_DESC',
  PackMasterByPackMasterIdGradeCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__GRADE_CODE_ID_ASC',
  PackMasterByPackMasterIdGradeCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__GRADE_CODE_ID_DESC',
  PackMasterByPackMasterIdMaCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__MA_CODE_ID_ASC',
  PackMasterByPackMasterIdMaCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__MA_CODE_ID_DESC',
  PackMasterByPackMasterIdLinerCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__LINER_CODE_ID_ASC',
  PackMasterByPackMasterIdLinerCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__LINER_CODE_ID_DESC',
  PackMasterByPackMasterIdNetWeightContentsAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_CONTENTS_ASC',
  PackMasterByPackMasterIdNetWeightContentsDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_CONTENTS_DESC',
  PackMasterByPackMasterIdNetWeightBoxAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_BOX_ASC',
  PackMasterByPackMasterIdNetWeightBoxDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_BOX_DESC',
  PackMasterByPackMasterIdBoxLengthAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_LENGTH_ASC',
  PackMasterByPackMasterIdBoxLengthDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_LENGTH_DESC',
  PackMasterByPackMasterIdBoxWidthAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_WIDTH_ASC',
  PackMasterByPackMasterIdBoxWidthDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_WIDTH_DESC',
  PackMasterByPackMasterIdBoxHeightAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_HEIGHT_ASC',
  PackMasterByPackMasterIdBoxHeightDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_HEIGHT_DESC',
  PackMasterByPackMasterIdPalletTypeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PALLET_TYPE_ID_ASC',
  PackMasterByPackMasterIdPalletTypeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PALLET_TYPE_ID_DESC',
  PackMasterByPackMasterIdDefaultPalletQuantityAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__DEFAULT_PALLET_QUANTITY_ASC',
  PackMasterByPackMasterIdDefaultPalletQuantityDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__DEFAULT_PALLET_QUANTITY_DESC',
  PackMasterByPackMasterIdPluUpcCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PLU_UPC_CODE_ASC',
  PackMasterByPackMasterIdPluUpcCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PLU_UPC_CODE_DESC',
  PackMasterByPackMasterIdDestinationCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__DESTINATION_CODE_ID_ASC',
  PackMasterByPackMasterIdDestinationCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__DESTINATION_CODE_ID_DESC',
  PackMasterByPackMasterIdOldPackCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_PACK_CODE_ASC',
  PackMasterByPackMasterIdOldPackCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_PACK_CODE_DESC',
  PackMasterByPackMasterIdOldLabelCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_LABEL_CODE_ASC',
  PackMasterByPackMasterIdOldLabelCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_LABEL_CODE_DESC',
  PackMasterByPackMasterIdJvPackCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__JV_PACK_CODE_ASC',
  PackMasterByPackMasterIdJvPackCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__JV_PACK_CODE_DESC',
  PackMasterByPackMasterIdPackDescriptionAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_DESCRIPTION_ASC',
  PackMasterByPackMasterIdPackDescriptionDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_DESCRIPTION_DESC',
  PackMasterByPackMasterIdVarietyIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__VARIETY_ID_ASC',
  PackMasterByPackMasterIdVarietyIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__VARIETY_ID_DESC',
  PackMasterByPackMasterIdSpeciesIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__SPECIES_ID_ASC',
  PackMasterByPackMasterIdSpeciesIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__SPECIES_ID_DESC',
  PackMasterByPackMasterIdHoldCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__HOLD_CODE_ID_ASC',
  PackMasterByPackMasterIdHoldCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__HOLD_CODE_ID_DESC'
}

/** Represents an update to a `CommonPackType`. Fields that are set will be updated. */
export type CommonPackTypePatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProgram`. */
export type CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonPackTypeShippersByShipperProgramCommonPackTypeIdAndShipperIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonPackTypeShippersByShipperProjectionProductCommonPackTypeIdAndShipperIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

export type CommonPackTypeTag = Node & {
  __typename?: 'CommonPackTypeTag';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  tagText: Scalars['String'];
  commonPackTypeId: Scalars['BigInt'];
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypeTag`. */
  commonPackType?: Maybe<CommonPackType>;
};

/** The `commonPackType` to be created by this mutation. */
export type CommonPackTypeTagCommonPackTypeIdFkeyCommonPackTypeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** The `commonPackTypeTag` to be created by this mutation. */
export type CommonPackTypeTagCommonPackTypeIdFkeyCommonPackTypeTagCreateInput = {
  tagText: Scalars['String'];
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInput>;
};

/** Input for the nested mutation of `commonPackType` in the `CommonPackTypeTagInput` mutation. */
export type CommonPackTypeTagCommonPackTypeIdFkeyInput = {
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectById?: Maybe<CommonPackTypeCommonPackTypePkeyConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonPackTypeNodeIdConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteById?: Maybe<CommonPackTypeCommonPackTypePkeyDelete>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonPackTypeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateById?: Maybe<CommonPackTypeOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonPackTypeTagOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyNodeIdUpdate>;
  /** A `CommonPackTypeInput` object that will be created and connected to this object. */
  create?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyCommonPackTypeCreateInput>;
};

/** Input for the nested mutation of `commonPackTypeTag` in the `CommonPackTypeInput` mutation. */
export type CommonPackTypeTagCommonPackTypeIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonPackTypeTag` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonPackTypeTag` for the far side of the relationship. */
  connectByTagTextAndCommonPackTypeId?: Maybe<Array<CommonPackTypeTagCommonPackTypeTagPkeyConnect>>;
  /** The primary key(s) for `commonPackTypeTag` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonPackTypeTagNodeIdConnect>>;
  /** The primary key(s) for `commonPackTypeTag` for the far side of the relationship. */
  deleteByTagTextAndCommonPackTypeId?: Maybe<Array<CommonPackTypeTagCommonPackTypeTagPkeyDelete>>;
  /** The primary key(s) for `commonPackTypeTag` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonPackTypeTagNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonPackTypeTag` for the far side of the relationship. */
  updateByTagTextAndCommonPackTypeId?: Maybe<Array<CommonPackTypeTagOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyUsingCommonPackTypeTagPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonPackTypeTag` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonPackTypeOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyNodeIdUpdate>>;
  /** A `CommonPackTypeTagInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonPackTypeTagCommonPackTypeIdFkeyCommonPackTypeTagCreateInput>>;
};

/** The fields on `commonPackTypeTag` to look up the row to connect. */
export type CommonPackTypeTagCommonPackTypeTagPkeyConnect = {
  tagText: Scalars['String'];
  commonPackTypeId: Scalars['BigInt'];
};

/** The fields on `commonPackTypeTag` to look up the row to delete. */
export type CommonPackTypeTagCommonPackTypeTagPkeyDelete = {
  tagText: Scalars['String'];
  commonPackTypeId: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonPackTypeTag` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonPackTypeTagCondition = {
  /** Checks for equality with the object’s `tagText` field. */
  tagText?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CommonPackTypeTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypeTagFilter = {
  /** Filter by the object’s `tagText` field. */
  tagText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonPackType` relation. */
  commonPackType?: Maybe<CommonPackTypeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonPackTypeTagFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonPackTypeTagFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonPackTypeTagFilter>;
};

/** An input for mutations affecting `CommonPackTypeTag` */
export type CommonPackTypeTagInput = {
  tagText: Scalars['String'];
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonPackTypeTagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonPackTypeTag` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonPackTypeTagNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonPackTypeTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonPackTypeTagOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** The fields on `commonPackTypeTag` to look up the row to update. */
export type CommonPackTypeTagOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyUsingCommonPackTypeTagPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonPackTypeTag` being updated. */
  patch: UpdateCommonPackTypeTagOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyPatch;
  tagText: Scalars['String'];
  commonPackTypeId: Scalars['BigInt'];
};

/** Represents an update to a `CommonPackTypeTag`. Fields that are set will be updated. */
export type CommonPackTypeTagPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInput>;
};

/** A connection to a list of `CommonPackTypeTag` values. */
export type CommonPackTypeTagsConnection = {
  __typename?: 'CommonPackTypeTagsConnection';
  /** A list of `CommonPackTypeTag` objects. */
  nodes: Array<Maybe<CommonPackTypeTag>>;
  /** A list of edges which contains the `CommonPackTypeTag` and cursor to aid in pagination. */
  edges: Array<CommonPackTypeTagsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackTypeTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackTypeTag` edge in the connection. */
export type CommonPackTypeTagsEdge = {
  __typename?: 'CommonPackTypeTagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackTypeTag` at the end of the edge. */
  node?: Maybe<CommonPackTypeTag>;
};

/** Methods to use when ordering `CommonPackTypeTag`. */
export enum CommonPackTypeTagsOrderBy {
  Natural = 'NATURAL',
  TagTextAsc = 'TAG_TEXT_ASC',
  TagTextDesc = 'TAG_TEXT_DESC',
  CommonPackTypeIdAsc = 'COMMON_PACK_TYPE_ID_ASC',
  CommonPackTypeIdDesc = 'COMMON_PACK_TYPE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_ASC',
  CommonPackTypeByCommonPackTypeIdIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_DESC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_ASC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_ASC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_DESC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdPalletWeightAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_ASC',
  CommonPackTypeByCommonPackTypeIdPalletWeightDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_DESC',
  CommonPackTypeByCommonPackTypeIdBoxCountAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_ASC',
  CommonPackTypeByCommonPackTypeIdBoxCountDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_DESC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_ASC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_DESC'
}

/** A filter to be used against many `CommonPackTypePackMaster` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypeToManyCommonPackTypePackMasterFilter = {
  /** Every related `CommonPackTypePackMaster` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonPackTypePackMasterFilter>;
  /** Some related `CommonPackTypePackMaster` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonPackTypePackMasterFilter>;
  /** No related `CommonPackTypePackMaster` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonPackTypePackMasterFilter>;
};

/** A filter to be used against many `CommonPackTypeTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypeToManyCommonPackTypeTagFilter = {
  /** Every related `CommonPackTypeTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonPackTypeTagFilter>;
  /** Some related `CommonPackTypeTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonPackTypeTagFilter>;
  /** No related `CommonPackTypeTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonPackTypeTagFilter>;
};

/** A filter to be used against many `CustomerProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypeToManyCustomerProgramFilter = {
  /** Every related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerProgramFilter>;
  /** Some related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerProgramFilter>;
  /** No related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerProgramFilter>;
};

/** A filter to be used against many `ShipperProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypeToManyShipperProgramFilter = {
  /** Every related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramFilter>;
  /** Some related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramFilter>;
  /** No related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramFilter>;
};

/** A filter to be used against many `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type CommonPackTypeToManyShipperProjectionProductFilter = {
  /** Every related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionProductFilter>;
  /** Some related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionProductFilter>;
  /** No related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonPackType` values. */
export type CommonPackTypesConnection = {
  __typename?: 'CommonPackTypesConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType` and cursor to aid in pagination. */
  edges: Array<CommonPackTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection. */
export type CommonPackTypesEdge = {
  __typename?: 'CommonPackTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
};

/** Methods to use when ordering `CommonPackType`. */
export enum CommonPackTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PackTypeNameAsc = 'PACK_TYPE_NAME_ASC',
  PackTypeNameDesc = 'PACK_TYPE_NAME_DESC',
  PackTypeDescriptionAsc = 'PACK_TYPE_DESCRIPTION_ASC',
  PackTypeDescriptionDesc = 'PACK_TYPE_DESCRIPTION_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  PackMasterIdAsc = 'PACK_MASTER_ID_ASC',
  PackMasterIdDesc = 'PACK_MASTER_ID_DESC',
  DefaultInvSortKeyAsc = 'DEFAULT_INV_SORT_KEY_ASC',
  DefaultInvSortKeyDesc = 'DEFAULT_INV_SORT_KEY_DESC',
  PalletWeightAsc = 'PALLET_WEIGHT_ASC',
  PalletWeightDesc = 'PALLET_WEIGHT_DESC',
  BoxCountAsc = 'BOX_COUNT_ASC',
  BoxCountDesc = 'BOX_COUNT_DESC',
  RepackStyleIdAsc = 'REPACK_STYLE_ID_ASC',
  RepackStyleIdDesc = 'REPACK_STYLE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC',
  PackMasterByPackMasterIdIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__ID_ASC',
  PackMasterByPackMasterIdIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__ID_DESC',
  PackMasterByPackMasterIdShipperIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__SHIPPER_ID_ASC',
  PackMasterByPackMasterIdShipperIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__SHIPPER_ID_DESC',
  PackMasterByPackMasterIdLabelCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__LABEL_CODE_ID_ASC',
  PackMasterByPackMasterIdLabelCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__LABEL_CODE_ID_DESC',
  PackMasterByPackMasterIdCustomerCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__CUSTOMER_CODE_ID_ASC',
  PackMasterByPackMasterIdCustomerCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__CUSTOMER_CODE_ID_DESC',
  PackMasterByPackMasterIdBoxTypeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_TYPE_ID_ASC',
  PackMasterByPackMasterIdBoxTypeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_TYPE_ID_DESC',
  PackMasterByPackMasterIdBoxStyleIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_STYLE_ID_ASC',
  PackMasterByPackMasterIdBoxStyleIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_STYLE_ID_DESC',
  PackMasterByPackMasterIdPackStyleIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_STYLE_ID_ASC',
  PackMasterByPackMasterIdPackStyleIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_STYLE_ID_DESC',
  PackMasterByPackMasterIdOutCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_CODE_ID_ASC',
  PackMasterByPackMasterIdOutCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_CODE_ID_DESC',
  PackMasterByPackMasterIdOutQuantityAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_QUANTITY_ASC',
  PackMasterByPackMasterIdOutQuantityDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_QUANTITY_DESC',
  PackMasterByPackMasterIdOutWeightAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_WEIGHT_ASC',
  PackMasterByPackMasterIdOutWeightDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OUT_WEIGHT_DESC',
  PackMasterByPackMasterIdProductionCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PRODUCTION_CODE_ID_ASC',
  PackMasterByPackMasterIdProductionCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PRODUCTION_CODE_ID_DESC',
  PackMasterByPackMasterIdTreeRipeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__TREE_RIPE_ID_ASC',
  PackMasterByPackMasterIdTreeRipeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__TREE_RIPE_ID_DESC',
  PackMasterByPackMasterIdGradeCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__GRADE_CODE_ID_ASC',
  PackMasterByPackMasterIdGradeCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__GRADE_CODE_ID_DESC',
  PackMasterByPackMasterIdMaCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__MA_CODE_ID_ASC',
  PackMasterByPackMasterIdMaCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__MA_CODE_ID_DESC',
  PackMasterByPackMasterIdLinerCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__LINER_CODE_ID_ASC',
  PackMasterByPackMasterIdLinerCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__LINER_CODE_ID_DESC',
  PackMasterByPackMasterIdNetWeightContentsAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_CONTENTS_ASC',
  PackMasterByPackMasterIdNetWeightContentsDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_CONTENTS_DESC',
  PackMasterByPackMasterIdNetWeightBoxAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_BOX_ASC',
  PackMasterByPackMasterIdNetWeightBoxDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__NET_WEIGHT_BOX_DESC',
  PackMasterByPackMasterIdBoxLengthAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_LENGTH_ASC',
  PackMasterByPackMasterIdBoxLengthDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_LENGTH_DESC',
  PackMasterByPackMasterIdBoxWidthAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_WIDTH_ASC',
  PackMasterByPackMasterIdBoxWidthDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_WIDTH_DESC',
  PackMasterByPackMasterIdBoxHeightAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_HEIGHT_ASC',
  PackMasterByPackMasterIdBoxHeightDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__BOX_HEIGHT_DESC',
  PackMasterByPackMasterIdPalletTypeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PALLET_TYPE_ID_ASC',
  PackMasterByPackMasterIdPalletTypeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PALLET_TYPE_ID_DESC',
  PackMasterByPackMasterIdDefaultPalletQuantityAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__DEFAULT_PALLET_QUANTITY_ASC',
  PackMasterByPackMasterIdDefaultPalletQuantityDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__DEFAULT_PALLET_QUANTITY_DESC',
  PackMasterByPackMasterIdPluUpcCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PLU_UPC_CODE_ASC',
  PackMasterByPackMasterIdPluUpcCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PLU_UPC_CODE_DESC',
  PackMasterByPackMasterIdDestinationCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__DESTINATION_CODE_ID_ASC',
  PackMasterByPackMasterIdDestinationCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__DESTINATION_CODE_ID_DESC',
  PackMasterByPackMasterIdOldPackCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_PACK_CODE_ASC',
  PackMasterByPackMasterIdOldPackCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_PACK_CODE_DESC',
  PackMasterByPackMasterIdOldLabelCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_LABEL_CODE_ASC',
  PackMasterByPackMasterIdOldLabelCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__OLD_LABEL_CODE_DESC',
  PackMasterByPackMasterIdJvPackCodeAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__JV_PACK_CODE_ASC',
  PackMasterByPackMasterIdJvPackCodeDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__JV_PACK_CODE_DESC',
  PackMasterByPackMasterIdPackDescriptionAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_DESCRIPTION_ASC',
  PackMasterByPackMasterIdPackDescriptionDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__PACK_DESCRIPTION_DESC',
  PackMasterByPackMasterIdVarietyIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__VARIETY_ID_ASC',
  PackMasterByPackMasterIdVarietyIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__VARIETY_ID_DESC',
  PackMasterByPackMasterIdSpeciesIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__SPECIES_ID_ASC',
  PackMasterByPackMasterIdSpeciesIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__SPECIES_ID_DESC',
  PackMasterByPackMasterIdHoldCodeIdAsc = 'PACK_MASTER_BY_PACK_MASTER_ID__HOLD_CODE_ID_ASC',
  PackMasterByPackMasterIdHoldCodeIdDesc = 'PACK_MASTER_BY_PACK_MASTER_ID__HOLD_CODE_ID_DESC',
  ShipperProjectionProductsByCommonPackTypeIdCountAsc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_PACK_TYPE_ID__COUNT_ASC',
  ShipperProjectionProductsByCommonPackTypeIdCountDesc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_PACK_TYPE_ID__COUNT_DESC',
  CommonPackTypeTagsByCommonPackTypeIdCountAsc = 'COMMON_PACK_TYPE_TAGS_BY_COMMON_PACK_TYPE_ID__COUNT_ASC',
  CommonPackTypeTagsByCommonPackTypeIdCountDesc = 'COMMON_PACK_TYPE_TAGS_BY_COMMON_PACK_TYPE_ID__COUNT_DESC',
  CommonPackTypePackMastersByCommonPackTypeIdCountAsc = 'COMMON_PACK_TYPE_PACK_MASTERS_BY_COMMON_PACK_TYPE_ID__COUNT_ASC',
  CommonPackTypePackMastersByCommonPackTypeIdCountDesc = 'COMMON_PACK_TYPE_PACK_MASTERS_BY_COMMON_PACK_TYPE_ID__COUNT_DESC',
  ShipperProgramsByCommonPackTypeIdCountAsc = 'SHIPPER_PROGRAMS_BY_COMMON_PACK_TYPE_ID__COUNT_ASC',
  ShipperProgramsByCommonPackTypeIdCountDesc = 'SHIPPER_PROGRAMS_BY_COMMON_PACK_TYPE_ID__COUNT_DESC',
  CustomerProgramsByCommonPackTypeIdCountAsc = 'CUSTOMER_PROGRAMS_BY_COMMON_PACK_TYPE_ID__COUNT_ASC',
  CustomerProgramsByCommonPackTypeIdCountDesc = 'CUSTOMER_PROGRAMS_BY_COMMON_PACK_TYPE_ID__COUNT_DESC'
}

export type CommonSize = Node & {
  __typename?: 'CommonSize';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSize`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSize` that is related to this `CommonSize`. */
  productSize?: Maybe<ProductSize>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
  /** Reads and enables pagination through a set of `CommonSizeTag`. */
  commonSizeTags: CommonSizeTagsConnection;
  /** Reads and enables pagination through a set of `CommonSizeProductSize`. */
  commonSizeProductSizes: CommonSizeProductSizesConnection;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionProductCommonSizeIdAndShipperId: CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesId: CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyId: CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeId: CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProjectionProductCommonSizeIdAndCustomerId: CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ProductSize`. */
  productSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeId: CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesId: CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyId: CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeId: CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProgramCommonSizeIdAndShipperId: CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProgramCommonSizeIdAndCustomerId: CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesId: CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyId: CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeId: CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByCustomerProgramCommonSizeIdAndCustomerId: CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdManyToManyConnection;
};


export type CommonSizeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type CommonSizeCommonSizeTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizeTagsOrderBy>>;
  condition?: Maybe<CommonSizeTagCondition>;
  filter?: Maybe<CommonSizeTagFilter>;
};


export type CommonSizeCommonSizeProductSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
  condition?: Maybe<CommonSizeProductSizeCondition>;
  filter?: Maybe<CommonSizeProductSizeFilter>;
};


export type CommonSizeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};


export type CommonSizeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};


export type CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
  condition?: Maybe<ProductSizeCondition>;
  filter?: Maybe<ProductSizeFilter>;
};


export type CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `CustomerProgram`. */
export type CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCommonPackTypesByCustomerProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProgram`. */
export type CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCommonPackTypesByShipperProgramCommonSizeIdAndCommonPackTypeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonPackTypesByShipperProjectionProductCommonSizeIdAndCommonPackTypeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** The fields on `commonSize` to look up the row to connect. */
export type CommonSizeCommonSizePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonSize` to look up the row to delete. */
export type CommonSizeCommonSizePkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `CommonSpecies` values, with data from `CustomerProgram`. */
export type CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCommonSpeciesByCustomerProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProgram`. */
export type CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCommonSpeciesByShipperProgramCommonSizeIdAndCommonSpeciesIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonSpeciesByShipperProjectionProductCommonSizeIdAndCommonSpeciesIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** The `commonSize` to be created by this mutation. */
export type CommonSizeCommonSpeciesIdFkeyCommonSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CommonSizeCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `CommonSizeInput` mutation. */
export type CommonSizeCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnCommonSizeForCommonSizeCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSizeOnCommonSizeForCommonSizeCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSizeCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `commonSize` in the `CommonSpeciesInput` mutation. */
export type CommonSizeCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSize` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSizeCommonSizePkeyConnect>>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSizeNodeIdConnect>>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSizeCommonSizePkeyDelete>>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSizeNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSizeOnCommonSizeForCommonSizeCommonSpeciesIdFkeyUsingCommonSizePkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnCommonSizeForCommonSizeCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CommonSizeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSizeCommonSpeciesIdFkeyCommonSizeCreateInput>>;
};

/** A connection to a list of `CommonVariety` values, with data from `CustomerProgram`. */
export type CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCommonVarietiesByCustomerProgramCommonSizeIdAndCommonVarietyIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProgram`. */
export type CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCommonVarietiesByShipperProgramCommonSizeIdAndCommonVarietyIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCommonVarietiesByShipperProjectionProductCommonSizeIdAndCommonVarietyIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/**
 * A condition to be used against `CommonSize` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CommonSizeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sizeName` field. */
  sizeName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeDescription` field. */
  sizeDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productSizeId` field. */
  productSizeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Customer` values, with data from `CustomerProgram`. */
export type CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonSizeCustomersByCustomerProgramCommonSizeIdAndCustomerIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProgram`. */
export type CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeCustomersByShipperProgramCommonSizeIdAndCustomerIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProjectionProduct`. */
export type CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeCustomersByShipperProjectionProductCommonSizeIdAndCustomerIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against `CommonSize` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `sizeName` field. */
  sizeName?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeDescription` field. */
  sizeDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productSizeId` field. */
  productSizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionProducts` relation. */
  shipperProjectionProducts?: Maybe<CommonSizeToManyShipperProjectionProductFilter>;
  /** Some related `shipperProjectionProducts` exist. */
  shipperProjectionProductsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSizeTags` relation. */
  commonSizeTags?: Maybe<CommonSizeToManyCommonSizeTagFilter>;
  /** Some related `commonSizeTags` exist. */
  commonSizeTagsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSizeProductSizes` relation. */
  commonSizeProductSizes?: Maybe<CommonSizeToManyCommonSizeProductSizeFilter>;
  /** Some related `commonSizeProductSizes` exist. */
  commonSizeProductSizesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPrograms` relation. */
  shipperPrograms?: Maybe<CommonSizeToManyShipperProgramFilter>;
  /** Some related `shipperPrograms` exist. */
  shipperProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerPrograms` relation. */
  customerPrograms?: Maybe<CommonSizeToManyCustomerProgramFilter>;
  /** Some related `customerPrograms` exist. */
  customerProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** A related `commonSpecies` exists. */
  commonSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `productSize` relation. */
  productSize?: Maybe<ProductSizeFilter>;
  /** A related `productSize` exists. */
  productSizeExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonSizeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonSizeFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonSizeFilter>;
};

/** An input for mutations affecting `CommonSize` */
export type CommonSizeInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonSizeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonSizeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeOnCommonSizeForCommonSizeCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `commonSize` to look up the row to update. */
export type CommonSizeOnCommonSizeForCommonSizeCommonSpeciesIdFkeyUsingCommonSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: UpdateCommonSizeOnCommonSizeForCommonSizeCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeOnCommonSizeForCommonSizeProductSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `productSize` being updated. */
  patch: ProductSizePatch;
};

/** The fields on `commonSize` to look up the row to update. */
export type CommonSizeOnCommonSizeForCommonSizeProductSizeIdFkeyUsingCommonSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: UpdateCommonSizeOnCommonSizeForCommonSizeProductSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSizeProductSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSizeProductSize` being updated. */
  patch: CommonSizeProductSizePatch;
};

/** The fields on `commonSize` to look up the row to update. */
export type CommonSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyUsingCommonSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: UpdateCommonSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSizeTag` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSizeTag` being updated. */
  patch: CommonSizeTagPatch;
};

/** The fields on `commonSize` to look up the row to update. */
export type CommonSizeOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyUsingCommonSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: UpdateCommonSizeOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeOnCustomerProgramForCustomerProgramCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: CustomerProgramPatch;
};

/** The fields on `commonSize` to look up the row to update. */
export type CommonSizeOnCustomerProgramForCustomerProgramCommonSizeIdFkeyUsingCommonSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: UpdateCommonSizeOnCustomerProgramForCustomerProgramCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeOnShipperProgramForShipperProgramCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** The fields on `commonSize` to look up the row to update. */
export type CommonSizeOnShipperProgramForShipperProgramCommonSizeIdFkeyUsingCommonSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: UpdateCommonSizeOnShipperProgramForShipperProgramCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The fields on `commonSize` to look up the row to update. */
export type CommonSizeOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyUsingCommonSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: UpdateCommonSizeOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `CommonSize`. Fields that are set will be updated. */
export type CommonSizePatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

export type CommonSizeProductSize = Node & {
  __typename?: 'CommonSizeProductSize';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  commonSizeId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeProductSize`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `ProductSize` that is related to this `CommonSizeProductSize`. */
  productSize?: Maybe<ProductSize>;
};

/** The `commonSize` to be created by this mutation. */
export type CommonSizeProductSizeCommonSizeIdFkeyCommonSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** The `commonSizeProductSize` to be created by this mutation. */
export type CommonSizeProductSizeCommonSizeIdFkeyCommonSizeProductSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInput>;
};

/** Input for the nested mutation of `commonSize` in the `CommonSizeProductSizeInput` mutation. */
export type CommonSizeProductSizeCommonSizeIdFkeyInput = {
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectById?: Maybe<CommonSizeCommonSizePkeyConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSizeNodeIdConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteById?: Maybe<CommonSizeCommonSizePkeyDelete>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateById?: Maybe<CommonSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyUsingCommonSizePkeyUpdate>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyNodeIdUpdate>;
  /** A `CommonSizeInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyCommonSizeCreateInput>;
};

/** Input for the nested mutation of `commonSizeProductSize` in the `CommonSizeInput` mutation. */
export type CommonSizeProductSizeCommonSizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSizeProductSize` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSizeProductSizeCommonSizeProductSizePkeyConnect>>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSizeProductSizeNodeIdConnect>>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSizeProductSizeCommonSizeProductSizePkeyDelete>>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSizeProductSizeNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSizeProductSize` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyUsingCommonSizeProductSizePkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSizeProductSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyNodeIdUpdate>>;
  /** A `CommonSizeProductSizeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSizeProductSizeCommonSizeIdFkeyCommonSizeProductSizeCreateInput>>;
};

/** The fields on `commonSizeProductSize` to look up the row to connect. */
export type CommonSizeProductSizeCommonSizeProductSizePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonSizeProductSize` to look up the row to delete. */
export type CommonSizeProductSizeCommonSizeProductSizePkeyDelete = {
  id: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonSizeProductSize` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CommonSizeProductSizeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productSizeId` field. */
  productSizeId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CommonSizeProductSize` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeProductSizeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productSizeId` field. */
  productSizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSize` relation. */
  commonSize?: Maybe<CommonSizeFilter>;
  /** A related `commonSize` exists. */
  commonSizeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `productSize` relation. */
  productSize?: Maybe<ProductSizeFilter>;
  /** A related `productSize` exists. */
  productSizeExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonSizeProductSizeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonSizeProductSizeFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonSizeProductSizeFilter>;
};

/** The `commonSize` to be created by this mutation. */
export type CommonSizeProductSizeIdFkeyCommonSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `productSize` in the `CommonSizeInput` mutation. */
export type CommonSizeProductSizeIdFkeyInput = {
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  connectById?: Maybe<ProductSizeProductSizePkeyConnect>;
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<ProductSizeNodeIdConnect>;
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  deleteById?: Maybe<ProductSizeProductSizePkeyDelete>;
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ProductSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `productSize` for the far side of the relationship. */
  updateById?: Maybe<ProductSizeOnCommonSizeForCommonSizeProductSizeIdFkeyUsingProductSizePkeyUpdate>;
  /** The primary key(s) and patch data for `productSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSizeOnCommonSizeForCommonSizeProductSizeIdFkeyNodeIdUpdate>;
  /** A `ProductSizeInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSizeProductSizeIdFkeyProductSizeCreateInput>;
};

/** Input for the nested mutation of `commonSize` in the `ProductSizeInput` mutation. */
export type CommonSizeProductSizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSize` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSizeCommonSizePkeyConnect>>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSizeNodeIdConnect>>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSizeCommonSizePkeyDelete>>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSizeNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSizeOnCommonSizeForCommonSizeProductSizeIdFkeyUsingCommonSizePkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ProductSizeOnCommonSizeForCommonSizeProductSizeIdFkeyNodeIdUpdate>>;
  /** A `CommonSizeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSizeProductSizeIdFkeyCommonSizeCreateInput>>;
};

/** The `productSize` to be created by this mutation. */
export type CommonSizeProductSizeIdFkeyProductSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSizesUsingId?: Maybe<CommonSizeProductSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInverseInput>;
};

/** An input for mutations affecting `CommonSizeProductSize` */
export type CommonSizeProductSizeInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonSizeProductSizeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonSizeProductSize` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonSizeProductSizeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonSizeProductSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: CommonSizePatch;
};

/** The fields on `commonSizeProductSize` to look up the row to update. */
export type CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyUsingCommonSizeProductSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSizeProductSize` being updated. */
  patch: UpdateCommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `productSize` being updated. */
  patch: ProductSizePatch;
};

/** The fields on `commonSizeProductSize` to look up the row to update. */
export type CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyUsingCommonSizeProductSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSizeProductSize` being updated. */
  patch: UpdateCommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `CommonSizeProductSize`. Fields that are set will be updated. */
export type CommonSizeProductSizePatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInput>;
};

/** The `commonSizeProductSize` to be created by this mutation. */
export type CommonSizeProductSizeProductSizeIdFkeyCommonSizeProductSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInput>;
};

/** Input for the nested mutation of `productSize` in the `CommonSizeProductSizeInput` mutation. */
export type CommonSizeProductSizeProductSizeIdFkeyInput = {
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  connectById?: Maybe<ProductSizeProductSizePkeyConnect>;
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<ProductSizeNodeIdConnect>;
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  deleteById?: Maybe<ProductSizeProductSizePkeyDelete>;
  /** The primary key(s) for `productSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ProductSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `productSize` for the far side of the relationship. */
  updateById?: Maybe<ProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyUsingProductSizePkeyUpdate>;
  /** The primary key(s) and patch data for `productSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyNodeIdUpdate>;
  /** A `ProductSizeInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSizeProductSizeProductSizeIdFkeyProductSizeCreateInput>;
};

/** Input for the nested mutation of `commonSizeProductSize` in the `ProductSizeInput` mutation. */
export type CommonSizeProductSizeProductSizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSizeProductSize` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSizeProductSizeCommonSizeProductSizePkeyConnect>>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSizeProductSizeNodeIdConnect>>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSizeProductSizeCommonSizeProductSizePkeyDelete>>;
  /** The primary key(s) for `commonSizeProductSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSizeProductSizeNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSizeProductSize` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyUsingCommonSizeProductSizePkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSizeProductSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyNodeIdUpdate>>;
  /** A `CommonSizeProductSizeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSizeProductSizeProductSizeIdFkeyCommonSizeProductSizeCreateInput>>;
};

/** The `productSize` to be created by this mutation. */
export type CommonSizeProductSizeProductSizeIdFkeyProductSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSizesUsingId?: Maybe<CommonSizeProductSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInverseInput>;
};

/** A connection to a list of `ProductSize` values, with data from `CommonSizeProductSize`. */
export type CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdManyToManyConnection = {
  __typename?: 'CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdManyToManyConnection';
  /** A list of `ProductSize` objects. */
  nodes: Array<Maybe<ProductSize>>;
  /** A list of edges which contains the `ProductSize`, info from the `CommonSizeProductSize`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSize` edge in the connection, with data from `CommonSizeProductSize`. */
export type CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdManyToManyEdge = {
  __typename?: 'CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSize` at the end of the edge. */
  node?: Maybe<ProductSize>;
  /** Reads and enables pagination through a set of `CommonSizeProductSize`. */
  commonSizeProductSizes: CommonSizeProductSizesConnection;
};


/** A `ProductSize` edge in the connection, with data from `CommonSizeProductSize`. */
export type CommonSizeProductSizesByCommonSizeProductSizeCommonSizeIdAndProductSizeIdManyToManyEdgeCommonSizeProductSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
  condition?: Maybe<CommonSizeProductSizeCondition>;
  filter?: Maybe<CommonSizeProductSizeFilter>;
};

/** A connection to a list of `CommonSizeProductSize` values. */
export type CommonSizeProductSizesConnection = {
  __typename?: 'CommonSizeProductSizesConnection';
  /** A list of `CommonSizeProductSize` objects. */
  nodes: Array<Maybe<CommonSizeProductSize>>;
  /** A list of edges which contains the `CommonSizeProductSize` and cursor to aid in pagination. */
  edges: Array<CommonSizeProductSizesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSizeProductSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSizeProductSize` edge in the connection. */
export type CommonSizeProductSizesEdge = {
  __typename?: 'CommonSizeProductSizesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSizeProductSize` at the end of the edge. */
  node?: Maybe<CommonSizeProductSize>;
};

/** Methods to use when ordering `CommonSizeProductSize`. */
export enum CommonSizeProductSizesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommonSizeIdAsc = 'COMMON_SIZE_ID_ASC',
  CommonSizeIdDesc = 'COMMON_SIZE_ID_DESC',
  ProductSizeIdAsc = 'PRODUCT_SIZE_ID_ASC',
  ProductSizeIdDesc = 'PRODUCT_SIZE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSizeByCommonSizeIdIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_ASC',
  CommonSizeByCommonSizeIdIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_DESC',
  CommonSizeByCommonSizeIdSizeNameAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_ASC',
  CommonSizeByCommonSizeIdSizeNameDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_DESC',
  CommonSizeByCommonSizeIdSizeDescriptionAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_ASC',
  CommonSizeByCommonSizeIdSizeDescriptionDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_DESC',
  CommonSizeByCommonSizeIdCommonSpeciesIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_ASC',
  CommonSizeByCommonSizeIdCommonSpeciesIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_DESC',
  CommonSizeByCommonSizeIdProductSizeIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_ASC',
  CommonSizeByCommonSizeIdProductSizeIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_DESC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_DESC',
  ProductSizeByProductSizeIdIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__ID_ASC',
  ProductSizeByProductSizeIdIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__ID_DESC',
  ProductSizeByProductSizeIdSpeciesIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SPECIES_ID_ASC',
  ProductSizeByProductSizeIdSpeciesIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SPECIES_ID_DESC',
  ProductSizeByProductSizeIdVarietyIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__VARIETY_ID_ASC',
  ProductSizeByProductSizeIdVarietyIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__VARIETY_ID_DESC',
  ProductSizeByProductSizeIdJvCodeAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_CODE_ASC',
  ProductSizeByProductSizeIdJvCodeDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_CODE_DESC',
  ProductSizeByProductSizeIdJvDescriptionAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_DESCRIPTION_ASC',
  ProductSizeByProductSizeIdJvDescriptionDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_DESCRIPTION_DESC',
  ProductSizeByProductSizeIdShipperCodeAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_CODE_ASC',
  ProductSizeByProductSizeIdShipperCodeDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_CODE_DESC',
  ProductSizeByProductSizeIdShipperDescriptionAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_DESCRIPTION_ASC',
  ProductSizeByProductSizeIdShipperDescriptionDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_DESCRIPTION_DESC',
  ProductSizeByProductSizeIdCombineWithAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_WITH_ASC',
  ProductSizeByProductSizeIdCombineWithDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_WITH_DESC',
  ProductSizeByProductSizeIdCombineDescriptionAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_DESCRIPTION_ASC',
  ProductSizeByProductSizeIdCombineDescriptionDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_DESCRIPTION_DESC',
  ProductSizeByProductSizeIdShipperIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_ID_ASC',
  ProductSizeByProductSizeIdShipperIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_ID_DESC'
}

/** A connection to a list of `Shipper` values, with data from `ShipperProgram`. */
export type CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonSizeShippersByShipperProgramCommonSizeIdAndShipperIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionProduct`. */
export type CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSizeShippersByShipperProjectionProductCommonSizeIdAndShipperIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

export type CommonSizeTag = Node & {
  __typename?: 'CommonSizeTag';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  tagText: Scalars['String'];
  commonSizeId: Scalars['BigInt'];
  /** Reads a single `CommonSize` that is related to this `CommonSizeTag`. */
  commonSize?: Maybe<CommonSize>;
};

/** The `commonSize` to be created by this mutation. */
export type CommonSizeTagCommonSizeIdFkeyCommonSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** The `commonSizeTag` to be created by this mutation. */
export type CommonSizeTagCommonSizeIdFkeyCommonSizeTagCreateInput = {
  tagText: Scalars['String'];
  commonSizeToCommonSizeId?: Maybe<CommonSizeTagCommonSizeIdFkeyInput>;
};

/** Input for the nested mutation of `commonSize` in the `CommonSizeTagInput` mutation. */
export type CommonSizeTagCommonSizeIdFkeyInput = {
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectById?: Maybe<CommonSizeCommonSizePkeyConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSizeNodeIdConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteById?: Maybe<CommonSizeCommonSizePkeyDelete>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateById?: Maybe<CommonSizeOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyUsingCommonSizePkeyUpdate>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSizeTagOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyNodeIdUpdate>;
  /** A `CommonSizeInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSizeTagCommonSizeIdFkeyCommonSizeCreateInput>;
};

/** Input for the nested mutation of `commonSizeTag` in the `CommonSizeInput` mutation. */
export type CommonSizeTagCommonSizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSizeTag` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSizeTag` for the far side of the relationship. */
  connectByTagTextAndCommonSizeId?: Maybe<Array<CommonSizeTagCommonSizeTagPkeyConnect>>;
  /** The primary key(s) for `commonSizeTag` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSizeTagNodeIdConnect>>;
  /** The primary key(s) for `commonSizeTag` for the far side of the relationship. */
  deleteByTagTextAndCommonSizeId?: Maybe<Array<CommonSizeTagCommonSizeTagPkeyDelete>>;
  /** The primary key(s) for `commonSizeTag` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSizeTagNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSizeTag` for the far side of the relationship. */
  updateByTagTextAndCommonSizeId?: Maybe<Array<CommonSizeTagOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyUsingCommonSizeTagPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSizeTag` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSizeOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyNodeIdUpdate>>;
  /** A `CommonSizeTagInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSizeTagCommonSizeIdFkeyCommonSizeTagCreateInput>>;
};

/** The fields on `commonSizeTag` to look up the row to connect. */
export type CommonSizeTagCommonSizeTagPkeyConnect = {
  tagText: Scalars['String'];
  commonSizeId: Scalars['BigInt'];
};

/** The fields on `commonSizeTag` to look up the row to delete. */
export type CommonSizeTagCommonSizeTagPkeyDelete = {
  tagText: Scalars['String'];
  commonSizeId: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonSizeTag` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonSizeTagCondition = {
  /** Checks for equality with the object’s `tagText` field. */
  tagText?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CommonSizeTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeTagFilter = {
  /** Filter by the object’s `tagText` field. */
  tagText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSize` relation. */
  commonSize?: Maybe<CommonSizeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonSizeTagFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonSizeTagFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonSizeTagFilter>;
};

/** An input for mutations affecting `CommonSizeTag` */
export type CommonSizeTagInput = {
  tagText: Scalars['String'];
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeTagCommonSizeIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonSizeTagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonSizeTag` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonSizeTagNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonSizeTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSizeTagOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: CommonSizePatch;
};

/** The fields on `commonSizeTag` to look up the row to update. */
export type CommonSizeTagOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyUsingCommonSizeTagPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSizeTag` being updated. */
  patch: UpdateCommonSizeTagOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyPatch;
  tagText: Scalars['String'];
  commonSizeId: Scalars['BigInt'];
};

/** Represents an update to a `CommonSizeTag`. Fields that are set will be updated. */
export type CommonSizeTagPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeTagCommonSizeIdFkeyInput>;
};

/** A connection to a list of `CommonSizeTag` values. */
export type CommonSizeTagsConnection = {
  __typename?: 'CommonSizeTagsConnection';
  /** A list of `CommonSizeTag` objects. */
  nodes: Array<Maybe<CommonSizeTag>>;
  /** A list of edges which contains the `CommonSizeTag` and cursor to aid in pagination. */
  edges: Array<CommonSizeTagsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSizeTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSizeTag` edge in the connection. */
export type CommonSizeTagsEdge = {
  __typename?: 'CommonSizeTagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSizeTag` at the end of the edge. */
  node?: Maybe<CommonSizeTag>;
};

/** Methods to use when ordering `CommonSizeTag`. */
export enum CommonSizeTagsOrderBy {
  Natural = 'NATURAL',
  TagTextAsc = 'TAG_TEXT_ASC',
  TagTextDesc = 'TAG_TEXT_DESC',
  CommonSizeIdAsc = 'COMMON_SIZE_ID_ASC',
  CommonSizeIdDesc = 'COMMON_SIZE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSizeByCommonSizeIdIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_ASC',
  CommonSizeByCommonSizeIdIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_DESC',
  CommonSizeByCommonSizeIdSizeNameAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_ASC',
  CommonSizeByCommonSizeIdSizeNameDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_DESC',
  CommonSizeByCommonSizeIdSizeDescriptionAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_ASC',
  CommonSizeByCommonSizeIdSizeDescriptionDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_DESC',
  CommonSizeByCommonSizeIdCommonSpeciesIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_ASC',
  CommonSizeByCommonSizeIdCommonSpeciesIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_DESC',
  CommonSizeByCommonSizeIdProductSizeIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_ASC',
  CommonSizeByCommonSizeIdProductSizeIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_DESC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_DESC'
}

/** A filter to be used against many `CommonSizeProductSize` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeToManyCommonSizeProductSizeFilter = {
  /** Every related `CommonSizeProductSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSizeProductSizeFilter>;
  /** Some related `CommonSizeProductSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSizeProductSizeFilter>;
  /** No related `CommonSizeProductSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSizeProductSizeFilter>;
};

/** A filter to be used against many `CommonSizeTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeToManyCommonSizeTagFilter = {
  /** Every related `CommonSizeTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSizeTagFilter>;
  /** Some related `CommonSizeTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSizeTagFilter>;
  /** No related `CommonSizeTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSizeTagFilter>;
};

/** A filter to be used against many `CustomerProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeToManyCustomerProgramFilter = {
  /** Every related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerProgramFilter>;
  /** Some related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerProgramFilter>;
  /** No related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerProgramFilter>;
};

/** A filter to be used against many `ShipperProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeToManyShipperProgramFilter = {
  /** Every related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramFilter>;
  /** Some related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramFilter>;
  /** No related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramFilter>;
};

/** A filter to be used against many `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type CommonSizeToManyShipperProjectionProductFilter = {
  /** Every related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionProductFilter>;
  /** Some related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionProductFilter>;
  /** No related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSize` values. */
export type CommonSizesConnection = {
  __typename?: 'CommonSizesConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize` and cursor to aid in pagination. */
  edges: Array<CommonSizesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection. */
export type CommonSizesEdge = {
  __typename?: 'CommonSizesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
};

/** Methods to use when ordering `CommonSize`. */
export enum CommonSizesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SizeNameAsc = 'SIZE_NAME_ASC',
  SizeNameDesc = 'SIZE_NAME_DESC',
  SizeDescriptionAsc = 'SIZE_DESCRIPTION_ASC',
  SizeDescriptionDesc = 'SIZE_DESCRIPTION_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  ProductSizeIdAsc = 'PRODUCT_SIZE_ID_ASC',
  ProductSizeIdDesc = 'PRODUCT_SIZE_ID_DESC',
  DefaultInvSortKeyAsc = 'DEFAULT_INV_SORT_KEY_ASC',
  DefaultInvSortKeyDesc = 'DEFAULT_INV_SORT_KEY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC',
  ProductSizeByProductSizeIdIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__ID_ASC',
  ProductSizeByProductSizeIdIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__ID_DESC',
  ProductSizeByProductSizeIdSpeciesIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SPECIES_ID_ASC',
  ProductSizeByProductSizeIdSpeciesIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SPECIES_ID_DESC',
  ProductSizeByProductSizeIdVarietyIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__VARIETY_ID_ASC',
  ProductSizeByProductSizeIdVarietyIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__VARIETY_ID_DESC',
  ProductSizeByProductSizeIdJvCodeAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_CODE_ASC',
  ProductSizeByProductSizeIdJvCodeDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_CODE_DESC',
  ProductSizeByProductSizeIdJvDescriptionAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_DESCRIPTION_ASC',
  ProductSizeByProductSizeIdJvDescriptionDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__JV_DESCRIPTION_DESC',
  ProductSizeByProductSizeIdShipperCodeAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_CODE_ASC',
  ProductSizeByProductSizeIdShipperCodeDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_CODE_DESC',
  ProductSizeByProductSizeIdShipperDescriptionAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_DESCRIPTION_ASC',
  ProductSizeByProductSizeIdShipperDescriptionDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_DESCRIPTION_DESC',
  ProductSizeByProductSizeIdCombineWithAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_WITH_ASC',
  ProductSizeByProductSizeIdCombineWithDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_WITH_DESC',
  ProductSizeByProductSizeIdCombineDescriptionAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_DESCRIPTION_ASC',
  ProductSizeByProductSizeIdCombineDescriptionDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__COMBINE_DESCRIPTION_DESC',
  ProductSizeByProductSizeIdShipperIdAsc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_ID_ASC',
  ProductSizeByProductSizeIdShipperIdDesc = 'PRODUCT_SIZE_BY_PRODUCT_SIZE_ID__SHIPPER_ID_DESC',
  ShipperProjectionProductsByCommonSizeIdCountAsc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_SIZE_ID__COUNT_ASC',
  ShipperProjectionProductsByCommonSizeIdCountDesc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_SIZE_ID__COUNT_DESC',
  CommonSizeTagsByCommonSizeIdCountAsc = 'COMMON_SIZE_TAGS_BY_COMMON_SIZE_ID__COUNT_ASC',
  CommonSizeTagsByCommonSizeIdCountDesc = 'COMMON_SIZE_TAGS_BY_COMMON_SIZE_ID__COUNT_DESC',
  CommonSizeProductSizesByCommonSizeIdCountAsc = 'COMMON_SIZE_PRODUCT_SIZES_BY_COMMON_SIZE_ID__COUNT_ASC',
  CommonSizeProductSizesByCommonSizeIdCountDesc = 'COMMON_SIZE_PRODUCT_SIZES_BY_COMMON_SIZE_ID__COUNT_DESC',
  ShipperProgramsByCommonSizeIdCountAsc = 'SHIPPER_PROGRAMS_BY_COMMON_SIZE_ID__COUNT_ASC',
  ShipperProgramsByCommonSizeIdCountDesc = 'SHIPPER_PROGRAMS_BY_COMMON_SIZE_ID__COUNT_DESC',
  CustomerProgramsByCommonSizeIdCountAsc = 'CUSTOMER_PROGRAMS_BY_COMMON_SIZE_ID__COUNT_ASC',
  CustomerProgramsByCommonSizeIdCountDesc = 'CUSTOMER_PROGRAMS_BY_COMMON_SIZE_ID__COUNT_DESC'
}

export type CommonSpecies = Node & {
  __typename?: 'CommonSpecies';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  /** Reads a single `CommonCategory` that is related to this `CommonSpecies`. */
  commonCategory?: Maybe<CommonCategory>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarieties: CommonVarietiesConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizes: CommonSizesConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypes: CommonPackTypesConnection;
  /** Reads and enables pagination through a set of `CommonSpeciesTag`. */
  commonSpeciesTags: CommonSpeciesTagsConnection;
  /** Reads and enables pagination through a set of `CommonSpeciesProductSpecies`. */
  commonSpeciesProductSpecieses: CommonSpeciesProductSpeciesConnection;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionProductCommonSpeciesIdAndShipperId: CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyId: CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeId: CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeId: CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProjectionProductCommonSpeciesIdAndCustomerId: CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ProductVariety`. */
  productVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyId: CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ProductSize`. */
  productSizesByCommonSizeCommonSpeciesIdAndProductSizeId: CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PackMaster`. */
  packMastersByCommonPackTypeCommonSpeciesIdAndPackMasterId: CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ProductSpecies`. */
  productSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesId: CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyId: CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProgramCommonSpeciesIdAndCommonSizeId: CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeId: CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProgramCommonSpeciesIdAndShipperId: CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProgramCommonSpeciesIdAndCustomerId: CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyId: CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeId: CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeId: CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByCustomerProgramCommonSpeciesIdAndCustomerId: CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdManyToManyConnection;
};


export type CommonSpeciesShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type CommonSpeciesCommonVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonSpeciesCommonSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonSpeciesCommonPackTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonSpeciesCommonSpeciesTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesTagsOrderBy>>;
  condition?: Maybe<CommonSpeciesTagCondition>;
  filter?: Maybe<CommonSpeciesTagFilter>;
};


export type CommonSpeciesCommonSpeciesProductSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesProductSpeciesCondition>;
  filter?: Maybe<CommonSpeciesProductSpeciesFilter>;
};


export type CommonSpeciesShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};


export type CommonSpeciesCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};


export type CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
  condition?: Maybe<ProductVarietyCondition>;
  filter?: Maybe<ProductVarietyFilter>;
};


export type CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
  condition?: Maybe<ProductSizeCondition>;
  filter?: Maybe<ProductSizeFilter>;
};


export type CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
  condition?: Maybe<PackMasterCondition>;
  filter?: Maybe<PackMasterFilter>;
};


export type CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
  condition?: Maybe<ProductSpeciesCondition>;
  filter?: Maybe<ProductSpeciesFilter>;
};


export type CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};

/** The `commonCategory` to be created by this mutation. */
export type CommonSpeciesCommonCategoryIdFkeyCommonCategoryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  categoryDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInverseInput>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CommonSpeciesCommonCategoryIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonCategory` in the `CommonSpeciesInput` mutation. */
export type CommonSpeciesCommonCategoryIdFkeyInput = {
  /** The primary key(s) for `commonCategory` for the far side of the relationship. */
  connectById?: Maybe<CommonCategoryCommonCategoryPkeyConnect>;
  /** The primary key(s) for `commonCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonCategoryNodeIdConnect>;
  /** The primary key(s) for `commonCategory` for the far side of the relationship. */
  deleteById?: Maybe<CommonCategoryCommonCategoryPkeyDelete>;
  /** The primary key(s) for `commonCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `commonCategory` for the far side of the relationship. */
  updateById?: Maybe<CommonCategoryOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyUsingCommonCategoryPkeyUpdate>;
  /** The primary key(s) and patch data for `commonCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSpeciesOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyNodeIdUpdate>;
  /** A `CommonCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSpeciesCommonCategoryIdFkeyCommonCategoryCreateInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `CommonCategoryInput` mutation. */
export type CommonSpeciesCommonCategoryIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSpecies` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSpeciesCommonSpeciesPkeyConnect>>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSpecyNodeIdConnect>>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSpeciesCommonSpeciesPkeyDelete>>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSpecyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSpeciesOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyUsingCommonSpeciesPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonCategoryOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyNodeIdUpdate>>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSpeciesCommonCategoryIdFkeyCommonSpeciesCreateInput>>;
};

/** A connection to a list of `CommonPackType` values, with data from `CustomerProgram`. */
export type CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCommonPackTypesByCustomerProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProgram`. */
export type CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCommonPackTypesByShipperProgramCommonSpeciesIdAndCommonPackTypeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonPackTypesByShipperProjectionProductCommonSpeciesIdAndCommonPackTypeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `CustomerProgram`. */
export type CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCommonSizesByCustomerProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProgram`. */
export type CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCommonSizesByShipperProgramCommonSpeciesIdAndCommonSizeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonSizesByShipperProjectionProductCommonSpeciesIdAndCommonSizeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** The fields on `commonSpecies` to look up the row to connect. */
export type CommonSpeciesCommonSpeciesPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonSpecies` to look up the row to delete. */
export type CommonSpeciesCommonSpeciesPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `CommonVariety` values, with data from `CustomerProgram`. */
export type CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCommonVarietiesByCustomerProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProgram`. */
export type CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCommonVarietiesByShipperProgramCommonSpeciesIdAndCommonVarietyIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCommonVarietiesByShipperProjectionProductCommonSpeciesIdAndCommonVarietyIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/**
 * A condition to be used against `CommonSpecies` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonSpeciesCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `speciesName` field. */
  speciesName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `speciesDescription` field. */
  speciesDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `uiColor` field. */
  uiColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonCategoryId` field. */
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productSpeciesId` field. */
  productSpeciesId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletWeight` field. */
  palletWeight?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `CommonSpecies` values. */
export type CommonSpeciesConnection = {
  __typename?: 'CommonSpeciesConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies` and cursor to aid in pagination. */
  edges: Array<CommonSpeciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A connection to a list of `Customer` values, with data from `CustomerProgram`. */
export type CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonSpeciesCustomersByCustomerProgramCommonSpeciesIdAndCustomerIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProgram`. */
export type CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesCustomersByShipperProgramCommonSpeciesIdAndCustomerIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesCustomersByShipperProjectionProductCommonSpeciesIdAndCustomerIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A `CommonSpecies` edge in the connection. */
export type CommonSpeciesEdge = {
  __typename?: 'CommonSpeciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
};

/** A filter to be used against `CommonSpecies` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `speciesName` field. */
  speciesName?: Maybe<StringFilter>;
  /** Filter by the object’s `speciesDescription` field. */
  speciesDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `uiColor` field. */
  uiColor?: Maybe<StringFilter>;
  /** Filter by the object’s `commonCategoryId` field. */
  commonCategoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productSpeciesId` field. */
  productSpeciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<StringFilter>;
  /** Filter by the object’s `palletWeight` field. */
  palletWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionProducts` relation. */
  shipperProjectionProducts?: Maybe<CommonSpeciesToManyShipperProjectionProductFilter>;
  /** Some related `shipperProjectionProducts` exist. */
  shipperProjectionProductsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonVarieties` relation. */
  commonVarieties?: Maybe<CommonSpeciesToManyCommonVarietyFilter>;
  /** Some related `commonVarieties` exist. */
  commonVarietiesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSizes` relation. */
  commonSizes?: Maybe<CommonSpeciesToManyCommonSizeFilter>;
  /** Some related `commonSizes` exist. */
  commonSizesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonPackTypes` relation. */
  commonPackTypes?: Maybe<CommonSpeciesToManyCommonPackTypeFilter>;
  /** Some related `commonPackTypes` exist. */
  commonPackTypesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpeciesTags` relation. */
  commonSpeciesTags?: Maybe<CommonSpeciesToManyCommonSpeciesTagFilter>;
  /** Some related `commonSpeciesTags` exist. */
  commonSpeciesTagsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpeciesProductSpecieses` relation. */
  commonSpeciesProductSpecieses?: Maybe<CommonSpeciesToManyCommonSpeciesProductSpeciesFilter>;
  /** Some related `commonSpeciesProductSpecieses` exist. */
  commonSpeciesProductSpeciesesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPrograms` relation. */
  shipperPrograms?: Maybe<CommonSpeciesToManyShipperProgramFilter>;
  /** Some related `shipperPrograms` exist. */
  shipperProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerPrograms` relation. */
  customerPrograms?: Maybe<CommonSpeciesToManyCustomerProgramFilter>;
  /** Some related `customerPrograms` exist. */
  customerProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonCategory` relation. */
  commonCategory?: Maybe<CommonCategoryFilter>;
  /** A related `commonCategory` exists. */
  commonCategoryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `productSpecies` relation. */
  productSpecies?: Maybe<ProductSpeciesFilter>;
  /** A related `productSpecies` exists. */
  productSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonSpeciesFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonSpeciesFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonSpeciesFilter>;
};

/** An input for mutations affecting `CommonSpecies` */
export type CommonSpeciesInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCommonSizeForCommonSizeCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: CommonSizePatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCommonSizeForCommonSizeCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCommonSizeForCommonSizeCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonCategory` being updated. */
  patch: CommonCategoryPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `productSpecies` being updated. */
  patch: ProductSpeciesPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpeciesProductSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpeciesProductSpecies` being updated. */
  patch: CommonSpeciesProductSpeciesPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpeciesTag` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpeciesTag` being updated. */
  patch: CommonSpeciesTagPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: CustomerProgramPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnShipperProgramForShipperProgramCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnShipperProgramForShipperProgramCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnShipperProgramForShipperProgramCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The fields on `commonSpecies` to look up the row to update. */
export type CommonSpeciesOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: UpdateCommonSpeciesOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Methods to use when ordering `CommonSpecies`. */
export enum CommonSpeciesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SpeciesNameAsc = 'SPECIES_NAME_ASC',
  SpeciesNameDesc = 'SPECIES_NAME_DESC',
  SpeciesDescriptionAsc = 'SPECIES_DESCRIPTION_ASC',
  SpeciesDescriptionDesc = 'SPECIES_DESCRIPTION_DESC',
  UiColorAsc = 'UI_COLOR_ASC',
  UiColorDesc = 'UI_COLOR_DESC',
  CommonCategoryIdAsc = 'COMMON_CATEGORY_ID_ASC',
  CommonCategoryIdDesc = 'COMMON_CATEGORY_ID_DESC',
  ProductSpeciesIdAsc = 'PRODUCT_SPECIES_ID_ASC',
  ProductSpeciesIdDesc = 'PRODUCT_SPECIES_ID_DESC',
  DefaultInvSortKeyAsc = 'DEFAULT_INV_SORT_KEY_ASC',
  DefaultInvSortKeyDesc = 'DEFAULT_INV_SORT_KEY_DESC',
  PalletWeightAsc = 'PALLET_WEIGHT_ASC',
  PalletWeightDesc = 'PALLET_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonCategoryByCommonCategoryIdIdAsc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__ID_ASC',
  CommonCategoryByCommonCategoryIdIdDesc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__ID_DESC',
  CommonCategoryByCommonCategoryIdCategoryNameAsc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__CATEGORY_NAME_ASC',
  CommonCategoryByCommonCategoryIdCategoryNameDesc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__CATEGORY_NAME_DESC',
  CommonCategoryByCommonCategoryIdCategoryDescriptionAsc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__CATEGORY_DESCRIPTION_ASC',
  CommonCategoryByCommonCategoryIdCategoryDescriptionDesc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__CATEGORY_DESCRIPTION_DESC',
  CommonCategoryByCommonCategoryIdUiColorAsc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__UI_COLOR_ASC',
  CommonCategoryByCommonCategoryIdUiColorDesc = 'COMMON_CATEGORY_BY_COMMON_CATEGORY_ID__UI_COLOR_DESC',
  ProductSpeciesByProductSpeciesIdIdAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__ID_ASC',
  ProductSpeciesByProductSpeciesIdIdDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__ID_DESC',
  ProductSpeciesByProductSpeciesIdSpeciesDescriptionAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  ProductSpeciesByProductSpeciesIdSpeciesDescriptionDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  ProductSpeciesByProductSpeciesIdSecondaryDescriptionAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SECONDARY_DESCRIPTION_ASC',
  ProductSpeciesByProductSpeciesIdSecondaryDescriptionDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SECONDARY_DESCRIPTION_DESC',
  ProductSpeciesByProductSpeciesIdFdaProductCodeAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_PRODUCT_CODE_ASC',
  ProductSpeciesByProductSpeciesIdFdaProductCodeDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_PRODUCT_CODE_DESC',
  ProductSpeciesByProductSpeciesIdFdaIndustryCodeAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_INDUSTRY_CODE_ASC',
  ProductSpeciesByProductSpeciesIdFdaIndustryCodeDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_INDUSTRY_CODE_DESC',
  ProductSpeciesByProductSpeciesIdDefaultTemperatureAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__DEFAULT_TEMPERATURE_ASC',
  ProductSpeciesByProductSpeciesIdDefaultTemperatureDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__DEFAULT_TEMPERATURE_DESC',
  ShipperProjectionProductsByCommonSpeciesIdCountAsc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_SPECIES_ID__COUNT_ASC',
  ShipperProjectionProductsByCommonSpeciesIdCountDesc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_SPECIES_ID__COUNT_DESC',
  CommonVarietiesByCommonSpeciesIdCountAsc = 'COMMON_VARIETIES_BY_COMMON_SPECIES_ID__COUNT_ASC',
  CommonVarietiesByCommonSpeciesIdCountDesc = 'COMMON_VARIETIES_BY_COMMON_SPECIES_ID__COUNT_DESC',
  CommonSizesByCommonSpeciesIdCountAsc = 'COMMON_SIZES_BY_COMMON_SPECIES_ID__COUNT_ASC',
  CommonSizesByCommonSpeciesIdCountDesc = 'COMMON_SIZES_BY_COMMON_SPECIES_ID__COUNT_DESC',
  CommonPackTypesByCommonSpeciesIdCountAsc = 'COMMON_PACK_TYPES_BY_COMMON_SPECIES_ID__COUNT_ASC',
  CommonPackTypesByCommonSpeciesIdCountDesc = 'COMMON_PACK_TYPES_BY_COMMON_SPECIES_ID__COUNT_DESC',
  CommonSpeciesTagsByCommonSpeciesIdCountAsc = 'COMMON_SPECIES_TAGS_BY_COMMON_SPECIES_ID__COUNT_ASC',
  CommonSpeciesTagsByCommonSpeciesIdCountDesc = 'COMMON_SPECIES_TAGS_BY_COMMON_SPECIES_ID__COUNT_DESC',
  CommonSpeciesProductSpeciesByCommonSpeciesIdCountAsc = 'COMMON_SPECIES_PRODUCT_SPECIES_BY_COMMON_SPECIES_ID__COUNT_ASC',
  CommonSpeciesProductSpeciesByCommonSpeciesIdCountDesc = 'COMMON_SPECIES_PRODUCT_SPECIES_BY_COMMON_SPECIES_ID__COUNT_DESC',
  ShipperProgramsByCommonSpeciesIdCountAsc = 'SHIPPER_PROGRAMS_BY_COMMON_SPECIES_ID__COUNT_ASC',
  ShipperProgramsByCommonSpeciesIdCountDesc = 'SHIPPER_PROGRAMS_BY_COMMON_SPECIES_ID__COUNT_DESC',
  CustomerProgramsByCommonSpeciesIdCountAsc = 'CUSTOMER_PROGRAMS_BY_COMMON_SPECIES_ID__COUNT_ASC',
  CustomerProgramsByCommonSpeciesIdCountDesc = 'CUSTOMER_PROGRAMS_BY_COMMON_SPECIES_ID__COUNT_DESC'
}

/** A connection to a list of `PackMaster` values, with data from `CommonPackType`. */
export type CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdManyToManyConnection = {
  __typename?: 'CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdManyToManyConnection';
  /** A list of `PackMaster` objects. */
  nodes: Array<Maybe<PackMaster>>;
  /** A list of edges which contains the `PackMaster`, info from the `CommonPackType`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackMaster` edge in the connection, with data from `CommonPackType`. */
export type CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdManyToManyEdge = {
  __typename?: 'CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackMaster` at the end of the edge. */
  node?: Maybe<PackMaster>;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypes: CommonPackTypesConnection;
};


/** A `PackMaster` edge in the connection, with data from `CommonPackType`. */
export type CommonSpeciesPackMastersByCommonPackTypeCommonSpeciesIdAndPackMasterIdManyToManyEdgeCommonPackTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};

/** Represents an update to a `CommonSpecies`. Fields that are set will be updated. */
export type CommonSpeciesPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** A connection to a list of `ProductSize` values, with data from `CommonSize`. */
export type CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdManyToManyConnection = {
  __typename?: 'CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdManyToManyConnection';
  /** A list of `ProductSize` objects. */
  nodes: Array<Maybe<ProductSize>>;
  /** A list of edges which contains the `ProductSize`, info from the `CommonSize`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSize` edge in the connection, with data from `CommonSize`. */
export type CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdManyToManyEdge = {
  __typename?: 'CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSize` at the end of the edge. */
  node?: Maybe<ProductSize>;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizes: CommonSizesConnection;
};


/** A `ProductSize` edge in the connection, with data from `CommonSize`. */
export type CommonSpeciesProductSizesByCommonSizeCommonSpeciesIdAndProductSizeIdManyToManyEdgeCommonSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};

export type CommonSpeciesProductSpecies = Node & {
  __typename?: 'CommonSpeciesProductSpecies';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
};

/** A connection to a list of `ProductSpecies` values, with data from `CommonSpeciesProductSpecies`. */
export type CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdManyToManyConnection = {
  __typename?: 'CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdManyToManyConnection';
  /** A list of `ProductSpecies` objects. */
  nodes: Array<Maybe<ProductSpecies>>;
  /** A list of edges which contains the `ProductSpecies`, info from the `CommonSpeciesProductSpecies`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSpecies` edge in the connection, with data from `CommonSpeciesProductSpecies`. */
export type CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdManyToManyEdge = {
  __typename?: 'CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSpecies` at the end of the edge. */
  node?: Maybe<ProductSpecies>;
  /** Reads and enables pagination through a set of `CommonSpeciesProductSpecies`. */
  commonSpeciesProductSpecieses: CommonSpeciesProductSpeciesConnection;
};


/** A `ProductSpecies` edge in the connection, with data from `CommonSpeciesProductSpecies`. */
export type CommonSpeciesProductSpeciesByCommonSpeciesProductSpeciesCommonSpeciesIdAndProductSpeciesIdManyToManyEdgeCommonSpeciesProductSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesProductSpeciesCondition>;
  filter?: Maybe<CommonSpeciesProductSpeciesFilter>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CommonSpeciesProductSpeciesCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** The `commonSpeciesProductSpecies` to be created by this mutation. */
export type CommonSpeciesProductSpeciesCommonSpeciesIdFkeyCommonSpeciesProductSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `CommonSpeciesProductSpeciesInput` mutation. */
export type CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `commonSpeciesProductSpecies` in the `CommonSpeciesInput` mutation. */
export type CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSpeciesProductSpecies` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSpeciesProductSpeciesCommonSpeciesProductSpeciesPkeyConnect>>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSpeciesProductSpecyNodeIdConnect>>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSpeciesProductSpeciesCommonSpeciesProductSpeciesPkeyDelete>>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSpeciesProductSpecyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSpeciesProductSpecies` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyUsingCommonSpeciesProductSpeciesPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSpeciesProductSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CommonSpeciesProductSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyCommonSpeciesProductSpeciesCreateInput>>;
};

/** The fields on `commonSpeciesProductSpecies` to look up the row to connect. */
export type CommonSpeciesProductSpeciesCommonSpeciesProductSpeciesPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonSpeciesProductSpecies` to look up the row to delete. */
export type CommonSpeciesProductSpeciesCommonSpeciesProductSpeciesPkeyDelete = {
  id: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonSpeciesProductSpecies` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type CommonSpeciesProductSpeciesCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productSpeciesId` field. */
  productSpeciesId?: Maybe<Scalars['String']>;
};

/** A connection to a list of `CommonSpeciesProductSpecies` values. */
export type CommonSpeciesProductSpeciesConnection = {
  __typename?: 'CommonSpeciesProductSpeciesConnection';
  /** A list of `CommonSpeciesProductSpecies` objects. */
  nodes: Array<Maybe<CommonSpeciesProductSpecies>>;
  /** A list of edges which contains the `CommonSpeciesProductSpecies` and cursor to aid in pagination. */
  edges: Array<CommonSpeciesProductSpeciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpeciesProductSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpeciesProductSpecies` edge in the connection. */
export type CommonSpeciesProductSpeciesEdge = {
  __typename?: 'CommonSpeciesProductSpeciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpeciesProductSpecies` at the end of the edge. */
  node?: Maybe<CommonSpeciesProductSpecies>;
};

/** A filter to be used against `CommonSpeciesProductSpecies` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesProductSpeciesFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productSpeciesId` field. */
  productSpeciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** A related `commonSpecies` exists. */
  commonSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `productSpecies` relation. */
  productSpecies?: Maybe<ProductSpeciesFilter>;
  /** A related `productSpecies` exists. */
  productSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonSpeciesProductSpeciesFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonSpeciesProductSpeciesFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonSpeciesProductSpeciesFilter>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CommonSpeciesProductSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** Input for the nested mutation of `productSpecies` in the `CommonSpeciesInput` mutation. */
export type CommonSpeciesProductSpeciesIdFkeyInput = {
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  connectById?: Maybe<ProductSpeciesProductSpeciesPkeyConnect>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<ProductSpecyNodeIdConnect>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  deleteById?: Maybe<ProductSpeciesProductSpeciesPkeyDelete>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ProductSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `productSpecies` for the far side of the relationship. */
  updateById?: Maybe<ProductSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyUsingProductSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `productSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyNodeIdUpdate>;
  /** A `ProductSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSpeciesProductSpeciesIdFkeyProductSpeciesCreateInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `ProductSpeciesInput` mutation. */
export type CommonSpeciesProductSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSpecies` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSpeciesCommonSpeciesPkeyConnect>>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSpecyNodeIdConnect>>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSpeciesCommonSpeciesPkeyDelete>>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSpecyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ProductSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSpeciesProductSpeciesIdFkeyCommonSpeciesCreateInput>>;
};

/** The `productSpecies` to be created by this mutation. */
export type CommonSpeciesProductSpeciesIdFkeyProductSpeciesCreateInput = {
  id: Scalars['String'];
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** An input for mutations affecting `CommonSpeciesProductSpecies` */
export type CommonSpeciesProductSpeciesInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `commonSpeciesProductSpecies` to look up the row to update. */
export type CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyUsingCommonSpeciesProductSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpeciesProductSpecies` being updated. */
  patch: UpdateCommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `productSpecies` being updated. */
  patch: ProductSpeciesPatch;
};

/** The fields on `commonSpeciesProductSpecies` to look up the row to update. */
export type CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyUsingCommonSpeciesProductSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpeciesProductSpecies` being updated. */
  patch: UpdateCommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Methods to use when ordering `CommonSpeciesProductSpecies`. */
export enum CommonSpeciesProductSpeciesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  ProductSpeciesIdAsc = 'PRODUCT_SPECIES_ID_ASC',
  ProductSpeciesIdDesc = 'PRODUCT_SPECIES_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC',
  ProductSpeciesByProductSpeciesIdIdAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__ID_ASC',
  ProductSpeciesByProductSpeciesIdIdDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__ID_DESC',
  ProductSpeciesByProductSpeciesIdSpeciesDescriptionAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  ProductSpeciesByProductSpeciesIdSpeciesDescriptionDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  ProductSpeciesByProductSpeciesIdSecondaryDescriptionAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SECONDARY_DESCRIPTION_ASC',
  ProductSpeciesByProductSpeciesIdSecondaryDescriptionDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__SECONDARY_DESCRIPTION_DESC',
  ProductSpeciesByProductSpeciesIdFdaProductCodeAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_PRODUCT_CODE_ASC',
  ProductSpeciesByProductSpeciesIdFdaProductCodeDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_PRODUCT_CODE_DESC',
  ProductSpeciesByProductSpeciesIdFdaIndustryCodeAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_INDUSTRY_CODE_ASC',
  ProductSpeciesByProductSpeciesIdFdaIndustryCodeDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__FDA_INDUSTRY_CODE_DESC',
  ProductSpeciesByProductSpeciesIdDefaultTemperatureAsc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__DEFAULT_TEMPERATURE_ASC',
  ProductSpeciesByProductSpeciesIdDefaultTemperatureDesc = 'PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__DEFAULT_TEMPERATURE_DESC'
}

/** Represents an update to a `CommonSpeciesProductSpecies`. Fields that are set will be updated. */
export type CommonSpeciesProductSpeciesPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInput>;
};

/** The `commonSpeciesProductSpecies` to be created by this mutation. */
export type CommonSpeciesProductSpeciesProductSpeciesIdFkeyCommonSpeciesProductSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInput>;
};

/** Input for the nested mutation of `productSpecies` in the `CommonSpeciesProductSpeciesInput` mutation. */
export type CommonSpeciesProductSpeciesProductSpeciesIdFkeyInput = {
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  connectById?: Maybe<ProductSpeciesProductSpeciesPkeyConnect>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<ProductSpecyNodeIdConnect>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  deleteById?: Maybe<ProductSpeciesProductSpeciesPkeyDelete>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ProductSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `productSpecies` for the far side of the relationship. */
  updateById?: Maybe<ProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyUsingProductSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `productSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyNodeIdUpdate>;
  /** A `ProductSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyProductSpeciesCreateInput>;
};

/** Input for the nested mutation of `commonSpeciesProductSpecies` in the `ProductSpeciesInput` mutation. */
export type CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSpeciesProductSpecies` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonSpeciesProductSpeciesCommonSpeciesProductSpeciesPkeyConnect>>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSpeciesProductSpecyNodeIdConnect>>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonSpeciesProductSpeciesCommonSpeciesProductSpeciesPkeyDelete>>;
  /** The primary key(s) for `commonSpeciesProductSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSpeciesProductSpecyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSpeciesProductSpecies` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyUsingCommonSpeciesProductSpeciesPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSpeciesProductSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CommonSpeciesProductSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSpeciesProductSpeciesProductSpeciesIdFkeyCommonSpeciesProductSpeciesCreateInput>>;
};

/** The `productSpecies` to be created by this mutation. */
export type CommonSpeciesProductSpeciesProductSpeciesIdFkeyProductSpeciesCreateInput = {
  id: Scalars['String'];
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonSpeciesProductSpecyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonSpeciesProductSpecies` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonSpeciesProductSpecyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonSpeciesProductSpecies` to be deleted. */
  nodeId: Scalars['ID'];
};

/** A connection to a list of `ProductVariety` values, with data from `CommonVariety`. */
export type CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdManyToManyConnection = {
  __typename?: 'CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdManyToManyConnection';
  /** A list of `ProductVariety` objects. */
  nodes: Array<Maybe<ProductVariety>>;
  /** A list of edges which contains the `ProductVariety`, info from the `CommonVariety`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductVariety` edge in the connection, with data from `CommonVariety`. */
export type CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdManyToManyEdge = {
  __typename?: 'CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductVariety` at the end of the edge. */
  node?: Maybe<ProductVariety>;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarieties: CommonVarietiesConnection;
};


/** A `ProductVariety` edge in the connection, with data from `CommonVariety`. */
export type CommonSpeciesProductVarietiesByCommonVarietyCommonSpeciesIdAndProductVarietyIdManyToManyEdgeCommonVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProgram`. */
export type CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonSpeciesShippersByShipperProgramCommonSpeciesIdAndShipperIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonSpeciesShippersByShipperProjectionProductCommonSpeciesIdAndShipperIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

export type CommonSpeciesTag = Node & {
  __typename?: 'CommonSpeciesTag';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  tagText: Scalars['String'];
  commonSpeciesId: Scalars['BigInt'];
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesTag`. */
  commonSpecies?: Maybe<CommonSpecies>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CommonSpeciesTagCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** The `commonSpeciesTag` to be created by this mutation. */
export type CommonSpeciesTagCommonSpeciesIdFkeyCommonSpeciesTagCreateInput = {
  tagText: Scalars['String'];
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `CommonSpeciesTagInput` mutation. */
export type CommonSpeciesTagCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonSpeciesTagOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `commonSpeciesTag` in the `CommonSpeciesInput` mutation. */
export type CommonSpeciesTagCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonSpeciesTag` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonSpeciesTag` for the far side of the relationship. */
  connectByTagTextAndCommonSpeciesId?: Maybe<Array<CommonSpeciesTagCommonSpeciesTagPkeyConnect>>;
  /** The primary key(s) for `commonSpeciesTag` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonSpeciesTagNodeIdConnect>>;
  /** The primary key(s) for `commonSpeciesTag` for the far side of the relationship. */
  deleteByTagTextAndCommonSpeciesId?: Maybe<Array<CommonSpeciesTagCommonSpeciesTagPkeyDelete>>;
  /** The primary key(s) for `commonSpeciesTag` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonSpeciesTagNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonSpeciesTag` for the far side of the relationship. */
  updateByTagTextAndCommonSpeciesId?: Maybe<Array<CommonSpeciesTagOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyUsingCommonSpeciesTagPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonSpeciesTag` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CommonSpeciesTagInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonSpeciesTagCommonSpeciesIdFkeyCommonSpeciesTagCreateInput>>;
};

/** The fields on `commonSpeciesTag` to look up the row to connect. */
export type CommonSpeciesTagCommonSpeciesTagPkeyConnect = {
  tagText: Scalars['String'];
  commonSpeciesId: Scalars['BigInt'];
};

/** The fields on `commonSpeciesTag` to look up the row to delete. */
export type CommonSpeciesTagCommonSpeciesTagPkeyDelete = {
  tagText: Scalars['String'];
  commonSpeciesId: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonSpeciesTag` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonSpeciesTagCondition = {
  /** Checks for equality with the object’s `tagText` field. */
  tagText?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CommonSpeciesTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesTagFilter = {
  /** Filter by the object’s `tagText` field. */
  tagText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonSpeciesTagFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonSpeciesTagFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonSpeciesTagFilter>;
};

/** An input for mutations affecting `CommonSpeciesTag` */
export type CommonSpeciesTagInput = {
  tagText: Scalars['String'];
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonSpeciesTagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonSpeciesTag` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonSpeciesTagNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonSpeciesTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonSpeciesTagOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `commonSpeciesTag` to look up the row to update. */
export type CommonSpeciesTagOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyUsingCommonSpeciesTagPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonSpeciesTag` being updated. */
  patch: UpdateCommonSpeciesTagOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyPatch;
  tagText: Scalars['String'];
  commonSpeciesId: Scalars['BigInt'];
};

/** Represents an update to a `CommonSpeciesTag`. Fields that are set will be updated. */
export type CommonSpeciesTagPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInput>;
};

/** A connection to a list of `CommonSpeciesTag` values. */
export type CommonSpeciesTagsConnection = {
  __typename?: 'CommonSpeciesTagsConnection';
  /** A list of `CommonSpeciesTag` objects. */
  nodes: Array<Maybe<CommonSpeciesTag>>;
  /** A list of edges which contains the `CommonSpeciesTag` and cursor to aid in pagination. */
  edges: Array<CommonSpeciesTagsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpeciesTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpeciesTag` edge in the connection. */
export type CommonSpeciesTagsEdge = {
  __typename?: 'CommonSpeciesTagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpeciesTag` at the end of the edge. */
  node?: Maybe<CommonSpeciesTag>;
};

/** Methods to use when ordering `CommonSpeciesTag`. */
export enum CommonSpeciesTagsOrderBy {
  Natural = 'NATURAL',
  TagTextAsc = 'TAG_TEXT_ASC',
  TagTextDesc = 'TAG_TEXT_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC'
}

/** A filter to be used against many `CommonPackType` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyCommonPackTypeFilter = {
  /** Every related `CommonPackType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonPackTypeFilter>;
  /** Some related `CommonPackType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonPackTypeFilter>;
  /** No related `CommonPackType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonPackTypeFilter>;
};

/** A filter to be used against many `CommonSize` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyCommonSizeFilter = {
  /** Every related `CommonSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSizeFilter>;
  /** Some related `CommonSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSizeFilter>;
  /** No related `CommonSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSizeFilter>;
};

/** A filter to be used against many `CommonSpeciesProductSpecies` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyCommonSpeciesProductSpeciesFilter = {
  /** Every related `CommonSpeciesProductSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSpeciesProductSpeciesFilter>;
  /** Some related `CommonSpeciesProductSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSpeciesProductSpeciesFilter>;
  /** No related `CommonSpeciesProductSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSpeciesProductSpeciesFilter>;
};

/** A filter to be used against many `CommonSpeciesTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyCommonSpeciesTagFilter = {
  /** Every related `CommonSpeciesTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSpeciesTagFilter>;
  /** Some related `CommonSpeciesTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSpeciesTagFilter>;
  /** No related `CommonSpeciesTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSpeciesTagFilter>;
};

/** A filter to be used against many `CommonVariety` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyCommonVarietyFilter = {
  /** Every related `CommonVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonVarietyFilter>;
  /** Some related `CommonVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonVarietyFilter>;
  /** No related `CommonVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonVarietyFilter>;
};

/** A filter to be used against many `CustomerProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyCustomerProgramFilter = {
  /** Every related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerProgramFilter>;
  /** Some related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerProgramFilter>;
  /** No related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerProgramFilter>;
};

/** A filter to be used against many `ShipperProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyShipperProgramFilter = {
  /** Every related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramFilter>;
  /** Some related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramFilter>;
  /** No related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramFilter>;
};

/** A filter to be used against many `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type CommonSpeciesToManyShipperProjectionProductFilter = {
  /** Every related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionProductFilter>;
  /** Some related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionProductFilter>;
  /** No related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionProductFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonSpecyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonSpecyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be deleted. */
  nodeId: Scalars['ID'];
};

/** A connection to a list of `CommonVariety` values. */
export type CommonVarietiesConnection = {
  __typename?: 'CommonVarietiesConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety` and cursor to aid in pagination. */
  edges: Array<CommonVarietiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection. */
export type CommonVarietiesEdge = {
  __typename?: 'CommonVarietiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
};

/** Methods to use when ordering `CommonVariety`. */
export enum CommonVarietiesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VarietyNameAsc = 'VARIETY_NAME_ASC',
  VarietyNameDesc = 'VARIETY_NAME_DESC',
  VarietyDescriptionAsc = 'VARIETY_DESCRIPTION_ASC',
  VarietyDescriptionDesc = 'VARIETY_DESCRIPTION_DESC',
  UiColorAsc = 'UI_COLOR_ASC',
  UiColorDesc = 'UI_COLOR_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  ProductVarietyIdAsc = 'PRODUCT_VARIETY_ID_ASC',
  ProductVarietyIdDesc = 'PRODUCT_VARIETY_ID_DESC',
  DefaultInvSortKeyAsc = 'DEFAULT_INV_SORT_KEY_ASC',
  DefaultInvSortKeyDesc = 'DEFAULT_INV_SORT_KEY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC',
  ProductVarietyByProductVarietyIdIdAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__ID_ASC',
  ProductVarietyByProductVarietyIdIdDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__ID_DESC',
  ProductVarietyByProductVarietyIdVarietyDescriptionAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_DESCRIPTION_ASC',
  ProductVarietyByProductVarietyIdVarietyDescriptionDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_DESCRIPTION_DESC',
  ProductVarietyByProductVarietyIdSecondaryDescriptionAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SECONDARY_DESCRIPTION_ASC',
  ProductVarietyByProductVarietyIdSecondaryDescriptionDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SECONDARY_DESCRIPTION_DESC',
  ProductVarietyByProductVarietyIdCustomerLetterSequenceAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__CUSTOMER_LETTER_SEQUENCE_ASC',
  ProductVarietyByProductVarietyIdCustomerLetterSequenceDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__CUSTOMER_LETTER_SEQUENCE_DESC',
  ProductVarietyByProductVarietyIdSummaryCodeAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SUMMARY_CODE_ASC',
  ProductVarietyByProductVarietyIdSummaryCodeDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SUMMARY_CODE_DESC',
  ProductVarietyByProductVarietyIdVarietyGroupAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_GROUP_ASC',
  ProductVarietyByProductVarietyIdVarietyGroupDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_GROUP_DESC',
  ProductVarietyByProductVarietyIdCombineWithAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__COMBINE_WITH_ASC',
  ProductVarietyByProductVarietyIdCombineWithDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__COMBINE_WITH_DESC',
  ShipperProjectionProductsByCommonVarietyIdCountAsc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_VARIETY_ID__COUNT_ASC',
  ShipperProjectionProductsByCommonVarietyIdCountDesc = 'SHIPPER_PROJECTION_PRODUCTS_BY_COMMON_VARIETY_ID__COUNT_DESC',
  CommonVarietyTagsByCommonVarietyIdCountAsc = 'COMMON_VARIETY_TAGS_BY_COMMON_VARIETY_ID__COUNT_ASC',
  CommonVarietyTagsByCommonVarietyIdCountDesc = 'COMMON_VARIETY_TAGS_BY_COMMON_VARIETY_ID__COUNT_DESC',
  CommonVarietyProductVarietiesByCommonVarietyIdCountAsc = 'COMMON_VARIETY_PRODUCT_VARIETIES_BY_COMMON_VARIETY_ID__COUNT_ASC',
  CommonVarietyProductVarietiesByCommonVarietyIdCountDesc = 'COMMON_VARIETY_PRODUCT_VARIETIES_BY_COMMON_VARIETY_ID__COUNT_DESC',
  ShipperProgramsByCommonVarietyIdCountAsc = 'SHIPPER_PROGRAMS_BY_COMMON_VARIETY_ID__COUNT_ASC',
  ShipperProgramsByCommonVarietyIdCountDesc = 'SHIPPER_PROGRAMS_BY_COMMON_VARIETY_ID__COUNT_DESC',
  CustomerProgramsByCommonVarietyIdCountAsc = 'CUSTOMER_PROGRAMS_BY_COMMON_VARIETY_ID__COUNT_ASC',
  CustomerProgramsByCommonVarietyIdCountDesc = 'CUSTOMER_PROGRAMS_BY_COMMON_VARIETY_ID__COUNT_DESC'
}

export type CommonVariety = Node & {
  __typename?: 'CommonVariety';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  /** Reads a single `CommonSpecies` that is related to this `CommonVariety`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductVariety` that is related to this `CommonVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
  /** Reads and enables pagination through a set of `CommonVarietyTag`. */
  commonVarietyTags: CommonVarietyTagsConnection;
  /** Reads and enables pagination through a set of `CommonVarietyProductVariety`. */
  commonVarietyProductVarieties: CommonVarietyProductVarietiesConnection;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionProductCommonVarietyIdAndShipperId: CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesId: CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeId: CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeId: CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProjectionProductCommonVarietyIdAndCustomerId: CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ProductVariety`. */
  productVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyId: CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesId: CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProgramCommonVarietyIdAndCommonSizeId: CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeId: CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProgramCommonVarietyIdAndShipperId: CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProgramCommonVarietyIdAndCustomerId: CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesId: CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByCustomerProgramCommonVarietyIdAndCommonSizeId: CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeId: CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByCustomerProgramCommonVarietyIdAndCustomerId: CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdManyToManyConnection;
};


export type CommonVarietyShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type CommonVarietyCommonVarietyTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietyTagsOrderBy>>;
  condition?: Maybe<CommonVarietyTagCondition>;
  filter?: Maybe<CommonVarietyTagFilter>;
};


export type CommonVarietyCommonVarietyProductVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyProductVarietyCondition>;
  filter?: Maybe<CommonVarietyProductVarietyFilter>;
};


export type CommonVarietyShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};


export type CommonVarietyCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};


export type CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
  condition?: Maybe<ProductVarietyCondition>;
  filter?: Maybe<ProductVarietyFilter>;
};


export type CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `CustomerProgram`. */
export type CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCommonPackTypesByCustomerProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProgram`. */
export type CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCommonPackTypesByShipperProgramCommonVarietyIdAndCommonPackTypeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonPackTypesByShipperProjectionProductCommonVarietyIdAndCommonPackTypeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `CustomerProgram`. */
export type CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCommonSizesByCustomerProgramCommonVarietyIdAndCommonSizeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProgram`. */
export type CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCommonSizesByShipperProgramCommonVarietyIdAndCommonSizeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonSizesByShipperProjectionProductCommonVarietyIdAndCommonSizeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `CustomerProgram`. */
export type CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCommonSpeciesByCustomerProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProgram`. */
export type CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCommonSpeciesByShipperProgramCommonVarietyIdAndCommonSpeciesIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCommonSpeciesByShipperProjectionProductCommonVarietyIdAndCommonSpeciesIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CommonVarietyCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** The `commonVariety` to be created by this mutation. */
export type CommonVarietyCommonSpeciesIdFkeyCommonVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `CommonVarietyInput` mutation. */
export type CommonVarietyCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonVarietyOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CommonVarietyCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `commonVariety` in the `CommonSpeciesInput` mutation. */
export type CommonVarietyCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonVariety` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonVarietyCommonVarietyPkeyConnect>>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonVarietyNodeIdConnect>>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonVarietyCommonVarietyPkeyDelete>>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonVarietyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonVarietyOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyUsingCommonVarietyPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CommonVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonVarietyCommonSpeciesIdFkeyCommonVarietyCreateInput>>;
};

/** The fields on `commonVariety` to look up the row to connect. */
export type CommonVarietyCommonVarietyPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonVariety` to look up the row to delete. */
export type CommonVarietyCommonVarietyPkeyDelete = {
  id: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonVariety` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonVarietyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `varietyName` field. */
  varietyName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyDescription` field. */
  varietyDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `uiColor` field. */
  uiColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productVarietyId` field. */
  productVarietyId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Customer` values, with data from `CustomerProgram`. */
export type CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `CustomerProgram`. */
export type CommonVarietyCustomersByCustomerProgramCommonVarietyIdAndCustomerIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProgram`. */
export type CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyCustomersByShipperProgramCommonVarietyIdAndCustomerIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdManyToManyConnection = {
  __typename?: 'CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdManyToManyEdge = {
  __typename?: 'CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyCustomersByShipperProjectionProductCommonVarietyIdAndCustomerIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against `CommonVariety` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `varietyName` field. */
  varietyName?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyDescription` field. */
  varietyDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `uiColor` field. */
  uiColor?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productVarietyId` field. */
  productVarietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultInvSortKey` field. */
  defaultInvSortKey?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionProducts` relation. */
  shipperProjectionProducts?: Maybe<CommonVarietyToManyShipperProjectionProductFilter>;
  /** Some related `shipperProjectionProducts` exist. */
  shipperProjectionProductsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonVarietyTags` relation. */
  commonVarietyTags?: Maybe<CommonVarietyToManyCommonVarietyTagFilter>;
  /** Some related `commonVarietyTags` exist. */
  commonVarietyTagsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonVarietyProductVarieties` relation. */
  commonVarietyProductVarieties?: Maybe<CommonVarietyToManyCommonVarietyProductVarietyFilter>;
  /** Some related `commonVarietyProductVarieties` exist. */
  commonVarietyProductVarietiesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPrograms` relation. */
  shipperPrograms?: Maybe<CommonVarietyToManyShipperProgramFilter>;
  /** Some related `shipperPrograms` exist. */
  shipperProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerPrograms` relation. */
  customerPrograms?: Maybe<CommonVarietyToManyCustomerProgramFilter>;
  /** Some related `customerPrograms` exist. */
  customerProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** A related `commonSpecies` exists. */
  commonSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `productVariety` relation. */
  productVariety?: Maybe<ProductVarietyFilter>;
  /** A related `productVariety` exists. */
  productVarietyExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonVarietyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonVarietyFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonVarietyFilter>;
};

/** An input for mutations affecting `CommonVariety` */
export type CommonVarietyInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonVarietyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonVarietyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `commonVariety` to look up the row to update. */
export type CommonVarietyOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyUsingCommonVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: UpdateCommonVarietyOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `productVariety` being updated. */
  patch: ProductVarietyPatch;
};

/** The fields on `commonVariety` to look up the row to update. */
export type CommonVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyUsingCommonVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: UpdateCommonVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVarietyProductVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVarietyProductVariety` being updated. */
  patch: CommonVarietyProductVarietyPatch;
};

/** The fields on `commonVariety` to look up the row to update. */
export type CommonVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: UpdateCommonVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVarietyTag` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVarietyTag` being updated. */
  patch: CommonVarietyTagPatch;
};

/** The fields on `commonVariety` to look up the row to update. */
export type CommonVarietyOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: UpdateCommonVarietyOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: CustomerProgramPatch;
};

/** The fields on `commonVariety` to look up the row to update. */
export type CommonVarietyOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: UpdateCommonVarietyOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyOnShipperProgramForShipperProgramCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** The fields on `commonVariety` to look up the row to update. */
export type CommonVarietyOnShipperProgramForShipperProgramCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: UpdateCommonVarietyOnShipperProgramForShipperProgramCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The fields on `commonVariety` to look up the row to update. */
export type CommonVarietyOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: UpdateCommonVarietyOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `CommonVariety`. Fields that are set will be updated. */
export type CommonVarietyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** A connection to a list of `ProductVariety` values, with data from `CommonVarietyProductVariety`. */
export type CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdManyToManyConnection = {
  __typename?: 'CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdManyToManyConnection';
  /** A list of `ProductVariety` objects. */
  nodes: Array<Maybe<ProductVariety>>;
  /** A list of edges which contains the `ProductVariety`, info from the `CommonVarietyProductVariety`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductVariety` edge in the connection, with data from `CommonVarietyProductVariety`. */
export type CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdManyToManyEdge = {
  __typename?: 'CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductVariety` at the end of the edge. */
  node?: Maybe<ProductVariety>;
  /** Reads and enables pagination through a set of `CommonVarietyProductVariety`. */
  commonVarietyProductVarieties: CommonVarietyProductVarietiesConnection;
};


/** A `ProductVariety` edge in the connection, with data from `CommonVarietyProductVariety`. */
export type CommonVarietyProductVarietiesByCommonVarietyProductVarietyCommonVarietyIdAndProductVarietyIdManyToManyEdgeCommonVarietyProductVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyProductVarietyCondition>;
  filter?: Maybe<CommonVarietyProductVarietyFilter>;
};

/** A connection to a list of `CommonVarietyProductVariety` values. */
export type CommonVarietyProductVarietiesConnection = {
  __typename?: 'CommonVarietyProductVarietiesConnection';
  /** A list of `CommonVarietyProductVariety` objects. */
  nodes: Array<Maybe<CommonVarietyProductVariety>>;
  /** A list of edges which contains the `CommonVarietyProductVariety` and cursor to aid in pagination. */
  edges: Array<CommonVarietyProductVarietiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVarietyProductVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVarietyProductVariety` edge in the connection. */
export type CommonVarietyProductVarietiesEdge = {
  __typename?: 'CommonVarietyProductVarietiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVarietyProductVariety` at the end of the edge. */
  node?: Maybe<CommonVarietyProductVariety>;
};

/** Methods to use when ordering `CommonVarietyProductVariety`. */
export enum CommonVarietyProductVarietiesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommonVarietyIdAsc = 'COMMON_VARIETY_ID_ASC',
  CommonVarietyIdDesc = 'COMMON_VARIETY_ID_DESC',
  ProductVarietyIdAsc = 'PRODUCT_VARIETY_ID_ASC',
  ProductVarietyIdDesc = 'PRODUCT_VARIETY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonVarietyByCommonVarietyIdIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_ASC',
  CommonVarietyByCommonVarietyIdIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_DESC',
  CommonVarietyByCommonVarietyIdVarietyNameAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_ASC',
  CommonVarietyByCommonVarietyIdVarietyNameDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_DESC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_ASC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_DESC',
  CommonVarietyByCommonVarietyIdUiColorAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_ASC',
  CommonVarietyByCommonVarietyIdUiColorDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_DESC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_ASC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_DESC',
  CommonVarietyByCommonVarietyIdProductVarietyIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_ASC',
  CommonVarietyByCommonVarietyIdProductVarietyIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_DESC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_DESC',
  ProductVarietyByProductVarietyIdIdAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__ID_ASC',
  ProductVarietyByProductVarietyIdIdDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__ID_DESC',
  ProductVarietyByProductVarietyIdVarietyDescriptionAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_DESCRIPTION_ASC',
  ProductVarietyByProductVarietyIdVarietyDescriptionDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_DESCRIPTION_DESC',
  ProductVarietyByProductVarietyIdSecondaryDescriptionAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SECONDARY_DESCRIPTION_ASC',
  ProductVarietyByProductVarietyIdSecondaryDescriptionDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SECONDARY_DESCRIPTION_DESC',
  ProductVarietyByProductVarietyIdCustomerLetterSequenceAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__CUSTOMER_LETTER_SEQUENCE_ASC',
  ProductVarietyByProductVarietyIdCustomerLetterSequenceDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__CUSTOMER_LETTER_SEQUENCE_DESC',
  ProductVarietyByProductVarietyIdSummaryCodeAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SUMMARY_CODE_ASC',
  ProductVarietyByProductVarietyIdSummaryCodeDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__SUMMARY_CODE_DESC',
  ProductVarietyByProductVarietyIdVarietyGroupAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_GROUP_ASC',
  ProductVarietyByProductVarietyIdVarietyGroupDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__VARIETY_GROUP_DESC',
  ProductVarietyByProductVarietyIdCombineWithAsc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__COMBINE_WITH_ASC',
  ProductVarietyByProductVarietyIdCombineWithDesc = 'PRODUCT_VARIETY_BY_PRODUCT_VARIETY_ID__COMBINE_WITH_DESC'
}

export type CommonVarietyProductVariety = Node & {
  __typename?: 'CommonVarietyProductVariety';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyProductVariety`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `ProductVariety` that is related to this `CommonVarietyProductVariety`. */
  productVariety?: Maybe<ProductVariety>;
};

/** The `commonVariety` to be created by this mutation. */
export type CommonVarietyProductVarietyCommonVarietyIdFkeyCommonVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** The `commonVarietyProductVariety` to be created by this mutation. */
export type CommonVarietyProductVarietyCommonVarietyIdFkeyCommonVarietyProductVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInput>;
};

/** Input for the nested mutation of `commonVariety` in the `CommonVarietyProductVarietyInput` mutation. */
export type CommonVarietyProductVarietyCommonVarietyIdFkeyInput = {
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectById?: Maybe<CommonVarietyCommonVarietyPkeyConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonVarietyNodeIdConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteById?: Maybe<CommonVarietyCommonVarietyPkeyDelete>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonVarietyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateById?: Maybe<CommonVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyNodeIdUpdate>;
  /** A `CommonVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyCommonVarietyCreateInput>;
};

/** Input for the nested mutation of `commonVarietyProductVariety` in the `CommonVarietyInput` mutation. */
export type CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonVarietyProductVariety` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonVarietyProductVarietyCommonVarietyProductVarietyPkeyConnect>>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonVarietyProductVarietyNodeIdConnect>>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonVarietyProductVarietyCommonVarietyProductVarietyPkeyDelete>>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonVarietyProductVarietyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonVarietyProductVariety` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyUsingCommonVarietyProductVarietyPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonVarietyProductVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyNodeIdUpdate>>;
  /** A `CommonVarietyProductVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonVarietyProductVarietyCommonVarietyIdFkeyCommonVarietyProductVarietyCreateInput>>;
};

/** The fields on `commonVarietyProductVariety` to look up the row to connect. */
export type CommonVarietyProductVarietyCommonVarietyProductVarietyPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `commonVarietyProductVariety` to look up the row to delete. */
export type CommonVarietyProductVarietyCommonVarietyProductVarietyPkeyDelete = {
  id: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonVarietyProductVariety` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type CommonVarietyProductVarietyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productVarietyId` field. */
  productVarietyId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CommonVarietyProductVariety` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyProductVarietyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productVarietyId` field. */
  productVarietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `commonVariety` relation. */
  commonVariety?: Maybe<CommonVarietyFilter>;
  /** A related `commonVariety` exists. */
  commonVarietyExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `productVariety` relation. */
  productVariety?: Maybe<ProductVarietyFilter>;
  /** A related `productVariety` exists. */
  productVarietyExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonVarietyProductVarietyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonVarietyProductVarietyFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonVarietyProductVarietyFilter>;
};

/** The `commonVariety` to be created by this mutation. */
export type CommonVarietyProductVarietyIdFkeyCommonVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `productVariety` in the `CommonVarietyInput` mutation. */
export type CommonVarietyProductVarietyIdFkeyInput = {
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  connectById?: Maybe<ProductVarietyProductVarietyPkeyConnect>;
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<ProductVarietyNodeIdConnect>;
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  deleteById?: Maybe<ProductVarietyProductVarietyPkeyDelete>;
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ProductVarietyNodeIdDelete>;
  /** The primary key(s) and patch data for `productVariety` for the far side of the relationship. */
  updateById?: Maybe<ProductVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyUsingProductVarietyPkeyUpdate>;
  /** The primary key(s) and patch data for `productVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyNodeIdUpdate>;
  /** A `ProductVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<CommonVarietyProductVarietyIdFkeyProductVarietyCreateInput>;
};

/** Input for the nested mutation of `commonVariety` in the `ProductVarietyInput` mutation. */
export type CommonVarietyProductVarietyIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonVariety` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonVarietyCommonVarietyPkeyConnect>>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonVarietyNodeIdConnect>>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonVarietyCommonVarietyPkeyDelete>>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonVarietyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyUsingCommonVarietyPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ProductVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyNodeIdUpdate>>;
  /** A `CommonVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonVarietyProductVarietyIdFkeyCommonVarietyCreateInput>>;
};

/** The `productVariety` to be created by this mutation. */
export type CommonVarietyProductVarietyIdFkeyProductVarietyCreateInput = {
  id: Scalars['String'];
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  commonVarietiesUsingId?: Maybe<CommonVarietyProductVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInverseInput>;
};

/** An input for mutations affecting `CommonVarietyProductVariety` */
export type CommonVarietyProductVarietyInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonVarietyProductVarietyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonVarietyProductVariety` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonVarietyProductVarietyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonVarietyProductVariety` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** The fields on `commonVarietyProductVariety` to look up the row to update. */
export type CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyUsingCommonVarietyProductVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVarietyProductVariety` being updated. */
  patch: UpdateCommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `productVariety` being updated. */
  patch: ProductVarietyPatch;
};

/** The fields on `commonVarietyProductVariety` to look up the row to update. */
export type CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyUsingCommonVarietyProductVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVarietyProductVariety` being updated. */
  patch: UpdateCommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `CommonVarietyProductVariety`. Fields that are set will be updated. */
export type CommonVarietyProductVarietyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInput>;
};

/** The `commonVarietyProductVariety` to be created by this mutation. */
export type CommonVarietyProductVarietyProductVarietyIdFkeyCommonVarietyProductVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInput>;
};

/** Input for the nested mutation of `productVariety` in the `CommonVarietyProductVarietyInput` mutation. */
export type CommonVarietyProductVarietyProductVarietyIdFkeyInput = {
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  connectById?: Maybe<ProductVarietyProductVarietyPkeyConnect>;
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<ProductVarietyNodeIdConnect>;
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  deleteById?: Maybe<ProductVarietyProductVarietyPkeyDelete>;
  /** The primary key(s) for `productVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ProductVarietyNodeIdDelete>;
  /** The primary key(s) and patch data for `productVariety` for the far side of the relationship. */
  updateById?: Maybe<ProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyUsingProductVarietyPkeyUpdate>;
  /** The primary key(s) and patch data for `productVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyNodeIdUpdate>;
  /** A `ProductVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyProductVarietyCreateInput>;
};

/** Input for the nested mutation of `commonVarietyProductVariety` in the `ProductVarietyInput` mutation. */
export type CommonVarietyProductVarietyProductVarietyIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonVarietyProductVariety` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  connectById?: Maybe<Array<CommonVarietyProductVarietyCommonVarietyProductVarietyPkeyConnect>>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonVarietyProductVarietyNodeIdConnect>>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  deleteById?: Maybe<Array<CommonVarietyProductVarietyCommonVarietyProductVarietyPkeyDelete>>;
  /** The primary key(s) for `commonVarietyProductVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonVarietyProductVarietyNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonVarietyProductVariety` for the far side of the relationship. */
  updateById?: Maybe<Array<CommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyUsingCommonVarietyProductVarietyPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonVarietyProductVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyNodeIdUpdate>>;
  /** A `CommonVarietyProductVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonVarietyProductVarietyProductVarietyIdFkeyCommonVarietyProductVarietyCreateInput>>;
};

/** The `productVariety` to be created by this mutation. */
export type CommonVarietyProductVarietyProductVarietyIdFkeyProductVarietyCreateInput = {
  id: Scalars['String'];
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  commonVarietiesUsingId?: Maybe<CommonVarietyProductVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInverseInput>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProgram`. */
export type CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CommonVarietyShippersByShipperProgramCommonVarietyIdAndShipperIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionProduct`. */
export type CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdManyToManyConnection = {
  __typename?: 'CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdManyToManyEdge = {
  __typename?: 'CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CommonVarietyShippersByShipperProjectionProductCommonVarietyIdAndShipperIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

export type CommonVarietyTag = Node & {
  __typename?: 'CommonVarietyTag';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  tagText: Scalars['String'];
  commonVarietyId: Scalars['BigInt'];
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyTag`. */
  commonVariety?: Maybe<CommonVariety>;
};

/** The `commonVariety` to be created by this mutation. */
export type CommonVarietyTagCommonVarietyIdFkeyCommonVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** The `commonVarietyTag` to be created by this mutation. */
export type CommonVarietyTagCommonVarietyIdFkeyCommonVarietyTagCreateInput = {
  tagText: Scalars['String'];
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInput>;
};

/** Input for the nested mutation of `commonVariety` in the `CommonVarietyTagInput` mutation. */
export type CommonVarietyTagCommonVarietyIdFkeyInput = {
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectById?: Maybe<CommonVarietyCommonVarietyPkeyConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonVarietyNodeIdConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteById?: Maybe<CommonVarietyCommonVarietyPkeyDelete>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonVarietyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateById?: Maybe<CommonVarietyOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<CommonVarietyTagOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyNodeIdUpdate>;
  /** A `CommonVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<CommonVarietyTagCommonVarietyIdFkeyCommonVarietyCreateInput>;
};

/** Input for the nested mutation of `commonVarietyTag` in the `CommonVarietyInput` mutation. */
export type CommonVarietyTagCommonVarietyIdFkeyInverseInput = {
  /** Flag indicating whether all other `commonVarietyTag` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `commonVarietyTag` for the far side of the relationship. */
  connectByTagTextAndCommonVarietyId?: Maybe<Array<CommonVarietyTagCommonVarietyTagPkeyConnect>>;
  /** The primary key(s) for `commonVarietyTag` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CommonVarietyTagNodeIdConnect>>;
  /** The primary key(s) for `commonVarietyTag` for the far side of the relationship. */
  deleteByTagTextAndCommonVarietyId?: Maybe<Array<CommonVarietyTagCommonVarietyTagPkeyDelete>>;
  /** The primary key(s) for `commonVarietyTag` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CommonVarietyTagNodeIdDelete>>;
  /** The primary key(s) and patch data for `commonVarietyTag` for the far side of the relationship. */
  updateByTagTextAndCommonVarietyId?: Maybe<Array<CommonVarietyTagOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyUsingCommonVarietyTagPkeyUpdate>>;
  /** The primary key(s) and patch data for `commonVarietyTag` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonVarietyOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyNodeIdUpdate>>;
  /** A `CommonVarietyTagInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CommonVarietyTagCommonVarietyIdFkeyCommonVarietyTagCreateInput>>;
};

/** The fields on `commonVarietyTag` to look up the row to connect. */
export type CommonVarietyTagCommonVarietyTagPkeyConnect = {
  tagText: Scalars['String'];
  commonVarietyId: Scalars['BigInt'];
};

/** The fields on `commonVarietyTag` to look up the row to delete. */
export type CommonVarietyTagCommonVarietyTagPkeyDelete = {
  tagText: Scalars['String'];
  commonVarietyId: Scalars['BigInt'];
};

/**
 * A condition to be used against `CommonVarietyTag` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CommonVarietyTagCondition = {
  /** Checks for equality with the object’s `tagText` field. */
  tagText?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `CommonVarietyTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyTagFilter = {
  /** Filter by the object’s `tagText` field. */
  tagText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonVariety` relation. */
  commonVariety?: Maybe<CommonVarietyFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CommonVarietyTagFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CommonVarietyTagFilter>>;
  /** Negates the expression. */
  not?: Maybe<CommonVarietyTagFilter>;
};

/** An input for mutations affecting `CommonVarietyTag` */
export type CommonVarietyTagInput = {
  tagText: Scalars['String'];
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CommonVarietyTagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `commonVarietyTag` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CommonVarietyTagNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `commonVarietyTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CommonVarietyTagOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** The fields on `commonVarietyTag` to look up the row to update. */
export type CommonVarietyTagOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyUsingCommonVarietyTagPkeyUpdate = {
  /** An object where the defined keys will be set on the `commonVarietyTag` being updated. */
  patch: UpdateCommonVarietyTagOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyPatch;
  tagText: Scalars['String'];
  commonVarietyId: Scalars['BigInt'];
};

/** Represents an update to a `CommonVarietyTag`. Fields that are set will be updated. */
export type CommonVarietyTagPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInput>;
};

/** A connection to a list of `CommonVarietyTag` values. */
export type CommonVarietyTagsConnection = {
  __typename?: 'CommonVarietyTagsConnection';
  /** A list of `CommonVarietyTag` objects. */
  nodes: Array<Maybe<CommonVarietyTag>>;
  /** A list of edges which contains the `CommonVarietyTag` and cursor to aid in pagination. */
  edges: Array<CommonVarietyTagsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVarietyTag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVarietyTag` edge in the connection. */
export type CommonVarietyTagsEdge = {
  __typename?: 'CommonVarietyTagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVarietyTag` at the end of the edge. */
  node?: Maybe<CommonVarietyTag>;
};

/** Methods to use when ordering `CommonVarietyTag`. */
export enum CommonVarietyTagsOrderBy {
  Natural = 'NATURAL',
  TagTextAsc = 'TAG_TEXT_ASC',
  TagTextDesc = 'TAG_TEXT_DESC',
  CommonVarietyIdAsc = 'COMMON_VARIETY_ID_ASC',
  CommonVarietyIdDesc = 'COMMON_VARIETY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonVarietyByCommonVarietyIdIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_ASC',
  CommonVarietyByCommonVarietyIdIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_DESC',
  CommonVarietyByCommonVarietyIdVarietyNameAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_ASC',
  CommonVarietyByCommonVarietyIdVarietyNameDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_DESC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_ASC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_DESC',
  CommonVarietyByCommonVarietyIdUiColorAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_ASC',
  CommonVarietyByCommonVarietyIdUiColorDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_DESC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_ASC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_DESC',
  CommonVarietyByCommonVarietyIdProductVarietyIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_ASC',
  CommonVarietyByCommonVarietyIdProductVarietyIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_DESC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_DESC'
}

/** A filter to be used against many `CommonVarietyProductVariety` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyToManyCommonVarietyProductVarietyFilter = {
  /** Every related `CommonVarietyProductVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonVarietyProductVarietyFilter>;
  /** Some related `CommonVarietyProductVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonVarietyProductVarietyFilter>;
  /** No related `CommonVarietyProductVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonVarietyProductVarietyFilter>;
};

/** A filter to be used against many `CommonVarietyTag` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyToManyCommonVarietyTagFilter = {
  /** Every related `CommonVarietyTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonVarietyTagFilter>;
  /** Some related `CommonVarietyTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonVarietyTagFilter>;
  /** No related `CommonVarietyTag` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonVarietyTagFilter>;
};

/** A filter to be used against many `CustomerProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyToManyCustomerProgramFilter = {
  /** Every related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerProgramFilter>;
  /** Some related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerProgramFilter>;
  /** No related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerProgramFilter>;
};

/** A filter to be used against many `ShipperProgram` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyToManyShipperProgramFilter = {
  /** Every related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramFilter>;
  /** Some related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramFilter>;
  /** No related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramFilter>;
};

/** A filter to be used against many `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type CommonVarietyToManyShipperProjectionProductFilter = {
  /** Every related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionProductFilter>;
  /** Some related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionProductFilter>;
  /** No related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionProductFilter>;
};

export type ContactGroup = Node & {
  __typename?: 'ContactGroup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `ContactGroupPersonContact`. */
  contactGroupPersonContactsByGroupId: ContactGroupPersonContactsConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByContactGroupPersonContactGroupIdAndPersonContactId: ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyConnection;
};


export type ContactGroupContactGroupPersonContactsByGroupIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
  condition?: Maybe<ContactGroupPersonContactCondition>;
  filter?: Maybe<ContactGroupPersonContactFilter>;
};


export type ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};

/**
 * A condition to be used against `ContactGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContactGroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `groupDescription` field. */
  groupDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groupName` field. */
  groupName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['BigInt']>;
};

/** The fields on `contactGroup` to look up the row to connect. */
export type ContactGroupContactGroupPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `contactGroup` to look up the row to delete. */
export type ContactGroupContactGroupPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against `ContactGroup` object types. All fields are combined with a logical ‘and.’ */
export type ContactGroupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `groupDescription` field. */
  groupDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `groupName` field. */
  groupName?: Maybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `contactGroupPersonContactsByGroupId` relation. */
  contactGroupPersonContactsByGroupId?: Maybe<ContactGroupToManyContactGroupPersonContactFilter>;
  /** Some related `contactGroupPersonContactsByGroupId` exist. */
  contactGroupPersonContactsByGroupIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ContactGroupFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ContactGroupFilter>>;
  /** Negates the expression. */
  not?: Maybe<ContactGroupFilter>;
};

/** An input for mutations affecting `ContactGroup` */
export type ContactGroupInput = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ContactGroupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ContactGroupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `contactGroup` to look up the row to update. */
export type ContactGroupOnContactGroupForContactGroupUserIdFkeyUsingContactGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: UpdateContactGroupOnContactGroupForContactGroupUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
};

/** The fields on `contactGroup` to look up the row to update. */
export type ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: UpdateContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ContactGroup`. Fields that are set will be updated. */
export type ContactGroupPatch = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription?: Maybe<Scalars['String']>;
  groupName?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

export type ContactGroupPersonContact = Node & {
  __typename?: 'ContactGroupPersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
};

/**
 * A condition to be used against `ContactGroupPersonContact` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ContactGroupPersonContactCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** The fields on `contactGroupPersonContact` to look up the row to connect. */
export type ContactGroupPersonContactContactGroupPersonContactPkeyConnect = {
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The fields on `contactGroupPersonContact` to look up the row to delete. */
export type ContactGroupPersonContactContactGroupPersonContactPkeyDelete = {
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** A filter to be used against `ContactGroupPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ContactGroupPersonContactFilter = {
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `group` relation. */
  group?: Maybe<ContactGroupFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ContactGroupPersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ContactGroupPersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<ContactGroupPersonContactFilter>;
};

/** The `contactGroup` to be created by this mutation. */
export type ContactGroupPersonContactGroupIdFkeyContactGroupCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** The `contactGroupPersonContact` to be created by this mutation. */
export type ContactGroupPersonContactGroupIdFkeyContactGroupPersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `contactGroup` in the `ContactGroupPersonContactInput` mutation. */
export type ContactGroupPersonContactGroupIdFkeyInput = {
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectById?: Maybe<ContactGroupContactGroupPkeyConnect>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectByNodeId?: Maybe<ContactGroupNodeIdConnect>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteById?: Maybe<ContactGroupContactGroupPkeyDelete>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ContactGroupNodeIdDelete>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateById?: Maybe<ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateByNodeId?: Maybe<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate>;
  /** A `ContactGroupInput` object that will be created and connected to this object. */
  create?: Maybe<ContactGroupPersonContactGroupIdFkeyContactGroupCreateInput>;
};

/** Input for the nested mutation of `contactGroupPersonContact` in the `ContactGroupInput` mutation. */
export type ContactGroupPersonContactGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `contactGroupPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyDelete>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate>>;
  /** A `ContactGroupPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ContactGroupPersonContactGroupIdFkeyContactGroupPersonContactCreateInput>>;
};

/** An input for mutations affecting `ContactGroupPersonContact` */
export type ContactGroupPersonContactInput = {
  groupId?: Maybe<Scalars['BigInt']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ContactGroupPersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ContactGroupPersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: ContactGroupPatch;
};

/** The fields on `contactGroupPersonContact` to look up the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyUsingContactGroupPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The fields on `contactGroupPersonContact` to look up the row to update. */
export type ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingContactGroupPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** Represents an update to a `ContactGroupPersonContact`. Fields that are set will be updated. */
export type ContactGroupPersonContactPatch = {
  groupId?: Maybe<Scalars['BigInt']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** The `contactGroupPersonContact` to be created by this mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyContactGroupPersonContactCreateInput = {
  groupId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `ContactGroupPersonContactInput` mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<ContactGroupPersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** Input for the nested mutation of `contactGroupPersonContact` in the `PersonContactInput` mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `contactGroupPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdConnect>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactContactGroupPersonContactPkeyDelete>>;
  /** The primary key(s) for `contactGroupPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ContactGroupPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByGroupIdAndPersonContactId?: Maybe<Array<ContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingContactGroupPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `contactGroupPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `ContactGroupPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ContactGroupPersonContactPersonContactIdFkeyContactGroupPersonContactCreateInput>>;
};

/** The `personContact` to be created by this mutation. */
export type ContactGroupPersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** A connection to a list of `PersonContact` values, with data from `ContactGroupPersonContact`. */
export type ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `ContactGroupPersonContact`, and the cursor to aid in pagination. */
  edges: Array<ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `ContactGroupPersonContact`. */
export type ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'ContactGroupPersonContactsByContactGroupPersonContactGroupIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A connection to a list of `ContactGroupPersonContact` values. */
export type ContactGroupPersonContactsConnection = {
  __typename?: 'ContactGroupPersonContactsConnection';
  /** A list of `ContactGroupPersonContact` objects. */
  nodes: Array<Maybe<ContactGroupPersonContact>>;
  /** A list of edges which contains the `ContactGroupPersonContact` and cursor to aid in pagination. */
  edges: Array<ContactGroupPersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContactGroupPersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ContactGroupPersonContact` edge in the connection. */
export type ContactGroupPersonContactsEdge = {
  __typename?: 'ContactGroupPersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContactGroupPersonContact` at the end of the edge. */
  node?: Maybe<ContactGroupPersonContact>;
};

/** Methods to use when ordering `ContactGroupPersonContact`. */
export enum ContactGroupPersonContactsOrderBy {
  Natural = 'NATURAL',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ContactGroupByGroupIdIdAsc = 'CONTACT_GROUP_BY_GROUP_ID__ID_ASC',
  ContactGroupByGroupIdIdDesc = 'CONTACT_GROUP_BY_GROUP_ID__ID_DESC',
  ContactGroupByGroupIdGroupDescriptionAsc = 'CONTACT_GROUP_BY_GROUP_ID__GROUP_DESCRIPTION_ASC',
  ContactGroupByGroupIdGroupDescriptionDesc = 'CONTACT_GROUP_BY_GROUP_ID__GROUP_DESCRIPTION_DESC',
  ContactGroupByGroupIdGroupNameAsc = 'CONTACT_GROUP_BY_GROUP_ID__GROUP_NAME_ASC',
  ContactGroupByGroupIdGroupNameDesc = 'CONTACT_GROUP_BY_GROUP_ID__GROUP_NAME_DESC',
  ContactGroupByGroupIdUserIdAsc = 'CONTACT_GROUP_BY_GROUP_ID__USER_ID_ASC',
  ContactGroupByGroupIdUserIdDesc = 'CONTACT_GROUP_BY_GROUP_ID__USER_ID_DESC',
  PersonContactByPersonContactIdIdAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_ASC',
  PersonContactByPersonContactIdIdDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_DESC',
  PersonContactByPersonContactIdFirstNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_ASC',
  PersonContactByPersonContactIdFirstNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_DESC',
  PersonContactByPersonContactIdLastNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_ASC',
  PersonContactByPersonContactIdLastNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_DESC',
  PersonContactByPersonContactIdIsPrimaryAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_ASC',
  PersonContactByPersonContactIdIsPrimaryDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_DESC',
  PersonContactByPersonContactIdEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_ASC',
  PersonContactByPersonContactIdEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_DESC',
  PersonContactByPersonContactIdSecondaryEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_ASC',
  PersonContactByPersonContactIdSecondaryEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_DESC',
  PersonContactByPersonContactIdHomePhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_ASC',
  PersonContactByPersonContactIdHomePhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_DESC',
  PersonContactByPersonContactIdCellPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_ASC',
  PersonContactByPersonContactIdCellPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_DESC',
  PersonContactByPersonContactIdWorkPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_ASC',
  PersonContactByPersonContactIdWorkPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_DESC',
  PersonContactByPersonContactIdWorkExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_ASC',
  PersonContactByPersonContactIdWorkExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_DESC',
  PersonContactByPersonContactIdImageSrcAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_ASC',
  PersonContactByPersonContactIdImageSrcDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_DESC',
  PersonContactByPersonContactIdIsInternalAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_ASC',
  PersonContactByPersonContactIdIsInternalDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_DESC',
  PersonContactByPersonContactIdRolesAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_ASC',
  PersonContactByPersonContactIdRolesDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_DESC',
  PersonContactByPersonContactIdHomeExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_ASC',
  PersonContactByPersonContactIdHomeExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_DESC',
  PersonContactByPersonContactIdLocationAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_ASC',
  PersonContactByPersonContactIdLocationDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_DESC'
}

/** A filter to be used against many `ContactGroupPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ContactGroupToManyContactGroupPersonContactFilter = {
  /** Every related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ContactGroupPersonContactFilter>;
  /** Some related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ContactGroupPersonContactFilter>;
  /** No related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ContactGroupPersonContactFilter>;
};

/** The `contactGroup` to be created by this mutation. */
export type ContactGroupUserIdFkeyContactGroupCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription: Scalars['String'];
  groupName: Scalars['String'];
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `ContactGroupInput` mutation. */
export type ContactGroupUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<UserUserPinKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<UserUserPinKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnContactGroupForContactGroupUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<UserOnContactGroupForContactGroupUserIdFkeyUsingUserPinKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<ContactGroupOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<ContactGroupUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `contactGroup` in the `UserInput` mutation. */
export type ContactGroupUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `contactGroup` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectById?: Maybe<Array<ContactGroupContactGroupPkeyConnect>>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ContactGroupNodeIdConnect>>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteById?: Maybe<Array<ContactGroupContactGroupPkeyDelete>>;
  /** The primary key(s) for `contactGroup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ContactGroupNodeIdDelete>>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateById?: Maybe<Array<ContactGroupOnContactGroupForContactGroupUserIdFkeyUsingContactGroupPkeyUpdate>>;
  /** The primary key(s) and patch data for `contactGroup` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate>>;
  /** A `ContactGroupInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ContactGroupUserIdFkeyContactGroupCreateInput>>;
};

/** The `user` to be created by this mutation. */
export type ContactGroupUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** A connection to a list of `ContactGroup` values. */
export type ContactGroupsConnection = {
  __typename?: 'ContactGroupsConnection';
  /** A list of `ContactGroup` objects. */
  nodes: Array<Maybe<ContactGroup>>;
  /** A list of edges which contains the `ContactGroup` and cursor to aid in pagination. */
  edges: Array<ContactGroupsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContactGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ContactGroup` edge in the connection. */
export type ContactGroupsEdge = {
  __typename?: 'ContactGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContactGroup` at the end of the edge. */
  node?: Maybe<ContactGroup>;
};

/** Methods to use when ordering `ContactGroup`. */
export enum ContactGroupsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  GroupDescriptionAsc = 'GROUP_DESCRIPTION_ASC',
  GroupDescriptionDesc = 'GROUP_DESCRIPTION_DESC',
  GroupNameAsc = 'GROUP_NAME_ASC',
  GroupNameDesc = 'GROUP_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdPinAsc = 'USER_BY_USER_ID__PIN_ASC',
  UserByUserIdPinDesc = 'USER_BY_USER_ID__PIN_DESC',
  UserByUserIdPersonContactIdAsc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_ASC',
  UserByUserIdPersonContactIdDesc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_DESC',
  UserByUserIdUserCodeAsc = 'USER_BY_USER_ID__USER_CODE_ASC',
  UserByUserIdUserCodeDesc = 'USER_BY_USER_ID__USER_CODE_DESC',
  UserByUserIdDefaultCoastAsc = 'USER_BY_USER_ID__DEFAULT_COAST_ASC',
  UserByUserIdDefaultCoastDesc = 'USER_BY_USER_ID__DEFAULT_COAST_DESC',
  ContactGroupPersonContactsByGroupIdCountAsc = 'CONTACT_GROUP_PERSON_CONTACTS_BY_GROUP_ID__COUNT_ASC',
  ContactGroupPersonContactsByGroupIdCountDesc = 'CONTACT_GROUP_PERSON_CONTACTS_BY_GROUP_ID__COUNT_DESC'
}

export type Container = Node & {
  __typename?: 'Container';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselCode: Scalars['String'];
  containerId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  containerDescription?: Maybe<Scalars['String']>;
  releaseDate?: Maybe<Scalars['Date']>;
  releaseConfirmed?: Maybe<Scalars['Boolean']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  dischargeConfirmed?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
  notes3?: Maybe<Scalars['String']>;
  sentConfirmed?: Maybe<Scalars['Boolean']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  isNew?: Maybe<Scalars['Boolean']>;
  isSchedule?: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `ContainerTreatment`. */
  containerTreatments: ContainerTreatmentsConnection;
  isVesselAvailable?: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets: PalletsConnection;
  searchText?: Maybe<Scalars['String']>;
  vendor?: Maybe<Vendor>;
  vessel?: Maybe<Vessel>;
  warehouse?: Maybe<Warehouse>;
};


export type ContainerContainerTreatmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContainerTreatmentsOrderBy>>;
  condition?: Maybe<ContainerTreatmentCondition>;
  filter?: Maybe<ContainerTreatmentFilter>;
};


export type ContainerPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletFilter>;
};

/**
 * A condition to be used against `Container` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ContainerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerDescription` field. */
  containerDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `releaseDate` field. */
  releaseDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `releaseConfirmed` field. */
  releaseConfirmed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `dischargeDate` field. */
  dischargeDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `dischargeConfirmed` field. */
  dischargeConfirmed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `notes1` field. */
  notes1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes2` field. */
  notes2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes3` field. */
  notes3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sentConfirmed` field. */
  sentConfirmed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isAvailable` field. */
  isAvailable?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isNew` field. */
  isNew?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isSchedule` field. */
  isSchedule?: Maybe<Scalars['Boolean']>;
};

/** The fields on `container` to look up the row to connect. */
export type ContainerContainerPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `container` to look up the row to delete. */
export type ContainerContainerPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against `Container` object types. All fields are combined with a logical ‘and.’ */
export type ContainerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `containerDescription` field. */
  containerDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `releaseDate` field. */
  releaseDate?: Maybe<DateFilter>;
  /** Filter by the object’s `releaseConfirmed` field. */
  releaseConfirmed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `dischargeDate` field. */
  dischargeDate?: Maybe<DateFilter>;
  /** Filter by the object’s `dischargeConfirmed` field. */
  dischargeConfirmed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `notes1` field. */
  notes1?: Maybe<StringFilter>;
  /** Filter by the object’s `notes2` field. */
  notes2?: Maybe<StringFilter>;
  /** Filter by the object’s `notes3` field. */
  notes3?: Maybe<StringFilter>;
  /** Filter by the object’s `sentConfirmed` field. */
  sentConfirmed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isAvailable` field. */
  isAvailable?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isNew` field. */
  isNew?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isSchedule` field. */
  isSchedule?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isVesselAvailable` field. */
  isVesselAvailable?: Maybe<BooleanFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `containerTreatments` relation. */
  containerTreatments?: Maybe<ContainerToManyContainerTreatmentFilter>;
  /** Some related `containerTreatments` exist. */
  containerTreatmentsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ContainerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ContainerFilter>>;
  /** Negates the expression. */
  not?: Maybe<ContainerFilter>;
};

/** An input for mutations affecting `Container` */
export type ContainerInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  containerId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  containerDescription?: Maybe<Scalars['String']>;
  releaseDate?: Maybe<Scalars['Date']>;
  releaseConfirmed?: Maybe<Scalars['Boolean']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  dischargeConfirmed?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
  notes3?: Maybe<Scalars['String']>;
  sentConfirmed?: Maybe<Scalars['Boolean']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  isNew?: Maybe<Scalars['Boolean']>;
  isSchedule?: Maybe<Scalars['Boolean']>;
  containerTreatmentsUsingId?: Maybe<ContainerTreatmentContainerIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ContainerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `container` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ContainerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `container` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ContainerOnContainerTreatmentForContainerTreatmentContainerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `containerTreatment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `containerTreatment` being updated. */
  patch: ContainerTreatmentPatch;
};

/** The fields on `container` to look up the row to update. */
export type ContainerOnContainerTreatmentForContainerTreatmentContainerIdFkeyUsingContainerPkeyUpdate = {
  /** An object where the defined keys will be set on the `container` being updated. */
  patch: UpdateContainerOnContainerTreatmentForContainerTreatmentContainerIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `Container`. Fields that are set will be updated. */
export type ContainerPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  containerDescription?: Maybe<Scalars['String']>;
  releaseDate?: Maybe<Scalars['Date']>;
  releaseConfirmed?: Maybe<Scalars['Boolean']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  dischargeConfirmed?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
  notes3?: Maybe<Scalars['String']>;
  sentConfirmed?: Maybe<Scalars['Boolean']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  isNew?: Maybe<Scalars['Boolean']>;
  isSchedule?: Maybe<Scalars['Boolean']>;
  containerTreatmentsUsingId?: Maybe<ContainerTreatmentContainerIdFkeyInverseInput>;
};

export type ContainerScheduleUpdateInput = {
  message: Scalars['String'];
  data: Scalars['String'];
};

/** A filter to be used against many `ContainerTreatment` object types. All fields are combined with a logical ‘and.’ */
export type ContainerToManyContainerTreatmentFilter = {
  /** Every related `ContainerTreatment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ContainerTreatmentFilter>;
  /** Some related `ContainerTreatment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ContainerTreatmentFilter>;
  /** No related `ContainerTreatment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ContainerTreatmentFilter>;
};

export type ContainerTreatment = Node & {
  __typename?: 'ContainerTreatment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  containerId: Scalars['BigInt'];
  treatmentDate?: Maybe<Scalars['Date']>;
  treatmentConfirmed?: Maybe<Scalars['Boolean']>;
  treatmentResult?: Maybe<Scalars['String']>;
  treatmentType: Scalars['String'];
  treatmentNotes?: Maybe<Scalars['String']>;
  /** Reads a single `Container` that is related to this `ContainerTreatment`. */
  container?: Maybe<Container>;
};

/**
 * A condition to be used against `ContainerTreatment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContainerTreatmentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `treatmentDate` field. */
  treatmentDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `treatmentConfirmed` field. */
  treatmentConfirmed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `treatmentResult` field. */
  treatmentResult?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treatmentType` field. */
  treatmentType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treatmentNotes` field. */
  treatmentNotes?: Maybe<Scalars['String']>;
};

/** The `container` to be created by this mutation. */
export type ContainerTreatmentContainerIdFkeyContainerCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  vendorId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  containerDescription?: Maybe<Scalars['String']>;
  releaseDate?: Maybe<Scalars['Date']>;
  releaseConfirmed?: Maybe<Scalars['Boolean']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  dischargeConfirmed?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
  notes3?: Maybe<Scalars['String']>;
  sentConfirmed?: Maybe<Scalars['Boolean']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  isNew?: Maybe<Scalars['Boolean']>;
  isSchedule?: Maybe<Scalars['Boolean']>;
  containerTreatmentsUsingId?: Maybe<ContainerTreatmentContainerIdFkeyInverseInput>;
};

/** The `containerTreatment` to be created by this mutation. */
export type ContainerTreatmentContainerIdFkeyContainerTreatmentCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  treatmentDate?: Maybe<Scalars['Date']>;
  treatmentConfirmed?: Maybe<Scalars['Boolean']>;
  treatmentResult?: Maybe<Scalars['String']>;
  treatmentType: Scalars['String'];
  treatmentNotes?: Maybe<Scalars['String']>;
  containerToContainerId?: Maybe<ContainerTreatmentContainerIdFkeyInput>;
};

/** Input for the nested mutation of `container` in the `ContainerTreatmentInput` mutation. */
export type ContainerTreatmentContainerIdFkeyInput = {
  /** The primary key(s) for `container` for the far side of the relationship. */
  connectById?: Maybe<ContainerContainerPkeyConnect>;
  /** The primary key(s) for `container` for the far side of the relationship. */
  connectByNodeId?: Maybe<ContainerNodeIdConnect>;
  /** The primary key(s) for `container` for the far side of the relationship. */
  deleteById?: Maybe<ContainerContainerPkeyDelete>;
  /** The primary key(s) for `container` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ContainerNodeIdDelete>;
  /** The primary key(s) and patch data for `container` for the far side of the relationship. */
  updateById?: Maybe<ContainerOnContainerTreatmentForContainerTreatmentContainerIdFkeyUsingContainerPkeyUpdate>;
  /** The primary key(s) and patch data for `container` for the far side of the relationship. */
  updateByNodeId?: Maybe<ContainerTreatmentOnContainerTreatmentForContainerTreatmentContainerIdFkeyNodeIdUpdate>;
  /** A `ContainerInput` object that will be created and connected to this object. */
  create?: Maybe<ContainerTreatmentContainerIdFkeyContainerCreateInput>;
};

/** Input for the nested mutation of `containerTreatment` in the `ContainerInput` mutation. */
export type ContainerTreatmentContainerIdFkeyInverseInput = {
  /** Flag indicating whether all other `containerTreatment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `containerTreatment` for the far side of the relationship. */
  connectById?: Maybe<Array<ContainerTreatmentContainerTreatmentPkeyConnect>>;
  /** The primary key(s) for `containerTreatment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ContainerTreatmentNodeIdConnect>>;
  /** The primary key(s) for `containerTreatment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ContainerTreatmentContainerTreatmentPkeyDelete>>;
  /** The primary key(s) for `containerTreatment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ContainerTreatmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `containerTreatment` for the far side of the relationship. */
  updateById?: Maybe<Array<ContainerTreatmentOnContainerTreatmentForContainerTreatmentContainerIdFkeyUsingContainerTreatmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `containerTreatment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ContainerOnContainerTreatmentForContainerTreatmentContainerIdFkeyNodeIdUpdate>>;
  /** A `ContainerTreatmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ContainerTreatmentContainerIdFkeyContainerTreatmentCreateInput>>;
};

/** The fields on `containerTreatment` to look up the row to connect. */
export type ContainerTreatmentContainerTreatmentPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `containerTreatment` to look up the row to delete. */
export type ContainerTreatmentContainerTreatmentPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against `ContainerTreatment` object types. All fields are combined with a logical ‘and.’ */
export type ContainerTreatmentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `treatmentDate` field. */
  treatmentDate?: Maybe<DateFilter>;
  /** Filter by the object’s `treatmentConfirmed` field. */
  treatmentConfirmed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `treatmentResult` field. */
  treatmentResult?: Maybe<StringFilter>;
  /** Filter by the object’s `treatmentType` field. */
  treatmentType?: Maybe<StringFilter>;
  /** Filter by the object’s `treatmentNotes` field. */
  treatmentNotes?: Maybe<StringFilter>;
  /** Filter by the object’s `container` relation. */
  container?: Maybe<ContainerFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ContainerTreatmentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ContainerTreatmentFilter>>;
  /** Negates the expression. */
  not?: Maybe<ContainerTreatmentFilter>;
};

/** An input for mutations affecting `ContainerTreatment` */
export type ContainerTreatmentInput = {
  id?: Maybe<Scalars['BigInt']>;
  containerId?: Maybe<Scalars['BigInt']>;
  treatmentDate?: Maybe<Scalars['Date']>;
  treatmentConfirmed?: Maybe<Scalars['Boolean']>;
  treatmentResult?: Maybe<Scalars['String']>;
  treatmentType: Scalars['String'];
  treatmentNotes?: Maybe<Scalars['String']>;
  containerToContainerId?: Maybe<ContainerTreatmentContainerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ContainerTreatmentNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `containerTreatment` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ContainerTreatmentNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `containerTreatment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ContainerTreatmentOnContainerTreatmentForContainerTreatmentContainerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `container` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `container` being updated. */
  patch: ContainerPatch;
};

/** The fields on `containerTreatment` to look up the row to update. */
export type ContainerTreatmentOnContainerTreatmentForContainerTreatmentContainerIdFkeyUsingContainerTreatmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `containerTreatment` being updated. */
  patch: UpdateContainerTreatmentOnContainerTreatmentForContainerTreatmentContainerIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ContainerTreatment`. Fields that are set will be updated. */
export type ContainerTreatmentPatch = {
  id?: Maybe<Scalars['BigInt']>;
  containerId?: Maybe<Scalars['BigInt']>;
  treatmentDate?: Maybe<Scalars['Date']>;
  treatmentConfirmed?: Maybe<Scalars['Boolean']>;
  treatmentResult?: Maybe<Scalars['String']>;
  treatmentType?: Maybe<Scalars['String']>;
  treatmentNotes?: Maybe<Scalars['String']>;
  containerToContainerId?: Maybe<ContainerTreatmentContainerIdFkeyInput>;
};

/** A connection to a list of `ContainerTreatment` values. */
export type ContainerTreatmentsConnection = {
  __typename?: 'ContainerTreatmentsConnection';
  /** A list of `ContainerTreatment` objects. */
  nodes: Array<Maybe<ContainerTreatment>>;
  /** A list of edges which contains the `ContainerTreatment` and cursor to aid in pagination. */
  edges: Array<ContainerTreatmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContainerTreatment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ContainerTreatment` edge in the connection. */
export type ContainerTreatmentsEdge = {
  __typename?: 'ContainerTreatmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContainerTreatment` at the end of the edge. */
  node?: Maybe<ContainerTreatment>;
};

/** Methods to use when ordering `ContainerTreatment`. */
export enum ContainerTreatmentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  TreatmentDateAsc = 'TREATMENT_DATE_ASC',
  TreatmentDateDesc = 'TREATMENT_DATE_DESC',
  TreatmentConfirmedAsc = 'TREATMENT_CONFIRMED_ASC',
  TreatmentConfirmedDesc = 'TREATMENT_CONFIRMED_DESC',
  TreatmentResultAsc = 'TREATMENT_RESULT_ASC',
  TreatmentResultDesc = 'TREATMENT_RESULT_DESC',
  TreatmentTypeAsc = 'TREATMENT_TYPE_ASC',
  TreatmentTypeDesc = 'TREATMENT_TYPE_DESC',
  TreatmentNotesAsc = 'TREATMENT_NOTES_ASC',
  TreatmentNotesDesc = 'TREATMENT_NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ContainerByContainerIdIdAsc = 'CONTAINER_BY_CONTAINER_ID__ID_ASC',
  ContainerByContainerIdIdDesc = 'CONTAINER_BY_CONTAINER_ID__ID_DESC',
  ContainerByContainerIdVesselCodeAsc = 'CONTAINER_BY_CONTAINER_ID__VESSEL_CODE_ASC',
  ContainerByContainerIdVesselCodeDesc = 'CONTAINER_BY_CONTAINER_ID__VESSEL_CODE_DESC',
  ContainerByContainerIdContainerIdAsc = 'CONTAINER_BY_CONTAINER_ID__CONTAINER_ID_ASC',
  ContainerByContainerIdContainerIdDesc = 'CONTAINER_BY_CONTAINER_ID__CONTAINER_ID_DESC',
  ContainerByContainerIdVendorIdAsc = 'CONTAINER_BY_CONTAINER_ID__VENDOR_ID_ASC',
  ContainerByContainerIdVendorIdDesc = 'CONTAINER_BY_CONTAINER_ID__VENDOR_ID_DESC',
  ContainerByContainerIdWarehouseIdAsc = 'CONTAINER_BY_CONTAINER_ID__WAREHOUSE_ID_ASC',
  ContainerByContainerIdWarehouseIdDesc = 'CONTAINER_BY_CONTAINER_ID__WAREHOUSE_ID_DESC',
  ContainerByContainerIdContainerDescriptionAsc = 'CONTAINER_BY_CONTAINER_ID__CONTAINER_DESCRIPTION_ASC',
  ContainerByContainerIdContainerDescriptionDesc = 'CONTAINER_BY_CONTAINER_ID__CONTAINER_DESCRIPTION_DESC',
  ContainerByContainerIdReleaseDateAsc = 'CONTAINER_BY_CONTAINER_ID__RELEASE_DATE_ASC',
  ContainerByContainerIdReleaseDateDesc = 'CONTAINER_BY_CONTAINER_ID__RELEASE_DATE_DESC',
  ContainerByContainerIdReleaseConfirmedAsc = 'CONTAINER_BY_CONTAINER_ID__RELEASE_CONFIRMED_ASC',
  ContainerByContainerIdReleaseConfirmedDesc = 'CONTAINER_BY_CONTAINER_ID__RELEASE_CONFIRMED_DESC',
  ContainerByContainerIdDischargeDateAsc = 'CONTAINER_BY_CONTAINER_ID__DISCHARGE_DATE_ASC',
  ContainerByContainerIdDischargeDateDesc = 'CONTAINER_BY_CONTAINER_ID__DISCHARGE_DATE_DESC',
  ContainerByContainerIdDischargeConfirmedAsc = 'CONTAINER_BY_CONTAINER_ID__DISCHARGE_CONFIRMED_ASC',
  ContainerByContainerIdDischargeConfirmedDesc = 'CONTAINER_BY_CONTAINER_ID__DISCHARGE_CONFIRMED_DESC',
  ContainerByContainerIdNotes1Asc = 'CONTAINER_BY_CONTAINER_ID__NOTES1_ASC',
  ContainerByContainerIdNotes1Desc = 'CONTAINER_BY_CONTAINER_ID__NOTES1_DESC',
  ContainerByContainerIdNotes2Asc = 'CONTAINER_BY_CONTAINER_ID__NOTES2_ASC',
  ContainerByContainerIdNotes2Desc = 'CONTAINER_BY_CONTAINER_ID__NOTES2_DESC',
  ContainerByContainerIdNotes3Asc = 'CONTAINER_BY_CONTAINER_ID__NOTES3_ASC',
  ContainerByContainerIdNotes3Desc = 'CONTAINER_BY_CONTAINER_ID__NOTES3_DESC',
  ContainerByContainerIdSentConfirmedAsc = 'CONTAINER_BY_CONTAINER_ID__SENT_CONFIRMED_ASC',
  ContainerByContainerIdSentConfirmedDesc = 'CONTAINER_BY_CONTAINER_ID__SENT_CONFIRMED_DESC',
  ContainerByContainerIdIsAvailableAsc = 'CONTAINER_BY_CONTAINER_ID__IS_AVAILABLE_ASC',
  ContainerByContainerIdIsAvailableDesc = 'CONTAINER_BY_CONTAINER_ID__IS_AVAILABLE_DESC',
  ContainerByContainerIdIsNewAsc = 'CONTAINER_BY_CONTAINER_ID__IS_NEW_ASC',
  ContainerByContainerIdIsNewDesc = 'CONTAINER_BY_CONTAINER_ID__IS_NEW_DESC',
  ContainerByContainerIdIsScheduleAsc = 'CONTAINER_BY_CONTAINER_ID__IS_SCHEDULE_ASC',
  ContainerByContainerIdIsScheduleDesc = 'CONTAINER_BY_CONTAINER_ID__IS_SCHEDULE_DESC'
}

/** A connection to a list of `Container` values. */
export type ContainersConnection = {
  __typename?: 'ContainersConnection';
  /** A list of `Container` objects. */
  nodes: Array<Maybe<Container>>;
  /** A list of edges which contains the `Container` and cursor to aid in pagination. */
  edges: Array<ContainersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Container` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Container` edge in the connection. */
export type ContainersEdge = {
  __typename?: 'ContainersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Container` at the end of the edge. */
  node?: Maybe<Container>;
};

/** Methods to use when ordering `Container`. */
export enum ContainersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  ContainerDescriptionAsc = 'CONTAINER_DESCRIPTION_ASC',
  ContainerDescriptionDesc = 'CONTAINER_DESCRIPTION_DESC',
  ReleaseDateAsc = 'RELEASE_DATE_ASC',
  ReleaseDateDesc = 'RELEASE_DATE_DESC',
  ReleaseConfirmedAsc = 'RELEASE_CONFIRMED_ASC',
  ReleaseConfirmedDesc = 'RELEASE_CONFIRMED_DESC',
  DischargeDateAsc = 'DISCHARGE_DATE_ASC',
  DischargeDateDesc = 'DISCHARGE_DATE_DESC',
  DischargeConfirmedAsc = 'DISCHARGE_CONFIRMED_ASC',
  DischargeConfirmedDesc = 'DISCHARGE_CONFIRMED_DESC',
  Notes1Asc = 'NOTES1_ASC',
  Notes1Desc = 'NOTES1_DESC',
  Notes2Asc = 'NOTES2_ASC',
  Notes2Desc = 'NOTES2_DESC',
  Notes3Asc = 'NOTES3_ASC',
  Notes3Desc = 'NOTES3_DESC',
  SentConfirmedAsc = 'SENT_CONFIRMED_ASC',
  SentConfirmedDesc = 'SENT_CONFIRMED_DESC',
  IsAvailableAsc = 'IS_AVAILABLE_ASC',
  IsAvailableDesc = 'IS_AVAILABLE_DESC',
  IsNewAsc = 'IS_NEW_ASC',
  IsNewDesc = 'IS_NEW_DESC',
  IsScheduleAsc = 'IS_SCHEDULE_ASC',
  IsScheduleDesc = 'IS_SCHEDULE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ContainerTreatmentsByContainerIdCountAsc = 'CONTAINER_TREATMENTS_BY_CONTAINER_ID__COUNT_ASC',
  ContainerTreatmentsByContainerIdCountDesc = 'CONTAINER_TREATMENTS_BY_CONTAINER_ID__COUNT_DESC'
}

/** A connection to a list of `Country` values. */
export type CountriesConnection = {
  __typename?: 'CountriesConnection';
  /** A list of `Country` objects. */
  nodes: Array<Maybe<Country>>;
  /** A list of edges which contains the `Country` and cursor to aid in pagination. */
  edges: Array<CountriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Country` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Country` edge in the connection. */
export type CountriesEdge = {
  __typename?: 'CountriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Country` at the end of the edge. */
  node?: Maybe<Country>;
};

/** Methods to use when ordering `Country`. */
export enum CountriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CountryNameAsc = 'COUNTRY_NAME_ASC',
  CountryNameDesc = 'COUNTRY_NAME_DESC',
  CmbIdAsc = 'CMB_ID_ASC',
  CmbIdDesc = 'CMB_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShippersByCountryIdCountAsc = 'SHIPPERS_BY_COUNTRY_ID__COUNT_ASC',
  ShippersByCountryIdCountDesc = 'SHIPPERS_BY_COUNTRY_ID__COUNT_DESC',
  WarehousesByCountryIdCountAsc = 'WAREHOUSES_BY_COUNTRY_ID__COUNT_ASC',
  WarehousesByCountryIdCountDesc = 'WAREHOUSES_BY_COUNTRY_ID__COUNT_DESC'
}

export type Country = Node & {
  __typename?: 'Country';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  countryName: Scalars['String'];
  cmbId?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippers: ShippersConnection;
  /** Reads and enables pagination through a set of `Warehouse`. */
  warehouses: WarehousesConnection;
  searchText?: Maybe<Scalars['String']>;
};


export type CountryShippersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CountryWarehousesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
  condition?: Maybe<WarehouseCondition>;
  filter?: Maybe<WarehouseFilter>;
};

/** A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CountryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryName` field. */
  countryName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cmbId` field. */
  cmbId?: Maybe<Scalars['String']>;
};

/** The fields on `country` to look up the row to connect. */
export type CountryCountryPkeyConnect = {
  id: Scalars['String'];
};

/** The fields on `country` to look up the row to delete. */
export type CountryCountryPkeyDelete = {
  id: Scalars['String'];
};

/** A filter to be used against `Country` object types. All fields are combined with a logical ‘and.’ */
export type CountryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `countryName` field. */
  countryName?: Maybe<StringFilter>;
  /** Filter by the object’s `cmbId` field. */
  cmbId?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shippers` relation. */
  shippers?: Maybe<CountryToManyShipperFilter>;
  /** Some related `shippers` exist. */
  shippersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `warehouses` relation. */
  warehouses?: Maybe<CountryToManyWarehouseFilter>;
  /** Some related `warehouses` exist. */
  warehousesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CountryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CountryFilter>>;
  /** Negates the expression. */
  not?: Maybe<CountryFilter>;
};

/** An input for mutations affecting `Country` */
export type CountryInput = {
  id: Scalars['String'];
  countryName: Scalars['String'];
  cmbId?: Maybe<Scalars['String']>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CountryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CountryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnShipperForShipperCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnShipperForShipperCountryIdFkeyUsingCountryPkeyUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnShipperForShipperCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehouse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: WarehousePatch;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnWarehouseForWarehouseCountryIdFkeyUsingCountryPkeyUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnWarehouseForWarehouseCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** Represents an update to a `Country`. Fields that are set will be updated. */
export type CountryPatch = {
  id?: Maybe<Scalars['String']>;
  countryName?: Maybe<Scalars['String']>;
  cmbId?: Maybe<Scalars['String']>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** A filter to be used against many `Shipper` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyShipperFilter = {
  /** Every related `Shipper` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperFilter>;
  /** Some related `Shipper` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperFilter>;
  /** No related `Shipper` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperFilter>;
};

/** A filter to be used against many `Warehouse` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyWarehouseFilter = {
  /** Every related `Warehouse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WarehouseFilter>;
  /** Some related `Warehouse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WarehouseFilter>;
  /** No related `Warehouse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WarehouseFilter>;
};

/** All input for the create `AgendaItem` mutation. */
export type CreateAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` to be created by this mutation. */
  agendaItem: AgendaItemInput;
};

/** The output of our create `AgendaItem` mutation. */
export type CreateAgendaItemPayload = {
  __typename?: 'CreateAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` that was created by this mutation. */
  agendaItem?: Maybe<AgendaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AgendaItem`. May be used by Relay 1. */
  agendaItemEdge?: Maybe<AgendaItemsEdge>;
};


/** The output of our create `AgendaItem` mutation. */
export type CreateAgendaItemPayloadAgendaItemEdgeArgs = {
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
};

/** All input for the create `CalendarEvent` mutation. */
export type CreateCalendarEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` to be created by this mutation. */
  calendarEvent: CalendarEventInput;
};

/** The output of our create `CalendarEvent` mutation. */
export type CreateCalendarEventPayload = {
  __typename?: 'CreateCalendarEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` that was created by this mutation. */
  calendarEvent?: Maybe<CalendarEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CalendarEvent`. May be used by Relay 1. */
  calendarEventEdge?: Maybe<CalendarEventsEdge>;
};


/** The output of our create `CalendarEvent` mutation. */
export type CreateCalendarEventPayloadCalendarEventEdgeArgs = {
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
};

/** All input for the create `CheckHeader` mutation. */
export type CreateCheckHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CheckHeader` to be created by this mutation. */
  checkHeader: CheckHeaderInput;
};

/** The output of our create `CheckHeader` mutation. */
export type CreateCheckHeaderPayload = {
  __typename?: 'CreateCheckHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CheckHeader` that was created by this mutation. */
  checkHeader?: Maybe<CheckHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CheckHeader`. May be used by Relay 1. */
  checkHeaderEdge?: Maybe<CheckHeadersEdge>;
};


/** The output of our create `CheckHeader` mutation. */
export type CreateCheckHeaderPayloadCheckHeaderEdgeArgs = {
  orderBy?: Maybe<Array<CheckHeadersOrderBy>>;
};

/** All input for the create `ChileDepartureInspectionPallet` mutation. */
export type CreateChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` to be created by this mutation. */
  chileDepartureInspectionPallet: ChileDepartureInspectionPalletInput;
};

/** The output of our create `ChileDepartureInspectionPallet` mutation. */
export type CreateChileDepartureInspectionPalletPayload = {
  __typename?: 'CreateChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` that was created by this mutation. */
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ChileDepartureInspectionPallet`. May be used by Relay 1. */
  chileDepartureInspectionPalletEdge?: Maybe<ChileDepartureInspectionPalletsEdge>;
};


/** The output of our create `ChileDepartureInspectionPallet` mutation. */
export type CreateChileDepartureInspectionPalletPayloadChileDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
};

/** All input for the create `CommonCategory` mutation. */
export type CreateCommonCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonCategory` to be created by this mutation. */
  commonCategory: CommonCategoryInput;
};

/** The output of our create `CommonCategory` mutation. */
export type CreateCommonCategoryPayload = {
  __typename?: 'CreateCommonCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonCategory` that was created by this mutation. */
  commonCategory?: Maybe<CommonCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CommonCategory`. May be used by Relay 1. */
  commonCategoryEdge?: Maybe<CommonCategoriesEdge>;
};


/** The output of our create `CommonCategory` mutation. */
export type CreateCommonCategoryPayloadCommonCategoryEdgeArgs = {
  orderBy?: Maybe<Array<CommonCategoriesOrderBy>>;
};

/** All input for the create `CommonPackType` mutation. */
export type CreateCommonPackTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackType` to be created by this mutation. */
  commonPackType: CommonPackTypeInput;
};

/** All input for the create `CommonPackTypePackMaster` mutation. */
export type CreateCommonPackTypePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypePackMaster` to be created by this mutation. */
  commonPackTypePackMaster: CommonPackTypePackMasterInput;
};

/** The output of our create `CommonPackTypePackMaster` mutation. */
export type CreateCommonPackTypePackMasterPayload = {
  __typename?: 'CreateCommonPackTypePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypePackMaster` that was created by this mutation. */
  commonPackTypePackMaster?: Maybe<CommonPackTypePackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypePackMaster`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `PackMaster` that is related to this `CommonPackTypePackMaster`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackTypePackMaster`. May be used by Relay 1. */
  commonPackTypePackMasterEdge?: Maybe<CommonPackTypePackMastersEdge>;
};


/** The output of our create `CommonPackTypePackMaster` mutation. */
export type CreateCommonPackTypePackMasterPayloadCommonPackTypePackMasterEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
};

/** The output of our create `CommonPackType` mutation. */
export type CreateCommonPackTypePayload = {
  __typename?: 'CreateCommonPackTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackType` that was created by this mutation. */
  commonPackType?: Maybe<CommonPackType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonPackType`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `PackMaster` that is related to this `CommonPackType`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackType`. May be used by Relay 1. */
  commonPackTypeEdge?: Maybe<CommonPackTypesEdge>;
};


/** The output of our create `CommonPackType` mutation. */
export type CreateCommonPackTypePayloadCommonPackTypeEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
};

/** All input for the create `CommonPackTypeTag` mutation. */
export type CreateCommonPackTypeTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypeTag` to be created by this mutation. */
  commonPackTypeTag: CommonPackTypeTagInput;
};

/** The output of our create `CommonPackTypeTag` mutation. */
export type CreateCommonPackTypeTagPayload = {
  __typename?: 'CreateCommonPackTypeTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypeTag` that was created by this mutation. */
  commonPackTypeTag?: Maybe<CommonPackTypeTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypeTag`. */
  commonPackType?: Maybe<CommonPackType>;
  /** An edge for our `CommonPackTypeTag`. May be used by Relay 1. */
  commonPackTypeTagEdge?: Maybe<CommonPackTypeTagsEdge>;
};


/** The output of our create `CommonPackTypeTag` mutation. */
export type CreateCommonPackTypeTagPayloadCommonPackTypeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypeTagsOrderBy>>;
};

/** All input for the create `CommonSize` mutation. */
export type CreateCommonSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSize` to be created by this mutation. */
  commonSize: CommonSizeInput;
};

/** The output of our create `CommonSize` mutation. */
export type CreateCommonSizePayload = {
  __typename?: 'CreateCommonSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSize` that was created by this mutation. */
  commonSize?: Maybe<CommonSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSize`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSize` that is related to this `CommonSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSize`. May be used by Relay 1. */
  commonSizeEdge?: Maybe<CommonSizesEdge>;
};


/** The output of our create `CommonSize` mutation. */
export type CreateCommonSizePayloadCommonSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
};

/** All input for the create `CommonSizeProductSize` mutation. */
export type CreateCommonSizeProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeProductSize` to be created by this mutation. */
  commonSizeProductSize: CommonSizeProductSizeInput;
};

/** The output of our create `CommonSizeProductSize` mutation. */
export type CreateCommonSizeProductSizePayload = {
  __typename?: 'CreateCommonSizeProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeProductSize` that was created by this mutation. */
  commonSizeProductSize?: Maybe<CommonSizeProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeProductSize`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `ProductSize` that is related to this `CommonSizeProductSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSizeProductSize`. May be used by Relay 1. */
  commonSizeProductSizeEdge?: Maybe<CommonSizeProductSizesEdge>;
};


/** The output of our create `CommonSizeProductSize` mutation. */
export type CreateCommonSizeProductSizePayloadCommonSizeProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
};

/** All input for the create `CommonSizeTag` mutation. */
export type CreateCommonSizeTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeTag` to be created by this mutation. */
  commonSizeTag: CommonSizeTagInput;
};

/** The output of our create `CommonSizeTag` mutation. */
export type CreateCommonSizeTagPayload = {
  __typename?: 'CreateCommonSizeTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeTag` that was created by this mutation. */
  commonSizeTag?: Maybe<CommonSizeTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeTag`. */
  commonSize?: Maybe<CommonSize>;
  /** An edge for our `CommonSizeTag`. May be used by Relay 1. */
  commonSizeTagEdge?: Maybe<CommonSizeTagsEdge>;
};


/** The output of our create `CommonSizeTag` mutation. */
export type CreateCommonSizeTagPayloadCommonSizeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeTagsOrderBy>>;
};

/** All input for the create `CommonSpecies` mutation. */
export type CreateCommonSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpecies` to be created by this mutation. */
  commonSpecies: CommonSpeciesInput;
};

/** The output of our create `CommonSpecies` mutation. */
export type CreateCommonSpeciesPayload = {
  __typename?: 'CreateCommonSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpecies` that was created by this mutation. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonCategory` that is related to this `CommonSpecies`. */
  commonCategory?: Maybe<CommonCategory>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpecies`. May be used by Relay 1. */
  commonSpeciesEdge?: Maybe<CommonSpeciesEdge>;
};


/** The output of our create `CommonSpecies` mutation. */
export type CreateCommonSpeciesPayloadCommonSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
};

/** All input for the create `CommonSpeciesProductSpecies` mutation. */
export type CreateCommonSpeciesProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesProductSpecies` to be created by this mutation. */
  commonSpeciesProductSpecies: CommonSpeciesProductSpeciesInput;
};

/** The output of our create `CommonSpeciesProductSpecies` mutation. */
export type CreateCommonSpeciesProductSpeciesPayload = {
  __typename?: 'CreateCommonSpeciesProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesProductSpecies` that was created by this mutation. */
  commonSpeciesProductSpecies?: Maybe<CommonSpeciesProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpeciesProductSpecies`. May be used by Relay 1. */
  commonSpeciesProductSpeciesEdge?: Maybe<CommonSpeciesProductSpeciesEdge>;
};


/** The output of our create `CommonSpeciesProductSpecies` mutation. */
export type CreateCommonSpeciesProductSpeciesPayloadCommonSpeciesProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
};

/** All input for the create `CommonSpeciesTag` mutation. */
export type CreateCommonSpeciesTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesTag` to be created by this mutation. */
  commonSpeciesTag: CommonSpeciesTagInput;
};

/** The output of our create `CommonSpeciesTag` mutation. */
export type CreateCommonSpeciesTagPayload = {
  __typename?: 'CreateCommonSpeciesTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesTag` that was created by this mutation. */
  commonSpeciesTag?: Maybe<CommonSpeciesTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesTag`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** An edge for our `CommonSpeciesTag`. May be used by Relay 1. */
  commonSpeciesTagEdge?: Maybe<CommonSpeciesTagsEdge>;
};


/** The output of our create `CommonSpeciesTag` mutation. */
export type CreateCommonSpeciesTagPayloadCommonSpeciesTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesTagsOrderBy>>;
};

/** All input for the create `CommonVariety` mutation. */
export type CreateCommonVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVariety` to be created by this mutation. */
  commonVariety: CommonVarietyInput;
};

/** The output of our create `CommonVariety` mutation. */
export type CreateCommonVarietyPayload = {
  __typename?: 'CreateCommonVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVariety` that was created by this mutation. */
  commonVariety?: Maybe<CommonVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonVariety`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductVariety` that is related to this `CommonVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVariety`. May be used by Relay 1. */
  commonVarietyEdge?: Maybe<CommonVarietiesEdge>;
};


/** The output of our create `CommonVariety` mutation. */
export type CreateCommonVarietyPayloadCommonVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
};

/** All input for the create `CommonVarietyProductVariety` mutation. */
export type CreateCommonVarietyProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyProductVariety` to be created by this mutation. */
  commonVarietyProductVariety: CommonVarietyProductVarietyInput;
};

/** The output of our create `CommonVarietyProductVariety` mutation. */
export type CreateCommonVarietyProductVarietyPayload = {
  __typename?: 'CreateCommonVarietyProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyProductVariety` that was created by this mutation. */
  commonVarietyProductVariety?: Maybe<CommonVarietyProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyProductVariety`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `ProductVariety` that is related to this `CommonVarietyProductVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVarietyProductVariety`. May be used by Relay 1. */
  commonVarietyProductVarietyEdge?: Maybe<CommonVarietyProductVarietiesEdge>;
};


/** The output of our create `CommonVarietyProductVariety` mutation. */
export type CreateCommonVarietyProductVarietyPayloadCommonVarietyProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
};

/** All input for the create `CommonVarietyTag` mutation. */
export type CreateCommonVarietyTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyTag` to be created by this mutation. */
  commonVarietyTag: CommonVarietyTagInput;
};

/** The output of our create `CommonVarietyTag` mutation. */
export type CreateCommonVarietyTagPayload = {
  __typename?: 'CreateCommonVarietyTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyTag` that was created by this mutation. */
  commonVarietyTag?: Maybe<CommonVarietyTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyTag`. */
  commonVariety?: Maybe<CommonVariety>;
  /** An edge for our `CommonVarietyTag`. May be used by Relay 1. */
  commonVarietyTagEdge?: Maybe<CommonVarietyTagsEdge>;
};


/** The output of our create `CommonVarietyTag` mutation. */
export type CreateCommonVarietyTagPayloadCommonVarietyTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyTagsOrderBy>>;
};

/** All input for the create `ContactGroup` mutation. */
export type CreateContactGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` to be created by this mutation. */
  contactGroup: ContactGroupInput;
};

/** The output of our create `ContactGroup` mutation. */
export type CreateContactGroupPayload = {
  __typename?: 'CreateContactGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` that was created by this mutation. */
  contactGroup?: Maybe<ContactGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** An edge for our `ContactGroup`. May be used by Relay 1. */
  contactGroupEdge?: Maybe<ContactGroupsEdge>;
};


/** The output of our create `ContactGroup` mutation. */
export type CreateContactGroupPayloadContactGroupEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
};

/** All input for the create `ContactGroupPersonContact` mutation. */
export type CreateContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` to be created by this mutation. */
  contactGroupPersonContact: ContactGroupPersonContactInput;
};

/** The output of our create `ContactGroupPersonContact` mutation. */
export type CreateContactGroupPersonContactPayload = {
  __typename?: 'CreateContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` that was created by this mutation. */
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ContactGroupPersonContact`. May be used by Relay 1. */
  contactGroupPersonContactEdge?: Maybe<ContactGroupPersonContactsEdge>;
};


/** The output of our create `ContactGroupPersonContact` mutation. */
export type CreateContactGroupPersonContactPayloadContactGroupPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
};

/** All input for the create `Container` mutation. */
export type CreateContainerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Container` to be created by this mutation. */
  container: ContainerInput;
};

/** The output of our create `Container` mutation. */
export type CreateContainerPayload = {
  __typename?: 'CreateContainerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Container` that was created by this mutation. */
  container?: Maybe<Container>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Container`. May be used by Relay 1. */
  containerEdge?: Maybe<ContainersEdge>;
};


/** The output of our create `Container` mutation. */
export type CreateContainerPayloadContainerEdgeArgs = {
  orderBy?: Maybe<Array<ContainersOrderBy>>;
};

/** All input for the create `ContainerTreatment` mutation. */
export type CreateContainerTreatmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContainerTreatment` to be created by this mutation. */
  containerTreatment: ContainerTreatmentInput;
};

/** The output of our create `ContainerTreatment` mutation. */
export type CreateContainerTreatmentPayload = {
  __typename?: 'CreateContainerTreatmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContainerTreatment` that was created by this mutation. */
  containerTreatment?: Maybe<ContainerTreatment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Container` that is related to this `ContainerTreatment`. */
  container?: Maybe<Container>;
  /** An edge for our `ContainerTreatment`. May be used by Relay 1. */
  containerTreatmentEdge?: Maybe<ContainerTreatmentsEdge>;
};


/** The output of our create `ContainerTreatment` mutation. */
export type CreateContainerTreatmentPayloadContainerTreatmentEdgeArgs = {
  orderBy?: Maybe<Array<ContainerTreatmentsOrderBy>>;
};

/** All input for the create `Country` mutation. */
export type CreateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` to be created by this mutation. */
  country: CountryInput;
};

/** The output of our create `Country` mutation. */
export type CreateCountryPayload = {
  __typename?: 'CreateCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was created by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our create `Country` mutation. */
export type CreateCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the create `Customer` mutation. */
export type CreateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` to be created by this mutation. */
  customer: CustomerInput;
};

/** The output of our create `Customer` mutation. */
export type CreateCustomerPayload = {
  __typename?: 'CreateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was created by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our create `Customer` mutation. */
export type CreateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the create `CustomerPayment` mutation. */
export type CreateCustomerPaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPayment` to be created by this mutation. */
  customerPayment: CustomerPaymentInput;
};

/** The output of our create `CustomerPayment` mutation. */
export type CreateCustomerPaymentPayload = {
  __typename?: 'CreateCustomerPaymentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPayment` that was created by this mutation. */
  customerPayment?: Maybe<CustomerPayment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerPayment`. May be used by Relay 1. */
  customerPaymentEdge?: Maybe<CustomerPaymentsEdge>;
};


/** The output of our create `CustomerPayment` mutation. */
export type CreateCustomerPaymentPayloadCustomerPaymentEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPaymentsOrderBy>>;
};

/** All input for the create `CustomerPersonContact` mutation. */
export type CreateCustomerPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` to be created by this mutation. */
  customerPersonContact: CustomerPersonContactInput;
};

/** The output of our create `CustomerPersonContact` mutation. */
export type CreateCustomerPersonContactPayload = {
  __typename?: 'CreateCustomerPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` that was created by this mutation. */
  customerPersonContact?: Maybe<CustomerPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `CustomerPersonContact`. May be used by Relay 1. */
  customerPersonContactEdge?: Maybe<CustomerPersonContactsEdge>;
};


/** The output of our create `CustomerPersonContact` mutation. */
export type CreateCustomerPersonContactPayloadCustomerPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
};

/** All input for the create `CustomerProgramEntry` mutation. */
export type CreateCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgramEntry` to be created by this mutation. */
  customerProgramEntry: CustomerProgramEntryInput;
};

/** The output of our create `CustomerProgramEntry` mutation. */
export type CreateCustomerProgramEntryPayload = {
  __typename?: 'CreateCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgramEntry` that was created by this mutation. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgram` that is related to this `CustomerProgramEntry`. */
  customerProgram?: Maybe<CustomerProgram>;
  /** An edge for our `CustomerProgramEntry`. May be used by Relay 1. */
  customerProgramEntryEdge?: Maybe<CustomerProgramEntriesEdge>;
};


/** The output of our create `CustomerProgramEntry` mutation. */
export type CreateCustomerProgramEntryPayloadCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramEntriesOrderBy>>;
};

/** All input for the create `CustomerProgram` mutation. */
export type CreateCustomerProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgram` to be created by this mutation. */
  customerProgram: CustomerProgramInput;
};

/** The output of our create `CustomerProgram` mutation. */
export type CreateCustomerProgramPayload = {
  __typename?: 'CreateCustomerProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgram` that was created by this mutation. */
  customerProgram?: Maybe<CustomerProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CustomerProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `CustomerProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `CustomerProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `CustomerProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `CustomerProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `CustomerProgram`. May be used by Relay 1. */
  customerProgramEdge?: Maybe<CustomerProgramsEdge>;
};


/** The output of our create `CustomerProgram` mutation. */
export type CreateCustomerProgramPayloadCustomerProgramEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
};

/** All input for the create `CustomerVolumeDiscount` mutation. */
export type CreateCustomerVolumeDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerVolumeDiscount` to be created by this mutation. */
  customerVolumeDiscount: CustomerVolumeDiscountInput;
};

/** The output of our create `CustomerVolumeDiscount` mutation. */
export type CreateCustomerVolumeDiscountPayload = {
  __typename?: 'CreateCustomerVolumeDiscountPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerVolumeDiscount` that was created by this mutation. */
  customerVolumeDiscount?: Maybe<CustomerVolumeDiscount>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerVolumeDiscount`. May be used by Relay 1. */
  customerVolumeDiscountEdge?: Maybe<CustomerVolumeDiscountsEdge>;
};


/** The output of our create `CustomerVolumeDiscount` mutation. */
export type CreateCustomerVolumeDiscountPayloadCustomerVolumeDiscountEdgeArgs = {
  orderBy?: Maybe<Array<CustomerVolumeDiscountsOrderBy>>;
};

/** All input for the create `ExpenseHeader` mutation. */
export type CreateExpenseHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeader` to be created by this mutation. */
  expenseHeader: ExpenseHeaderInput;
};

/** The output of our create `ExpenseHeader` mutation. */
export type CreateExpenseHeaderPayload = {
  __typename?: 'CreateExpenseHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeader` that was created by this mutation. */
  expenseHeader?: Maybe<ExpenseHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeader`. May be used by Relay 1. */
  expenseHeaderEdge?: Maybe<ExpenseHeadersEdge>;
};


/** The output of our create `ExpenseHeader` mutation. */
export type CreateExpenseHeaderPayloadExpenseHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeadersOrderBy>>;
};

/** All input for the create `ExpenseHeaderReview` mutation. */
export type CreateExpenseHeaderReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeaderReview` to be created by this mutation. */
  expenseHeaderReview: ExpenseHeaderReviewInput;
};

/** The output of our create `ExpenseHeaderReview` mutation. */
export type CreateExpenseHeaderReviewPayload = {
  __typename?: 'CreateExpenseHeaderReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeaderReview` that was created by this mutation. */
  expenseHeaderReview?: Maybe<ExpenseHeaderReview>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeaderReview`. May be used by Relay 1. */
  expenseHeaderReviewEdge?: Maybe<ExpenseHeaderReviewsEdge>;
};


/** The output of our create `ExpenseHeaderReview` mutation. */
export type CreateExpenseHeaderReviewPayloadExpenseHeaderReviewEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeaderReviewsOrderBy>>;
};

/** All input for the create `ExpenseItem` mutation. */
export type CreateExpenseItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseItem` to be created by this mutation. */
  expenseItem: ExpenseItemInput;
};

/** The output of our create `ExpenseItem` mutation. */
export type CreateExpenseItemPayload = {
  __typename?: 'CreateExpenseItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseItem` that was created by this mutation. */
  expenseItem?: Maybe<ExpenseItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseItem`. May be used by Relay 1. */
  expenseItemEdge?: Maybe<ExpenseItemsEdge>;
};


/** The output of our create `ExpenseItem` mutation. */
export type CreateExpenseItemPayloadExpenseItemEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseItemsOrderBy>>;
};

/** All input for the create `InventoryItem` mutation. */
export type CreateInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` to be created by this mutation. */
  inventoryItem: InventoryItemInput;
};

/** The output of our create `InventoryItem` mutation. */
export type CreateInventoryItemPayload = {
  __typename?: 'CreateInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` that was created by this mutation. */
  inventoryItem?: Maybe<InventoryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InventoryItem`. May be used by Relay 1. */
  inventoryItemEdge?: Maybe<InventoryItemsEdge>;
};


/** The output of our create `InventoryItem` mutation. */
export type CreateInventoryItemPayloadInventoryItemEdgeArgs = {
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
};

/** All input for the create `InvoiceHeader` mutation. */
export type CreateInvoiceHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceHeader` to be created by this mutation. */
  invoiceHeader: InvoiceHeaderInput;
};

/** The output of our create `InvoiceHeader` mutation. */
export type CreateInvoiceHeaderPayload = {
  __typename?: 'CreateInvoiceHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceHeader` that was created by this mutation. */
  invoiceHeader?: Maybe<InvoiceHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceHeader`. May be used by Relay 1. */
  invoiceHeaderEdge?: Maybe<InvoiceHeadersEdge>;
};


/** The output of our create `InvoiceHeader` mutation. */
export type CreateInvoiceHeaderPayloadInvoiceHeaderEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceHeadersOrderBy>>;
};

/** All input for the create `InvoiceItemHistory` mutation. */
export type CreateInvoiceItemHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItemHistory` to be created by this mutation. */
  invoiceItemHistory: InvoiceItemHistoryInput;
};

/** The output of our create `InvoiceItemHistory` mutation. */
export type CreateInvoiceItemHistoryPayload = {
  __typename?: 'CreateInvoiceItemHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItemHistory` that was created by this mutation. */
  invoiceItemHistory?: Maybe<InvoiceItemHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItemHistory`. May be used by Relay 1. */
  invoiceItemHistoryEdge?: Maybe<InvoiceItemHistoriesEdge>;
};


/** The output of our create `InvoiceItemHistory` mutation. */
export type CreateInvoiceItemHistoryPayloadInvoiceItemHistoryEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemHistoriesOrderBy>>;
};

/** All input for the create `InvoiceItem` mutation. */
export type CreateInvoiceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItem` to be created by this mutation. */
  invoiceItem: InvoiceItemInput;
};

/** The output of our create `InvoiceItem` mutation. */
export type CreateInvoiceItemPayload = {
  __typename?: 'CreateInvoiceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItem` that was created by this mutation. */
  invoiceItem?: Maybe<InvoiceItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItem`. May be used by Relay 1. */
  invoiceItemEdge?: Maybe<InvoiceItemsEdge>;
};


/** The output of our create `InvoiceItem` mutation. */
export type CreateInvoiceItemPayloadInvoiceItemEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemsOrderBy>>;
};

/** All input for the create `LoadNumber` mutation. */
export type CreateLoadNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LoadNumber` to be created by this mutation. */
  loadNumber: LoadNumberInput;
};

/** The output of our create `LoadNumber` mutation. */
export type CreateLoadNumberPayload = {
  __typename?: 'CreateLoadNumberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LoadNumber` that was created by this mutation. */
  loadNumber?: Maybe<LoadNumber>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LoadNumber`. */
  user?: Maybe<User>;
  /** An edge for our `LoadNumber`. May be used by Relay 1. */
  loadNumberEdge?: Maybe<LoadNumbersEdge>;
};


/** The output of our create `LoadNumber` mutation. */
export type CreateLoadNumberPayloadLoadNumberEdgeArgs = {
  orderBy?: Maybe<Array<LoadNumbersOrderBy>>;
};

/** All input for the create `OrderComment` mutation. */
export type CreateOrderCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderComment` to be created by this mutation. */
  orderComment: OrderCommentInput;
};

/** The output of our create `OrderComment` mutation. */
export type CreateOrderCommentPayload = {
  __typename?: 'CreateOrderCommentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderComment` that was created by this mutation. */
  orderComment?: Maybe<OrderComment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderComment`. May be used by Relay 1. */
  orderCommentEdge?: Maybe<OrderCommentsEdge>;
};


/** The output of our create `OrderComment` mutation. */
export type CreateOrderCommentPayloadOrderCommentEdgeArgs = {
  orderBy?: Maybe<Array<OrderCommentsOrderBy>>;
};

/** All input for the create `OrderEntry` mutation. */
export type CreateOrderEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntry` to be created by this mutation. */
  orderEntry: OrderEntryInput;
};

/** All input for the create `OrderEntryItem` mutation. */
export type CreateOrderEntryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryItem` to be created by this mutation. */
  orderEntryItem: OrderEntryItemInput;
};

/** The output of our create `OrderEntryItem` mutation. */
export type CreateOrderEntryItemPayload = {
  __typename?: 'CreateOrderEntryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryItem` that was created by this mutation. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntry` that is related to this `OrderEntryItem`. */
  orderEntry?: Maybe<OrderEntry>;
  /** An edge for our `OrderEntryItem`. May be used by Relay 1. */
  orderEntryItemEdge?: Maybe<OrderEntryItemsEdge>;
};


/** The output of our create `OrderEntryItem` mutation. */
export type CreateOrderEntryItemPayloadOrderEntryItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryItemsOrderBy>>;
};

/** The output of our create `OrderEntry` mutation. */
export type CreateOrderEntryPayload = {
  __typename?: 'CreateOrderEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntry` that was created by this mutation. */
  orderEntry?: Maybe<OrderEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderEntry`. May be used by Relay 1. */
  orderEntryEdge?: Maybe<OrderEntriesEdge>;
};


/** The output of our create `OrderEntry` mutation. */
export type CreateOrderEntryPayloadOrderEntryEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntriesOrderBy>>;
};

/** All input for the create `OrderEntryReviewItem` mutation. */
export type CreateOrderEntryReviewItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryReviewItem` to be created by this mutation. */
  orderEntryReviewItem: OrderEntryReviewItemInput;
};

/** The output of our create `OrderEntryReviewItem` mutation. */
export type CreateOrderEntryReviewItemPayload = {
  __typename?: 'CreateOrderEntryReviewItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryReviewItem` that was created by this mutation. */
  orderEntryReviewItem?: Maybe<OrderEntryReviewItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntryItem` that is related to this `OrderEntryReviewItem`. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  /** An edge for our `OrderEntryReviewItem`. May be used by Relay 1. */
  orderEntryReviewItemEdge?: Maybe<OrderEntryReviewItemsEdge>;
};


/** The output of our create `OrderEntryReviewItem` mutation. */
export type CreateOrderEntryReviewItemPayloadOrderEntryReviewItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryReviewItemsOrderBy>>;
};

/** All input for the create `OrderItem` mutation. */
export type CreateOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderItem` to be created by this mutation. */
  orderItem: OrderItemInput;
};

/** The output of our create `OrderItem` mutation. */
export type CreateOrderItemPayload = {
  __typename?: 'CreateOrderItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderItem` that was created by this mutation. */
  orderItem?: Maybe<OrderItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderItem`. May be used by Relay 1. */
  orderItemEdge?: Maybe<OrderItemsEdge>;
};


/** The output of our create `OrderItem` mutation. */
export type CreateOrderItemPayloadOrderItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderItemsOrderBy>>;
};

/** All input for the create `OrderMaster` mutation. */
export type CreateOrderMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderMaster` to be created by this mutation. */
  orderMaster: OrderMasterInput;
};

/** The output of our create `OrderMaster` mutation. */
export type CreateOrderMasterPayload = {
  __typename?: 'CreateOrderMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderMaster` that was created by this mutation. */
  orderMaster?: Maybe<OrderMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderMaster`. May be used by Relay 1. */
  orderMasterEdge?: Maybe<OrderMastersEdge>;
};


/** The output of our create `OrderMaster` mutation. */
export type CreateOrderMasterPayloadOrderMasterEdgeArgs = {
  orderBy?: Maybe<Array<OrderMastersOrderBy>>;
};

/** All input for the create `OrderNumber` mutation. */
export type CreateOrderNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderNumber` to be created by this mutation. */
  orderNumber: OrderNumberInput;
};

/** The output of our create `OrderNumber` mutation. */
export type CreateOrderNumberPayload = {
  __typename?: 'CreateOrderNumberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderNumber` that was created by this mutation. */
  orderNumber?: Maybe<OrderNumber>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderNumber`. May be used by Relay 1. */
  orderNumberEdge?: Maybe<OrderNumbersEdge>;
};


/** The output of our create `OrderNumber` mutation. */
export type CreateOrderNumberPayloadOrderNumberEdgeArgs = {
  orderBy?: Maybe<Array<OrderNumbersOrderBy>>;
};

/** All input for the create `OrderPallet` mutation. */
export type CreateOrderPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderPallet` to be created by this mutation. */
  orderPallet: OrderPalletInput;
};

/** The output of our create `OrderPallet` mutation. */
export type CreateOrderPalletPayload = {
  __typename?: 'CreateOrderPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderPallet` that was created by this mutation. */
  orderPallet?: Maybe<OrderPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderPallet`. May be used by Relay 1. */
  orderPalletEdge?: Maybe<OrderPalletsEdge>;
};


/** The output of our create `OrderPallet` mutation. */
export type CreateOrderPalletPayloadOrderPalletEdgeArgs = {
  orderBy?: Maybe<Array<OrderPalletsOrderBy>>;
};

/** All input for the create `PackAtmosphere` mutation. */
export type CreatePackAtmosphereInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` to be created by this mutation. */
  packAtmosphere: PackAtmosphereInput;
};

/** The output of our create `PackAtmosphere` mutation. */
export type CreatePackAtmospherePayload = {
  __typename?: 'CreatePackAtmospherePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` that was created by this mutation. */
  packAtmosphere?: Maybe<PackAtmosphere>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackAtmosphere`. May be used by Relay 1. */
  packAtmosphereEdge?: Maybe<PackAtmospheresEdge>;
};


/** The output of our create `PackAtmosphere` mutation. */
export type CreatePackAtmospherePayloadPackAtmosphereEdgeArgs = {
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
};

/** All input for the create `PackBoxStyle` mutation. */
export type CreatePackBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` to be created by this mutation. */
  packBoxStyle: PackBoxStyleInput;
};

/** The output of our create `PackBoxStyle` mutation. */
export type CreatePackBoxStylePayload = {
  __typename?: 'CreatePackBoxStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` that was created by this mutation. */
  packBoxStyle?: Maybe<PackBoxStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxStyle`. May be used by Relay 1. */
  packBoxStyleEdge?: Maybe<PackBoxStylesEdge>;
};


/** The output of our create `PackBoxStyle` mutation. */
export type CreatePackBoxStylePayloadPackBoxStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
};

/** All input for the create `PackBoxType` mutation. */
export type CreatePackBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` to be created by this mutation. */
  packBoxType: PackBoxTypeInput;
};

/** The output of our create `PackBoxType` mutation. */
export type CreatePackBoxTypePayload = {
  __typename?: 'CreatePackBoxTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` that was created by this mutation. */
  packBoxType?: Maybe<PackBoxType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxType`. May be used by Relay 1. */
  packBoxTypeEdge?: Maybe<PackBoxTypesEdge>;
};


/** The output of our create `PackBoxType` mutation. */
export type CreatePackBoxTypePayloadPackBoxTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
};

/** All input for the create `PackDestination` mutation. */
export type CreatePackDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` to be created by this mutation. */
  packDestination: PackDestinationInput;
};

/** The output of our create `PackDestination` mutation. */
export type CreatePackDestinationPayload = {
  __typename?: 'CreatePackDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` that was created by this mutation. */
  packDestination?: Maybe<PackDestination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackDestination`. May be used by Relay 1. */
  packDestinationEdge?: Maybe<PackDestinationsEdge>;
};


/** The output of our create `PackDestination` mutation. */
export type CreatePackDestinationPayloadPackDestinationEdgeArgs = {
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
};

/** All input for the create `PackGrade` mutation. */
export type CreatePackGradeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` to be created by this mutation. */
  packGrade: PackGradeInput;
};

/** The output of our create `PackGrade` mutation. */
export type CreatePackGradePayload = {
  __typename?: 'CreatePackGradePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` that was created by this mutation. */
  packGrade?: Maybe<PackGrade>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackGrade`. May be used by Relay 1. */
  packGradeEdge?: Maybe<PackGradesEdge>;
};


/** The output of our create `PackGrade` mutation. */
export type CreatePackGradePayloadPackGradeEdgeArgs = {
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
};

/** All input for the create `PackHold` mutation. */
export type CreatePackHoldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` to be created by this mutation. */
  packHold: PackHoldInput;
};

/** The output of our create `PackHold` mutation. */
export type CreatePackHoldPayload = {
  __typename?: 'CreatePackHoldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` that was created by this mutation. */
  packHold?: Maybe<PackHold>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackHold`. May be used by Relay 1. */
  packHoldEdge?: Maybe<PackHoldsEdge>;
};


/** The output of our create `PackHold` mutation. */
export type CreatePackHoldPayloadPackHoldEdgeArgs = {
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
};

/** All input for the create `PackLabel` mutation. */
export type CreatePackLabelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` to be created by this mutation. */
  packLabel: PackLabelInput;
};

/** The output of our create `PackLabel` mutation. */
export type CreatePackLabelPayload = {
  __typename?: 'CreatePackLabelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` that was created by this mutation. */
  packLabel?: Maybe<PackLabel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLabel`. May be used by Relay 1. */
  packLabelEdge?: Maybe<PackLabelsEdge>;
};


/** The output of our create `PackLabel` mutation. */
export type CreatePackLabelPayloadPackLabelEdgeArgs = {
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
};

/** All input for the create `PackLiner` mutation. */
export type CreatePackLinerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` to be created by this mutation. */
  packLiner: PackLinerInput;
};

/** The output of our create `PackLiner` mutation. */
export type CreatePackLinerPayload = {
  __typename?: 'CreatePackLinerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` that was created by this mutation. */
  packLiner?: Maybe<PackLiner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLiner`. May be used by Relay 1. */
  packLinerEdge?: Maybe<PackLinersEdge>;
};


/** The output of our create `PackLiner` mutation. */
export type CreatePackLinerPayloadPackLinerEdgeArgs = {
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
};

/** All input for the create `PackMaster` mutation. */
export type CreatePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` to be created by this mutation. */
  packMaster: PackMasterInput;
};

/** The output of our create `PackMaster` mutation. */
export type CreatePackMasterPayload = {
  __typename?: 'CreatePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` that was created by this mutation. */
  packMaster?: Maybe<PackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackMaster`. May be used by Relay 1. */
  packMasterEdge?: Maybe<PackMastersEdge>;
};


/** The output of our create `PackMaster` mutation. */
export type CreatePackMasterPayloadPackMasterEdgeArgs = {
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
};

/** All input for the create `PackOut` mutation. */
export type CreatePackOutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` to be created by this mutation. */
  packOut: PackOutInput;
};

/** The output of our create `PackOut` mutation. */
export type CreatePackOutPayload = {
  __typename?: 'CreatePackOutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` that was created by this mutation. */
  packOut?: Maybe<PackOut>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackOut`. May be used by Relay 1. */
  packOutEdge?: Maybe<PackOutsEdge>;
};


/** The output of our create `PackOut` mutation. */
export type CreatePackOutPayloadPackOutEdgeArgs = {
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
};

/** All input for the create `PackPalletType` mutation. */
export type CreatePackPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` to be created by this mutation. */
  packPalletType: PackPalletTypeInput;
};

/** The output of our create `PackPalletType` mutation. */
export type CreatePackPalletTypePayload = {
  __typename?: 'CreatePackPalletTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` that was created by this mutation. */
  packPalletType?: Maybe<PackPalletType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackPalletType`. May be used by Relay 1. */
  packPalletTypeEdge?: Maybe<PackPalletTypesEdge>;
};


/** The output of our create `PackPalletType` mutation. */
export type CreatePackPalletTypePayloadPackPalletTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
};

/** All input for the create `PackProduction` mutation. */
export type CreatePackProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` to be created by this mutation. */
  packProduction: PackProductionInput;
};

/** The output of our create `PackProduction` mutation. */
export type CreatePackProductionPayload = {
  __typename?: 'CreatePackProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` that was created by this mutation. */
  packProduction?: Maybe<PackProduction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackProduction`. May be used by Relay 1. */
  packProductionEdge?: Maybe<PackProductionsEdge>;
};


/** The output of our create `PackProduction` mutation. */
export type CreatePackProductionPayloadPackProductionEdgeArgs = {
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
};

/** All input for the create `PackSpecial` mutation. */
export type CreatePackSpecialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` to be created by this mutation. */
  packSpecial: PackSpecialInput;
};

/** The output of our create `PackSpecial` mutation. */
export type CreatePackSpecialPayload = {
  __typename?: 'CreatePackSpecialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` that was created by this mutation. */
  packSpecial?: Maybe<PackSpecial>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackSpecial`. May be used by Relay 1. */
  packSpecialEdge?: Maybe<PackSpecialsEdge>;
};


/** The output of our create `PackSpecial` mutation. */
export type CreatePackSpecialPayloadPackSpecialEdgeArgs = {
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
};

/** All input for the create `PackStyle` mutation. */
export type CreatePackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` to be created by this mutation. */
  packStyle: PackStyleInput;
};

/** The output of our create `PackStyle` mutation. */
export type CreatePackStylePayload = {
  __typename?: 'CreatePackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` that was created by this mutation. */
  packStyle?: Maybe<PackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackStyle`. May be used by Relay 1. */
  packStyleEdge?: Maybe<PackStylesEdge>;
};


/** The output of our create `PackStyle` mutation. */
export type CreatePackStylePayloadPackStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
};

/** All input for the create `PackTreeRipe` mutation. */
export type CreatePackTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` to be created by this mutation. */
  packTreeRipe: PackTreeRipeInput;
};

/** The output of our create `PackTreeRipe` mutation. */
export type CreatePackTreeRipePayload = {
  __typename?: 'CreatePackTreeRipePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` that was created by this mutation. */
  packTreeRipe?: Maybe<PackTreeRipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackTreeRipe`. May be used by Relay 1. */
  packTreeRipeEdge?: Maybe<PackTreeRipesEdge>;
};


/** The output of our create `PackTreeRipe` mutation. */
export type CreatePackTreeRipePayloadPackTreeRipeEdgeArgs = {
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
};

/** All input for the create `Pallet` mutation. */
export type CreatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` to be created by this mutation. */
  pallet: PalletInput;
};

/** The output of our create `Pallet` mutation. */
export type CreatePalletPayload = {
  __typename?: 'CreatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` that was created by this mutation. */
  pallet?: Maybe<Pallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Pallet`. May be used by Relay 1. */
  palletEdge?: Maybe<PalletsEdge>;
};


/** The output of our create `Pallet` mutation. */
export type CreatePalletPayloadPalletEdgeArgs = {
  orderBy?: Maybe<Array<PalletsOrderBy>>;
};

/** All input for the create `PalletSection` mutation. */
export type CreatePalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` to be created by this mutation. */
  palletSection: PalletSectionInput;
};

/** The output of our create `PalletSection` mutation. */
export type CreatePalletSectionPayload = {
  __typename?: 'CreatePalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` that was created by this mutation. */
  palletSection?: Maybe<PalletSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletSection`. May be used by Relay 1. */
  palletSectionEdge?: Maybe<PalletSectionsEdge>;
};


/** The output of our create `PalletSection` mutation. */
export type CreatePalletSectionPayloadPalletSectionEdgeArgs = {
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
};

/** All input for the create `PersonContact` mutation. */
export type CreatePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` to be created by this mutation. */
  personContact: PersonContactInput;
};

/** The output of our create `PersonContact` mutation. */
export type CreatePersonContactPayload = {
  __typename?: 'CreatePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` that was created by this mutation. */
  personContact?: Maybe<PersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PersonContact`. May be used by Relay 1. */
  personContactEdge?: Maybe<PersonContactsEdge>;
};


/** The output of our create `PersonContact` mutation. */
export type CreatePersonContactPayloadPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
};

/** All input for the create `PeruDepartureInspection` mutation. */
export type CreatePeruDepartureInspectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` to be created by this mutation. */
  peruDepartureInspection: PeruDepartureInspectionInput;
};

/** All input for the create `PeruDepartureInspectionPallet` mutation. */
export type CreatePeruDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` to be created by this mutation. */
  peruDepartureInspectionPallet: PeruDepartureInspectionPalletInput;
};

/** The output of our create `PeruDepartureInspectionPallet` mutation. */
export type CreatePeruDepartureInspectionPalletPayload = {
  __typename?: 'CreatePeruDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` that was created by this mutation. */
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
  /** An edge for our `PeruDepartureInspectionPallet`. May be used by Relay 1. */
  peruDepartureInspectionPalletEdge?: Maybe<PeruDepartureInspectionPalletsEdge>;
};


/** The output of our create `PeruDepartureInspectionPallet` mutation. */
export type CreatePeruDepartureInspectionPalletPayloadPeruDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
};

/** The output of our create `PeruDepartureInspection` mutation. */
export type CreatePeruDepartureInspectionPayload = {
  __typename?: 'CreatePeruDepartureInspectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` that was created by this mutation. */
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PeruDepartureInspection`. May be used by Relay 1. */
  peruDepartureInspectionEdge?: Maybe<PeruDepartureInspectionsEdge>;
};


/** The output of our create `PeruDepartureInspection` mutation. */
export type CreatePeruDepartureInspectionPayloadPeruDepartureInspectionEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
};

/** All input for the create `PriceCategory` mutation. */
export type CreatePriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` to be created by this mutation. */
  priceCategory: PriceCategoryInput;
};

/** The output of our create `PriceCategory` mutation. */
export type CreatePriceCategoryPayload = {
  __typename?: 'CreatePriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` that was created by this mutation. */
  priceCategory?: Maybe<PriceCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PriceCategory`. May be used by Relay 1. */
  priceCategoryEdge?: Maybe<PriceCategoriesEdge>;
};


/** The output of our create `PriceCategory` mutation. */
export type CreatePriceCategoryPayloadPriceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
};

/** All input for the create `PriceEntry` mutation. */
export type CreatePriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` to be created by this mutation. */
  priceEntry: PriceEntryInput;
};

/** The output of our create `PriceEntry` mutation. */
export type CreatePriceEntryPayload = {
  __typename?: 'CreatePriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` that was created by this mutation. */
  priceEntry?: Maybe<PriceEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
  /** An edge for our `PriceEntry`. May be used by Relay 1. */
  priceEntryEdge?: Maybe<PriceEntriesEdge>;
};


/** The output of our create `PriceEntry` mutation. */
export type CreatePriceEntryPayloadPriceEntryEdgeArgs = {
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
};

/** All input for the create `PriceProduct` mutation. */
export type CreatePriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` to be created by this mutation. */
  priceProduct: PriceProductInput;
};

/** The output of our create `PriceProduct` mutation. */
export type CreatePriceProductPayload = {
  __typename?: 'CreatePriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` that was created by this mutation. */
  priceProduct?: Maybe<PriceProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** An edge for our `PriceProduct`. May be used by Relay 1. */
  priceProductEdge?: Maybe<PriceProductsEdge>;
};


/** The output of our create `PriceProduct` mutation. */
export type CreatePriceProductPayloadPriceProductEdgeArgs = {
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
};

/** All input for the create `PriceSize` mutation. */
export type CreatePriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` to be created by this mutation. */
  priceSize: PriceSizeInput;
};

/** The output of our create `PriceSize` mutation. */
export type CreatePriceSizePayload = {
  __typename?: 'CreatePriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` that was created by this mutation. */
  priceSize?: Maybe<PriceSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** An edge for our `PriceSize`. May be used by Relay 1. */
  priceSizeEdge?: Maybe<PriceSizesEdge>;
};


/** The output of our create `PriceSize` mutation. */
export type CreatePriceSizePayloadPriceSizeEdgeArgs = {
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
};

/** All input for the create `ProductMaster` mutation. */
export type CreateProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` to be created by this mutation. */
  productMaster: ProductMasterInput;
};

/** The output of our create `ProductMaster` mutation. */
export type CreateProductMasterPayload = {
  __typename?: 'CreateProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` that was created by this mutation. */
  productMaster?: Maybe<ProductMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductMaster`. May be used by Relay 1. */
  productMasterEdge?: Maybe<ProductMastersEdge>;
};


/** The output of our create `ProductMaster` mutation. */
export type CreateProductMasterPayloadProductMasterEdgeArgs = {
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
};

/** All input for the create `ProductSize` mutation. */
export type CreateProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` to be created by this mutation. */
  productSize: ProductSizeInput;
};

/** The output of our create `ProductSize` mutation. */
export type CreateProductSizePayload = {
  __typename?: 'CreateProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` that was created by this mutation. */
  productSize?: Maybe<ProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSize`. May be used by Relay 1. */
  productSizeEdge?: Maybe<ProductSizesEdge>;
};


/** The output of our create `ProductSize` mutation. */
export type CreateProductSizePayloadProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
};

/** All input for the create `ProductSpecies` mutation. */
export type CreateProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` to be created by this mutation. */
  productSpecies: ProductSpeciesInput;
};

/** The output of our create `ProductSpecies` mutation. */
export type CreateProductSpeciesPayload = {
  __typename?: 'CreateProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` that was created by this mutation. */
  productSpecies?: Maybe<ProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSpecies`. May be used by Relay 1. */
  productSpeciesEdge?: Maybe<ProductSpeciesEdge>;
};


/** The output of our create `ProductSpecies` mutation. */
export type CreateProductSpeciesPayloadProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
};

/** All input for the create `ProductVariety` mutation. */
export type CreateProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` to be created by this mutation. */
  productVariety: ProductVarietyInput;
};

/** The output of our create `ProductVariety` mutation. */
export type CreateProductVarietyPayload = {
  __typename?: 'CreateProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` that was created by this mutation. */
  productVariety?: Maybe<ProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductVariety`. May be used by Relay 1. */
  productVarietyEdge?: Maybe<ProductVarietiesEdge>;
};


/** The output of our create `ProductVariety` mutation. */
export type CreateProductVarietyPayloadProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
};

/** All input for the create `PsaApplePallet` mutation. */
export type CreatePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` to be created by this mutation. */
  psaApplePallet: PsaApplePalletInput;
};

/** The output of our create `PsaApplePallet` mutation. */
export type CreatePsaApplePalletPayload = {
  __typename?: 'CreatePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` that was created by this mutation. */
  psaApplePallet?: Maybe<PsaApplePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaApplePallet`. May be used by Relay 1. */
  psaApplePalletEdge?: Maybe<PsaApplePalletsEdge>;
};


/** The output of our create `PsaApplePallet` mutation. */
export type CreatePsaApplePalletPayloadPsaApplePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
};

/** All input for the create `PsaArrivalPicture` mutation. */
export type CreatePsaArrivalPictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` to be created by this mutation. */
  psaArrivalPicture: PsaArrivalPictureInput;
};

/** The output of our create `PsaArrivalPicture` mutation. */
export type CreatePsaArrivalPicturePayload = {
  __typename?: 'CreatePsaArrivalPicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` that was created by this mutation. */
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalPicture`. May be used by Relay 1. */
  psaArrivalPictureEdge?: Maybe<PsaArrivalPicturesEdge>;
};


/** The output of our create `PsaArrivalPicture` mutation. */
export type CreatePsaArrivalPicturePayloadPsaArrivalPictureEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
};

/** All input for the create `PsaArrivalReport` mutation. */
export type CreatePsaArrivalReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` to be created by this mutation. */
  psaArrivalReport: PsaArrivalReportInput;
};

/** The output of our create `PsaArrivalReport` mutation. */
export type CreatePsaArrivalReportPayload = {
  __typename?: 'CreatePsaArrivalReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` that was created by this mutation. */
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalReport`. May be used by Relay 1. */
  psaArrivalReportEdge?: Maybe<PsaArrivalReportsEdge>;
};


/** The output of our create `PsaArrivalReport` mutation. */
export type CreatePsaArrivalReportPayloadPsaArrivalReportEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
};

/** All input for the create `PsaCherryPallet` mutation. */
export type CreatePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` to be created by this mutation. */
  psaCherryPallet: PsaCherryPalletInput;
};

/** The output of our create `PsaCherryPallet` mutation. */
export type CreatePsaCherryPalletPayload = {
  __typename?: 'CreatePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` that was created by this mutation. */
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCherryPallet`. May be used by Relay 1. */
  psaCherryPalletEdge?: Maybe<PsaCherryPalletsEdge>;
};


/** The output of our create `PsaCherryPallet` mutation. */
export type CreatePsaCherryPalletPayloadPsaCherryPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
};

/** All input for the create `PsaCitrusPallet` mutation. */
export type CreatePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` to be created by this mutation. */
  psaCitrusPallet: PsaCitrusPalletInput;
};

/** The output of our create `PsaCitrusPallet` mutation. */
export type CreatePsaCitrusPalletPayload = {
  __typename?: 'CreatePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` that was created by this mutation. */
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCitrusPallet`. May be used by Relay 1. */
  psaCitrusPalletEdge?: Maybe<PsaCitrusPalletsEdge>;
};


/** The output of our create `PsaCitrusPallet` mutation. */
export type CreatePsaCitrusPalletPayloadPsaCitrusPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
};

/** All input for the create `PsaGrapePallet` mutation. */
export type CreatePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` to be created by this mutation. */
  psaGrapePallet: PsaGrapePalletInput;
};

/** The output of our create `PsaGrapePallet` mutation. */
export type CreatePsaGrapePalletPayload = {
  __typename?: 'CreatePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` that was created by this mutation. */
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaGrapePallet`. May be used by Relay 1. */
  psaGrapePalletEdge?: Maybe<PsaGrapePalletsEdge>;
};


/** The output of our create `PsaGrapePallet` mutation. */
export type CreatePsaGrapePalletPayloadPsaGrapePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
};

/** All input for the create `PsaLemonPallet` mutation. */
export type CreatePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` to be created by this mutation. */
  psaLemonPallet: PsaLemonPalletInput;
};

/** The output of our create `PsaLemonPallet` mutation. */
export type CreatePsaLemonPalletPayload = {
  __typename?: 'CreatePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` that was created by this mutation. */
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaLemonPallet`. May be used by Relay 1. */
  psaLemonPalletEdge?: Maybe<PsaLemonPalletsEdge>;
};


/** The output of our create `PsaLemonPallet` mutation. */
export type CreatePsaLemonPalletPayloadPsaLemonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
};

/** All input for the create `PsaPearPallet` mutation. */
export type CreatePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` to be created by this mutation. */
  psaPearPallet: PsaPearPalletInput;
};

/** The output of our create `PsaPearPallet` mutation. */
export type CreatePsaPearPalletPayload = {
  __typename?: 'CreatePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` that was created by this mutation. */
  psaPearPallet?: Maybe<PsaPearPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPearPallet`. May be used by Relay 1. */
  psaPearPalletEdge?: Maybe<PsaPearPalletsEdge>;
};


/** The output of our create `PsaPearPallet` mutation. */
export type CreatePsaPearPalletPayloadPsaPearPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
};

/** All input for the create `PsaPersimmonPallet` mutation. */
export type CreatePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` to be created by this mutation. */
  psaPersimmonPallet: PsaPersimmonPalletInput;
};

/** The output of our create `PsaPersimmonPallet` mutation. */
export type CreatePsaPersimmonPalletPayload = {
  __typename?: 'CreatePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` that was created by this mutation. */
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPersimmonPallet`. May be used by Relay 1. */
  psaPersimmonPalletEdge?: Maybe<PsaPersimmonPalletsEdge>;
};


/** The output of our create `PsaPersimmonPallet` mutation. */
export type CreatePsaPersimmonPalletPayloadPsaPersimmonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
};

/** All input for the create `PsaPomegranatePallet` mutation. */
export type CreatePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` to be created by this mutation. */
  psaPomegranatePallet: PsaPomegranatePalletInput;
};

/** The output of our create `PsaPomegranatePallet` mutation. */
export type CreatePsaPomegranatePalletPayload = {
  __typename?: 'CreatePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` that was created by this mutation. */
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPomegranatePallet`. May be used by Relay 1. */
  psaPomegranatePalletEdge?: Maybe<PsaPomegranatePalletsEdge>;
};


/** The output of our create `PsaPomegranatePallet` mutation. */
export type CreatePsaPomegranatePalletPayloadPsaPomegranatePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
};

/** All input for the create `PsaStoneFruitPallet` mutation. */
export type CreatePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` to be created by this mutation. */
  psaStoneFruitPallet: PsaStoneFruitPalletInput;
};

/** The output of our create `PsaStoneFruitPallet` mutation. */
export type CreatePsaStoneFruitPalletPayload = {
  __typename?: 'CreatePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` that was created by this mutation. */
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaStoneFruitPallet`. May be used by Relay 1. */
  psaStoneFruitPalletEdge?: Maybe<PsaStoneFruitPalletsEdge>;
};


/** The output of our create `PsaStoneFruitPallet` mutation. */
export type CreatePsaStoneFruitPalletPayloadPsaStoneFruitPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
};

/** All input for the create `RepackHeader` mutation. */
export type CreateRepackHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackHeader` to be created by this mutation. */
  repackHeader: RepackHeaderInput;
};

/** The output of our create `RepackHeader` mutation. */
export type CreateRepackHeaderPayload = {
  __typename?: 'CreateRepackHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackHeader` that was created by this mutation. */
  repackHeader?: Maybe<RepackHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackHeader`. May be used by Relay 1. */
  repackHeaderEdge?: Maybe<RepackHeadersEdge>;
};


/** The output of our create `RepackHeader` mutation. */
export type CreateRepackHeaderPayloadRepackHeaderEdgeArgs = {
  orderBy?: Maybe<Array<RepackHeadersOrderBy>>;
};

/** All input for the create `RepackItem` mutation. */
export type CreateRepackItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackItem` to be created by this mutation. */
  repackItem: RepackItemInput;
};

/** The output of our create `RepackItem` mutation. */
export type CreateRepackItemPayload = {
  __typename?: 'CreateRepackItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackItem` that was created by this mutation. */
  repackItem?: Maybe<RepackItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackItem`. May be used by Relay 1. */
  repackItemEdge?: Maybe<RepackItemsEdge>;
};


/** The output of our create `RepackItem` mutation. */
export type CreateRepackItemPayloadRepackItemEdgeArgs = {
  orderBy?: Maybe<Array<RepackItemsOrderBy>>;
};

/** All input for the create `RepackQueue` mutation. */
export type CreateRepackQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackQueue` to be created by this mutation. */
  repackQueue: RepackQueueInput;
};

/** The output of our create `RepackQueue` mutation. */
export type CreateRepackQueuePayload = {
  __typename?: 'CreateRepackQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackQueue` that was created by this mutation. */
  repackQueue?: Maybe<RepackQueue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackQueue`. May be used by Relay 1. */
  repackQueueEdge?: Maybe<RepackQueuesEdge>;
};


/** The output of our create `RepackQueue` mutation. */
export type CreateRepackQueuePayloadRepackQueueEdgeArgs = {
  orderBy?: Maybe<Array<RepackQueuesOrderBy>>;
};

/** All input for the create `RepackStyle` mutation. */
export type CreateRepackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackStyle` to be created by this mutation. */
  repackStyle: RepackStyleInput;
};

/** The output of our create `RepackStyle` mutation. */
export type CreateRepackStylePayload = {
  __typename?: 'CreateRepackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackStyle` that was created by this mutation. */
  repackStyle?: Maybe<RepackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackStyle`. May be used by Relay 1. */
  repackStyleEdge?: Maybe<RepackStylesEdge>;
};


/** The output of our create `RepackStyle` mutation. */
export type CreateRepackStylePayloadRepackStyleEdgeArgs = {
  orderBy?: Maybe<Array<RepackStylesOrderBy>>;
};

/** All input for the create `ShipperAdvance` mutation. */
export type CreateShipperAdvanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperAdvance` to be created by this mutation. */
  shipperAdvance: ShipperAdvanceInput;
};

/** The output of our create `ShipperAdvance` mutation. */
export type CreateShipperAdvancePayload = {
  __typename?: 'CreateShipperAdvancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperAdvance` that was created by this mutation. */
  shipperAdvance?: Maybe<ShipperAdvance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ProductSpecies` that is related to this `ShipperAdvance`. */
  species?: Maybe<ProductSpecies>;
  /** Reads a single `Shipper` that is related to this `ShipperAdvance`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperAdvance`. May be used by Relay 1. */
  shipperAdvanceEdge?: Maybe<ShipperAdvancesEdge>;
};


/** The output of our create `ShipperAdvance` mutation. */
export type CreateShipperAdvancePayloadShipperAdvanceEdgeArgs = {
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
};

/** All input for the create `Shipper` mutation. */
export type CreateShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` to be created by this mutation. */
  shipper: ShipperInput;
};

/** The output of our create `Shipper` mutation. */
export type CreateShipperPayload = {
  __typename?: 'CreateShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` that was created by this mutation. */
  shipper?: Maybe<Shipper>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** An edge for our `Shipper`. May be used by Relay 1. */
  shipperEdge?: Maybe<ShippersEdge>;
};


/** The output of our create `Shipper` mutation. */
export type CreateShipperPayloadShipperEdgeArgs = {
  orderBy?: Maybe<Array<ShippersOrderBy>>;
};

/** All input for the create `ShipperPersonContact` mutation. */
export type CreateShipperPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` to be created by this mutation. */
  shipperPersonContact: ShipperPersonContactInput;
};

/** The output of our create `ShipperPersonContact` mutation. */
export type CreateShipperPersonContactPayload = {
  __typename?: 'CreateShipperPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` that was created by this mutation. */
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ShipperPersonContact`. May be used by Relay 1. */
  shipperPersonContactEdge?: Maybe<ShipperPersonContactsEdge>;
};


/** The output of our create `ShipperPersonContact` mutation. */
export type CreateShipperPersonContactPayloadShipperPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
};

/** All input for the create `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type CreateShipperProgramEntryCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntryCustomerProgramEntry` to be created by this mutation. */
  shipperProgramEntryCustomerProgramEntry: ShipperProgramEntryCustomerProgramEntryInput;
};

/** The output of our create `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type CreateShipperProgramEntryCustomerProgramEntryPayload = {
  __typename?: 'CreateShipperProgramEntryCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntryCustomerProgramEntry` that was created by this mutation. */
  shipperProgramEntryCustomerProgramEntry?: Maybe<ShipperProgramEntryCustomerProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Reads a single `ShipperProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  /** An edge for our `ShipperProgramEntryCustomerProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryCustomerProgramEntryEdge?: Maybe<ShipperProgramEntryCustomerProgramEntriesEdge>;
};


/** The output of our create `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type CreateShipperProgramEntryCustomerProgramEntryPayloadShipperProgramEntryCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
};

/** All input for the create `ShipperProgramEntry` mutation. */
export type CreateShipperProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntry` to be created by this mutation. */
  shipperProgramEntry: ShipperProgramEntryInput;
};

/** The output of our create `ShipperProgramEntry` mutation. */
export type CreateShipperProgramEntryPayload = {
  __typename?: 'CreateShipperProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntry` that was created by this mutation. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProgram` that is related to this `ShipperProgramEntry`. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** An edge for our `ShipperProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryEdge?: Maybe<ShipperProgramEntriesEdge>;
};


/** The output of our create `ShipperProgramEntry` mutation. */
export type CreateShipperProgramEntryPayloadShipperProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntriesOrderBy>>;
};

/** All input for the create `ShipperProgram` mutation. */
export type CreateShipperProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgram` to be created by this mutation. */
  shipperProgram: ShipperProgramInput;
};

/** The output of our create `ShipperProgram` mutation. */
export type CreateShipperProgramPayload = {
  __typename?: 'CreateShipperProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgram` that was created by this mutation. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Shipper` that is related to this `ShipperProgram`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Customer` that is related to this `ShipperProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProgram`. May be used by Relay 1. */
  shipperProgramEdge?: Maybe<ShipperProgramsEdge>;
};


/** The output of our create `ShipperProgram` mutation. */
export type CreateShipperProgramPayloadShipperProgramEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
};

/** All input for the create `ShipperProjectionEntry` mutation. */
export type CreateShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` to be created by this mutation. */
  shipperProjectionEntry: ShipperProjectionEntryInput;
};

/** The output of our create `ShipperProjectionEntry` mutation. */
export type CreateShipperProjectionEntryPayload = {
  __typename?: 'CreateShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` that was created by this mutation. */
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjectionVesselInfo` that is related to this `ShipperProjectionEntry`. */
  vesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** An edge for our `ShipperProjectionEntry`. May be used by Relay 1. */
  shipperProjectionEntryEdge?: Maybe<ShipperProjectionEntriesEdge>;
};


/** The output of our create `ShipperProjectionEntry` mutation. */
export type CreateShipperProjectionEntryPayloadShipperProjectionEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
};

/** All input for the create `ShipperProjection` mutation. */
export type CreateShipperProjectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` to be created by this mutation. */
  shipperProjection: ShipperProjectionInput;
};

/** The output of our create `ShipperProjection` mutation. */
export type CreateShipperProjectionPayload = {
  __typename?: 'CreateShipperProjectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` that was created by this mutation. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our create `ShipperProjection` mutation. */
export type CreateShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the create `ShipperProjectionProduct` mutation. */
export type CreateShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` to be created by this mutation. */
  shipperProjectionProduct: ShipperProjectionProductInput;
};

/** The output of our create `ShipperProjectionProduct` mutation. */
export type CreateShipperProjectionProductPayload = {
  __typename?: 'CreateShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` that was created by this mutation. */
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProjectionProduct`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProjectionProduct`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProjectionProduct`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProjectionProduct`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `ShipperProjectionProduct`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProjectionProduct`. May be used by Relay 1. */
  shipperProjectionProductEdge?: Maybe<ShipperProjectionProductsEdge>;
};


/** The output of our create `ShipperProjectionProduct` mutation. */
export type CreateShipperProjectionProductPayloadShipperProjectionProductEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
};

/** All input for the create `ShipperProjectionVesselInfo` mutation. */
export type CreateShipperProjectionVesselInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVesselInfo` to be created by this mutation. */
  shipperProjectionVesselInfo: ShipperProjectionVesselInfoInput;
};

/** The output of our create `ShipperProjectionVesselInfo` mutation. */
export type CreateShipperProjectionVesselInfoPayload = {
  __typename?: 'CreateShipperProjectionVesselInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVesselInfo` that was created by this mutation. */
  shipperProjectionVesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionVesselInfo`. */
  projection?: Maybe<ShipperProjection>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionVesselInfo`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVesselInfo`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionVesselInfo`. May be used by Relay 1. */
  shipperProjectionVesselInfoEdge?: Maybe<ShipperProjectionVesselInfosEdge>;
};


/** The output of our create `ShipperProjectionVesselInfo` mutation. */
export type CreateShipperProjectionVesselInfoPayloadShipperProjectionVesselInfoEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
};

/** All input for the create `ShipperProjectionVessel` mutation. */
export type CreateShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` to be created by this mutation. */
  shipperProjectionVessel: ShipperProjectionVesselInput;
};

/** The output of our create `ShipperProjectionVessel` mutation. */
export type CreateShipperProjectionVesselPayload = {
  __typename?: 'CreateShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` that was created by this mutation. */
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Vessel` that is related to this `ShipperProjectionVessel`. */
  vessel?: Maybe<Vessel>;
  /** An edge for our `ShipperProjectionVessel`. May be used by Relay 1. */
  shipperProjectionVesselEdge?: Maybe<ShipperProjectionVesselsEdge>;
};


/** The output of our create `ShipperProjectionVessel` mutation. */
export type CreateShipperProjectionVesselPayloadShipperProjectionVesselEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
};

/** All input for the create `TruckLoad` mutation. */
export type CreateTruckLoadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckLoad` to be created by this mutation. */
  truckLoad: TruckLoadInput;
};

/** The output of our create `TruckLoad` mutation. */
export type CreateTruckLoadPayload = {
  __typename?: 'CreateTruckLoadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckLoad` that was created by this mutation. */
  truckLoad?: Maybe<TruckLoad>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckLoad`. May be used by Relay 1. */
  truckLoadEdge?: Maybe<TruckLoadsEdge>;
};


/** The output of our create `TruckLoad` mutation. */
export type CreateTruckLoadPayloadTruckLoadEdgeArgs = {
  orderBy?: Maybe<Array<TruckLoadsOrderBy>>;
};

/** All input for the create `TruckRateCustomer` mutation. */
export type CreateTruckRateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRateCustomer` to be created by this mutation. */
  truckRateCustomer: TruckRateCustomerInput;
};

/** The output of our create `TruckRateCustomer` mutation. */
export type CreateTruckRateCustomerPayload = {
  __typename?: 'CreateTruckRateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRateCustomer` that was created by this mutation. */
  truckRateCustomer?: Maybe<TruckRateCustomer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TruckRate` that is related to this `TruckRateCustomer`. */
  truckRate?: Maybe<TruckRate>;
  /** Reads a single `Customer` that is related to this `TruckRateCustomer`. */
  customer?: Maybe<Customer>;
  /** An edge for our `TruckRateCustomer`. May be used by Relay 1. */
  truckRateCustomerEdge?: Maybe<TruckRateCustomersEdge>;
};


/** The output of our create `TruckRateCustomer` mutation. */
export type CreateTruckRateCustomerPayloadTruckRateCustomerEdgeArgs = {
  orderBy?: Maybe<Array<TruckRateCustomersOrderBy>>;
};

/** All input for the create `TruckRate` mutation. */
export type CreateTruckRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRate` to be created by this mutation. */
  truckRate: TruckRateInput;
};

/** The output of our create `TruckRate` mutation. */
export type CreateTruckRatePayload = {
  __typename?: 'CreateTruckRatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRate` that was created by this mutation. */
  truckRate?: Maybe<TruckRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckRate`. May be used by Relay 1. */
  truckRateEdge?: Maybe<TruckRatesEdge>;
};


/** The output of our create `TruckRate` mutation. */
export type CreateTruckRatePayloadTruckRateEdgeArgs = {
  orderBy?: Maybe<Array<TruckRatesOrderBy>>;
};

/** All input for the create `Unpaid` mutation. */
export type CreateUnpaidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Unpaid` to be created by this mutation. */
  unpaid: UnpaidInput;
};

/** The output of our create `Unpaid` mutation. */
export type CreateUnpaidPayload = {
  __typename?: 'CreateUnpaidPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Unpaid` that was created by this mutation. */
  unpaid?: Maybe<Unpaid>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Unpaid`. May be used by Relay 1. */
  unpaidEdge?: Maybe<UnpaidsEdge>;
};


/** The output of our create `Unpaid` mutation. */
export type CreateUnpaidPayloadUnpaidEdgeArgs = {
  orderBy?: Maybe<Array<UnpaidsOrderBy>>;
};

/** All input for the create `UserBookmark` mutation. */
export type CreateUserBookmarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserBookmark` to be created by this mutation. */
  userBookmark: UserBookmarkInput;
};

/** The output of our create `UserBookmark` mutation. */
export type CreateUserBookmarkPayload = {
  __typename?: 'CreateUserBookmarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserBookmark` that was created by this mutation. */
  userBookmark?: Maybe<UserBookmark>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserBookmark`. */
  user?: Maybe<User>;
  /** An edge for our `UserBookmark`. May be used by Relay 1. */
  userBookmarkEdge?: Maybe<UserBookmarksEdge>;
};


/** The output of our create `UserBookmark` mutation. */
export type CreateUserBookmarkPayloadUserBookmarkEdgeArgs = {
  orderBy?: Maybe<Array<UserBookmarksOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** All input for the create `UserMessage` mutation. */
export type CreateUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` to be created by this mutation. */
  userMessage: UserMessageInput;
};

/** The output of our create `UserMessage` mutation. */
export type CreateUserMessagePayload = {
  __typename?: 'CreateUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` that was created by this mutation. */
  userMessage?: Maybe<UserMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
  /** An edge for our `UserMessage`. May be used by Relay 1. */
  userMessageEdge?: Maybe<UserMessagesEdge>;
};


/** The output of our create `UserMessage` mutation. */
export type CreateUserMessagePayloadUserMessageEdgeArgs = {
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the create `UserRole` mutation. */
export type CreateUserRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserRole` to be created by this mutation. */
  userRole: UserRoleInput;
};

/** The output of our create `UserRole` mutation. */
export type CreateUserRolePayload = {
  __typename?: 'CreateUserRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserRole` that was created by this mutation. */
  userRole?: Maybe<UserRole>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>;
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>;
};


/** The output of our create `UserRole` mutation. */
export type CreateUserRolePayloadUserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>;
};

/** All input for the create `Vendor` mutation. */
export type CreateVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` to be created by this mutation. */
  vendor: VendorInput;
};

/** The output of our create `Vendor` mutation. */
export type CreateVendorPayload = {
  __typename?: 'CreateVendorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was created by this mutation. */
  vendor?: Maybe<Vendor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our create `Vendor` mutation. */
export type CreateVendorPayloadVendorEdgeArgs = {
  orderBy?: Maybe<Array<VendorsOrderBy>>;
};

/** All input for the create `VendorPersonContact` mutation. */
export type CreateVendorPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VendorPersonContact` to be created by this mutation. */
  vendorPersonContact: VendorPersonContactInput;
};

/** The output of our create `VendorPersonContact` mutation. */
export type CreateVendorPersonContactPayload = {
  __typename?: 'CreateVendorPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VendorPersonContact` that was created by this mutation. */
  vendorPersonContact?: Maybe<VendorPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vendor` that is related to this `VendorPersonContact`. */
  vendor?: Maybe<Vendor>;
  /** Reads a single `PersonContact` that is related to this `VendorPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `VendorPersonContact`. May be used by Relay 1. */
  vendorPersonContactEdge?: Maybe<VendorPersonContactsEdge>;
};


/** The output of our create `VendorPersonContact` mutation. */
export type CreateVendorPersonContactPayloadVendorPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<VendorPersonContactsOrderBy>>;
};

/** All input for the create `VesselControl` mutation. */
export type CreateVesselControlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VesselControl` to be created by this mutation. */
  vesselControl: VesselControlInput;
};

/** The output of our create `VesselControl` mutation. */
export type CreateVesselControlPayload = {
  __typename?: 'CreateVesselControlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VesselControl` that was created by this mutation. */
  vesselControl?: Maybe<VesselControl>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VesselControl`. May be used by Relay 1. */
  vesselControlEdge?: Maybe<VesselControlsEdge>;
};


/** The output of our create `VesselControl` mutation. */
export type CreateVesselControlPayloadVesselControlEdgeArgs = {
  orderBy?: Maybe<Array<VesselControlsOrderBy>>;
};

/** All input for the create `Vessel` mutation. */
export type CreateVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` to be created by this mutation. */
  vessel: VesselInput;
};

/** The output of our create `Vessel` mutation. */
export type CreateVesselPayload = {
  __typename?: 'CreateVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` that was created by this mutation. */
  vessel?: Maybe<Vessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vessel`. May be used by Relay 1. */
  vesselEdge?: Maybe<VesselsEdge>;
};


/** The output of our create `Vessel` mutation. */
export type CreateVesselPayloadVesselEdgeArgs = {
  orderBy?: Maybe<Array<VesselsOrderBy>>;
};

/** All input for the create `Warehouse` mutation. */
export type CreateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` to be created by this mutation. */
  warehouse: WarehouseInput;
};

/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayload = {
  __typename?: 'CreateWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was created by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayloadWarehouseEdgeArgs = {
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
};

/** All input for the create `WarehousePersonContact` mutation. */
export type CreateWarehousePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` to be created by this mutation. */
  warehousePersonContact: WarehousePersonContactInput;
};

/** The output of our create `WarehousePersonContact` mutation. */
export type CreateWarehousePersonContactPayload = {
  __typename?: 'CreateWarehousePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` that was created by this mutation. */
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `WarehousePersonContact`. May be used by Relay 1. */
  warehousePersonContactEdge?: Maybe<WarehousePersonContactsEdge>;
};


/** The output of our create `WarehousePersonContact` mutation. */
export type CreateWarehousePersonContactPayloadWarehousePersonContactEdgeArgs = {
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
};

/** All input for the create `WireRequestAccountOfSaleItem` mutation. */
export type CreateWireRequestAccountOfSaleItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestAccountOfSaleItem` to be created by this mutation. */
  wireRequestAccountOfSaleItem: WireRequestAccountOfSaleItemInput;
};

/** The output of our create `WireRequestAccountOfSaleItem` mutation. */
export type CreateWireRequestAccountOfSaleItemPayload = {
  __typename?: 'CreateWireRequestAccountOfSaleItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestAccountOfSaleItem` that was created by this mutation. */
  wireRequestAccountOfSaleItem?: Maybe<WireRequestAccountOfSaleItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestAccountOfSaleItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestAccountOfSaleItem`. May be used by Relay 1. */
  wireRequestAccountOfSaleItemEdge?: Maybe<WireRequestAccountOfSaleItemsEdge>;
};


/** The output of our create `WireRequestAccountOfSaleItem` mutation. */
export type CreateWireRequestAccountOfSaleItemPayloadWireRequestAccountOfSaleItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestAccountOfSaleItemsOrderBy>>;
};

/** All input for the create `WireRequest` mutation. */
export type CreateWireRequestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequest` to be created by this mutation. */
  wireRequest: WireRequestInput;
};

/** All input for the create `WireRequestMiscItem` mutation. */
export type CreateWireRequestMiscItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestMiscItem` to be created by this mutation. */
  wireRequestMiscItem: WireRequestMiscItemInput;
};

/** The output of our create `WireRequestMiscItem` mutation. */
export type CreateWireRequestMiscItemPayload = {
  __typename?: 'CreateWireRequestMiscItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestMiscItem` that was created by this mutation. */
  wireRequestMiscItem?: Maybe<WireRequestMiscItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestMiscItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestMiscItem`. May be used by Relay 1. */
  wireRequestMiscItemEdge?: Maybe<WireRequestMiscItemsEdge>;
};


/** The output of our create `WireRequestMiscItem` mutation. */
export type CreateWireRequestMiscItemPayloadWireRequestMiscItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestMiscItemsOrderBy>>;
};

/** All input for the create `WireRequestOceanFreightItem` mutation. */
export type CreateWireRequestOceanFreightItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestOceanFreightItem` to be created by this mutation. */
  wireRequestOceanFreightItem: WireRequestOceanFreightItemInput;
};

/** The output of our create `WireRequestOceanFreightItem` mutation. */
export type CreateWireRequestOceanFreightItemPayload = {
  __typename?: 'CreateWireRequestOceanFreightItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestOceanFreightItem` that was created by this mutation. */
  wireRequestOceanFreightItem?: Maybe<WireRequestOceanFreightItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestOceanFreightItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestOceanFreightItem`. May be used by Relay 1. */
  wireRequestOceanFreightItemEdge?: Maybe<WireRequestOceanFreightItemsEdge>;
};


/** The output of our create `WireRequestOceanFreightItem` mutation. */
export type CreateWireRequestOceanFreightItemPayloadWireRequestOceanFreightItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestOceanFreightItemsOrderBy>>;
};

/** The output of our create `WireRequest` mutation. */
export type CreateWireRequestPayload = {
  __typename?: 'CreateWireRequestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequest` that was created by this mutation. */
  wireRequest?: Maybe<WireRequest>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `WireRequest`. May be used by Relay 1. */
  wireRequestEdge?: Maybe<WireRequestsEdge>;
};


/** The output of our create `WireRequest` mutation. */
export type CreateWireRequestPayloadWireRequestEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestsOrderBy>>;
};

/** All input for the create `WireRequestShipperAdvanceItem` mutation. */
export type CreateWireRequestShipperAdvanceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestShipperAdvanceItem` to be created by this mutation. */
  wireRequestShipperAdvanceItem: WireRequestShipperAdvanceItemInput;
};

/** The output of our create `WireRequestShipperAdvanceItem` mutation. */
export type CreateWireRequestShipperAdvanceItemPayload = {
  __typename?: 'CreateWireRequestShipperAdvanceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestShipperAdvanceItem` that was created by this mutation. */
  wireRequestShipperAdvanceItem?: Maybe<WireRequestShipperAdvanceItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestShipperAdvanceItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestShipperAdvanceItem`. May be used by Relay 1. */
  wireRequestShipperAdvanceItemEdge?: Maybe<WireRequestShipperAdvanceItemsEdge>;
};


/** The output of our create `WireRequestShipperAdvanceItem` mutation. */
export type CreateWireRequestShipperAdvanceItemPayloadWireRequestShipperAdvanceItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestShipperAdvanceItemsOrderBy>>;
};


export type Customer = Node & {
  __typename?: 'Customer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  salesUserCode?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
  /** Reads and enables pagination through a set of `CustomerPersonContact`. */
  customerPersonContacts: CustomerPersonContactsConnection;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
  /** Reads and enables pagination through a set of `TruckRateCustomer`. */
  truckRateCustomers: TruckRateCustomersConnection;
  country?: Maybe<Country>;
  salesUser?: Maybe<User>;
  searchText?: Maybe<Scalars['String']>;
  vendor?: Maybe<Vendor>;
  /** Reads and enables pagination through a set of `CustomerVolumeDiscount`. */
  volumeDiscounts: CustomerVolumeDiscountsConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionProductCustomerIdAndShipperId: CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesId: CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyId: CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProjectionProductCustomerIdAndCommonSizeId: CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeId: CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByCustomerPersonContactCustomerIdAndPersonContactId: CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProgramCustomerIdAndCommonSpeciesId: CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProgramCustomerIdAndCommonVarietyId: CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProgramCustomerIdAndCommonSizeId: CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProgramCustomerIdAndCommonPackTypeId: CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProgramCustomerIdAndShipperId: CustomerShippersByShipperProgramCustomerIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesId: CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByCustomerProgramCustomerIdAndCommonVarietyId: CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByCustomerProgramCustomerIdAndCommonSizeId: CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeId: CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `TruckRate`. */
  truckRatesByTruckRateCustomerCustomerIdAndTruckRateId: CustomerTruckRatesByTruckRateCustomerCustomerIdAndTruckRateIdManyToManyConnection;
};


export type CustomerShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type CustomerCustomerPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
  condition?: Maybe<CustomerPersonContactCondition>;
  filter?: Maybe<CustomerPersonContactFilter>;
};


export type CustomerShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};


export type CustomerCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};


export type CustomerTruckRateCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TruckRateCustomersOrderBy>>;
  condition?: Maybe<TruckRateCustomerCondition>;
  filter?: Maybe<TruckRateCustomerFilter>;
};


export type CustomerVolumeDiscountsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<CustomerVolumeDiscountFilter>;
};


export type CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};


export type CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CustomerShippersByShipperProgramCustomerIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type CustomerTruckRatesByTruckRateCustomerCustomerIdAndTruckRateIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TruckRatesOrderBy>>;
  condition?: Maybe<TruckRateCondition>;
  filter?: Maybe<TruckRateFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `CustomerProgram`. */
export type CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonPackTypesByCustomerProgramCustomerIdAndCommonPackTypeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProgram`. */
export type CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonPackTypesByShipperProgramCustomerIdAndCommonPackTypeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProjectionProduct`. */
export type CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonPackTypesByShipperProjectionProductCustomerIdAndCommonPackTypeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `CustomerProgram`. */
export type CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonSizesByCustomerProgramCustomerIdAndCommonSizeIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProgram`. */
export type CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonSizesByShipperProgramCustomerIdAndCommonSizeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProjectionProduct`. */
export type CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonSizesByShipperProjectionProductCustomerIdAndCommonSizeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `CustomerProgram`. */
export type CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonSpeciesByCustomerProgramCustomerIdAndCommonSpeciesIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProgram`. */
export type CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonSpeciesByShipperProgramCustomerIdAndCommonSpeciesIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProjectionProduct`. */
export type CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonSpeciesByShipperProjectionProductCustomerIdAndCommonSpeciesIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `CustomerProgram`. */
export type CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `CustomerProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms: CustomerProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `CustomerProgram`. */
export type CustomerCommonVarietiesByCustomerProgramCustomerIdAndCommonVarietyIdManyToManyEdgeCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProgram`. */
export type CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type CustomerCommonVarietiesByShipperProgramCustomerIdAndCommonVarietyIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProjectionProduct`. */
export type CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerCommonVarietiesByShipperProjectionProductCustomerIdAndCommonVarietyIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/**
 * A condition to be used against `Customer` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CustomerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address1` field. */
  address1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address2` field. */
  address2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalState` field. */
  postalState?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipCode` field. */
  zipCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `logoSrc` field. */
  logoSrc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `active` field. */
  active?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<Scalars['String']>;
};

/** The fields on `customer` to look up the row to connect. */
export type CustomerCustomerPkeyConnect = {
  id: Scalars['String'];
};

/** The fields on `customer` to look up the row to delete. */
export type CustomerCustomerPkeyDelete = {
  id: Scalars['String'];
};

/** A `String` edge in the connection. */
export type CustomerDistinctColumnValueEdge = {
  __typename?: 'CustomerDistinctColumnValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type CustomerDistinctColumnValuesConnection = {
  __typename?: 'CustomerDistinctColumnValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<CustomerDistinctColumnValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type CustomerDistinctValueEdge = {
  __typename?: 'CustomerDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type CustomerDistinctValuesConnection = {
  __typename?: 'CustomerDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<CustomerDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A filter to be used against `Customer` object types. All fields are combined with a logical ‘and.’ */
export type CustomerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `customerName` field. */
  customerName?: Maybe<StringFilter>;
  /** Filter by the object’s `address1` field. */
  address1?: Maybe<StringFilter>;
  /** Filter by the object’s `address2` field. */
  address2?: Maybe<StringFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `postalState` field. */
  postalState?: Maybe<StringFilter>;
  /** Filter by the object’s `zipCode` field. */
  zipCode?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `logoSrc` field. */
  logoSrc?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `website` field. */
  website?: Maybe<StringFilter>;
  /** Filter by the object’s `active` field. */
  active?: Maybe<BooleanFilter>;
  /** Filter by the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionProducts` relation. */
  shipperProjectionProducts?: Maybe<CustomerToManyShipperProjectionProductFilter>;
  /** Some related `shipperProjectionProducts` exist. */
  shipperProjectionProductsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerPersonContacts` relation. */
  customerPersonContacts?: Maybe<CustomerToManyCustomerPersonContactFilter>;
  /** Some related `customerPersonContacts` exist. */
  customerPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPrograms` relation. */
  shipperPrograms?: Maybe<CustomerToManyShipperProgramFilter>;
  /** Some related `shipperPrograms` exist. */
  shipperProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerPrograms` relation. */
  customerPrograms?: Maybe<CustomerToManyCustomerProgramFilter>;
  /** Some related `customerPrograms` exist. */
  customerProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `truckRateCustomers` relation. */
  truckRateCustomers?: Maybe<CustomerToManyTruckRateCustomerFilter>;
  /** Some related `truckRateCustomers` exist. */
  truckRateCustomersExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerFilter>;
};

/** An input for mutations affecting `Customer` */
export type CustomerInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnCustomerProgramForCustomerProgramCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: CustomerProgramPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnCustomerProgramForCustomerProgramCustomerIdFkeyUsingCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnCustomerProgramForCustomerProgramCustomerIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnShipperProgramForShipperProgramCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnShipperProgramForShipperProgramCustomerIdFkeyUsingCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnShipperProgramForShipperProgramCustomerIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyUsingCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `truckRateCustomer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `truckRateCustomer` being updated. */
  patch: TruckRateCustomerPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyUsingCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyPatch;
  id: Scalars['String'];
};

/** Represents an update to a `Customer`. Fields that are set will be updated. */
export type CustomerPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

export type CustomerPayment = Node & {
  __typename?: 'CustomerPayment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  invoiceId: Scalars['String'];
  checkNumber?: Maybe<Scalars['String']>;
  transactionCode?: Maybe<Scalars['String']>;
  transactionType?: Maybe<Scalars['String']>;
  netAmountDue?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  invoiceHeader?: Maybe<InvoiceHeader>;
};

/**
 * A condition to be used against `CustomerPayment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CustomerPaymentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `checkNumber` field. */
  checkNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `transactionCode` field. */
  transactionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `transactionType` field. */
  transactionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `netAmountDue` field. */
  netAmountDue?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `CustomerPayment` object types. All fields are combined with a logical ‘and.’ */
export type CustomerPaymentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<StringFilter>;
  /** Filter by the object’s `checkNumber` field. */
  checkNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `transactionCode` field. */
  transactionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `transactionType` field. */
  transactionType?: Maybe<StringFilter>;
  /** Filter by the object’s `netAmountDue` field. */
  netAmountDue?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerPaymentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerPaymentFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerPaymentFilter>;
};

/** An input for mutations affecting `CustomerPayment` */
export type CustomerPaymentInput = {
  id?: Maybe<Scalars['BigInt']>;
  invoiceId: Scalars['String'];
  checkNumber?: Maybe<Scalars['String']>;
  transactionCode?: Maybe<Scalars['String']>;
  transactionType?: Maybe<Scalars['String']>;
  netAmountDue?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
};

/** Represents an update to a `CustomerPayment`. Fields that are set will be updated. */
export type CustomerPaymentPatch = {
  id?: Maybe<Scalars['BigInt']>;
  invoiceId?: Maybe<Scalars['String']>;
  checkNumber?: Maybe<Scalars['String']>;
  transactionCode?: Maybe<Scalars['String']>;
  transactionType?: Maybe<Scalars['String']>;
  netAmountDue?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
};

/** A connection to a list of `CustomerPayment` values. */
export type CustomerPaymentsConnection = {
  __typename?: 'CustomerPaymentsConnection';
  /** A list of `CustomerPayment` objects. */
  nodes: Array<Maybe<CustomerPayment>>;
  /** A list of edges which contains the `CustomerPayment` and cursor to aid in pagination. */
  edges: Array<CustomerPaymentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerPayment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CustomerPayment` edge in the connection. */
export type CustomerPaymentsEdge = {
  __typename?: 'CustomerPaymentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerPayment` at the end of the edge. */
  node?: Maybe<CustomerPayment>;
};

/** Methods to use when ordering `CustomerPayment`. */
export enum CustomerPaymentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  CheckNumberAsc = 'CHECK_NUMBER_ASC',
  CheckNumberDesc = 'CHECK_NUMBER_DESC',
  TransactionCodeAsc = 'TRANSACTION_CODE_ASC',
  TransactionCodeDesc = 'TRANSACTION_CODE_DESC',
  TransactionTypeAsc = 'TRANSACTION_TYPE_ASC',
  TransactionTypeDesc = 'TRANSACTION_TYPE_DESC',
  NetAmountDueAsc = 'NET_AMOUNT_DUE_ASC',
  NetAmountDueDesc = 'NET_AMOUNT_DUE_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type CustomerPersonContact = Node & {
  __typename?: 'CustomerPersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
};

/**
 * A condition to be used against `CustomerPersonContact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CustomerPersonContactCondition = {
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** The `customer` to be created by this mutation. */
export type CustomerPersonContactCustomerIdFkeyCustomerCreateInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** The `customerPersonContact` to be created by this mutation. */
export type CustomerPersonContactCustomerIdFkeyCustomerPersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `customer` in the `CustomerPersonContactInput` mutation. */
export type CustomerPersonContactCustomerIdFkeyInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerCustomerPkeyConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerCustomerPkeyDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPkeyUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerPersonContactCustomerIdFkeyCustomerCreateInput>;
};

/** Input for the nested mutation of `customerPersonContact` in the `CustomerInput` mutation. */
export type CustomerPersonContactCustomerIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerPersonContactNodeIdConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyDelete>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate>>;
  /** A `CustomerPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerPersonContactCustomerIdFkeyCustomerPersonContactCreateInput>>;
};

/** The fields on `customerPersonContact` to look up the row to connect. */
export type CustomerPersonContactCustomerPersonContactPkeyConnect = {
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The fields on `customerPersonContact` to look up the row to delete. */
export type CustomerPersonContactCustomerPersonContactPkeyDelete = {
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** A filter to be used against `CustomerPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type CustomerPersonContactFilter = {
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerPersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerPersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerPersonContactFilter>;
};

/** An input for mutations affecting `CustomerPersonContact` */
export type CustomerPersonContactInput = {
  customerId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerPersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerPersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The fields on `customerPersonContact` to look up the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyUsingCustomerPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The fields on `customerPersonContact` to look up the row to update. */
export type CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingCustomerPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** Represents an update to a `CustomerPersonContact`. Fields that are set will be updated. */
export type CustomerPersonContactPatch = {
  customerId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** The `customerPersonContact` to be created by this mutation. */
export type CustomerPersonContactPersonContactIdFkeyCustomerPersonContactCreateInput = {
  customerId?: Maybe<Scalars['String']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `CustomerPersonContactInput` mutation. */
export type CustomerPersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerPersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** Input for the nested mutation of `customerPersonContact` in the `PersonContactInput` mutation. */
export type CustomerPersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerPersonContactNodeIdConnect>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactCustomerPersonContactPkeyDelete>>;
  /** The primary key(s) for `customerPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByCustomerIdAndPersonContactId?: Maybe<Array<CustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingCustomerPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `CustomerPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerPersonContactPersonContactIdFkeyCustomerPersonContactCreateInput>>;
};

/** The `personContact` to be created by this mutation. */
export type CustomerPersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** A connection to a list of `PersonContact` values, with data from `CustomerPersonContact`. */
export type CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `CustomerPersonContact`, and the cursor to aid in pagination. */
  edges: Array<CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `CustomerPersonContact`. */
export type CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'CustomerPersonContactsByCustomerPersonContactCustomerIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A connection to a list of `CustomerPersonContact` values. */
export type CustomerPersonContactsConnection = {
  __typename?: 'CustomerPersonContactsConnection';
  /** A list of `CustomerPersonContact` objects. */
  nodes: Array<Maybe<CustomerPersonContact>>;
  /** A list of edges which contains the `CustomerPersonContact` and cursor to aid in pagination. */
  edges: Array<CustomerPersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerPersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CustomerPersonContact` edge in the connection. */
export type CustomerPersonContactsEdge = {
  __typename?: 'CustomerPersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerPersonContact` at the end of the edge. */
  node?: Maybe<CustomerPersonContact>;
};

/** Methods to use when ordering `CustomerPersonContact`. */
export enum CustomerPersonContactsOrderBy {
  Natural = 'NATURAL',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCustomerNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_ASC',
  CustomerByCustomerIdCustomerNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_DESC',
  CustomerByCustomerIdAddress_1Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_ASC',
  CustomerByCustomerIdAddress_1Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_DESC',
  CustomerByCustomerIdAddress_2Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_ASC',
  CustomerByCustomerIdAddress_2Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_DESC',
  CustomerByCustomerIdCityAsc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_ASC',
  CustomerByCustomerIdCityDesc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_DESC',
  CustomerByCustomerIdPostalStateAsc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_ASC',
  CustomerByCustomerIdPostalStateDesc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_DESC',
  CustomerByCustomerIdZipCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_ASC',
  CustomerByCustomerIdZipCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_DESC',
  CustomerByCustomerIdCountryIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_ASC',
  CustomerByCustomerIdCountryIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerByCustomerIdLogoSrcAsc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_ASC',
  CustomerByCustomerIdLogoSrcDesc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_DESC',
  CustomerByCustomerIdNotesAsc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_ASC',
  CustomerByCustomerIdNotesDesc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_DESC',
  CustomerByCustomerIdWebsiteAsc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_ASC',
  CustomerByCustomerIdWebsiteDesc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_DESC',
  CustomerByCustomerIdActiveAsc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_ASC',
  CustomerByCustomerIdActiveDesc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_DESC',
  CustomerByCustomerIdSalesUserCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_ASC',
  CustomerByCustomerIdSalesUserCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_DESC',
  PersonContactByPersonContactIdIdAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_ASC',
  PersonContactByPersonContactIdIdDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_DESC',
  PersonContactByPersonContactIdFirstNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_ASC',
  PersonContactByPersonContactIdFirstNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_DESC',
  PersonContactByPersonContactIdLastNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_ASC',
  PersonContactByPersonContactIdLastNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_DESC',
  PersonContactByPersonContactIdIsPrimaryAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_ASC',
  PersonContactByPersonContactIdIsPrimaryDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_DESC',
  PersonContactByPersonContactIdEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_ASC',
  PersonContactByPersonContactIdEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_DESC',
  PersonContactByPersonContactIdSecondaryEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_ASC',
  PersonContactByPersonContactIdSecondaryEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_DESC',
  PersonContactByPersonContactIdHomePhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_ASC',
  PersonContactByPersonContactIdHomePhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_DESC',
  PersonContactByPersonContactIdCellPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_ASC',
  PersonContactByPersonContactIdCellPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_DESC',
  PersonContactByPersonContactIdWorkPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_ASC',
  PersonContactByPersonContactIdWorkPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_DESC',
  PersonContactByPersonContactIdWorkExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_ASC',
  PersonContactByPersonContactIdWorkExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_DESC',
  PersonContactByPersonContactIdImageSrcAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_ASC',
  PersonContactByPersonContactIdImageSrcDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_DESC',
  PersonContactByPersonContactIdIsInternalAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_ASC',
  PersonContactByPersonContactIdIsInternalDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_DESC',
  PersonContactByPersonContactIdRolesAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_ASC',
  PersonContactByPersonContactIdRolesDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_DESC',
  PersonContactByPersonContactIdHomeExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_ASC',
  PersonContactByPersonContactIdHomeExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_DESC',
  PersonContactByPersonContactIdLocationAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_ASC',
  PersonContactByPersonContactIdLocationDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_DESC'
}

export type CustomerProgram = Node & {
  __typename?: 'CustomerProgram';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  /** Reads a single `CommonSpecies` that is related to this `CustomerProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `CustomerProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `CustomerProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `CustomerProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `CustomerProgram`. */
  customer?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `CustomerProgramEntry`. */
  customerProgramEntries: CustomerProgramEntriesConnection;
};


export type CustomerProgramCustomerProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramEntriesOrderBy>>;
  condition?: Maybe<CustomerProgramEntryCondition>;
  filter?: Maybe<CustomerProgramEntryFilter>;
};

/** The `commonPackType` to be created by this mutation. */
export type CustomerProgramCommonPackTypeIdFkeyCommonPackTypeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** The `customerProgram` to be created by this mutation. */
export type CustomerProgramCommonPackTypeIdFkeyCustomerProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonPackType` in the `CustomerProgramInput` mutation. */
export type CustomerProgramCommonPackTypeIdFkeyInput = {
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectById?: Maybe<CommonPackTypeCommonPackTypePkeyConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonPackTypeNodeIdConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteById?: Maybe<CommonPackTypeCommonPackTypePkeyDelete>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonPackTypeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateById?: Maybe<CommonPackTypeOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerProgramOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyNodeIdUpdate>;
  /** A `CommonPackTypeInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerProgramCommonPackTypeIdFkeyCommonPackTypeCreateInput>;
};

/** Input for the nested mutation of `customerProgram` in the `CommonPackTypeInput` mutation. */
export type CustomerProgramCommonPackTypeIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerProgramCustomerProgramPkeyConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerProgramNodeIdConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerProgramCustomerProgramPkeyDelete>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerProgramOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyUsingCustomerProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonPackTypeOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyNodeIdUpdate>>;
  /** A `CustomerProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerProgramCommonPackTypeIdFkeyCustomerProgramCreateInput>>;
};

/** The `commonSize` to be created by this mutation. */
export type CustomerProgramCommonSizeIdFkeyCommonSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** The `customerProgram` to be created by this mutation. */
export type CustomerProgramCommonSizeIdFkeyCustomerProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSize` in the `CustomerProgramInput` mutation. */
export type CustomerProgramCommonSizeIdFkeyInput = {
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectById?: Maybe<CommonSizeCommonSizePkeyConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSizeNodeIdConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteById?: Maybe<CommonSizeCommonSizePkeyDelete>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateById?: Maybe<CommonSizeOnCustomerProgramForCustomerProgramCommonSizeIdFkeyUsingCommonSizePkeyUpdate>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerProgramOnCustomerProgramForCustomerProgramCommonSizeIdFkeyNodeIdUpdate>;
  /** A `CommonSizeInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerProgramCommonSizeIdFkeyCommonSizeCreateInput>;
};

/** Input for the nested mutation of `customerProgram` in the `CommonSizeInput` mutation. */
export type CustomerProgramCommonSizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerProgramCustomerProgramPkeyConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerProgramNodeIdConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerProgramCustomerProgramPkeyDelete>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerProgramOnCustomerProgramForCustomerProgramCommonSizeIdFkeyUsingCustomerProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSizeOnCustomerProgramForCustomerProgramCommonSizeIdFkeyNodeIdUpdate>>;
  /** A `CustomerProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerProgramCommonSizeIdFkeyCustomerProgramCreateInput>>;
};

/** The `commonSpecies` to be created by this mutation. */
export type CustomerProgramCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** The `customerProgram` to be created by this mutation. */
export type CustomerProgramCommonSpeciesIdFkeyCustomerProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `CustomerProgramInput` mutation. */
export type CustomerProgramCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerProgramOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerProgramCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `customerProgram` in the `CommonSpeciesInput` mutation. */
export type CustomerProgramCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerProgramCustomerProgramPkeyConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerProgramNodeIdConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerProgramCustomerProgramPkeyDelete>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerProgramOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyUsingCustomerProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `CustomerProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerProgramCommonSpeciesIdFkeyCustomerProgramCreateInput>>;
};

/** The `commonVariety` to be created by this mutation. */
export type CustomerProgramCommonVarietyIdFkeyCommonVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** The `customerProgram` to be created by this mutation. */
export type CustomerProgramCommonVarietyIdFkeyCustomerProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonVariety` in the `CustomerProgramInput` mutation. */
export type CustomerProgramCommonVarietyIdFkeyInput = {
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectById?: Maybe<CommonVarietyCommonVarietyPkeyConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonVarietyNodeIdConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteById?: Maybe<CommonVarietyCommonVarietyPkeyDelete>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonVarietyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateById?: Maybe<CommonVarietyOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerProgramOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyNodeIdUpdate>;
  /** A `CommonVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerProgramCommonVarietyIdFkeyCommonVarietyCreateInput>;
};

/** Input for the nested mutation of `customerProgram` in the `CommonVarietyInput` mutation. */
export type CustomerProgramCommonVarietyIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerProgramCustomerProgramPkeyConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerProgramNodeIdConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerProgramCustomerProgramPkeyDelete>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerProgramOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyUsingCustomerProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonVarietyOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyNodeIdUpdate>>;
  /** A `CustomerProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerProgramCommonVarietyIdFkeyCustomerProgramCreateInput>>;
};

/**
 * A condition to be used against `CustomerProgram` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CustomerProgramCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** The `customer` to be created by this mutation. */
export type CustomerProgramCustomerIdFkeyCustomerCreateInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** The `customerProgram` to be created by this mutation. */
export type CustomerProgramCustomerIdFkeyCustomerProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customer` in the `CustomerProgramInput` mutation. */
export type CustomerProgramCustomerIdFkeyInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerCustomerPkeyConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerCustomerPkeyDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnCustomerProgramForCustomerProgramCustomerIdFkeyUsingCustomerPkeyUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerProgramOnCustomerProgramForCustomerProgramCustomerIdFkeyNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerProgramCustomerIdFkeyCustomerCreateInput>;
};

/** Input for the nested mutation of `customerProgram` in the `CustomerInput` mutation. */
export type CustomerProgramCustomerIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerProgramCustomerProgramPkeyConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerProgramNodeIdConnect>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerProgramCustomerProgramPkeyDelete>>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerProgramOnCustomerProgramForCustomerProgramCustomerIdFkeyUsingCustomerProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnCustomerProgramForCustomerProgramCustomerIdFkeyNodeIdUpdate>>;
  /** A `CustomerProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerProgramCustomerIdFkeyCustomerProgramCreateInput>>;
};

/** The fields on `customerProgram` to look up the row to connect. */
export type CustomerProgramCustomerProgramPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `customerProgram` to look up the row to delete. */
export type CustomerProgramCustomerProgramPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `CustomerProgramEntry` values. */
export type CustomerProgramEntriesConnection = {
  __typename?: 'CustomerProgramEntriesConnection';
  /** A list of `CustomerProgramEntry` objects. */
  nodes: Array<Maybe<CustomerProgramEntry>>;
  /** A list of edges which contains the `CustomerProgramEntry` and cursor to aid in pagination. */
  edges: Array<CustomerProgramEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerProgramEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CustomerProgramEntry` edge in the connection. */
export type CustomerProgramEntriesEdge = {
  __typename?: 'CustomerProgramEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerProgramEntry` at the end of the edge. */
  node?: Maybe<CustomerProgramEntry>;
};

/** Methods to use when ordering `CustomerProgramEntry`. */
export enum CustomerProgramEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  ProgramDateAsc = 'PROGRAM_DATE_ASC',
  ProgramDateDesc = 'PROGRAM_DATE_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  CustomerProgramIdAsc = 'CUSTOMER_PROGRAM_ID_ASC',
  CustomerProgramIdDesc = 'CUSTOMER_PROGRAM_ID_DESC',
  IsAdWeekAsc = 'IS_AD_WEEK_ASC',
  IsAdWeekDesc = 'IS_AD_WEEK_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerProgramByCustomerProgramIdIdAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__ID_ASC',
  CustomerProgramByCustomerProgramIdIdDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__ID_DESC',
  CustomerProgramByCustomerProgramIdCommonSpeciesIdAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_SPECIES_ID_ASC',
  CustomerProgramByCustomerProgramIdCommonSpeciesIdDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_SPECIES_ID_DESC',
  CustomerProgramByCustomerProgramIdCommonVarietyIdAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_VARIETY_ID_ASC',
  CustomerProgramByCustomerProgramIdCommonVarietyIdDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_VARIETY_ID_DESC',
  CustomerProgramByCustomerProgramIdCommonSizeIdAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_SIZE_ID_ASC',
  CustomerProgramByCustomerProgramIdCommonSizeIdDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_SIZE_ID_DESC',
  CustomerProgramByCustomerProgramIdCommonPackTypeIdAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_PACK_TYPE_ID_ASC',
  CustomerProgramByCustomerProgramIdCommonPackTypeIdDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__COMMON_PACK_TYPE_ID_DESC',
  CustomerProgramByCustomerProgramIdCustomerIdAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__CUSTOMER_ID_ASC',
  CustomerProgramByCustomerProgramIdCustomerIdDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__CUSTOMER_ID_DESC',
  CustomerProgramByCustomerProgramIdArrivalPortAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__ARRIVAL_PORT_ASC',
  CustomerProgramByCustomerProgramIdArrivalPortDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__ARRIVAL_PORT_DESC',
  CustomerProgramByCustomerProgramIdPluAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__PLU_ASC',
  CustomerProgramByCustomerProgramIdPluDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__PLU_DESC',
  CustomerProgramByCustomerProgramIdNotesAsc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__NOTES_ASC',
  CustomerProgramByCustomerProgramIdNotesDesc = 'CUSTOMER_PROGRAM_BY_CUSTOMER_PROGRAM_ID__NOTES_DESC',
  ShipperProgramEntryCustomerProgramEntriesByCustomerProgramEntryIdCountAsc = 'SHIPPER_PROGRAM_ENTRY_CUSTOMER_PROGRAM_ENTRIES_BY_CUSTOMER_PROGRAM_ENTRY_ID__COUNT_ASC',
  ShipperProgramEntryCustomerProgramEntriesByCustomerProgramEntryIdCountDesc = 'SHIPPER_PROGRAM_ENTRY_CUSTOMER_PROGRAM_ENTRIES_BY_CUSTOMER_PROGRAM_ENTRY_ID__COUNT_DESC'
}

export type CustomerProgramEntry = Node & {
  __typename?: 'CustomerProgramEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramId?: Maybe<Scalars['BigInt']>;
  isAdWeek?: Maybe<Scalars['Boolean']>;
  /** Reads a single `CustomerProgram` that is related to this `CustomerProgramEntry`. */
  customerProgram?: Maybe<CustomerProgram>;
  /** Reads and enables pagination through a set of `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntryCustomerProgramEntries: ShipperProgramEntryCustomerProgramEntriesConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `ShipperProgramEntry`. */
  shipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryId: CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdManyToManyConnection;
};


export type CustomerProgramEntryShipperProgramEntryCustomerProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCustomerProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};


export type CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryFilter>;
};

/**
 * A condition to be used against `CustomerProgramEntry` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CustomerProgramEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `programDate` field. */
  programDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `customerProgramId` field. */
  customerProgramId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isAdWeek` field. */
  isAdWeek?: Maybe<Scalars['Boolean']>;
};

/** The fields on `customerProgramEntry` to look up the row to connect. */
export type CustomerProgramEntryCustomerProgramEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `customerProgramEntry` to look up the row to delete. */
export type CustomerProgramEntryCustomerProgramEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The `customerProgram` to be created by this mutation. */
export type CustomerProgramEntryCustomerProgramIdFkeyCustomerProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** The `customerProgramEntry` to be created by this mutation. */
export type CustomerProgramEntryCustomerProgramIdFkeyCustomerProgramEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  isAdWeek?: Maybe<Scalars['Boolean']>;
  customerProgramToCustomerProgramId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customerProgram` in the `CustomerProgramEntryInput` mutation. */
export type CustomerProgramEntryCustomerProgramIdFkeyInput = {
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectById?: Maybe<CustomerProgramCustomerProgramPkeyConnect>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerProgramNodeIdConnect>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteById?: Maybe<CustomerProgramCustomerProgramPkeyDelete>;
  /** The primary key(s) for `customerProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerProgramNodeIdDelete>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateById?: Maybe<CustomerProgramOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyUsingCustomerProgramPkeyUpdate>;
  /** The primary key(s) and patch data for `customerProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerProgramEntryOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyNodeIdUpdate>;
  /** A `CustomerProgramInput` object that will be created and connected to this object. */
  create?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyCustomerProgramCreateInput>;
};

/** Input for the nested mutation of `customerProgramEntry` in the `CustomerProgramInput` mutation. */
export type CustomerProgramEntryCustomerProgramIdFkeyInverseInput = {
  /** Flag indicating whether all other `customerProgramEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerProgramEntryCustomerProgramEntryPkeyConnect>>;
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerProgramEntryNodeIdConnect>>;
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerProgramEntryCustomerProgramEntryPkeyDelete>>;
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerProgramEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerProgramEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerProgramEntryOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyUsingCustomerProgramEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `customerProgramEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerProgramOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyNodeIdUpdate>>;
  /** A `CustomerProgramEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<CustomerProgramEntryCustomerProgramIdFkeyCustomerProgramEntryCreateInput>>;
};

/** A filter to be used against `CustomerProgramEntry` object types. All fields are combined with a logical ‘and.’ */
export type CustomerProgramEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `programDate` field. */
  programDate?: Maybe<DateFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `customerProgramId` field. */
  customerProgramId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `isAdWeek` field. */
  isAdWeek?: Maybe<BooleanFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProgramEntryCustomerProgramEntries` relation. */
  shipperProgramEntryCustomerProgramEntries?: Maybe<CustomerProgramEntryToManyShipperProgramEntryCustomerProgramEntryFilter>;
  /** Some related `shipperProgramEntryCustomerProgramEntries` exist. */
  shipperProgramEntryCustomerProgramEntriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerProgram` relation. */
  customerProgram?: Maybe<CustomerProgramFilter>;
  /** A related `customerProgram` exists. */
  customerProgramExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerProgramEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerProgramEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerProgramEntryFilter>;
};

/** An input for mutations affecting `CustomerProgramEntry` */
export type CustomerProgramEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramId?: Maybe<Scalars['BigInt']>;
  isAdWeek?: Maybe<Scalars['Boolean']>;
  customerProgramToCustomerProgramId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerProgramEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customerProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerProgramEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customerProgramEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramEntryOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: CustomerProgramPatch;
};

/** The fields on `customerProgramEntry` to look up the row to update. */
export type CustomerProgramEntryOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyUsingCustomerProgramEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgramEntry` being updated. */
  patch: UpdateCustomerProgramEntryOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntryCustomerProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgramEntryCustomerProgramEntry` being updated. */
  patch: ShipperProgramEntryCustomerProgramEntryPatch;
};

/** The fields on `customerProgramEntry` to look up the row to update. */
export type CustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyUsingCustomerProgramEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgramEntry` being updated. */
  patch: UpdateCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `CustomerProgramEntry`. Fields that are set will be updated. */
export type CustomerProgramEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramId?: Maybe<Scalars['BigInt']>;
  isAdWeek?: Maybe<Scalars['Boolean']>;
  customerProgramToCustomerProgramId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInverseInput>;
};

/** A connection to a list of `ShipperProgramEntry` values, with data from `ShipperProgramEntryCustomerProgramEntry`. */
export type CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdManyToManyConnection = {
  __typename?: 'CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdManyToManyConnection';
  /** A list of `ShipperProgramEntry` objects. */
  nodes: Array<Maybe<ShipperProgramEntry>>;
  /** A list of edges which contains the `ShipperProgramEntry`, info from the `ShipperProgramEntryCustomerProgramEntry`, and the cursor to aid in pagination. */
  edges: Array<CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProgramEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProgramEntry` edge in the connection, with data from `ShipperProgramEntryCustomerProgramEntry`. */
export type CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdManyToManyEdge = {
  __typename?: 'CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProgramEntry` at the end of the edge. */
  node?: Maybe<ShipperProgramEntry>;
  /** Reads and enables pagination through a set of `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntryCustomerProgramEntries: ShipperProgramEntryCustomerProgramEntriesConnection;
};


/** A `ShipperProgramEntry` edge in the connection, with data from `ShipperProgramEntryCustomerProgramEntry`. */
export type CustomerProgramEntryShipperProgramEntriesByShipperProgramEntryCustomerProgramEntryCustomerProgramEntryIdAndShipperProgramEntryIdManyToManyEdgeShipperProgramEntryCustomerProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCustomerProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};

/** A filter to be used against many `ShipperProgramEntryCustomerProgramEntry` object types. All fields are combined with a logical ‘and.’ */
export type CustomerProgramEntryToManyShipperProgramEntryCustomerProgramEntryFilter = {
  /** Every related `ShipperProgramEntryCustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
  /** Some related `ShipperProgramEntryCustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
  /** No related `ShipperProgramEntryCustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};

/** A filter to be used against `CustomerProgram` object types. All fields are combined with a logical ‘and.’ */
export type CustomerProgramFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `customerProgramEntries` relation. */
  customerProgramEntries?: Maybe<CustomerProgramToManyCustomerProgramEntryFilter>;
  /** Some related `customerProgramEntries` exist. */
  customerProgramEntriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** A related `commonSpecies` exists. */
  commonSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonVariety` relation. */
  commonVariety?: Maybe<CommonVarietyFilter>;
  /** A related `commonVariety` exists. */
  commonVarietyExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSize` relation. */
  commonSize?: Maybe<CommonSizeFilter>;
  /** A related `commonSize` exists. */
  commonSizeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonPackType` relation. */
  commonPackType?: Maybe<CommonPackTypeFilter>;
  /** A related `commonPackType` exists. */
  commonPackTypeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** A related `customer` exists. */
  customerExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerProgramFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerProgramFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerProgramFilter>;
};

/** An input for mutations affecting `CustomerProgram` */
export type CustomerProgramInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerProgramNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerProgramNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customerProgram` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgramEntry` being updated. */
  patch: CustomerProgramEntryPatch;
};

/** The fields on `customerProgram` to look up the row to update. */
export type CustomerProgramOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyUsingCustomerProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: UpdateCustomerProgramOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** The fields on `customerProgram` to look up the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyUsingCustomerProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: CommonSizePatch;
};

/** The fields on `customerProgram` to look up the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonSizeIdFkeyUsingCustomerProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `customerProgram` to look up the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyUsingCustomerProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** The fields on `customerProgram` to look up the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyUsingCustomerProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The fields on `customerProgram` to look up the row to update. */
export type CustomerProgramOnCustomerProgramForCustomerProgramCustomerIdFkeyUsingCustomerProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `customerProgram` being updated. */
  patch: UpdateCustomerProgramOnCustomerProgramForCustomerProgramCustomerIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `CustomerProgram`. Fields that are set will be updated. */
export type CustomerProgramPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** A filter to be used against many `CustomerProgramEntry` object types. All fields are combined with a logical ‘and.’ */
export type CustomerProgramToManyCustomerProgramEntryFilter = {
  /** Every related `CustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerProgramEntryFilter>;
  /** Some related `CustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerProgramEntryFilter>;
  /** No related `CustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerProgramEntryFilter>;
};

/** A connection to a list of `CustomerProgram` values. */
export type CustomerProgramsConnection = {
  __typename?: 'CustomerProgramsConnection';
  /** A list of `CustomerProgram` objects. */
  nodes: Array<Maybe<CustomerProgram>>;
  /** A list of edges which contains the `CustomerProgram` and cursor to aid in pagination. */
  edges: Array<CustomerProgramsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerProgram` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CustomerProgram` edge in the connection. */
export type CustomerProgramsEdge = {
  __typename?: 'CustomerProgramsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerProgram` at the end of the edge. */
  node?: Maybe<CustomerProgram>;
};

/** Methods to use when ordering `CustomerProgram`. */
export enum CustomerProgramsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  CommonVarietyIdAsc = 'COMMON_VARIETY_ID_ASC',
  CommonVarietyIdDesc = 'COMMON_VARIETY_ID_DESC',
  CommonSizeIdAsc = 'COMMON_SIZE_ID_ASC',
  CommonSizeIdDesc = 'COMMON_SIZE_ID_DESC',
  CommonPackTypeIdAsc = 'COMMON_PACK_TYPE_ID_ASC',
  CommonPackTypeIdDesc = 'COMMON_PACK_TYPE_ID_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  ArrivalPortAsc = 'ARRIVAL_PORT_ASC',
  ArrivalPortDesc = 'ARRIVAL_PORT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC',
  CommonVarietyByCommonVarietyIdIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_ASC',
  CommonVarietyByCommonVarietyIdIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_DESC',
  CommonVarietyByCommonVarietyIdVarietyNameAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_ASC',
  CommonVarietyByCommonVarietyIdVarietyNameDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_DESC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_ASC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_DESC',
  CommonVarietyByCommonVarietyIdUiColorAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_ASC',
  CommonVarietyByCommonVarietyIdUiColorDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_DESC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_ASC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_DESC',
  CommonVarietyByCommonVarietyIdProductVarietyIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_ASC',
  CommonVarietyByCommonVarietyIdProductVarietyIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_DESC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSizeByCommonSizeIdIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_ASC',
  CommonSizeByCommonSizeIdIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_DESC',
  CommonSizeByCommonSizeIdSizeNameAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_ASC',
  CommonSizeByCommonSizeIdSizeNameDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_DESC',
  CommonSizeByCommonSizeIdSizeDescriptionAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_ASC',
  CommonSizeByCommonSizeIdSizeDescriptionDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_DESC',
  CommonSizeByCommonSizeIdCommonSpeciesIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_ASC',
  CommonSizeByCommonSizeIdCommonSpeciesIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_DESC',
  CommonSizeByCommonSizeIdProductSizeIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_ASC',
  CommonSizeByCommonSizeIdProductSizeIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_DESC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_ASC',
  CommonPackTypeByCommonPackTypeIdIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_DESC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_ASC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_ASC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_DESC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdPalletWeightAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_ASC',
  CommonPackTypeByCommonPackTypeIdPalletWeightDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_DESC',
  CommonPackTypeByCommonPackTypeIdBoxCountAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_ASC',
  CommonPackTypeByCommonPackTypeIdBoxCountDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_DESC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_ASC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCustomerNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_ASC',
  CustomerByCustomerIdCustomerNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_DESC',
  CustomerByCustomerIdAddress_1Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_ASC',
  CustomerByCustomerIdAddress_1Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_DESC',
  CustomerByCustomerIdAddress_2Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_ASC',
  CustomerByCustomerIdAddress_2Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_DESC',
  CustomerByCustomerIdCityAsc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_ASC',
  CustomerByCustomerIdCityDesc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_DESC',
  CustomerByCustomerIdPostalStateAsc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_ASC',
  CustomerByCustomerIdPostalStateDesc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_DESC',
  CustomerByCustomerIdZipCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_ASC',
  CustomerByCustomerIdZipCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_DESC',
  CustomerByCustomerIdCountryIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_ASC',
  CustomerByCustomerIdCountryIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerByCustomerIdLogoSrcAsc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_ASC',
  CustomerByCustomerIdLogoSrcDesc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_DESC',
  CustomerByCustomerIdNotesAsc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_ASC',
  CustomerByCustomerIdNotesDesc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_DESC',
  CustomerByCustomerIdWebsiteAsc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_ASC',
  CustomerByCustomerIdWebsiteDesc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_DESC',
  CustomerByCustomerIdActiveAsc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_ASC',
  CustomerByCustomerIdActiveDesc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_DESC',
  CustomerByCustomerIdSalesUserCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_ASC',
  CustomerByCustomerIdSalesUserCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_DESC',
  CustomerProgramEntriesByCustomerProgramIdCountAsc = 'CUSTOMER_PROGRAM_ENTRIES_BY_CUSTOMER_PROGRAM_ID__COUNT_ASC',
  CustomerProgramEntriesByCustomerProgramIdCountDesc = 'CUSTOMER_PROGRAM_ENTRIES_BY_CUSTOMER_PROGRAM_ID__COUNT_DESC'
}

/** A connection to a list of `Shipper` values, with data from `ShipperProgram`. */
export type CustomerShippersByShipperProgramCustomerIdAndShipperIdManyToManyConnection = {
  __typename?: 'CustomerShippersByShipperProgramCustomerIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<CustomerShippersByShipperProgramCustomerIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CustomerShippersByShipperProgramCustomerIdAndShipperIdManyToManyEdge = {
  __typename?: 'CustomerShippersByShipperProgramCustomerIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProgram`. */
export type CustomerShippersByShipperProgramCustomerIdAndShipperIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionProduct`. */
export type CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdManyToManyConnection = {
  __typename?: 'CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdManyToManyEdge = {
  __typename?: 'CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionProduct`. */
export type CustomerShippersByShipperProjectionProductCustomerIdAndShipperIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against many `CustomerPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyCustomerPersonContactFilter = {
  /** Every related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerPersonContactFilter>;
  /** Some related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerPersonContactFilter>;
  /** No related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerPersonContactFilter>;
};

/** A filter to be used against many `CustomerProgram` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyCustomerProgramFilter = {
  /** Every related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerProgramFilter>;
  /** Some related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerProgramFilter>;
  /** No related `CustomerProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerProgramFilter>;
};

/** A filter to be used against many `ShipperProgram` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyShipperProgramFilter = {
  /** Every related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramFilter>;
  /** Some related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramFilter>;
  /** No related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramFilter>;
};

/** A filter to be used against many `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyShipperProjectionProductFilter = {
  /** Every related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionProductFilter>;
  /** Some related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionProductFilter>;
  /** No related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against many `TruckRateCustomer` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyTruckRateCustomerFilter = {
  /** Every related `TruckRateCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TruckRateCustomerFilter>;
  /** Some related `TruckRateCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TruckRateCustomerFilter>;
  /** No related `TruckRateCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TruckRateCustomerFilter>;
};

/** A connection to a list of `TruckRate` values, with data from `TruckRateCustomer`. */
export type CustomerTruckRatesByTruckRateCustomerCustomerIdAndTruckRateIdManyToManyConnection = {
  __typename?: 'CustomerTruckRatesByTruckRateCustomerCustomerIdAndTruckRateIdManyToManyConnection';
  /** A list of `TruckRate` objects. */
  nodes: Array<Maybe<TruckRate>>;
  /** A list of edges which contains the `TruckRate`, info from the `TruckRateCustomer`, and the cursor to aid in pagination. */
  edges: Array<CustomerTruckRatesByTruckRateCustomerCustomerIdAndTruckRateIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TruckRate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TruckRate` edge in the connection, with data from `TruckRateCustomer`. */
export type CustomerTruckRatesByTruckRateCustomerCustomerIdAndTruckRateIdManyToManyEdge = {
  __typename?: 'CustomerTruckRatesByTruckRateCustomerCustomerIdAndTruckRateIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TruckRate` at the end of the edge. */
  node?: Maybe<TruckRate>;
};

export type CustomerVolumeDiscount = Node & {
  __typename?: 'CustomerVolumeDiscount';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  customerId?: Maybe<Scalars['String']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['BigFloat']>;
  customer?: Maybe<Customer>;
};

/**
 * A condition to be used against `CustomerVolumeDiscount` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CustomerVolumeDiscountCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `CustomerVolumeDiscount` object types. All fields are combined with a logical ‘and.’ */
export type CustomerVolumeDiscountFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerVolumeDiscountFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerVolumeDiscountFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerVolumeDiscountFilter>;
};

/** An input for mutations affecting `CustomerVolumeDiscount` */
export type CustomerVolumeDiscountInput = {
  id?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['BigFloat']>;
};

/** Represents an update to a `CustomerVolumeDiscount`. Fields that are set will be updated. */
export type CustomerVolumeDiscountPatch = {
  id?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `CustomerVolumeDiscount` values. */
export type CustomerVolumeDiscountsConnection = {
  __typename?: 'CustomerVolumeDiscountsConnection';
  /** A list of `CustomerVolumeDiscount` objects. */
  nodes: Array<Maybe<CustomerVolumeDiscount>>;
  /** A list of edges which contains the `CustomerVolumeDiscount` and cursor to aid in pagination. */
  edges: Array<CustomerVolumeDiscountsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerVolumeDiscount` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CustomerVolumeDiscount` edge in the connection. */
export type CustomerVolumeDiscountsEdge = {
  __typename?: 'CustomerVolumeDiscountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerVolumeDiscount` at the end of the edge. */
  node?: Maybe<CustomerVolumeDiscount>;
};

/** Methods to use when ordering `CustomerVolumeDiscount`. */
export enum CustomerVolumeDiscountsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  VolumeDiscountCodeAsc = 'VOLUME_DISCOUNT_CODE_ASC',
  VolumeDiscountCodeDesc = 'VOLUME_DISCOUNT_CODE_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Customer` values. */
export type CustomersConnection = {
  __typename?: 'CustomersConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer` and cursor to aid in pagination. */
  edges: Array<CustomersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection. */
export type CustomersEdge = {
  __typename?: 'CustomersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** Methods to use when ordering `Customer`. */
export enum CustomersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CustomerNameAsc = 'CUSTOMER_NAME_ASC',
  CustomerNameDesc = 'CUSTOMER_NAME_DESC',
  Address_1Asc = 'ADDRESS_1_ASC',
  Address_1Desc = 'ADDRESS_1_DESC',
  Address_2Asc = 'ADDRESS_2_ASC',
  Address_2Desc = 'ADDRESS_2_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  PostalStateAsc = 'POSTAL_STATE_ASC',
  PostalStateDesc = 'POSTAL_STATE_DESC',
  ZipCodeAsc = 'ZIP_CODE_ASC',
  ZipCodeDesc = 'ZIP_CODE_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  LogoSrcAsc = 'LOGO_SRC_ASC',
  LogoSrcDesc = 'LOGO_SRC_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  WebsiteAsc = 'WEBSITE_ASC',
  WebsiteDesc = 'WEBSITE_DESC',
  ActiveAsc = 'ACTIVE_ASC',
  ActiveDesc = 'ACTIVE_DESC',
  SalesUserCodeAsc = 'SALES_USER_CODE_ASC',
  SalesUserCodeDesc = 'SALES_USER_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperProjectionProductsByCustomerIdCountAsc = 'SHIPPER_PROJECTION_PRODUCTS_BY_CUSTOMER_ID__COUNT_ASC',
  ShipperProjectionProductsByCustomerIdCountDesc = 'SHIPPER_PROJECTION_PRODUCTS_BY_CUSTOMER_ID__COUNT_DESC',
  CustomerPersonContactsByCustomerIdCountAsc = 'CUSTOMER_PERSON_CONTACTS_BY_CUSTOMER_ID__COUNT_ASC',
  CustomerPersonContactsByCustomerIdCountDesc = 'CUSTOMER_PERSON_CONTACTS_BY_CUSTOMER_ID__COUNT_DESC',
  ShipperProgramsByCustomerIdCountAsc = 'SHIPPER_PROGRAMS_BY_CUSTOMER_ID__COUNT_ASC',
  ShipperProgramsByCustomerIdCountDesc = 'SHIPPER_PROGRAMS_BY_CUSTOMER_ID__COUNT_DESC',
  CustomerProgramsByCustomerIdCountAsc = 'CUSTOMER_PROGRAMS_BY_CUSTOMER_ID__COUNT_ASC',
  CustomerProgramsByCustomerIdCountDesc = 'CUSTOMER_PROGRAMS_BY_CUSTOMER_ID__COUNT_DESC',
  TruckRateCustomersByCustomerIdCountAsc = 'TRUCK_RATE_CUSTOMERS_BY_CUSTOMER_ID__COUNT_ASC',
  TruckRateCustomersByCustomerIdCountDesc = 'TRUCK_RATE_CUSTOMERS_BY_CUSTOMER_ID__COUNT_DESC'
}

export type Db2QueryInput = {
  queryString: Scalars['String'];
};


/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Date']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Date']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Date']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Date']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Date']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Date']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Date']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Date']>;
};


/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
};

/** All input for the `deleteAgendaItemByNodeId` mutation. */
export type DeleteAgendaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AgendaItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAgendaItem` mutation. */
export type DeleteAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `AgendaItem` mutation. */
export type DeleteAgendaItemPayload = {
  __typename?: 'DeleteAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` that was deleted by this mutation. */
  agendaItem?: Maybe<AgendaItem>;
  deletedAgendaItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AgendaItem`. May be used by Relay 1. */
  agendaItemEdge?: Maybe<AgendaItemsEdge>;
};


/** The output of our delete `AgendaItem` mutation. */
export type DeleteAgendaItemPayloadAgendaItemEdgeArgs = {
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
};

/** All input for the `deleteCalendarEventByNodeId` mutation. */
export type DeleteCalendarEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CalendarEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCalendarEvent` mutation. */
export type DeleteCalendarEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CalendarEvent` mutation. */
export type DeleteCalendarEventPayload = {
  __typename?: 'DeleteCalendarEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` that was deleted by this mutation. */
  calendarEvent?: Maybe<CalendarEvent>;
  deletedCalendarEventNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CalendarEvent`. May be used by Relay 1. */
  calendarEventEdge?: Maybe<CalendarEventsEdge>;
};


/** The output of our delete `CalendarEvent` mutation. */
export type DeleteCalendarEventPayloadCalendarEventEdgeArgs = {
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
};

/** All input for the `deleteCheckHeaderByNodeId` mutation. */
export type DeleteCheckHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CheckHeader` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCheckHeader` mutation. */
export type DeleteCheckHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CheckHeader` mutation. */
export type DeleteCheckHeaderPayload = {
  __typename?: 'DeleteCheckHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CheckHeader` that was deleted by this mutation. */
  checkHeader?: Maybe<CheckHeader>;
  deletedCheckHeaderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CheckHeader`. May be used by Relay 1. */
  checkHeaderEdge?: Maybe<CheckHeadersEdge>;
};


/** The output of our delete `CheckHeader` mutation. */
export type DeleteCheckHeaderPayloadCheckHeaderEdgeArgs = {
  orderBy?: Maybe<Array<CheckHeadersOrderBy>>;
};

/** All input for the `deleteChileDepartureInspectionPalletByNodeId` mutation. */
export type DeleteChileDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChileDepartureInspectionPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChileDepartureInspectionPallet` mutation. */
export type DeleteChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ChileDepartureInspectionPallet` mutation. */
export type DeleteChileDepartureInspectionPalletPayload = {
  __typename?: 'DeleteChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` that was deleted by this mutation. */
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  deletedChileDepartureInspectionPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ChileDepartureInspectionPallet`. May be used by Relay 1. */
  chileDepartureInspectionPalletEdge?: Maybe<ChileDepartureInspectionPalletsEdge>;
};


/** The output of our delete `ChileDepartureInspectionPallet` mutation. */
export type DeleteChileDepartureInspectionPalletPayloadChileDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
};

/** All input for the `deleteCommonCategoryByNodeId` mutation. */
export type DeleteCommonCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonCategory` mutation. */
export type DeleteCommonCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonCategory` mutation. */
export type DeleteCommonCategoryPayload = {
  __typename?: 'DeleteCommonCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonCategory` that was deleted by this mutation. */
  commonCategory?: Maybe<CommonCategory>;
  deletedCommonCategoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CommonCategory`. May be used by Relay 1. */
  commonCategoryEdge?: Maybe<CommonCategoriesEdge>;
};


/** The output of our delete `CommonCategory` mutation. */
export type DeleteCommonCategoryPayloadCommonCategoryEdgeArgs = {
  orderBy?: Maybe<Array<CommonCategoriesOrderBy>>;
};

/** All input for the `deleteCommonPackTypeByNodeId` mutation. */
export type DeleteCommonPackTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonPackType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonPackType` mutation. */
export type DeleteCommonPackTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteCommonPackTypePackMasterByNodeId` mutation. */
export type DeleteCommonPackTypePackMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonPackTypePackMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonPackTypePackMaster` mutation. */
export type DeleteCommonPackTypePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonPackTypePackMaster` mutation. */
export type DeleteCommonPackTypePackMasterPayload = {
  __typename?: 'DeleteCommonPackTypePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypePackMaster` that was deleted by this mutation. */
  commonPackTypePackMaster?: Maybe<CommonPackTypePackMaster>;
  deletedCommonPackTypePackMasterNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypePackMaster`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `PackMaster` that is related to this `CommonPackTypePackMaster`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackTypePackMaster`. May be used by Relay 1. */
  commonPackTypePackMasterEdge?: Maybe<CommonPackTypePackMastersEdge>;
};


/** The output of our delete `CommonPackTypePackMaster` mutation. */
export type DeleteCommonPackTypePackMasterPayloadCommonPackTypePackMasterEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
};

/** The output of our delete `CommonPackType` mutation. */
export type DeleteCommonPackTypePayload = {
  __typename?: 'DeleteCommonPackTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackType` that was deleted by this mutation. */
  commonPackType?: Maybe<CommonPackType>;
  deletedCommonPackTypeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonPackType`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `PackMaster` that is related to this `CommonPackType`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackType`. May be used by Relay 1. */
  commonPackTypeEdge?: Maybe<CommonPackTypesEdge>;
};


/** The output of our delete `CommonPackType` mutation. */
export type DeleteCommonPackTypePayloadCommonPackTypeEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
};

/** All input for the `deleteCommonPackTypeTagByNodeId` mutation. */
export type DeleteCommonPackTypeTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonPackTypeTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonPackTypeTag` mutation. */
export type DeleteCommonPackTypeTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  tagText: Scalars['String'];
  commonPackTypeId: Scalars['BigInt'];
};

/** The output of our delete `CommonPackTypeTag` mutation. */
export type DeleteCommonPackTypeTagPayload = {
  __typename?: 'DeleteCommonPackTypeTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypeTag` that was deleted by this mutation. */
  commonPackTypeTag?: Maybe<CommonPackTypeTag>;
  deletedCommonPackTypeTagNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypeTag`. */
  commonPackType?: Maybe<CommonPackType>;
  /** An edge for our `CommonPackTypeTag`. May be used by Relay 1. */
  commonPackTypeTagEdge?: Maybe<CommonPackTypeTagsEdge>;
};


/** The output of our delete `CommonPackTypeTag` mutation. */
export type DeleteCommonPackTypeTagPayloadCommonPackTypeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypeTagsOrderBy>>;
};

/** All input for the `deleteCommonSizeByNodeId` mutation. */
export type DeleteCommonSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonSize` mutation. */
export type DeleteCommonSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonSize` mutation. */
export type DeleteCommonSizePayload = {
  __typename?: 'DeleteCommonSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSize` that was deleted by this mutation. */
  commonSize?: Maybe<CommonSize>;
  deletedCommonSizeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSize`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSize` that is related to this `CommonSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSize`. May be used by Relay 1. */
  commonSizeEdge?: Maybe<CommonSizesEdge>;
};


/** The output of our delete `CommonSize` mutation. */
export type DeleteCommonSizePayloadCommonSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
};

/** All input for the `deleteCommonSizeProductSizeByNodeId` mutation. */
export type DeleteCommonSizeProductSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSizeProductSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonSizeProductSize` mutation. */
export type DeleteCommonSizeProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonSizeProductSize` mutation. */
export type DeleteCommonSizeProductSizePayload = {
  __typename?: 'DeleteCommonSizeProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeProductSize` that was deleted by this mutation. */
  commonSizeProductSize?: Maybe<CommonSizeProductSize>;
  deletedCommonSizeProductSizeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeProductSize`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `ProductSize` that is related to this `CommonSizeProductSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSizeProductSize`. May be used by Relay 1. */
  commonSizeProductSizeEdge?: Maybe<CommonSizeProductSizesEdge>;
};


/** The output of our delete `CommonSizeProductSize` mutation. */
export type DeleteCommonSizeProductSizePayloadCommonSizeProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
};

/** All input for the `deleteCommonSizeTagByNodeId` mutation. */
export type DeleteCommonSizeTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSizeTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonSizeTag` mutation. */
export type DeleteCommonSizeTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  tagText: Scalars['String'];
  commonSizeId: Scalars['BigInt'];
};

/** The output of our delete `CommonSizeTag` mutation. */
export type DeleteCommonSizeTagPayload = {
  __typename?: 'DeleteCommonSizeTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeTag` that was deleted by this mutation. */
  commonSizeTag?: Maybe<CommonSizeTag>;
  deletedCommonSizeTagNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeTag`. */
  commonSize?: Maybe<CommonSize>;
  /** An edge for our `CommonSizeTag`. May be used by Relay 1. */
  commonSizeTagEdge?: Maybe<CommonSizeTagsEdge>;
};


/** The output of our delete `CommonSizeTag` mutation. */
export type DeleteCommonSizeTagPayloadCommonSizeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeTagsOrderBy>>;
};

/** All input for the `deleteCommonSpeciesByNodeId` mutation. */
export type DeleteCommonSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSpecies` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonSpecies` mutation. */
export type DeleteCommonSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonSpecies` mutation. */
export type DeleteCommonSpeciesPayload = {
  __typename?: 'DeleteCommonSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpecies` that was deleted by this mutation. */
  commonSpecies?: Maybe<CommonSpecies>;
  deletedCommonSpeciesNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonCategory` that is related to this `CommonSpecies`. */
  commonCategory?: Maybe<CommonCategory>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpecies`. May be used by Relay 1. */
  commonSpeciesEdge?: Maybe<CommonSpeciesEdge>;
};


/** The output of our delete `CommonSpecies` mutation. */
export type DeleteCommonSpeciesPayloadCommonSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
};

/** All input for the `deleteCommonSpeciesProductSpeciesByNodeId` mutation. */
export type DeleteCommonSpeciesProductSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSpeciesProductSpecies` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonSpeciesProductSpecies` mutation. */
export type DeleteCommonSpeciesProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonSpeciesProductSpecies` mutation. */
export type DeleteCommonSpeciesProductSpeciesPayload = {
  __typename?: 'DeleteCommonSpeciesProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesProductSpecies` that was deleted by this mutation. */
  commonSpeciesProductSpecies?: Maybe<CommonSpeciesProductSpecies>;
  deletedCommonSpeciesProductSpeciesNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpeciesProductSpecies`. May be used by Relay 1. */
  commonSpeciesProductSpeciesEdge?: Maybe<CommonSpeciesProductSpeciesEdge>;
};


/** The output of our delete `CommonSpeciesProductSpecies` mutation. */
export type DeleteCommonSpeciesProductSpeciesPayloadCommonSpeciesProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
};

/** All input for the `deleteCommonSpeciesTagByNodeId` mutation. */
export type DeleteCommonSpeciesTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSpeciesTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonSpeciesTag` mutation. */
export type DeleteCommonSpeciesTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  tagText: Scalars['String'];
  commonSpeciesId: Scalars['BigInt'];
};

/** The output of our delete `CommonSpeciesTag` mutation. */
export type DeleteCommonSpeciesTagPayload = {
  __typename?: 'DeleteCommonSpeciesTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesTag` that was deleted by this mutation. */
  commonSpeciesTag?: Maybe<CommonSpeciesTag>;
  deletedCommonSpeciesTagNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesTag`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** An edge for our `CommonSpeciesTag`. May be used by Relay 1. */
  commonSpeciesTagEdge?: Maybe<CommonSpeciesTagsEdge>;
};


/** The output of our delete `CommonSpeciesTag` mutation. */
export type DeleteCommonSpeciesTagPayloadCommonSpeciesTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesTagsOrderBy>>;
};

/** All input for the `deleteCommonVarietyByNodeId` mutation. */
export type DeleteCommonVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonVariety` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonVariety` mutation. */
export type DeleteCommonVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonVariety` mutation. */
export type DeleteCommonVarietyPayload = {
  __typename?: 'DeleteCommonVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVariety` that was deleted by this mutation. */
  commonVariety?: Maybe<CommonVariety>;
  deletedCommonVarietyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonVariety`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductVariety` that is related to this `CommonVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVariety`. May be used by Relay 1. */
  commonVarietyEdge?: Maybe<CommonVarietiesEdge>;
};


/** The output of our delete `CommonVariety` mutation. */
export type DeleteCommonVarietyPayloadCommonVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
};

/** All input for the `deleteCommonVarietyProductVarietyByNodeId` mutation. */
export type DeleteCommonVarietyProductVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonVarietyProductVariety` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonVarietyProductVariety` mutation. */
export type DeleteCommonVarietyProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CommonVarietyProductVariety` mutation. */
export type DeleteCommonVarietyProductVarietyPayload = {
  __typename?: 'DeleteCommonVarietyProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyProductVariety` that was deleted by this mutation. */
  commonVarietyProductVariety?: Maybe<CommonVarietyProductVariety>;
  deletedCommonVarietyProductVarietyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyProductVariety`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `ProductVariety` that is related to this `CommonVarietyProductVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVarietyProductVariety`. May be used by Relay 1. */
  commonVarietyProductVarietyEdge?: Maybe<CommonVarietyProductVarietiesEdge>;
};


/** The output of our delete `CommonVarietyProductVariety` mutation. */
export type DeleteCommonVarietyProductVarietyPayloadCommonVarietyProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
};

/** All input for the `deleteCommonVarietyTagByNodeId` mutation. */
export type DeleteCommonVarietyTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonVarietyTag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommonVarietyTag` mutation. */
export type DeleteCommonVarietyTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  tagText: Scalars['String'];
  commonVarietyId: Scalars['BigInt'];
};

/** The output of our delete `CommonVarietyTag` mutation. */
export type DeleteCommonVarietyTagPayload = {
  __typename?: 'DeleteCommonVarietyTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyTag` that was deleted by this mutation. */
  commonVarietyTag?: Maybe<CommonVarietyTag>;
  deletedCommonVarietyTagNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyTag`. */
  commonVariety?: Maybe<CommonVariety>;
  /** An edge for our `CommonVarietyTag`. May be used by Relay 1. */
  commonVarietyTagEdge?: Maybe<CommonVarietyTagsEdge>;
};


/** The output of our delete `CommonVarietyTag` mutation. */
export type DeleteCommonVarietyTagPayloadCommonVarietyTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyTagsOrderBy>>;
};

/** All input for the `deleteContactGroupByNodeId` mutation. */
export type DeleteContactGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContactGroup` mutation. */
export type DeleteContactGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ContactGroup` mutation. */
export type DeleteContactGroupPayload = {
  __typename?: 'DeleteContactGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` that was deleted by this mutation. */
  contactGroup?: Maybe<ContactGroup>;
  deletedContactGroupNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** An edge for our `ContactGroup`. May be used by Relay 1. */
  contactGroupEdge?: Maybe<ContactGroupsEdge>;
};


/** The output of our delete `ContactGroup` mutation. */
export type DeleteContactGroupPayloadContactGroupEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
};

/** All input for the `deleteContactGroupPersonContactByNodeId` mutation. */
export type DeleteContactGroupPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroupPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContactGroupPersonContact` mutation. */
export type DeleteContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `ContactGroupPersonContact` mutation. */
export type DeleteContactGroupPersonContactPayload = {
  __typename?: 'DeleteContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` that was deleted by this mutation. */
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  deletedContactGroupPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ContactGroupPersonContact`. May be used by Relay 1. */
  contactGroupPersonContactEdge?: Maybe<ContactGroupPersonContactsEdge>;
};


/** The output of our delete `ContactGroupPersonContact` mutation. */
export type DeleteContactGroupPersonContactPayloadContactGroupPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
};

/** All input for the `deleteContainerByNodeId` mutation. */
export type DeleteContainerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Container` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContainer` mutation. */
export type DeleteContainerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Container` mutation. */
export type DeleteContainerPayload = {
  __typename?: 'DeleteContainerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Container` that was deleted by this mutation. */
  container?: Maybe<Container>;
  deletedContainerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Container`. May be used by Relay 1. */
  containerEdge?: Maybe<ContainersEdge>;
};


/** The output of our delete `Container` mutation. */
export type DeleteContainerPayloadContainerEdgeArgs = {
  orderBy?: Maybe<Array<ContainersOrderBy>>;
};

/** All input for the `deleteContainerTreatmentByNodeId` mutation. */
export type DeleteContainerTreatmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContainerTreatment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContainerTreatment` mutation. */
export type DeleteContainerTreatmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ContainerTreatment` mutation. */
export type DeleteContainerTreatmentPayload = {
  __typename?: 'DeleteContainerTreatmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContainerTreatment` that was deleted by this mutation. */
  containerTreatment?: Maybe<ContainerTreatment>;
  deletedContainerTreatmentNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Container` that is related to this `ContainerTreatment`. */
  container?: Maybe<Container>;
  /** An edge for our `ContainerTreatment`. May be used by Relay 1. */
  containerTreatmentEdge?: Maybe<ContainerTreatmentsEdge>;
};


/** The output of our delete `ContainerTreatment` mutation. */
export type DeleteContainerTreatmentPayloadContainerTreatmentEdgeArgs = {
  orderBy?: Maybe<Array<ContainerTreatmentsOrderBy>>;
};

/** All input for the `deleteCountryByNodeId` mutation. */
export type DeleteCountryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCountry` mutation. */
export type DeleteCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `Country` mutation. */
export type DeleteCountryPayload = {
  __typename?: 'DeleteCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was deleted by this mutation. */
  country?: Maybe<Country>;
  deletedCountryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our delete `Country` mutation. */
export type DeleteCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the `deleteCustomerByNodeId` mutation. */
export type DeleteCustomerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomer` mutation. */
export type DeleteCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayload = {
  __typename?: 'DeleteCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was deleted by this mutation. */
  customer?: Maybe<Customer>;
  deletedCustomerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the `deleteCustomerPaymentByNodeId` mutation. */
export type DeleteCustomerPaymentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerPayment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerPayment` mutation. */
export type DeleteCustomerPaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CustomerPayment` mutation. */
export type DeleteCustomerPaymentPayload = {
  __typename?: 'DeleteCustomerPaymentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPayment` that was deleted by this mutation. */
  customerPayment?: Maybe<CustomerPayment>;
  deletedCustomerPaymentNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerPayment`. May be used by Relay 1. */
  customerPaymentEdge?: Maybe<CustomerPaymentsEdge>;
};


/** The output of our delete `CustomerPayment` mutation. */
export type DeleteCustomerPaymentPayloadCustomerPaymentEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPaymentsOrderBy>>;
};

/** All input for the `deleteCustomerPersonContactByNodeId` mutation. */
export type DeleteCustomerPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerPersonContact` mutation. */
export type DeleteCustomerPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `CustomerPersonContact` mutation. */
export type DeleteCustomerPersonContactPayload = {
  __typename?: 'DeleteCustomerPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` that was deleted by this mutation. */
  customerPersonContact?: Maybe<CustomerPersonContact>;
  deletedCustomerPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `CustomerPersonContact`. May be used by Relay 1. */
  customerPersonContactEdge?: Maybe<CustomerPersonContactsEdge>;
};


/** The output of our delete `CustomerPersonContact` mutation. */
export type DeleteCustomerPersonContactPayloadCustomerPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
};

/** All input for the `deleteCustomerProgramByNodeId` mutation. */
export type DeleteCustomerProgramByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerProgram` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerProgramEntryByNodeId` mutation. */
export type DeleteCustomerProgramEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerProgramEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerProgramEntry` mutation. */
export type DeleteCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CustomerProgramEntry` mutation. */
export type DeleteCustomerProgramEntryPayload = {
  __typename?: 'DeleteCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgramEntry` that was deleted by this mutation. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  deletedCustomerProgramEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgram` that is related to this `CustomerProgramEntry`. */
  customerProgram?: Maybe<CustomerProgram>;
  /** An edge for our `CustomerProgramEntry`. May be used by Relay 1. */
  customerProgramEntryEdge?: Maybe<CustomerProgramEntriesEdge>;
};


/** The output of our delete `CustomerProgramEntry` mutation. */
export type DeleteCustomerProgramEntryPayloadCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramEntriesOrderBy>>;
};

/** All input for the `deleteCustomerProgram` mutation. */
export type DeleteCustomerProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CustomerProgram` mutation. */
export type DeleteCustomerProgramPayload = {
  __typename?: 'DeleteCustomerProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgram` that was deleted by this mutation. */
  customerProgram?: Maybe<CustomerProgram>;
  deletedCustomerProgramNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CustomerProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `CustomerProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `CustomerProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `CustomerProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `CustomerProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `CustomerProgram`. May be used by Relay 1. */
  customerProgramEdge?: Maybe<CustomerProgramsEdge>;
};


/** The output of our delete `CustomerProgram` mutation. */
export type DeleteCustomerProgramPayloadCustomerProgramEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
};

/** All input for the `deleteCustomerVolumeDiscountByNodeId` mutation. */
export type DeleteCustomerVolumeDiscountByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerVolumeDiscount` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerVolumeDiscount` mutation. */
export type DeleteCustomerVolumeDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CustomerVolumeDiscount` mutation. */
export type DeleteCustomerVolumeDiscountPayload = {
  __typename?: 'DeleteCustomerVolumeDiscountPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerVolumeDiscount` that was deleted by this mutation. */
  customerVolumeDiscount?: Maybe<CustomerVolumeDiscount>;
  deletedCustomerVolumeDiscountNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerVolumeDiscount`. May be used by Relay 1. */
  customerVolumeDiscountEdge?: Maybe<CustomerVolumeDiscountsEdge>;
};


/** The output of our delete `CustomerVolumeDiscount` mutation. */
export type DeleteCustomerVolumeDiscountPayloadCustomerVolumeDiscountEdgeArgs = {
  orderBy?: Maybe<Array<CustomerVolumeDiscountsOrderBy>>;
};

/** All input for the `deleteExpenseHeaderByNodeId` mutation. */
export type DeleteExpenseHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ExpenseHeader` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteExpenseHeader` mutation. */
export type DeleteExpenseHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ExpenseHeader` mutation. */
export type DeleteExpenseHeaderPayload = {
  __typename?: 'DeleteExpenseHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeader` that was deleted by this mutation. */
  expenseHeader?: Maybe<ExpenseHeader>;
  deletedExpenseHeaderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeader`. May be used by Relay 1. */
  expenseHeaderEdge?: Maybe<ExpenseHeadersEdge>;
};


/** The output of our delete `ExpenseHeader` mutation. */
export type DeleteExpenseHeaderPayloadExpenseHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeadersOrderBy>>;
};

/** All input for the `deleteExpenseHeaderReviewByNodeId` mutation. */
export type DeleteExpenseHeaderReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ExpenseHeaderReview` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteExpenseHeaderReview` mutation. */
export type DeleteExpenseHeaderReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ExpenseHeaderReview` mutation. */
export type DeleteExpenseHeaderReviewPayload = {
  __typename?: 'DeleteExpenseHeaderReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeaderReview` that was deleted by this mutation. */
  expenseHeaderReview?: Maybe<ExpenseHeaderReview>;
  deletedExpenseHeaderReviewNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeaderReview`. May be used by Relay 1. */
  expenseHeaderReviewEdge?: Maybe<ExpenseHeaderReviewsEdge>;
};


/** The output of our delete `ExpenseHeaderReview` mutation. */
export type DeleteExpenseHeaderReviewPayloadExpenseHeaderReviewEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeaderReviewsOrderBy>>;
};

/** All input for the `deleteExpenseItemByNodeId` mutation. */
export type DeleteExpenseItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ExpenseItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteExpenseItem` mutation. */
export type DeleteExpenseItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ExpenseItem` mutation. */
export type DeleteExpenseItemPayload = {
  __typename?: 'DeleteExpenseItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseItem` that was deleted by this mutation. */
  expenseItem?: Maybe<ExpenseItem>;
  deletedExpenseItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseItem`. May be used by Relay 1. */
  expenseItemEdge?: Maybe<ExpenseItemsEdge>;
};


/** The output of our delete `ExpenseItem` mutation. */
export type DeleteExpenseItemPayloadExpenseItemEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseItemsOrderBy>>;
};

/** All input for the `deleteInventoryItemByNodeId` mutation. */
export type DeleteInventoryItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InventoryItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInventoryItem` mutation. */
export type DeleteInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `InventoryItem` mutation. */
export type DeleteInventoryItemPayload = {
  __typename?: 'DeleteInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` that was deleted by this mutation. */
  inventoryItem?: Maybe<InventoryItem>;
  deletedInventoryItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InventoryItem`. May be used by Relay 1. */
  inventoryItemEdge?: Maybe<InventoryItemsEdge>;
};


/** The output of our delete `InventoryItem` mutation. */
export type DeleteInventoryItemPayloadInventoryItemEdgeArgs = {
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
};

/** All input for the `deleteInvoiceHeaderByNodeId` mutation. */
export type DeleteInvoiceHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InvoiceHeader` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInvoiceHeader` mutation. */
export type DeleteInvoiceHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `InvoiceHeader` mutation. */
export type DeleteInvoiceHeaderPayload = {
  __typename?: 'DeleteInvoiceHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceHeader` that was deleted by this mutation. */
  invoiceHeader?: Maybe<InvoiceHeader>;
  deletedInvoiceHeaderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceHeader`. May be used by Relay 1. */
  invoiceHeaderEdge?: Maybe<InvoiceHeadersEdge>;
};


/** The output of our delete `InvoiceHeader` mutation. */
export type DeleteInvoiceHeaderPayloadInvoiceHeaderEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceHeadersOrderBy>>;
};

/** All input for the `deleteInvoiceItemByNodeId` mutation. */
export type DeleteInvoiceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InvoiceItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInvoiceItemHistoryByNodeId` mutation. */
export type DeleteInvoiceItemHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InvoiceItemHistory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInvoiceItemHistory` mutation. */
export type DeleteInvoiceItemHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `InvoiceItemHistory` mutation. */
export type DeleteInvoiceItemHistoryPayload = {
  __typename?: 'DeleteInvoiceItemHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItemHistory` that was deleted by this mutation. */
  invoiceItemHistory?: Maybe<InvoiceItemHistory>;
  deletedInvoiceItemHistoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItemHistory`. May be used by Relay 1. */
  invoiceItemHistoryEdge?: Maybe<InvoiceItemHistoriesEdge>;
};


/** The output of our delete `InvoiceItemHistory` mutation. */
export type DeleteInvoiceItemHistoryPayloadInvoiceItemHistoryEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemHistoriesOrderBy>>;
};

/** All input for the `deleteInvoiceItem` mutation. */
export type DeleteInvoiceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `InvoiceItem` mutation. */
export type DeleteInvoiceItemPayload = {
  __typename?: 'DeleteInvoiceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItem` that was deleted by this mutation. */
  invoiceItem?: Maybe<InvoiceItem>;
  deletedInvoiceItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItem`. May be used by Relay 1. */
  invoiceItemEdge?: Maybe<InvoiceItemsEdge>;
};


/** The output of our delete `InvoiceItem` mutation. */
export type DeleteInvoiceItemPayloadInvoiceItemEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemsOrderBy>>;
};

/** All input for the `deleteLoadNumberByNodeId` mutation. */
export type DeleteLoadNumberByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LoadNumber` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLoadNumber` mutation. */
export type DeleteLoadNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `LoadNumber` mutation. */
export type DeleteLoadNumberPayload = {
  __typename?: 'DeleteLoadNumberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LoadNumber` that was deleted by this mutation. */
  loadNumber?: Maybe<LoadNumber>;
  deletedLoadNumberNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LoadNumber`. */
  user?: Maybe<User>;
  /** An edge for our `LoadNumber`. May be used by Relay 1. */
  loadNumberEdge?: Maybe<LoadNumbersEdge>;
};


/** The output of our delete `LoadNumber` mutation. */
export type DeleteLoadNumberPayloadLoadNumberEdgeArgs = {
  orderBy?: Maybe<Array<LoadNumbersOrderBy>>;
};

/** All input for the `deleteOrderCommentByNodeId` mutation. */
export type DeleteOrderCommentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderComment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderComment` mutation. */
export type DeleteOrderCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `OrderComment` mutation. */
export type DeleteOrderCommentPayload = {
  __typename?: 'DeleteOrderCommentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderComment` that was deleted by this mutation. */
  orderComment?: Maybe<OrderComment>;
  deletedOrderCommentNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderComment`. May be used by Relay 1. */
  orderCommentEdge?: Maybe<OrderCommentsEdge>;
};


/** The output of our delete `OrderComment` mutation. */
export type DeleteOrderCommentPayloadOrderCommentEdgeArgs = {
  orderBy?: Maybe<Array<OrderCommentsOrderBy>>;
};

/** All input for the `deleteOrderEntryByNodeId` mutation. */
export type DeleteOrderEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderEntry` mutation. */
export type DeleteOrderEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteOrderEntryItemByNodeId` mutation. */
export type DeleteOrderEntryItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderEntryItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderEntryItem` mutation. */
export type DeleteOrderEntryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `OrderEntryItem` mutation. */
export type DeleteOrderEntryItemPayload = {
  __typename?: 'DeleteOrderEntryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryItem` that was deleted by this mutation. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  deletedOrderEntryItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntry` that is related to this `OrderEntryItem`. */
  orderEntry?: Maybe<OrderEntry>;
  /** An edge for our `OrderEntryItem`. May be used by Relay 1. */
  orderEntryItemEdge?: Maybe<OrderEntryItemsEdge>;
};


/** The output of our delete `OrderEntryItem` mutation. */
export type DeleteOrderEntryItemPayloadOrderEntryItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryItemsOrderBy>>;
};

/** The output of our delete `OrderEntry` mutation. */
export type DeleteOrderEntryPayload = {
  __typename?: 'DeleteOrderEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntry` that was deleted by this mutation. */
  orderEntry?: Maybe<OrderEntry>;
  deletedOrderEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderEntry`. May be used by Relay 1. */
  orderEntryEdge?: Maybe<OrderEntriesEdge>;
};


/** The output of our delete `OrderEntry` mutation. */
export type DeleteOrderEntryPayloadOrderEntryEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntriesOrderBy>>;
};

/** All input for the `deleteOrderEntryReviewItemByNodeId` mutation. */
export type DeleteOrderEntryReviewItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderEntryReviewItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderEntryReviewItem` mutation. */
export type DeleteOrderEntryReviewItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `OrderEntryReviewItem` mutation. */
export type DeleteOrderEntryReviewItemPayload = {
  __typename?: 'DeleteOrderEntryReviewItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryReviewItem` that was deleted by this mutation. */
  orderEntryReviewItem?: Maybe<OrderEntryReviewItem>;
  deletedOrderEntryReviewItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntryItem` that is related to this `OrderEntryReviewItem`. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  /** An edge for our `OrderEntryReviewItem`. May be used by Relay 1. */
  orderEntryReviewItemEdge?: Maybe<OrderEntryReviewItemsEdge>;
};


/** The output of our delete `OrderEntryReviewItem` mutation. */
export type DeleteOrderEntryReviewItemPayloadOrderEntryReviewItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryReviewItemsOrderBy>>;
};

/** All input for the `deleteOrderItemByNodeId` mutation. */
export type DeleteOrderItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderItem` mutation. */
export type DeleteOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `OrderItem` mutation. */
export type DeleteOrderItemPayload = {
  __typename?: 'DeleteOrderItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderItem` that was deleted by this mutation. */
  orderItem?: Maybe<OrderItem>;
  deletedOrderItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderItem`. May be used by Relay 1. */
  orderItemEdge?: Maybe<OrderItemsEdge>;
};


/** The output of our delete `OrderItem` mutation. */
export type DeleteOrderItemPayloadOrderItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderItemsOrderBy>>;
};

/** All input for the `deleteOrderMasterByNodeId` mutation. */
export type DeleteOrderMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderMaster` mutation. */
export type DeleteOrderMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `OrderMaster` mutation. */
export type DeleteOrderMasterPayload = {
  __typename?: 'DeleteOrderMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderMaster` that was deleted by this mutation. */
  orderMaster?: Maybe<OrderMaster>;
  deletedOrderMasterNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderMaster`. May be used by Relay 1. */
  orderMasterEdge?: Maybe<OrderMastersEdge>;
};


/** The output of our delete `OrderMaster` mutation. */
export type DeleteOrderMasterPayloadOrderMasterEdgeArgs = {
  orderBy?: Maybe<Array<OrderMastersOrderBy>>;
};

/** All input for the `deleteOrderNumberByNodeId` mutation. */
export type DeleteOrderNumberByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderNumber` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderNumber` mutation. */
export type DeleteOrderNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `OrderNumber` mutation. */
export type DeleteOrderNumberPayload = {
  __typename?: 'DeleteOrderNumberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderNumber` that was deleted by this mutation. */
  orderNumber?: Maybe<OrderNumber>;
  deletedOrderNumberNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderNumber`. May be used by Relay 1. */
  orderNumberEdge?: Maybe<OrderNumbersEdge>;
};


/** The output of our delete `OrderNumber` mutation. */
export type DeleteOrderNumberPayloadOrderNumberEdgeArgs = {
  orderBy?: Maybe<Array<OrderNumbersOrderBy>>;
};

/** All input for the `deleteOrderPalletByNodeId` mutation. */
export type DeleteOrderPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderPallet` mutation. */
export type DeleteOrderPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `OrderPallet` mutation. */
export type DeleteOrderPalletPayload = {
  __typename?: 'DeleteOrderPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderPallet` that was deleted by this mutation. */
  orderPallet?: Maybe<OrderPallet>;
  deletedOrderPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderPallet`. May be used by Relay 1. */
  orderPalletEdge?: Maybe<OrderPalletsEdge>;
};


/** The output of our delete `OrderPallet` mutation. */
export type DeleteOrderPalletPayloadOrderPalletEdgeArgs = {
  orderBy?: Maybe<Array<OrderPalletsOrderBy>>;
};

/** All input for the `deletePackAtmosphereByNodeId` mutation. */
export type DeletePackAtmosphereByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackAtmosphere` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackAtmosphereByShipperIdAndMaCode` mutation. */
export type DeletePackAtmosphereByShipperIdAndMaCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  maCode: Scalars['String'];
};

/** All input for the `deletePackAtmosphere` mutation. */
export type DeletePackAtmosphereInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackAtmosphere` mutation. */
export type DeletePackAtmospherePayload = {
  __typename?: 'DeletePackAtmospherePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` that was deleted by this mutation. */
  packAtmosphere?: Maybe<PackAtmosphere>;
  deletedPackAtmosphereNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackAtmosphere`. May be used by Relay 1. */
  packAtmosphereEdge?: Maybe<PackAtmospheresEdge>;
};


/** The output of our delete `PackAtmosphere` mutation. */
export type DeletePackAtmospherePayloadPackAtmosphereEdgeArgs = {
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
};

/** All input for the `deletePackBoxStyleByNodeId` mutation. */
export type DeletePackBoxStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxStyle` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackBoxStyleByShipperIdAndBoxStyle` mutation. */
export type DeletePackBoxStyleByShipperIdAndBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  boxStyle: Scalars['String'];
};

/** All input for the `deletePackBoxStyle` mutation. */
export type DeletePackBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackBoxStyle` mutation. */
export type DeletePackBoxStylePayload = {
  __typename?: 'DeletePackBoxStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` that was deleted by this mutation. */
  packBoxStyle?: Maybe<PackBoxStyle>;
  deletedPackBoxStyleNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxStyle`. May be used by Relay 1. */
  packBoxStyleEdge?: Maybe<PackBoxStylesEdge>;
};


/** The output of our delete `PackBoxStyle` mutation. */
export type DeletePackBoxStylePayloadPackBoxStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
};

/** All input for the `deletePackBoxTypeByNodeId` mutation. */
export type DeletePackBoxTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackBoxTypeByShipperIdAndBoxType` mutation. */
export type DeletePackBoxTypeByShipperIdAndBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  boxType: Scalars['String'];
};

/** All input for the `deletePackBoxType` mutation. */
export type DeletePackBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackBoxType` mutation. */
export type DeletePackBoxTypePayload = {
  __typename?: 'DeletePackBoxTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` that was deleted by this mutation. */
  packBoxType?: Maybe<PackBoxType>;
  deletedPackBoxTypeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxType`. May be used by Relay 1. */
  packBoxTypeEdge?: Maybe<PackBoxTypesEdge>;
};


/** The output of our delete `PackBoxType` mutation. */
export type DeletePackBoxTypePayloadPackBoxTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
};

/** All input for the `deletePackDestinationByNodeId` mutation. */
export type DeletePackDestinationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackDestination` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackDestinationByShipperIdAndDestinationCode` mutation. */
export type DeletePackDestinationByShipperIdAndDestinationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  destinationCode: Scalars['String'];
};

/** All input for the `deletePackDestination` mutation. */
export type DeletePackDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackDestination` mutation. */
export type DeletePackDestinationPayload = {
  __typename?: 'DeletePackDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` that was deleted by this mutation. */
  packDestination?: Maybe<PackDestination>;
  deletedPackDestinationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackDestination`. May be used by Relay 1. */
  packDestinationEdge?: Maybe<PackDestinationsEdge>;
};


/** The output of our delete `PackDestination` mutation. */
export type DeletePackDestinationPayloadPackDestinationEdgeArgs = {
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
};

/** All input for the `deletePackGradeByNodeId` mutation. */
export type DeletePackGradeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackGrade` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackGradeByShipperIdAndGradeCode` mutation. */
export type DeletePackGradeByShipperIdAndGradeCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  gradeCode: Scalars['String'];
};

/** All input for the `deletePackGrade` mutation. */
export type DeletePackGradeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackGrade` mutation. */
export type DeletePackGradePayload = {
  __typename?: 'DeletePackGradePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` that was deleted by this mutation. */
  packGrade?: Maybe<PackGrade>;
  deletedPackGradeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackGrade`. May be used by Relay 1. */
  packGradeEdge?: Maybe<PackGradesEdge>;
};


/** The output of our delete `PackGrade` mutation. */
export type DeletePackGradePayloadPackGradeEdgeArgs = {
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
};

/** All input for the `deletePackHoldByNodeId` mutation. */
export type DeletePackHoldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackHold` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackHoldByShipperIdAndHoldCode` mutation. */
export type DeletePackHoldByShipperIdAndHoldCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  holdCode: Scalars['String'];
};

/** All input for the `deletePackHold` mutation. */
export type DeletePackHoldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackHold` mutation. */
export type DeletePackHoldPayload = {
  __typename?: 'DeletePackHoldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` that was deleted by this mutation. */
  packHold?: Maybe<PackHold>;
  deletedPackHoldNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackHold`. May be used by Relay 1. */
  packHoldEdge?: Maybe<PackHoldsEdge>;
};


/** The output of our delete `PackHold` mutation. */
export type DeletePackHoldPayloadPackHoldEdgeArgs = {
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
};

/** All input for the `deletePackLabelByNodeId` mutation. */
export type DeletePackLabelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLabel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackLabelByShipperIdAndLabelCode` mutation. */
export type DeletePackLabelByShipperIdAndLabelCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  labelCode: Scalars['String'];
};

/** All input for the `deletePackLabel` mutation. */
export type DeletePackLabelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackLabel` mutation. */
export type DeletePackLabelPayload = {
  __typename?: 'DeletePackLabelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` that was deleted by this mutation. */
  packLabel?: Maybe<PackLabel>;
  deletedPackLabelNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLabel`. May be used by Relay 1. */
  packLabelEdge?: Maybe<PackLabelsEdge>;
};


/** The output of our delete `PackLabel` mutation. */
export type DeletePackLabelPayloadPackLabelEdgeArgs = {
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
};

/** All input for the `deletePackLinerByNodeId` mutation. */
export type DeletePackLinerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLiner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackLinerByShipperIdAndLinerCode` mutation. */
export type DeletePackLinerByShipperIdAndLinerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  linerCode: Scalars['String'];
};

/** All input for the `deletePackLiner` mutation. */
export type DeletePackLinerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackLiner` mutation. */
export type DeletePackLinerPayload = {
  __typename?: 'DeletePackLinerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` that was deleted by this mutation. */
  packLiner?: Maybe<PackLiner>;
  deletedPackLinerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLiner`. May be used by Relay 1. */
  packLinerEdge?: Maybe<PackLinersEdge>;
};


/** The output of our delete `PackLiner` mutation. */
export type DeletePackLinerPayloadPackLinerEdgeArgs = {
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
};

/** All input for the `deletePackMasterByNodeId` mutation. */
export type DeletePackMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackMaster` mutation. */
export type DeletePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackMaster` mutation. */
export type DeletePackMasterPayload = {
  __typename?: 'DeletePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` that was deleted by this mutation. */
  packMaster?: Maybe<PackMaster>;
  deletedPackMasterNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackMaster`. May be used by Relay 1. */
  packMasterEdge?: Maybe<PackMastersEdge>;
};


/** The output of our delete `PackMaster` mutation. */
export type DeletePackMasterPayloadPackMasterEdgeArgs = {
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
};

/** All input for the `deletePackOutByNodeId` mutation. */
export type DeletePackOutByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackOut` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackOutByShipperIdAndOutCode` mutation. */
export type DeletePackOutByShipperIdAndOutCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  outCode: Scalars['String'];
};

/** All input for the `deletePackOut` mutation. */
export type DeletePackOutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackOut` mutation. */
export type DeletePackOutPayload = {
  __typename?: 'DeletePackOutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` that was deleted by this mutation. */
  packOut?: Maybe<PackOut>;
  deletedPackOutNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackOut`. May be used by Relay 1. */
  packOutEdge?: Maybe<PackOutsEdge>;
};


/** The output of our delete `PackOut` mutation. */
export type DeletePackOutPayloadPackOutEdgeArgs = {
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
};

/** All input for the `deletePackPalletTypeByNodeId` mutation. */
export type DeletePackPalletTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackPalletType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackPalletTypeByShipperIdAndPalletType` mutation. */
export type DeletePackPalletTypeByShipperIdAndPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  palletType: Scalars['String'];
};

/** All input for the `deletePackPalletType` mutation. */
export type DeletePackPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackPalletType` mutation. */
export type DeletePackPalletTypePayload = {
  __typename?: 'DeletePackPalletTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` that was deleted by this mutation. */
  packPalletType?: Maybe<PackPalletType>;
  deletedPackPalletTypeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackPalletType`. May be used by Relay 1. */
  packPalletTypeEdge?: Maybe<PackPalletTypesEdge>;
};


/** The output of our delete `PackPalletType` mutation. */
export type DeletePackPalletTypePayloadPackPalletTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
};

/** All input for the `deletePackProductionByNodeId` mutation. */
export type DeletePackProductionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackProduction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackProductionByShipperIdAndProductionCode` mutation. */
export type DeletePackProductionByShipperIdAndProductionCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  productionCode: Scalars['String'];
};

/** All input for the `deletePackProduction` mutation. */
export type DeletePackProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackProduction` mutation. */
export type DeletePackProductionPayload = {
  __typename?: 'DeletePackProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` that was deleted by this mutation. */
  packProduction?: Maybe<PackProduction>;
  deletedPackProductionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackProduction`. May be used by Relay 1. */
  packProductionEdge?: Maybe<PackProductionsEdge>;
};


/** The output of our delete `PackProduction` mutation. */
export type DeletePackProductionPayloadPackProductionEdgeArgs = {
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
};

/** All input for the `deletePackSpecialByNodeId` mutation. */
export type DeletePackSpecialByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackSpecial` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackSpecialByShipperIdAndCustomerCode` mutation. */
export type DeletePackSpecialByShipperIdAndCustomerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  customerCode: Scalars['String'];
};

/** All input for the `deletePackSpecial` mutation. */
export type DeletePackSpecialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackSpecial` mutation. */
export type DeletePackSpecialPayload = {
  __typename?: 'DeletePackSpecialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` that was deleted by this mutation. */
  packSpecial?: Maybe<PackSpecial>;
  deletedPackSpecialNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackSpecial`. May be used by Relay 1. */
  packSpecialEdge?: Maybe<PackSpecialsEdge>;
};


/** The output of our delete `PackSpecial` mutation. */
export type DeletePackSpecialPayloadPackSpecialEdgeArgs = {
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
};

/** All input for the `deletePackStyleByNodeId` mutation. */
export type DeletePackStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackStyle` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackStyleByShipperIdAndPackStyle` mutation. */
export type DeletePackStyleByShipperIdAndPackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  packStyle: Scalars['String'];
};

/** All input for the `deletePackStyle` mutation. */
export type DeletePackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackStyle` mutation. */
export type DeletePackStylePayload = {
  __typename?: 'DeletePackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` that was deleted by this mutation. */
  packStyle?: Maybe<PackStyle>;
  deletedPackStyleNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackStyle`. May be used by Relay 1. */
  packStyleEdge?: Maybe<PackStylesEdge>;
};


/** The output of our delete `PackStyle` mutation. */
export type DeletePackStylePayloadPackStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
};

/** All input for the `deletePackTreeRipeByNodeId` mutation. */
export type DeletePackTreeRipeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackTreeRipe` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePackTreeRipeByShipperIdAndTreeRipe` mutation. */
export type DeletePackTreeRipeByShipperIdAndTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  treeRipe: Scalars['String'];
};

/** All input for the `deletePackTreeRipe` mutation. */
export type DeletePackTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PackTreeRipe` mutation. */
export type DeletePackTreeRipePayload = {
  __typename?: 'DeletePackTreeRipePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` that was deleted by this mutation. */
  packTreeRipe?: Maybe<PackTreeRipe>;
  deletedPackTreeRipeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackTreeRipe`. May be used by Relay 1. */
  packTreeRipeEdge?: Maybe<PackTreeRipesEdge>;
};


/** The output of our delete `PackTreeRipe` mutation. */
export type DeletePackTreeRipePayloadPackTreeRipeEdgeArgs = {
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
};

/** All input for the `deletePalletByNodeId` mutation. */
export type DeletePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePallet` mutation. */
export type DeletePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Pallet` mutation. */
export type DeletePalletPayload = {
  __typename?: 'DeletePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` that was deleted by this mutation. */
  pallet?: Maybe<Pallet>;
  deletedPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Pallet`. May be used by Relay 1. */
  palletEdge?: Maybe<PalletsEdge>;
};


/** The output of our delete `Pallet` mutation. */
export type DeletePalletPayloadPalletEdgeArgs = {
  orderBy?: Maybe<Array<PalletsOrderBy>>;
};

/** All input for the `deletePalletSectionByNodeId` mutation. */
export type DeletePalletSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletSection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePalletSection` mutation. */
export type DeletePalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PalletSection` mutation. */
export type DeletePalletSectionPayload = {
  __typename?: 'DeletePalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` that was deleted by this mutation. */
  palletSection?: Maybe<PalletSection>;
  deletedPalletSectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletSection`. May be used by Relay 1. */
  palletSectionEdge?: Maybe<PalletSectionsEdge>;
};


/** The output of our delete `PalletSection` mutation. */
export type DeletePalletSectionPayloadPalletSectionEdgeArgs = {
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
};

/** All input for the `deletePersonContactByNodeId` mutation. */
export type DeletePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePersonContact` mutation. */
export type DeletePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PersonContact` mutation. */
export type DeletePersonContactPayload = {
  __typename?: 'DeletePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` that was deleted by this mutation. */
  personContact?: Maybe<PersonContact>;
  deletedPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PersonContact`. May be used by Relay 1. */
  personContactEdge?: Maybe<PersonContactsEdge>;
};


/** The output of our delete `PersonContact` mutation. */
export type DeletePersonContactPayloadPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
};

/** All input for the `deletePeruDepartureInspectionByNodeId` mutation. */
export type DeletePeruDepartureInspectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePeruDepartureInspection` mutation. */
export type DeletePeruDepartureInspectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  containerId: Scalars['String'];
};

/** All input for the `deletePeruDepartureInspectionPalletByNodeId` mutation. */
export type DeletePeruDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspectionPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePeruDepartureInspectionPallet` mutation. */
export type DeletePeruDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PeruDepartureInspectionPallet` mutation. */
export type DeletePeruDepartureInspectionPalletPayload = {
  __typename?: 'DeletePeruDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` that was deleted by this mutation. */
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  deletedPeruDepartureInspectionPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
  /** An edge for our `PeruDepartureInspectionPallet`. May be used by Relay 1. */
  peruDepartureInspectionPalletEdge?: Maybe<PeruDepartureInspectionPalletsEdge>;
};


/** The output of our delete `PeruDepartureInspectionPallet` mutation. */
export type DeletePeruDepartureInspectionPalletPayloadPeruDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
};

/** The output of our delete `PeruDepartureInspection` mutation. */
export type DeletePeruDepartureInspectionPayload = {
  __typename?: 'DeletePeruDepartureInspectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` that was deleted by this mutation. */
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  deletedPeruDepartureInspectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PeruDepartureInspection`. May be used by Relay 1. */
  peruDepartureInspectionEdge?: Maybe<PeruDepartureInspectionsEdge>;
};


/** The output of our delete `PeruDepartureInspection` mutation. */
export type DeletePeruDepartureInspectionPayloadPeruDepartureInspectionEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
};

/** All input for the `deletePriceCategoryByNodeId` mutation. */
export type DeletePriceCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceCategoryEntries` mutation. */
export type DeletePriceCategoryEntriesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  selectedCategoryId: Scalars['BigInt'];
  selectedDate: Scalars['Date'];
};

/** The output of our `deletePriceCategoryEntries` mutation. */
export type DeletePriceCategoryEntriesPayload = {
  __typename?: 'DeletePriceCategoryEntriesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `deletePriceCategory` mutation. */
export type DeletePriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceCategory` mutation. */
export type DeletePriceCategoryPayload = {
  __typename?: 'DeletePriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` that was deleted by this mutation. */
  priceCategory?: Maybe<PriceCategory>;
  deletedPriceCategoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PriceCategory`. May be used by Relay 1. */
  priceCategoryEdge?: Maybe<PriceCategoriesEdge>;
};


/** The output of our delete `PriceCategory` mutation. */
export type DeletePriceCategoryPayloadPriceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
};

/** All input for the `deletePriceEntryByNodeId` mutation. */
export type DeletePriceEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceEntry` mutation. */
export type DeletePriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceEntry` mutation. */
export type DeletePriceEntryPayload = {
  __typename?: 'DeletePriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` that was deleted by this mutation. */
  priceEntry?: Maybe<PriceEntry>;
  deletedPriceEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
  /** An edge for our `PriceEntry`. May be used by Relay 1. */
  priceEntryEdge?: Maybe<PriceEntriesEdge>;
};


/** The output of our delete `PriceEntry` mutation. */
export type DeletePriceEntryPayloadPriceEntryEdgeArgs = {
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
};

/** All input for the `deletePriceProductByNodeId` mutation. */
export type DeletePriceProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceProductEntries` mutation. */
export type DeletePriceProductEntriesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  selectedProductId: Scalars['BigInt'];
  selectedDate: Scalars['Date'];
};

/** The output of our `deletePriceProductEntries` mutation. */
export type DeletePriceProductEntriesPayload = {
  __typename?: 'DeletePriceProductEntriesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `deletePriceProduct` mutation. */
export type DeletePriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceProduct` mutation. */
export type DeletePriceProductPayload = {
  __typename?: 'DeletePriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` that was deleted by this mutation. */
  priceProduct?: Maybe<PriceProduct>;
  deletedPriceProductNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** An edge for our `PriceProduct`. May be used by Relay 1. */
  priceProductEdge?: Maybe<PriceProductsEdge>;
};


/** The output of our delete `PriceProduct` mutation. */
export type DeletePriceProductPayloadPriceProductEdgeArgs = {
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
};

/** All input for the `deletePriceSizeByNodeId` mutation. */
export type DeletePriceSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePriceSizeEntries` mutation. */
export type DeletePriceSizeEntriesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  selectedSizeId: Scalars['BigInt'];
  selectedDate: Scalars['Date'];
};

/** The output of our `deletePriceSizeEntries` mutation. */
export type DeletePriceSizeEntriesPayload = {
  __typename?: 'DeletePriceSizeEntriesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  bigInts?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `deletePriceSize` mutation. */
export type DeletePriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PriceSize` mutation. */
export type DeletePriceSizePayload = {
  __typename?: 'DeletePriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` that was deleted by this mutation. */
  priceSize?: Maybe<PriceSize>;
  deletedPriceSizeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** An edge for our `PriceSize`. May be used by Relay 1. */
  priceSizeEdge?: Maybe<PriceSizesEdge>;
};


/** The output of our delete `PriceSize` mutation. */
export type DeletePriceSizePayloadPriceSizeEdgeArgs = {
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
};

/** All input for the `deleteProductMasterByNodeId` mutation. */
export type DeleteProductMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductMaster` mutation. */
export type DeleteProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ProductMaster` mutation. */
export type DeleteProductMasterPayload = {
  __typename?: 'DeleteProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` that was deleted by this mutation. */
  productMaster?: Maybe<ProductMaster>;
  deletedProductMasterNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductMaster`. May be used by Relay 1. */
  productMasterEdge?: Maybe<ProductMastersEdge>;
};


/** The output of our delete `ProductMaster` mutation. */
export type DeleteProductMasterPayloadProductMasterEdgeArgs = {
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
};

/** All input for the `deleteProductSizeByNodeId` mutation. */
export type DeleteProductSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductSize` mutation. */
export type DeleteProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ProductSize` mutation. */
export type DeleteProductSizePayload = {
  __typename?: 'DeleteProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` that was deleted by this mutation. */
  productSize?: Maybe<ProductSize>;
  deletedProductSizeNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSize`. May be used by Relay 1. */
  productSizeEdge?: Maybe<ProductSizesEdge>;
};


/** The output of our delete `ProductSize` mutation. */
export type DeleteProductSizePayloadProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
};

/** All input for the `deleteProductSpeciesByNodeId` mutation. */
export type DeleteProductSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSpecies` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductSpecies` mutation. */
export type DeleteProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ProductSpecies` mutation. */
export type DeleteProductSpeciesPayload = {
  __typename?: 'DeleteProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` that was deleted by this mutation. */
  productSpecies?: Maybe<ProductSpecies>;
  deletedProductSpeciesNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSpecies`. May be used by Relay 1. */
  productSpeciesEdge?: Maybe<ProductSpeciesEdge>;
};


/** The output of our delete `ProductSpecies` mutation. */
export type DeleteProductSpeciesPayloadProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
};

/** All input for the `deleteProductVarietyByNodeId` mutation. */
export type DeleteProductVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductVariety` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductVariety` mutation. */
export type DeleteProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `ProductVariety` mutation. */
export type DeleteProductVarietyPayload = {
  __typename?: 'DeleteProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` that was deleted by this mutation. */
  productVariety?: Maybe<ProductVariety>;
  deletedProductVarietyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductVariety`. May be used by Relay 1. */
  productVarietyEdge?: Maybe<ProductVarietiesEdge>;
};


/** The output of our delete `ProductVariety` mutation. */
export type DeleteProductVarietyPayloadProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
};

/** All input for the `deletePsaApplePalletByNodeId` mutation. */
export type DeletePsaApplePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaApplePallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaApplePallet` mutation. */
export type DeletePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaApplePallet` mutation. */
export type DeletePsaApplePalletPayload = {
  __typename?: 'DeletePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` that was deleted by this mutation. */
  psaApplePallet?: Maybe<PsaApplePallet>;
  deletedPsaApplePalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaApplePallet`. May be used by Relay 1. */
  psaApplePalletEdge?: Maybe<PsaApplePalletsEdge>;
};


/** The output of our delete `PsaApplePallet` mutation. */
export type DeletePsaApplePalletPayloadPsaApplePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
};

/** All input for the `deletePsaArrivalPictureByNodeId` mutation. */
export type DeletePsaArrivalPictureByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalPicture` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaArrivalPicture` mutation. */
export type DeletePsaArrivalPictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaArrivalPicture` mutation. */
export type DeletePsaArrivalPicturePayload = {
  __typename?: 'DeletePsaArrivalPicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` that was deleted by this mutation. */
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  deletedPsaArrivalPictureNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalPicture`. May be used by Relay 1. */
  psaArrivalPictureEdge?: Maybe<PsaArrivalPicturesEdge>;
};


/** The output of our delete `PsaArrivalPicture` mutation. */
export type DeletePsaArrivalPicturePayloadPsaArrivalPictureEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
};

/** All input for the `deletePsaArrivalReportByNodeId` mutation. */
export type DeletePsaArrivalReportByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalReport` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaArrivalReport` mutation. */
export type DeletePsaArrivalReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaArrivalReport` mutation. */
export type DeletePsaArrivalReportPayload = {
  __typename?: 'DeletePsaArrivalReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` that was deleted by this mutation. */
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  deletedPsaArrivalReportNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalReport`. May be used by Relay 1. */
  psaArrivalReportEdge?: Maybe<PsaArrivalReportsEdge>;
};


/** The output of our delete `PsaArrivalReport` mutation. */
export type DeletePsaArrivalReportPayloadPsaArrivalReportEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
};

/** All input for the `deletePsaCherryPalletByNodeId` mutation. */
export type DeletePsaCherryPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCherryPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaCherryPallet` mutation. */
export type DeletePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaCherryPallet` mutation. */
export type DeletePsaCherryPalletPayload = {
  __typename?: 'DeletePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` that was deleted by this mutation. */
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  deletedPsaCherryPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCherryPallet`. May be used by Relay 1. */
  psaCherryPalletEdge?: Maybe<PsaCherryPalletsEdge>;
};


/** The output of our delete `PsaCherryPallet` mutation. */
export type DeletePsaCherryPalletPayloadPsaCherryPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
};

/** All input for the `deletePsaCitrusPalletByNodeId` mutation. */
export type DeletePsaCitrusPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCitrusPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaCitrusPallet` mutation. */
export type DeletePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaCitrusPallet` mutation. */
export type DeletePsaCitrusPalletPayload = {
  __typename?: 'DeletePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` that was deleted by this mutation. */
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  deletedPsaCitrusPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCitrusPallet`. May be used by Relay 1. */
  psaCitrusPalletEdge?: Maybe<PsaCitrusPalletsEdge>;
};


/** The output of our delete `PsaCitrusPallet` mutation. */
export type DeletePsaCitrusPalletPayloadPsaCitrusPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
};

/** All input for the `deletePsaGrapePalletByNodeId` mutation. */
export type DeletePsaGrapePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaGrapePallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaGrapePallet` mutation. */
export type DeletePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaGrapePallet` mutation. */
export type DeletePsaGrapePalletPayload = {
  __typename?: 'DeletePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` that was deleted by this mutation. */
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  deletedPsaGrapePalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaGrapePallet`. May be used by Relay 1. */
  psaGrapePalletEdge?: Maybe<PsaGrapePalletsEdge>;
};


/** The output of our delete `PsaGrapePallet` mutation. */
export type DeletePsaGrapePalletPayloadPsaGrapePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
};

/** All input for the `deletePsaLemonPalletByNodeId` mutation. */
export type DeletePsaLemonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaLemonPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaLemonPallet` mutation. */
export type DeletePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaLemonPallet` mutation. */
export type DeletePsaLemonPalletPayload = {
  __typename?: 'DeletePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` that was deleted by this mutation. */
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  deletedPsaLemonPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaLemonPallet`. May be used by Relay 1. */
  psaLemonPalletEdge?: Maybe<PsaLemonPalletsEdge>;
};


/** The output of our delete `PsaLemonPallet` mutation. */
export type DeletePsaLemonPalletPayloadPsaLemonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
};

/** All input for the `deletePsaPearPalletByNodeId` mutation. */
export type DeletePsaPearPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPearPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaPearPallet` mutation. */
export type DeletePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaPearPallet` mutation. */
export type DeletePsaPearPalletPayload = {
  __typename?: 'DeletePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` that was deleted by this mutation. */
  psaPearPallet?: Maybe<PsaPearPallet>;
  deletedPsaPearPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPearPallet`. May be used by Relay 1. */
  psaPearPalletEdge?: Maybe<PsaPearPalletsEdge>;
};


/** The output of our delete `PsaPearPallet` mutation. */
export type DeletePsaPearPalletPayloadPsaPearPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
};

/** All input for the `deletePsaPersimmonPalletByNodeId` mutation. */
export type DeletePsaPersimmonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPersimmonPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaPersimmonPallet` mutation. */
export type DeletePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaPersimmonPallet` mutation. */
export type DeletePsaPersimmonPalletPayload = {
  __typename?: 'DeletePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` that was deleted by this mutation. */
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  deletedPsaPersimmonPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPersimmonPallet`. May be used by Relay 1. */
  psaPersimmonPalletEdge?: Maybe<PsaPersimmonPalletsEdge>;
};


/** The output of our delete `PsaPersimmonPallet` mutation. */
export type DeletePsaPersimmonPalletPayloadPsaPersimmonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
};

/** All input for the `deletePsaPomegranatePalletByNodeId` mutation. */
export type DeletePsaPomegranatePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPomegranatePallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaPomegranatePallet` mutation. */
export type DeletePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaPomegranatePallet` mutation. */
export type DeletePsaPomegranatePalletPayload = {
  __typename?: 'DeletePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` that was deleted by this mutation. */
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  deletedPsaPomegranatePalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPomegranatePallet`. May be used by Relay 1. */
  psaPomegranatePalletEdge?: Maybe<PsaPomegranatePalletsEdge>;
};


/** The output of our delete `PsaPomegranatePallet` mutation. */
export type DeletePsaPomegranatePalletPayloadPsaPomegranatePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
};

/** All input for the `deletePsaStoneFruitPalletByNodeId` mutation. */
export type DeletePsaStoneFruitPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaStoneFruitPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePsaStoneFruitPallet` mutation. */
export type DeletePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `PsaStoneFruitPallet` mutation. */
export type DeletePsaStoneFruitPalletPayload = {
  __typename?: 'DeletePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` that was deleted by this mutation. */
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  deletedPsaStoneFruitPalletNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaStoneFruitPallet`. May be used by Relay 1. */
  psaStoneFruitPalletEdge?: Maybe<PsaStoneFruitPalletsEdge>;
};


/** The output of our delete `PsaStoneFruitPallet` mutation. */
export type DeletePsaStoneFruitPalletPayloadPsaStoneFruitPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
};

/** All input for the `deleteRepackHeaderByNodeId` mutation. */
export type DeleteRepackHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackHeader` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRepackHeader` mutation. */
export type DeleteRepackHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `RepackHeader` mutation. */
export type DeleteRepackHeaderPayload = {
  __typename?: 'DeleteRepackHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackHeader` that was deleted by this mutation. */
  repackHeader?: Maybe<RepackHeader>;
  deletedRepackHeaderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackHeader`. May be used by Relay 1. */
  repackHeaderEdge?: Maybe<RepackHeadersEdge>;
};


/** The output of our delete `RepackHeader` mutation. */
export type DeleteRepackHeaderPayloadRepackHeaderEdgeArgs = {
  orderBy?: Maybe<Array<RepackHeadersOrderBy>>;
};

/** All input for the `deleteRepackItemByNodeId` mutation. */
export type DeleteRepackItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRepackItem` mutation. */
export type DeleteRepackItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `RepackItem` mutation. */
export type DeleteRepackItemPayload = {
  __typename?: 'DeleteRepackItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackItem` that was deleted by this mutation. */
  repackItem?: Maybe<RepackItem>;
  deletedRepackItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackItem`. May be used by Relay 1. */
  repackItemEdge?: Maybe<RepackItemsEdge>;
};


/** The output of our delete `RepackItem` mutation. */
export type DeleteRepackItemPayloadRepackItemEdgeArgs = {
  orderBy?: Maybe<Array<RepackItemsOrderBy>>;
};

/** All input for the `deleteRepackQueueByNodeId` mutation. */
export type DeleteRepackQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackQueue` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRepackQueue` mutation. */
export type DeleteRepackQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `RepackQueue` mutation. */
export type DeleteRepackQueuePayload = {
  __typename?: 'DeleteRepackQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackQueue` that was deleted by this mutation. */
  repackQueue?: Maybe<RepackQueue>;
  deletedRepackQueueNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackQueue`. May be used by Relay 1. */
  repackQueueEdge?: Maybe<RepackQueuesEdge>;
};


/** The output of our delete `RepackQueue` mutation. */
export type DeleteRepackQueuePayloadRepackQueueEdgeArgs = {
  orderBy?: Maybe<Array<RepackQueuesOrderBy>>;
};

/** All input for the `deleteRepackStyleByNodeId` mutation. */
export type DeleteRepackStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackStyle` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRepackStyle` mutation. */
export type DeleteRepackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `RepackStyle` mutation. */
export type DeleteRepackStylePayload = {
  __typename?: 'DeleteRepackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackStyle` that was deleted by this mutation. */
  repackStyle?: Maybe<RepackStyle>;
  deletedRepackStyleNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackStyle`. May be used by Relay 1. */
  repackStyleEdge?: Maybe<RepackStylesEdge>;
};


/** The output of our delete `RepackStyle` mutation. */
export type DeleteRepackStylePayloadRepackStyleEdgeArgs = {
  orderBy?: Maybe<Array<RepackStylesOrderBy>>;
};

/** All input for the `deleteShipperAdvanceByNodeId` mutation. */
export type DeleteShipperAdvanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperAdvance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperAdvance` mutation. */
export type DeleteShipperAdvanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperAdvance` mutation. */
export type DeleteShipperAdvancePayload = {
  __typename?: 'DeleteShipperAdvancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperAdvance` that was deleted by this mutation. */
  shipperAdvance?: Maybe<ShipperAdvance>;
  deletedShipperAdvanceNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ProductSpecies` that is related to this `ShipperAdvance`. */
  species?: Maybe<ProductSpecies>;
  /** Reads a single `Shipper` that is related to this `ShipperAdvance`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperAdvance`. May be used by Relay 1. */
  shipperAdvanceEdge?: Maybe<ShipperAdvancesEdge>;
};


/** The output of our delete `ShipperAdvance` mutation. */
export type DeleteShipperAdvancePayloadShipperAdvanceEdgeArgs = {
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
};

/** All input for the `deleteShipperByNodeId` mutation. */
export type DeleteShipperByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipper` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipper` mutation. */
export type DeleteShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `Shipper` mutation. */
export type DeleteShipperPayload = {
  __typename?: 'DeleteShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` that was deleted by this mutation. */
  shipper?: Maybe<Shipper>;
  deletedShipperNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** An edge for our `Shipper`. May be used by Relay 1. */
  shipperEdge?: Maybe<ShippersEdge>;
};


/** The output of our delete `Shipper` mutation. */
export type DeleteShipperPayloadShipperEdgeArgs = {
  orderBy?: Maybe<Array<ShippersOrderBy>>;
};

/** All input for the `deleteShipperPersonContactByNodeId` mutation. */
export type DeleteShipperPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperPersonContact` mutation. */
export type DeleteShipperPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `ShipperPersonContact` mutation. */
export type DeleteShipperPersonContactPayload = {
  __typename?: 'DeleteShipperPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` that was deleted by this mutation. */
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  deletedShipperPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ShipperPersonContact`. May be used by Relay 1. */
  shipperPersonContactEdge?: Maybe<ShipperPersonContactsEdge>;
};


/** The output of our delete `ShipperPersonContact` mutation. */
export type DeleteShipperPersonContactPayloadShipperPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
};

/** All input for the `deleteShipperProgramByNodeId` mutation. */
export type DeleteShipperProgramByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProgram` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProgramEntryByNodeId` mutation. */
export type DeleteShipperProgramEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProgramEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProgramEntryCustomerProgramEntryByNodeId` mutation. */
export type DeleteShipperProgramEntryCustomerProgramEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProgramEntryCustomerProgramEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProgramEntryCustomerProgramEntry` mutation. */
export type DeleteShipperProgramEntryCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type DeleteShipperProgramEntryCustomerProgramEntryPayload = {
  __typename?: 'DeleteShipperProgramEntryCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntryCustomerProgramEntry` that was deleted by this mutation. */
  shipperProgramEntryCustomerProgramEntry?: Maybe<ShipperProgramEntryCustomerProgramEntry>;
  deletedShipperProgramEntryCustomerProgramEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Reads a single `ShipperProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  /** An edge for our `ShipperProgramEntryCustomerProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryCustomerProgramEntryEdge?: Maybe<ShipperProgramEntryCustomerProgramEntriesEdge>;
};


/** The output of our delete `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type DeleteShipperProgramEntryCustomerProgramEntryPayloadShipperProgramEntryCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
};

/** All input for the `deleteShipperProgramEntry` mutation. */
export type DeleteShipperProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProgramEntry` mutation. */
export type DeleteShipperProgramEntryPayload = {
  __typename?: 'DeleteShipperProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntry` that was deleted by this mutation. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  deletedShipperProgramEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProgram` that is related to this `ShipperProgramEntry`. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** An edge for our `ShipperProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryEdge?: Maybe<ShipperProgramEntriesEdge>;
};


/** The output of our delete `ShipperProgramEntry` mutation. */
export type DeleteShipperProgramEntryPayloadShipperProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntriesOrderBy>>;
};

/** All input for the `deleteShipperProgram` mutation. */
export type DeleteShipperProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProgram` mutation. */
export type DeleteShipperProgramPayload = {
  __typename?: 'DeleteShipperProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgram` that was deleted by this mutation. */
  shipperProgram?: Maybe<ShipperProgram>;
  deletedShipperProgramNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Shipper` that is related to this `ShipperProgram`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Customer` that is related to this `ShipperProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProgram`. May be used by Relay 1. */
  shipperProgramEdge?: Maybe<ShipperProgramsEdge>;
};


/** The output of our delete `ShipperProgram` mutation. */
export type DeleteShipperProgramPayloadShipperProgramEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
};

/** All input for the `deleteShipperProjectionByNodeId` mutation. */
export type DeleteShipperProjectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionEntryByNodeId` mutation. */
export type DeleteShipperProjectionEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionEntry` mutation. */
export type DeleteShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjectionEntry` mutation. */
export type DeleteShipperProjectionEntryPayload = {
  __typename?: 'DeleteShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` that was deleted by this mutation. */
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  deletedShipperProjectionEntryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjectionVesselInfo` that is related to this `ShipperProjectionEntry`. */
  vesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** An edge for our `ShipperProjectionEntry`. May be used by Relay 1. */
  shipperProjectionEntryEdge?: Maybe<ShipperProjectionEntriesEdge>;
};


/** The output of our delete `ShipperProjectionEntry` mutation. */
export type DeleteShipperProjectionEntryPayloadShipperProjectionEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
};

/** All input for the `deleteShipperProjection` mutation. */
export type DeleteShipperProjectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjection` mutation. */
export type DeleteShipperProjectionPayload = {
  __typename?: 'DeleteShipperProjectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` that was deleted by this mutation. */
  shipperProjection?: Maybe<ShipperProjection>;
  deletedShipperProjectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our delete `ShipperProjection` mutation. */
export type DeleteShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the `deleteShipperProjectionProductByNodeId` mutation. */
export type DeleteShipperProjectionProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionProduct` mutation. */
export type DeleteShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjectionProduct` mutation. */
export type DeleteShipperProjectionProductPayload = {
  __typename?: 'DeleteShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` that was deleted by this mutation. */
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  deletedShipperProjectionProductNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProjectionProduct`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProjectionProduct`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProjectionProduct`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProjectionProduct`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `ShipperProjectionProduct`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProjectionProduct`. May be used by Relay 1. */
  shipperProjectionProductEdge?: Maybe<ShipperProjectionProductsEdge>;
};


/** The output of our delete `ShipperProjectionProduct` mutation. */
export type DeleteShipperProjectionProductPayloadShipperProjectionProductEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
};

/** All input for the `deleteShipperProjectionVesselByNodeId` mutation. */
export type DeleteShipperProjectionVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionVessel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionVesselInfoByNodeId` mutation. */
export type DeleteShipperProjectionVesselInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionVesselInfo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipperProjectionVesselInfo` mutation. */
export type DeleteShipperProjectionVesselInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjectionVesselInfo` mutation. */
export type DeleteShipperProjectionVesselInfoPayload = {
  __typename?: 'DeleteShipperProjectionVesselInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVesselInfo` that was deleted by this mutation. */
  shipperProjectionVesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  deletedShipperProjectionVesselInfoNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionVesselInfo`. */
  projection?: Maybe<ShipperProjection>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionVesselInfo`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVesselInfo`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionVesselInfo`. May be used by Relay 1. */
  shipperProjectionVesselInfoEdge?: Maybe<ShipperProjectionVesselInfosEdge>;
};


/** The output of our delete `ShipperProjectionVesselInfo` mutation. */
export type DeleteShipperProjectionVesselInfoPayloadShipperProjectionVesselInfoEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
};

/** All input for the `deleteShipperProjectionVessel` mutation. */
export type DeleteShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `ShipperProjectionVessel` mutation. */
export type DeleteShipperProjectionVesselPayload = {
  __typename?: 'DeleteShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` that was deleted by this mutation. */
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  deletedShipperProjectionVesselNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Vessel` that is related to this `ShipperProjectionVessel`. */
  vessel?: Maybe<Vessel>;
  /** An edge for our `ShipperProjectionVessel`. May be used by Relay 1. */
  shipperProjectionVesselEdge?: Maybe<ShipperProjectionVesselsEdge>;
};


/** The output of our delete `ShipperProjectionVessel` mutation. */
export type DeleteShipperProjectionVesselPayloadShipperProjectionVesselEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
};

/** All input for the `deleteTruckLoadByNodeId` mutation. */
export type DeleteTruckLoadByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TruckLoad` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTruckLoad` mutation. */
export type DeleteTruckLoadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `TruckLoad` mutation. */
export type DeleteTruckLoadPayload = {
  __typename?: 'DeleteTruckLoadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckLoad` that was deleted by this mutation. */
  truckLoad?: Maybe<TruckLoad>;
  deletedTruckLoadNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckLoad`. May be used by Relay 1. */
  truckLoadEdge?: Maybe<TruckLoadsEdge>;
};


/** The output of our delete `TruckLoad` mutation. */
export type DeleteTruckLoadPayloadTruckLoadEdgeArgs = {
  orderBy?: Maybe<Array<TruckLoadsOrderBy>>;
};

/** All input for the `deleteTruckRateByNodeId` mutation. */
export type DeleteTruckRateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TruckRate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTruckRateCustomerByNodeId` mutation. */
export type DeleteTruckRateCustomerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TruckRateCustomer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTruckRateCustomer` mutation. */
export type DeleteTruckRateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
};

/** The output of our delete `TruckRateCustomer` mutation. */
export type DeleteTruckRateCustomerPayload = {
  __typename?: 'DeleteTruckRateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRateCustomer` that was deleted by this mutation. */
  truckRateCustomer?: Maybe<TruckRateCustomer>;
  deletedTruckRateCustomerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TruckRate` that is related to this `TruckRateCustomer`. */
  truckRate?: Maybe<TruckRate>;
  /** Reads a single `Customer` that is related to this `TruckRateCustomer`. */
  customer?: Maybe<Customer>;
  /** An edge for our `TruckRateCustomer`. May be used by Relay 1. */
  truckRateCustomerEdge?: Maybe<TruckRateCustomersEdge>;
};


/** The output of our delete `TruckRateCustomer` mutation. */
export type DeleteTruckRateCustomerPayloadTruckRateCustomerEdgeArgs = {
  orderBy?: Maybe<Array<TruckRateCustomersOrderBy>>;
};

/** All input for the `deleteTruckRate` mutation. */
export type DeleteTruckRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `TruckRate` mutation. */
export type DeleteTruckRatePayload = {
  __typename?: 'DeleteTruckRatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRate` that was deleted by this mutation. */
  truckRate?: Maybe<TruckRate>;
  deletedTruckRateNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckRate`. May be used by Relay 1. */
  truckRateEdge?: Maybe<TruckRatesEdge>;
};


/** The output of our delete `TruckRate` mutation. */
export type DeleteTruckRatePayloadTruckRateEdgeArgs = {
  orderBy?: Maybe<Array<TruckRatesOrderBy>>;
};

/** All input for the `deleteUnpaidByNodeId` mutation. */
export type DeleteUnpaidByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Unpaid` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUnpaid` mutation. */
export type DeleteUnpaidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Unpaid` mutation. */
export type DeleteUnpaidPayload = {
  __typename?: 'DeleteUnpaidPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Unpaid` that was deleted by this mutation. */
  unpaid?: Maybe<Unpaid>;
  deletedUnpaidNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Unpaid`. May be used by Relay 1. */
  unpaidEdge?: Maybe<UnpaidsEdge>;
};


/** The output of our delete `Unpaid` mutation. */
export type DeleteUnpaidPayloadUnpaidEdgeArgs = {
  orderBy?: Maybe<Array<UnpaidsOrderBy>>;
};

/** All input for the `deleteUserBookmarkByNodeId` mutation. */
export type DeleteUserBookmarkByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserBookmark` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserBookmark` mutation. */
export type DeleteUserBookmarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `UserBookmark` mutation. */
export type DeleteUserBookmarkPayload = {
  __typename?: 'DeleteUserBookmarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserBookmark` that was deleted by this mutation. */
  userBookmark?: Maybe<UserBookmark>;
  deletedUserBookmarkNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserBookmark`. */
  user?: Maybe<User>;
  /** An edge for our `UserBookmark`. May be used by Relay 1. */
  userBookmarkEdge?: Maybe<UserBookmarksEdge>;
};


/** The output of our delete `UserBookmark` mutation. */
export type DeleteUserBookmarkPayloadUserBookmarkEdgeArgs = {
  orderBy?: Maybe<Array<UserBookmarksOrderBy>>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserByPin` mutation. */
export type DeleteUserByPinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  pin: Scalars['String'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteUserMessageByNodeId` mutation. */
export type DeleteUserMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserMessage` mutation. */
export type DeleteUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `UserMessage` mutation. */
export type DeleteUserMessagePayload = {
  __typename?: 'DeleteUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` that was deleted by this mutation. */
  userMessage?: Maybe<UserMessage>;
  deletedUserMessageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
  /** An edge for our `UserMessage`. May be used by Relay 1. */
  userMessageEdge?: Maybe<UserMessagesEdge>;
};


/** The output of our delete `UserMessage` mutation. */
export type DeleteUserMessagePayloadUserMessageEdgeArgs = {
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  deletedUserNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUserRoleByUserIdAndRoleName` mutation. */
export type DeleteUserRoleByUserIdAndRoleNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  userId: Scalars['BigInt'];
  roleName: Scalars['String'];
};

/** The output of our delete `UserRole` mutation. */
export type DeleteUserRolePayload = {
  __typename?: 'DeleteUserRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserRole` that was deleted by this mutation. */
  userRole?: Maybe<UserRole>;
  deletedUserRoleNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>;
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>;
};


/** The output of our delete `UserRole` mutation. */
export type DeleteUserRolePayloadUserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>;
};

/** All input for the `deleteVendorByNodeId` mutation. */
export type DeleteVendorByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vendor` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVendor` mutation. */
export type DeleteVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `Vendor` mutation. */
export type DeleteVendorPayload = {
  __typename?: 'DeleteVendorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was deleted by this mutation. */
  vendor?: Maybe<Vendor>;
  deletedVendorNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our delete `Vendor` mutation. */
export type DeleteVendorPayloadVendorEdgeArgs = {
  orderBy?: Maybe<Array<VendorsOrderBy>>;
};

/** All input for the `deleteVendorPersonContactByNodeId` mutation. */
export type DeleteVendorPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VendorPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVendorPersonContact` mutation. */
export type DeleteVendorPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `VendorPersonContact` mutation. */
export type DeleteVendorPersonContactPayload = {
  __typename?: 'DeleteVendorPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VendorPersonContact` that was deleted by this mutation. */
  vendorPersonContact?: Maybe<VendorPersonContact>;
  deletedVendorPersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vendor` that is related to this `VendorPersonContact`. */
  vendor?: Maybe<Vendor>;
  /** Reads a single `PersonContact` that is related to this `VendorPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `VendorPersonContact`. May be used by Relay 1. */
  vendorPersonContactEdge?: Maybe<VendorPersonContactsEdge>;
};


/** The output of our delete `VendorPersonContact` mutation. */
export type DeleteVendorPersonContactPayloadVendorPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<VendorPersonContactsOrderBy>>;
};

/** All input for the `deleteVesselByNodeId` mutation. */
export type DeleteVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vessel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVesselControlByNodeId` mutation. */
export type DeleteVesselControlByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VesselControl` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVesselControl` mutation. */
export type DeleteVesselControlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `VesselControl` mutation. */
export type DeleteVesselControlPayload = {
  __typename?: 'DeleteVesselControlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VesselControl` that was deleted by this mutation. */
  vesselControl?: Maybe<VesselControl>;
  deletedVesselControlNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VesselControl`. May be used by Relay 1. */
  vesselControlEdge?: Maybe<VesselControlsEdge>;
};


/** The output of our delete `VesselControl` mutation. */
export type DeleteVesselControlPayloadVesselControlEdgeArgs = {
  orderBy?: Maybe<Array<VesselControlsOrderBy>>;
};

/** All input for the `deleteVessel` mutation. */
export type DeleteVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Vessel` mutation. */
export type DeleteVesselPayload = {
  __typename?: 'DeleteVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` that was deleted by this mutation. */
  vessel?: Maybe<Vessel>;
  deletedVesselNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vessel`. May be used by Relay 1. */
  vesselEdge?: Maybe<VesselsEdge>;
};


/** The output of our delete `Vessel` mutation. */
export type DeleteVesselPayloadVesselEdgeArgs = {
  orderBy?: Maybe<Array<VesselsOrderBy>>;
};

/** All input for the `deleteWarehouseByNodeId` mutation. */
export type DeleteWarehouseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWarehouse` mutation. */
export type DeleteWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['String'];
};

/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayload = {
  __typename?: 'DeleteWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was deleted by this mutation. */
  warehouse?: Maybe<Warehouse>;
  deletedWarehouseNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayloadWarehouseEdgeArgs = {
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
};

/** All input for the `deleteWarehousePersonContactByNodeId` mutation. */
export type DeleteWarehousePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WarehousePersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWarehousePersonContact` mutation. */
export type DeleteWarehousePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our delete `WarehousePersonContact` mutation. */
export type DeleteWarehousePersonContactPayload = {
  __typename?: 'DeleteWarehousePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` that was deleted by this mutation. */
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  deletedWarehousePersonContactNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `WarehousePersonContact`. May be used by Relay 1. */
  warehousePersonContactEdge?: Maybe<WarehousePersonContactsEdge>;
};


/** The output of our delete `WarehousePersonContact` mutation. */
export type DeleteWarehousePersonContactPayloadWarehousePersonContactEdgeArgs = {
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
};

/** All input for the `deleteWireRequestAccountOfSaleItemByNodeId` mutation. */
export type DeleteWireRequestAccountOfSaleItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestAccountOfSaleItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWireRequestAccountOfSaleItem` mutation. */
export type DeleteWireRequestAccountOfSaleItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `WireRequestAccountOfSaleItem` mutation. */
export type DeleteWireRequestAccountOfSaleItemPayload = {
  __typename?: 'DeleteWireRequestAccountOfSaleItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestAccountOfSaleItem` that was deleted by this mutation. */
  wireRequestAccountOfSaleItem?: Maybe<WireRequestAccountOfSaleItem>;
  deletedWireRequestAccountOfSaleItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestAccountOfSaleItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestAccountOfSaleItem`. May be used by Relay 1. */
  wireRequestAccountOfSaleItemEdge?: Maybe<WireRequestAccountOfSaleItemsEdge>;
};


/** The output of our delete `WireRequestAccountOfSaleItem` mutation. */
export type DeleteWireRequestAccountOfSaleItemPayloadWireRequestAccountOfSaleItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestAccountOfSaleItemsOrderBy>>;
};

/** All input for the `deleteWireRequestByNodeId` mutation. */
export type DeleteWireRequestByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequest` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWireRequest` mutation. */
export type DeleteWireRequestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteWireRequestMiscItemByNodeId` mutation. */
export type DeleteWireRequestMiscItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestMiscItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWireRequestMiscItem` mutation. */
export type DeleteWireRequestMiscItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `WireRequestMiscItem` mutation. */
export type DeleteWireRequestMiscItemPayload = {
  __typename?: 'DeleteWireRequestMiscItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestMiscItem` that was deleted by this mutation. */
  wireRequestMiscItem?: Maybe<WireRequestMiscItem>;
  deletedWireRequestMiscItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestMiscItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestMiscItem`. May be used by Relay 1. */
  wireRequestMiscItemEdge?: Maybe<WireRequestMiscItemsEdge>;
};


/** The output of our delete `WireRequestMiscItem` mutation. */
export type DeleteWireRequestMiscItemPayloadWireRequestMiscItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestMiscItemsOrderBy>>;
};

/** All input for the `deleteWireRequestOceanFreightItemByNodeId` mutation. */
export type DeleteWireRequestOceanFreightItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestOceanFreightItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWireRequestOceanFreightItem` mutation. */
export type DeleteWireRequestOceanFreightItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `WireRequestOceanFreightItem` mutation. */
export type DeleteWireRequestOceanFreightItemPayload = {
  __typename?: 'DeleteWireRequestOceanFreightItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestOceanFreightItem` that was deleted by this mutation. */
  wireRequestOceanFreightItem?: Maybe<WireRequestOceanFreightItem>;
  deletedWireRequestOceanFreightItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestOceanFreightItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestOceanFreightItem`. May be used by Relay 1. */
  wireRequestOceanFreightItemEdge?: Maybe<WireRequestOceanFreightItemsEdge>;
};


/** The output of our delete `WireRequestOceanFreightItem` mutation. */
export type DeleteWireRequestOceanFreightItemPayloadWireRequestOceanFreightItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestOceanFreightItemsOrderBy>>;
};

/** The output of our delete `WireRequest` mutation. */
export type DeleteWireRequestPayload = {
  __typename?: 'DeleteWireRequestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequest` that was deleted by this mutation. */
  wireRequest?: Maybe<WireRequest>;
  deletedWireRequestNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `WireRequest`. May be used by Relay 1. */
  wireRequestEdge?: Maybe<WireRequestsEdge>;
};


/** The output of our delete `WireRequest` mutation. */
export type DeleteWireRequestPayloadWireRequestEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestsOrderBy>>;
};

/** All input for the `deleteWireRequestShipperAdvanceItemByNodeId` mutation. */
export type DeleteWireRequestShipperAdvanceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestShipperAdvanceItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWireRequestShipperAdvanceItem` mutation. */
export type DeleteWireRequestShipperAdvanceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `WireRequestShipperAdvanceItem` mutation. */
export type DeleteWireRequestShipperAdvanceItemPayload = {
  __typename?: 'DeleteWireRequestShipperAdvanceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestShipperAdvanceItem` that was deleted by this mutation. */
  wireRequestShipperAdvanceItem?: Maybe<WireRequestShipperAdvanceItem>;
  deletedWireRequestShipperAdvanceItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestShipperAdvanceItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestShipperAdvanceItem`. May be used by Relay 1. */
  wireRequestShipperAdvanceItemEdge?: Maybe<WireRequestShipperAdvanceItemsEdge>;
};


/** The output of our delete `WireRequestShipperAdvanceItem` mutation. */
export type DeleteWireRequestShipperAdvanceItemPayloadWireRequestShipperAdvanceItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestShipperAdvanceItemsOrderBy>>;
};

/** A `String` edge in the connection. */
export type DistinctValueEdge = {
  __typename?: 'DistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type DistinctValuesConnection = {
  __typename?: 'DistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<DistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ExpenseHeader = Node & {
  __typename?: 'ExpenseHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  isEstimated?: Maybe<Scalars['Boolean']>;
  paidCode?: Maybe<Scalars['String']>;
  receivableCut?: Maybe<Scalars['Boolean']>;
  apHide?: Maybe<Scalars['Boolean']>;
  isProrate?: Maybe<Scalars['Boolean']>;
  expenseAmount?: Maybe<Scalars['BigFloat']>;
  checkNumber?: Maybe<Scalars['BigFloat']>;
  entryDate?: Maybe<Scalars['Date']>;
  expenseCode?: Maybe<Scalars['String']>;
  truckLoadId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  customsEntryCode?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `ExpenseItem`. */
  items: ExpenseItemsConnection;
  searchText?: Maybe<Scalars['String']>;
  truckLoad?: Maybe<TruckLoad>;
  vendor?: Maybe<Vendor>;
  vessel?: Maybe<Vessel>;
  vesselCodesByLoad: ExpenseHeaderVesselCodesByLoadConnection;
  vesselDischargeDate?: Maybe<Scalars['Date']>;
};


export type ExpenseHeaderItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ExpenseItemFilter>;
};


export type ExpenseHeaderVesselCodesByLoadArgs = {
  vesselCodeParam?: Maybe<Scalars['String']>;
  shipperIdParam?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};

/**
 * A condition to be used against `ExpenseHeader` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ExpenseHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `voucherId` field. */
  voucherId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isEstimated` field. */
  isEstimated?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `paidCode` field. */
  paidCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `receivableCut` field. */
  receivableCut?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `apHide` field. */
  apHide?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isProrate` field. */
  isProrate?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `expenseAmount` field. */
  expenseAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `checkNumber` field. */
  checkNumber?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `entryDate` field. */
  entryDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `expenseCode` field. */
  expenseCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customsEntryCode` field. */
  customsEntryCode?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ExpenseHeader` object types. All fields are combined with a logical ‘and.’ */
export type ExpenseHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `voucherId` field. */
  voucherId?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<StringFilter>;
  /** Filter by the object’s `isEstimated` field. */
  isEstimated?: Maybe<BooleanFilter>;
  /** Filter by the object’s `paidCode` field. */
  paidCode?: Maybe<StringFilter>;
  /** Filter by the object’s `receivableCut` field. */
  receivableCut?: Maybe<BooleanFilter>;
  /** Filter by the object’s `apHide` field. */
  apHide?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isProrate` field. */
  isProrate?: Maybe<BooleanFilter>;
  /** Filter by the object’s `expenseAmount` field. */
  expenseAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `checkNumber` field. */
  checkNumber?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `entryDate` field. */
  entryDate?: Maybe<DateFilter>;
  /** Filter by the object’s `expenseCode` field. */
  expenseCode?: Maybe<StringFilter>;
  /** Filter by the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `customsEntryCode` field. */
  customsEntryCode?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselDischargeDate` field. */
  vesselDischargeDate?: Maybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ExpenseHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ExpenseHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<ExpenseHeaderFilter>;
};

/** An input for mutations affecting `ExpenseHeader` */
export type ExpenseHeaderInput = {
  id?: Maybe<Scalars['BigInt']>;
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  isEstimated?: Maybe<Scalars['Boolean']>;
  paidCode?: Maybe<Scalars['String']>;
  receivableCut?: Maybe<Scalars['Boolean']>;
  apHide?: Maybe<Scalars['Boolean']>;
  isProrate?: Maybe<Scalars['Boolean']>;
  expenseAmount?: Maybe<Scalars['BigFloat']>;
  checkNumber?: Maybe<Scalars['BigFloat']>;
  entryDate?: Maybe<Scalars['Date']>;
  expenseCode?: Maybe<Scalars['String']>;
  truckLoadId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  customsEntryCode?: Maybe<Scalars['String']>;
};

/** Represents an update to a `ExpenseHeader`. Fields that are set will be updated. */
export type ExpenseHeaderPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  isEstimated?: Maybe<Scalars['Boolean']>;
  paidCode?: Maybe<Scalars['String']>;
  receivableCut?: Maybe<Scalars['Boolean']>;
  apHide?: Maybe<Scalars['Boolean']>;
  isProrate?: Maybe<Scalars['Boolean']>;
  expenseAmount?: Maybe<Scalars['BigFloat']>;
  checkNumber?: Maybe<Scalars['BigFloat']>;
  entryDate?: Maybe<Scalars['Date']>;
  expenseCode?: Maybe<Scalars['String']>;
  truckLoadId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  customsEntryCode?: Maybe<Scalars['String']>;
};

export type ExpenseHeaderReview = Node & {
  __typename?: 'ExpenseHeaderReview';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  expenseCode?: Maybe<Scalars['String']>;
  isApproved?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `ExpenseHeaderReview` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ExpenseHeaderReviewCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `expenseCode` field. */
  expenseCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isApproved` field. */
  isApproved?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `voucherId` field. */
  voucherId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ExpenseHeaderReview` object types. All fields are combined with a logical ‘and.’ */
export type ExpenseHeaderReviewFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `expenseCode` field. */
  expenseCode?: Maybe<StringFilter>;
  /** Filter by the object’s `isApproved` field. */
  isApproved?: Maybe<BooleanFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `voucherId` field. */
  voucherId?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ExpenseHeaderReviewFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ExpenseHeaderReviewFilter>>;
  /** Negates the expression. */
  not?: Maybe<ExpenseHeaderReviewFilter>;
};

/** An input for mutations affecting `ExpenseHeaderReview` */
export type ExpenseHeaderReviewInput = {
  id?: Maybe<Scalars['BigInt']>;
  expenseCode?: Maybe<Scalars['String']>;
  isApproved?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
};

/** Represents an update to a `ExpenseHeaderReview`. Fields that are set will be updated. */
export type ExpenseHeaderReviewPatch = {
  id?: Maybe<Scalars['BigInt']>;
  expenseCode?: Maybe<Scalars['String']>;
  isApproved?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ExpenseHeaderReview` values. */
export type ExpenseHeaderReviewsConnection = {
  __typename?: 'ExpenseHeaderReviewsConnection';
  /** A list of `ExpenseHeaderReview` objects. */
  nodes: Array<Maybe<ExpenseHeaderReview>>;
  /** A list of edges which contains the `ExpenseHeaderReview` and cursor to aid in pagination. */
  edges: Array<ExpenseHeaderReviewsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ExpenseHeaderReview` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ExpenseHeaderReview` edge in the connection. */
export type ExpenseHeaderReviewsEdge = {
  __typename?: 'ExpenseHeaderReviewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ExpenseHeaderReview` at the end of the edge. */
  node?: Maybe<ExpenseHeaderReview>;
};

/** Methods to use when ordering `ExpenseHeaderReview`. */
export enum ExpenseHeaderReviewsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ExpenseCodeAsc = 'EXPENSE_CODE_ASC',
  ExpenseCodeDesc = 'EXPENSE_CODE_DESC',
  IsApprovedAsc = 'IS_APPROVED_ASC',
  IsApprovedDesc = 'IS_APPROVED_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  VoucherIdAsc = 'VOUCHER_ID_ASC',
  VoucherIdDesc = 'VOUCHER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `String` values. */
export type ExpenseHeaderVesselCodesByLoadConnection = {
  __typename?: 'ExpenseHeaderVesselCodesByLoadConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ExpenseHeaderVesselCodesByLoadEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type ExpenseHeaderVesselCodesByLoadEdge = {
  __typename?: 'ExpenseHeaderVesselCodesByLoadEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ExpenseHeader` values. */
export type ExpenseHeadersConnection = {
  __typename?: 'ExpenseHeadersConnection';
  /** A list of `ExpenseHeader` objects. */
  nodes: Array<Maybe<ExpenseHeader>>;
  /** A list of edges which contains the `ExpenseHeader` and cursor to aid in pagination. */
  edges: Array<ExpenseHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ExpenseHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ExpenseHeader` edge in the connection. */
export type ExpenseHeadersEdge = {
  __typename?: 'ExpenseHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ExpenseHeader` at the end of the edge. */
  node?: Maybe<ExpenseHeader>;
};

/** Methods to use when ordering `ExpenseHeader`. */
export enum ExpenseHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  VoucherIdAsc = 'VOUCHER_ID_ASC',
  VoucherIdDesc = 'VOUCHER_ID_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  IsEstimatedAsc = 'IS_ESTIMATED_ASC',
  IsEstimatedDesc = 'IS_ESTIMATED_DESC',
  PaidCodeAsc = 'PAID_CODE_ASC',
  PaidCodeDesc = 'PAID_CODE_DESC',
  ReceivableCutAsc = 'RECEIVABLE_CUT_ASC',
  ReceivableCutDesc = 'RECEIVABLE_CUT_DESC',
  ApHideAsc = 'AP_HIDE_ASC',
  ApHideDesc = 'AP_HIDE_DESC',
  IsProrateAsc = 'IS_PRORATE_ASC',
  IsProrateDesc = 'IS_PRORATE_DESC',
  ExpenseAmountAsc = 'EXPENSE_AMOUNT_ASC',
  ExpenseAmountDesc = 'EXPENSE_AMOUNT_DESC',
  CheckNumberAsc = 'CHECK_NUMBER_ASC',
  CheckNumberDesc = 'CHECK_NUMBER_DESC',
  EntryDateAsc = 'ENTRY_DATE_ASC',
  EntryDateDesc = 'ENTRY_DATE_DESC',
  ExpenseCodeAsc = 'EXPENSE_CODE_ASC',
  ExpenseCodeDesc = 'EXPENSE_CODE_DESC',
  TruckLoadIdAsc = 'TRUCK_LOAD_ID_ASC',
  TruckLoadIdDesc = 'TRUCK_LOAD_ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  CustomsEntryCodeAsc = 'CUSTOMS_ENTRY_CODE_ASC',
  CustomsEntryCodeDesc = 'CUSTOMS_ENTRY_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ExpenseItem = Node & {
  __typename?: 'ExpenseItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  unitPrice?: Maybe<Scalars['BigFloat']>;
  itemAmount?: Maybe<Scalars['BigFloat']>;
  billOfLadingId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  expenseCode?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  commonSpecies?: Maybe<CommonSpecies>;
  commonVariety?: Maybe<CommonVariety>;
  pallet?: Maybe<Pallet>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
};

/**
 * A condition to be used against `ExpenseItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ExpenseItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `voucherId` field. */
  voucherId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sequenceId` field. */
  sequenceId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `unitPrice` field. */
  unitPrice?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `itemAmount` field. */
  itemAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `billOfLadingId` field. */
  billOfLadingId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `expenseCode` field. */
  expenseCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ExpenseItem` object types. All fields are combined with a logical ‘and.’ */
export type ExpenseItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `voucherId` field. */
  voucherId?: Maybe<StringFilter>;
  /** Filter by the object’s `sequenceId` field. */
  sequenceId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `unitPrice` field. */
  unitPrice?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `itemAmount` field. */
  itemAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `billOfLadingId` field. */
  billOfLadingId?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `expenseCode` field. */
  expenseCode?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ExpenseItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ExpenseItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<ExpenseItemFilter>;
};

/** An input for mutations affecting `ExpenseItem` */
export type ExpenseItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  unitPrice?: Maybe<Scalars['BigFloat']>;
  itemAmount?: Maybe<Scalars['BigFloat']>;
  billOfLadingId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  expenseCode?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
};

/** Represents an update to a `ExpenseItem`. Fields that are set will be updated. */
export type ExpenseItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vendorId?: Maybe<Scalars['String']>;
  voucherId?: Maybe<Scalars['String']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  unitPrice?: Maybe<Scalars['BigFloat']>;
  itemAmount?: Maybe<Scalars['BigFloat']>;
  billOfLadingId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  expenseCode?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ExpenseItem` values. */
export type ExpenseItemsConnection = {
  __typename?: 'ExpenseItemsConnection';
  /** A list of `ExpenseItem` objects. */
  nodes: Array<Maybe<ExpenseItem>>;
  /** A list of edges which contains the `ExpenseItem` and cursor to aid in pagination. */
  edges: Array<ExpenseItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ExpenseItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ExpenseItem` edge in the connection. */
export type ExpenseItemsEdge = {
  __typename?: 'ExpenseItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ExpenseItem` at the end of the edge. */
  node?: Maybe<ExpenseItem>;
};

/** Methods to use when ordering `ExpenseItem`. */
export enum ExpenseItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  VoucherIdAsc = 'VOUCHER_ID_ASC',
  VoucherIdDesc = 'VOUCHER_ID_DESC',
  SequenceIdAsc = 'SEQUENCE_ID_ASC',
  SequenceIdDesc = 'SEQUENCE_ID_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  UnitPriceAsc = 'UNIT_PRICE_ASC',
  UnitPriceDesc = 'UNIT_PRICE_DESC',
  ItemAmountAsc = 'ITEM_AMOUNT_ASC',
  ItemAmountDesc = 'ITEM_AMOUNT_DESC',
  BillOfLadingIdAsc = 'BILL_OF_LADING_ID_ASC',
  BillOfLadingIdDesc = 'BILL_OF_LADING_ID_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  ExpenseCodeAsc = 'EXPENSE_CODE_ASC',
  ExpenseCodeDesc = 'EXPENSE_CODE_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A `String` edge in the connection. */
export type ExpenseSummaryTruckLoadIdEdge = {
  __typename?: 'ExpenseSummaryTruckLoadIdEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type ExpenseSummaryTruckLoadIdsConnection = {
  __typename?: 'ExpenseSummaryTruckLoadIdsConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ExpenseSummaryTruckLoadIdEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** Input for the nested mutation of `peruDepartureInspection` in the `PeruDepartureInspectionPalletInput` mutation. */
export type FkContainerInput = {
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  connectByContainerId?: Maybe<PeruDepartureInspectionPeruDepartureInspectionPkeyConnect>;
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  connectByNodeId?: Maybe<PeruDepartureInspectionNodeIdConnect>;
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  deleteByContainerId?: Maybe<PeruDepartureInspectionPeruDepartureInspectionPkeyDelete>;
  /** The primary key(s) for `peruDepartureInspection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PeruDepartureInspectionNodeIdDelete>;
  /** The primary key(s) and patch data for `peruDepartureInspection` for the far side of the relationship. */
  updateByContainerId?: Maybe<PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPkeyUpdate>;
  /** The primary key(s) and patch data for `peruDepartureInspection` for the far side of the relationship. */
  updateByNodeId?: Maybe<PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate>;
  /** A `PeruDepartureInspectionInput` object that will be created and connected to this object. */
  create?: Maybe<FkContainerPeruDepartureInspectionCreateInput>;
};

/** Input for the nested mutation of `peruDepartureInspectionPallet` in the `PeruDepartureInspectionInput` mutation. */
export type FkContainerInverseInput = {
  /** Flag indicating whether all other `peruDepartureInspectionPallet` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  connectById?: Maybe<Array<PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyConnect>>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PeruDepartureInspectionPalletNodeIdConnect>>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  deleteById?: Maybe<Array<PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyDelete>>;
  /** The primary key(s) for `peruDepartureInspectionPallet` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PeruDepartureInspectionPalletNodeIdDelete>>;
  /** The primary key(s) and patch data for `peruDepartureInspectionPallet` for the far side of the relationship. */
  updateById?: Maybe<Array<PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPalletPkeyUpdate>>;
  /** The primary key(s) and patch data for `peruDepartureInspectionPallet` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate>>;
  /** A `PeruDepartureInspectionPalletInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkContainerPeruDepartureInspectionPalletCreateInput>>;
};

/** The `peruDepartureInspection` to be created by this mutation. */
export type FkContainerPeruDepartureInspectionCreateInput = {
  avgBunchesPerBox: Scalars['BigFloat'];
  avgNetWeight: Scalars['BigFloat'];
  bagsPerBox: Scalars['BigFloat'];
  bagType?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  brixAvg: Scalars['BigFloat'];
  brixMax: Scalars['BigFloat'];
  brixMin: Scalars['BigFloat'];
  category: Scalars['String'];
  comments: Scalars['String'];
  conditionScore: Scalars['BigFloat'];
  departureWeek: Scalars['String'];
  destination: Scalars['String'];
  exporter: Scalars['String'];
  inspectionDate: Scalars['Date'];
  packingDate: Scalars['Date'];
  packingHouse: Scalars['String'];
  packingMaterial: Scalars['String'];
  presentation: Scalars['String'];
  qualityScore: Scalars['BigFloat'];
  variety: Scalars['String'];
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** The `peruDepartureInspectionPallet` to be created by this mutation. */
export type FkContainerPeruDepartureInspectionPalletCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletId: Scalars['String'];
  size: Scalars['String'];
  netWeight: Scalars['BigFloat'];
  openingScore: Scalars['BigFloat'];
  colorScore: Scalars['BigFloat'];
  stemScore: Scalars['BigFloat'];
  textureScore: Scalars['BigFloat'];
  bunchesPerBox: Scalars['BigFloat'];
  brix: Scalars['BigFloat'];
  qualityScore: Scalars['BigFloat'];
  conditionScore: Scalars['BigFloat'];
  stragglyTightPct: Scalars['BigFloat'];
  surfaceDiscPct: Scalars['BigFloat'];
  russetScarsPct: Scalars['BigFloat'];
  sunburnPct: Scalars['BigFloat'];
  undersizedBunchesPct: Scalars['BigFloat'];
  otherDefectsPct: Scalars['BigFloat'];
  totalQualityDefectsPct: Scalars['BigFloat'];
  stemDehyPct: Scalars['BigFloat'];
  glassyWeakPct: Scalars['BigFloat'];
  decayPct: Scalars['BigFloat'];
  splitCrushedPct: Scalars['BigFloat'];
  drySplitPct: Scalars['BigFloat'];
  wetStickyPct: Scalars['BigFloat'];
  waterberriesPct: Scalars['BigFloat'];
  shatterPct: Scalars['BigFloat'];
  totalConditionDefectsPct: Scalars['BigFloat'];
  totalDefectsPct: Scalars['BigFloat'];
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperProjectionVesselInfoInput` mutation. */
export type FkShipperIdInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProjectionVesselInfoForFkShipperIdUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForFkShipperIdNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<FkShipperIdShipperCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionVesselInfo` in the `ShipperInput` mutation. */
export type FkShipperIdInverseInput = {
  /** Flag indicating whether all other `shipperProjectionVesselInfo` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionVesselInfoNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionVesselInfoNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForFkShipperIdUsingShipperProjectionVesselInfoPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProjectionVesselInfoForFkShipperIdNodeIdUpdate>>;
  /** A `ShipperProjectionVesselInfoInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkShipperIdShipperProjectionVesselInfoCreateInput>>;
};

/** The `shipper` to be created by this mutation. */
export type FkShipperIdShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** The `shipperProjectionVesselInfo` to be created by this mutation. */
export type FkShipperIdShipperProjectionVesselInfoCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** All input for the `generateNewContainers` mutation. */
export type GenerateNewContainersInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** The output of our `generateNewContainers` mutation. */
export type GenerateNewContainersPayload = {
  __typename?: 'GenerateNewContainersPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  containers?: Maybe<Array<Maybe<Container>>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};

export type InventoryItem = Node & {
  __typename?: 'InventoryItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  plu?: Maybe<Scalars['Boolean']>;
  countryId?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  coast?: Maybe<Scalars['String']>;
  storageRank?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
  country?: Maybe<Country>;
  packType?: Maybe<PackMaster>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets: PalletsConnection;
  product?: Maybe<ProductMaster>;
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ProductSize`. */
  sizes: ProductSizesConnection;
  vessel?: Maybe<Vessel>;
  vesselDischargeDate?: Maybe<Scalars['Date']>;
  vesselInvFlag?: Maybe<Scalars['Boolean']>;
  warehouse?: Maybe<Warehouse>;
};


export type InventoryItemPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletFilter>;
};


export type InventoryItemSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ProductSizeFilter>;
};

/**
 * A condition to be used against `InventoryItem` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InventoryItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletsReceived` field. */
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsCommitted` field. */
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsOnHand` field. */
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsAvailable` field. */
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsShipped` field. */
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsTransferredIn` field. */
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletsTransferredOut` field. */
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `specialLotNumber` field. */
  specialLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `coast` field. */
  coast?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `storageRank` field. */
  storageRank?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPre` field. */
  isPre?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `InventoryItem` object types. All fields are combined with a logical ‘and.’ */
export type InventoryItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<StringFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `palletsReceived` field. */
  palletsReceived?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsCommitted` field. */
  palletsCommitted?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsOnHand` field. */
  palletsOnHand?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsAvailable` field. */
  palletsAvailable?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsShipped` field. */
  palletsShipped?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsTransferredIn` field. */
  palletsTransferredIn?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletsTransferredOut` field. */
  palletsTransferredOut?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<BooleanFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `specialLotNumber` field. */
  specialLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `coast` field. */
  coast?: Maybe<StringFilter>;
  /** Filter by the object’s `storageRank` field. */
  storageRank?: Maybe<StringFilter>;
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `isPre` field. */
  isPre?: Maybe<BooleanFilter>;
  /** Filter by the object’s `vesselDischargeDate` field. */
  vesselDischargeDate?: Maybe<DateFilter>;
  /** Filter by the object’s `vesselInvFlag` field. */
  vesselInvFlag?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InventoryItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InventoryItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<InventoryItemFilter>;
};

/** An input for mutations affecting `InventoryItem` */
export type InventoryItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  plu?: Maybe<Scalars['Boolean']>;
  countryId?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  coast?: Maybe<Scalars['String']>;
  storageRank?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
};

/** Represents an update to a `InventoryItem`. Fields that are set will be updated. */
export type InventoryItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletsReceived?: Maybe<Scalars['BigFloat']>;
  palletsCommitted?: Maybe<Scalars['BigFloat']>;
  palletsOnHand?: Maybe<Scalars['BigFloat']>;
  palletsAvailable?: Maybe<Scalars['BigFloat']>;
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  palletsTransferredIn?: Maybe<Scalars['BigFloat']>;
  palletsTransferredOut?: Maybe<Scalars['BigFloat']>;
  plu?: Maybe<Scalars['Boolean']>;
  countryId?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  coast?: Maybe<Scalars['String']>;
  storageRank?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
};

/** A connection to a list of `InventoryItem` values. */
export type InventoryItemsConnection = {
  __typename?: 'InventoryItemsConnection';
  /** A list of `InventoryItem` objects. */
  nodes: Array<Maybe<InventoryItem>>;
  /** A list of edges which contains the `InventoryItem` and cursor to aid in pagination. */
  edges: Array<InventoryItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InventoryItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `InventoryItem` edge in the connection. */
export type InventoryItemsEdge = {
  __typename?: 'InventoryItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InventoryItem` at the end of the edge. */
  node?: Maybe<InventoryItem>;
};

/** Methods to use when ordering `InventoryItem`. */
export enum InventoryItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  JvLotNumberAsc = 'JV_LOT_NUMBER_ASC',
  JvLotNumberDesc = 'JV_LOT_NUMBER_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PalletsReceivedAsc = 'PALLETS_RECEIVED_ASC',
  PalletsReceivedDesc = 'PALLETS_RECEIVED_DESC',
  PalletsCommittedAsc = 'PALLETS_COMMITTED_ASC',
  PalletsCommittedDesc = 'PALLETS_COMMITTED_DESC',
  PalletsOnHandAsc = 'PALLETS_ON_HAND_ASC',
  PalletsOnHandDesc = 'PALLETS_ON_HAND_DESC',
  PalletsAvailableAsc = 'PALLETS_AVAILABLE_ASC',
  PalletsAvailableDesc = 'PALLETS_AVAILABLE_DESC',
  PalletsShippedAsc = 'PALLETS_SHIPPED_ASC',
  PalletsShippedDesc = 'PALLETS_SHIPPED_DESC',
  PalletsTransferredInAsc = 'PALLETS_TRANSFERRED_IN_ASC',
  PalletsTransferredInDesc = 'PALLETS_TRANSFERRED_IN_DESC',
  PalletsTransferredOutAsc = 'PALLETS_TRANSFERRED_OUT_ASC',
  PalletsTransferredOutDesc = 'PALLETS_TRANSFERRED_OUT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  SpecialLotNumberAsc = 'SPECIAL_LOT_NUMBER_ASC',
  SpecialLotNumberDesc = 'SPECIAL_LOT_NUMBER_DESC',
  CoastAsc = 'COAST_ASC',
  CoastDesc = 'COAST_DESC',
  StorageRankAsc = 'STORAGE_RANK_ASC',
  StorageRankDesc = 'STORAGE_RANK_DESC',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  IsPreAsc = 'IS_PRE_ASC',
  IsPreDesc = 'IS_PRE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type InvoiceHeader = Node & {
  __typename?: 'InvoiceHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  orderStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  shipWarehouseId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  invoiceDate?: Maybe<Scalars['Date']>;
  shippingCustomerId?: Maybe<Scalars['String']>;
  orderDate?: Maybe<Scalars['Date']>;
  entryDate?: Maybe<Scalars['Date']>;
  actualShipDate?: Maybe<Scalars['Date']>;
  expectedShipDate?: Maybe<Scalars['Date']>;
  amountOwed?: Maybe<Scalars['BigFloat']>;
  paidCode?: Maybe<Scalars['String']>;
  loadLocation?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  registerNumber?: Maybe<Scalars['String']>;
  deliveryZone?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  billingCustomer?: Maybe<Customer>;
  conditionCode?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  flag?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `InvoiceItemHistory`. */
  itemHistories: InvoiceItemHistoriesConnection;
  /** Reads and enables pagination through a set of `InvoiceItem`. */
  items: InvoiceItemsConnection;
  netAmountDue?: Maybe<Scalars['BigFloat']>;
  originalInvoice?: Maybe<InvoiceHeader>;
  /** Reads and enables pagination through a set of `CustomerPayment`. */
  payments: CustomerPaymentsConnection;
  /** Reads and enables pagination through a set of `InvoiceHeader`. */
  rejectedInvoices: InvoiceHeadersConnection;
  /** Reads and enables pagination through a set of `RepackQueue`. */
  repackQueues: RepackQueuesConnection;
  salesUser?: Maybe<User>;
  searchText?: Maybe<Scalars['String']>;
  shipWarehouse?: Maybe<Warehouse>;
  shippingCustomer?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `InvoiceHeader`. */
  splitInvoices: InvoiceHeadersConnection;
  totalAmount?: Maybe<Scalars['BigFloat']>;
  totalAmountsByVesselAndShipper: InvoiceHeaderTotalAmountsByVesselAndShipperConnection;
  truckLoad?: Maybe<TruckLoad>;
  vendor?: Maybe<Vendor>;
};


export type InvoiceHeaderItemHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceItemHistoryFilter>;
};


export type InvoiceHeaderItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceItemFilter>;
};


export type InvoiceHeaderPaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<CustomerPaymentFilter>;
};


export type InvoiceHeaderRejectedInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceHeaderFilter>;
};


export type InvoiceHeaderRepackQueuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<RepackQueueFilter>;
};


export type InvoiceHeaderSplitInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceHeaderFilter>;
};


export type InvoiceHeaderTotalAmountsByVesselAndShipperArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};

/**
 * A condition to be used against `InvoiceHeader` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InvoiceHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderStatus` field. */
  orderStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipWarehouseId` field. */
  shipWarehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `billingCustomerId` field. */
  billingCustomerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerPo` field. */
  customerPo?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceDate` field. */
  invoiceDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `shippingCustomerId` field. */
  shippingCustomerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderDate` field. */
  orderDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `entryDate` field. */
  entryDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `actualShipDate` field. */
  actualShipDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `expectedShipDate` field. */
  expectedShipDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `amountOwed` field. */
  amountOwed?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `paidCode` field. */
  paidCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `loadLocation` field. */
  loadLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `loadStatus` field. */
  loadStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fob` field. */
  fob?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `registerNumber` field. */
  registerNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deliveryZone` field. */
  deliveryZone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `InvoiceHeader` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orderStatus` field. */
  orderStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipWarehouseId` field. */
  shipWarehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<StringFilter>;
  /** Filter by the object’s `billingCustomerId` field. */
  billingCustomerId?: Maybe<StringFilter>;
  /** Filter by the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `customerPo` field. */
  customerPo?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiceDate` field. */
  invoiceDate?: Maybe<DateFilter>;
  /** Filter by the object’s `shippingCustomerId` field. */
  shippingCustomerId?: Maybe<StringFilter>;
  /** Filter by the object’s `orderDate` field. */
  orderDate?: Maybe<DateFilter>;
  /** Filter by the object’s `entryDate` field. */
  entryDate?: Maybe<DateFilter>;
  /** Filter by the object’s `actualShipDate` field. */
  actualShipDate?: Maybe<DateFilter>;
  /** Filter by the object’s `expectedShipDate` field. */
  expectedShipDate?: Maybe<DateFilter>;
  /** Filter by the object’s `amountOwed` field. */
  amountOwed?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `paidCode` field. */
  paidCode?: Maybe<StringFilter>;
  /** Filter by the object’s `loadLocation` field. */
  loadLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `loadStatus` field. */
  loadStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `fob` field. */
  fob?: Maybe<BooleanFilter>;
  /** Filter by the object’s `registerNumber` field. */
  registerNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `deliveryZone` field. */
  deliveryZone?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `conditionCode` field. */
  conditionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `creditCode` field. */
  creditCode?: Maybe<StringFilter>;
  /** Filter by the object’s `flag` field. */
  flag?: Maybe<StringFilter>;
  /** Filter by the object’s `netAmountDue` field. */
  netAmountDue?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `totalAmount` field. */
  totalAmount?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InvoiceHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InvoiceHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<InvoiceHeaderFilter>;
};

/** An input for mutations affecting `InvoiceHeader` */
export type InvoiceHeaderInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  shipWarehouseId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  invoiceDate?: Maybe<Scalars['Date']>;
  shippingCustomerId?: Maybe<Scalars['String']>;
  orderDate?: Maybe<Scalars['Date']>;
  entryDate?: Maybe<Scalars['Date']>;
  actualShipDate?: Maybe<Scalars['Date']>;
  expectedShipDate?: Maybe<Scalars['Date']>;
  amountOwed?: Maybe<Scalars['BigFloat']>;
  paidCode?: Maybe<Scalars['String']>;
  loadLocation?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  registerNumber?: Maybe<Scalars['String']>;
  deliveryZone?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
};

/** Represents an update to a `InvoiceHeader`. Fields that are set will be updated. */
export type InvoiceHeaderPatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  shipWarehouseId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  invoiceDate?: Maybe<Scalars['Date']>;
  shippingCustomerId?: Maybe<Scalars['String']>;
  orderDate?: Maybe<Scalars['Date']>;
  entryDate?: Maybe<Scalars['Date']>;
  actualShipDate?: Maybe<Scalars['Date']>;
  expectedShipDate?: Maybe<Scalars['Date']>;
  amountOwed?: Maybe<Scalars['BigFloat']>;
  paidCode?: Maybe<Scalars['String']>;
  loadLocation?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  registerNumber?: Maybe<Scalars['String']>;
  deliveryZone?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type InvoiceHeaderTotalAmountsByVesselAndShipperConnection = {
  __typename?: 'InvoiceHeaderTotalAmountsByVesselAndShipperConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<InvoiceHeaderTotalAmountsByVesselAndShipperEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type InvoiceHeaderTotalAmountsByVesselAndShipperEdge = {
  __typename?: 'InvoiceHeaderTotalAmountsByVesselAndShipperEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `InvoiceHeader` values. */
export type InvoiceHeadersConnection = {
  __typename?: 'InvoiceHeadersConnection';
  /** A list of `InvoiceHeader` objects. */
  nodes: Array<Maybe<InvoiceHeader>>;
  /** A list of edges which contains the `InvoiceHeader` and cursor to aid in pagination. */
  edges: Array<InvoiceHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InvoiceHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `InvoiceHeader` edge in the connection. */
export type InvoiceHeadersEdge = {
  __typename?: 'InvoiceHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InvoiceHeader` at the end of the edge. */
  node?: Maybe<InvoiceHeader>;
};

/** Methods to use when ordering `InvoiceHeader`. */
export enum InvoiceHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderStatusAsc = 'ORDER_STATUS_ASC',
  OrderStatusDesc = 'ORDER_STATUS_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  TruckLoadIdAsc = 'TRUCK_LOAD_ID_ASC',
  TruckLoadIdDesc = 'TRUCK_LOAD_ID_DESC',
  ShipWarehouseIdAsc = 'SHIP_WAREHOUSE_ID_ASC',
  ShipWarehouseIdDesc = 'SHIP_WAREHOUSE_ID_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  BillingCustomerIdAsc = 'BILLING_CUSTOMER_ID_ASC',
  BillingCustomerIdDesc = 'BILLING_CUSTOMER_ID_DESC',
  SalesUserCodeAsc = 'SALES_USER_CODE_ASC',
  SalesUserCodeDesc = 'SALES_USER_CODE_DESC',
  CustomerPoAsc = 'CUSTOMER_PO_ASC',
  CustomerPoDesc = 'CUSTOMER_PO_DESC',
  InvoiceDateAsc = 'INVOICE_DATE_ASC',
  InvoiceDateDesc = 'INVOICE_DATE_DESC',
  ShippingCustomerIdAsc = 'SHIPPING_CUSTOMER_ID_ASC',
  ShippingCustomerIdDesc = 'SHIPPING_CUSTOMER_ID_DESC',
  OrderDateAsc = 'ORDER_DATE_ASC',
  OrderDateDesc = 'ORDER_DATE_DESC',
  EntryDateAsc = 'ENTRY_DATE_ASC',
  EntryDateDesc = 'ENTRY_DATE_DESC',
  ActualShipDateAsc = 'ACTUAL_SHIP_DATE_ASC',
  ActualShipDateDesc = 'ACTUAL_SHIP_DATE_DESC',
  ExpectedShipDateAsc = 'EXPECTED_SHIP_DATE_ASC',
  ExpectedShipDateDesc = 'EXPECTED_SHIP_DATE_DESC',
  AmountOwedAsc = 'AMOUNT_OWED_ASC',
  AmountOwedDesc = 'AMOUNT_OWED_DESC',
  PaidCodeAsc = 'PAID_CODE_ASC',
  PaidCodeDesc = 'PAID_CODE_DESC',
  LoadLocationAsc = 'LOAD_LOCATION_ASC',
  LoadLocationDesc = 'LOAD_LOCATION_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  LoadStatusAsc = 'LOAD_STATUS_ASC',
  LoadStatusDesc = 'LOAD_STATUS_DESC',
  FobAsc = 'FOB_ASC',
  FobDesc = 'FOB_DESC',
  RegisterNumberAsc = 'REGISTER_NUMBER_ASC',
  RegisterNumberDesc = 'REGISTER_NUMBER_DESC',
  DeliveryZoneAsc = 'DELIVERY_ZONE_ASC',
  DeliveryZoneDesc = 'DELIVERY_ZONE_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type InvoiceItem = Node & {
  __typename?: 'InvoiceItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  pickedQty?: Maybe<Scalars['BigFloat']>;
  palletId?: Maybe<Scalars['String']>;
  conditionCode?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  creditAmount?: Maybe<Scalars['BigFloat']>;
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
  layerMult?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  flag?: Maybe<Scalars['String']>;
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  creditedQty?: Maybe<Scalars['BigFloat']>;
  repackCode?: Maybe<Scalars['String']>;
  pallet?: Maybe<Pallet>;
};

/**
 * A condition to be used against `InvoiceItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type InvoiceItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletStatus` field. */
  palletStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `lineId` field. */
  lineId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `sequenceId` field. */
  sequenceId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pickedQty` field. */
  pickedQty?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `conditionCode` field. */
  conditionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creditCode` field. */
  creditCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `priceAdjustment` field. */
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `freightAdjustment` field. */
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `creditAmount` field. */
  creditAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brokerageAmount` field. */
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `layerMult` field. */
  layerMult?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `flag` field. */
  flag?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `volumeDiscountAmount` field. */
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `miaAdjustment` field. */
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `creditedQty` field. */
  creditedQty?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `repackCode` field. */
  repackCode?: Maybe<Scalars['String']>;
};

/** A filter to be used against `InvoiceItem` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletStatus` field. */
  palletStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `lineId` field. */
  lineId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `sequenceId` field. */
  sequenceId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `pickedQty` field. */
  pickedQty?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `conditionCode` field. */
  conditionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `creditCode` field. */
  creditCode?: Maybe<StringFilter>;
  /** Filter by the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `priceAdjustment` field. */
  priceAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `freightAdjustment` field. */
  freightAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `creditAmount` field. */
  creditAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brokerageAmount` field. */
  brokerageAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `layerMult` field. */
  layerMult?: Maybe<BooleanFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `flag` field. */
  flag?: Maybe<StringFilter>;
  /** Filter by the object’s `volumeDiscountAmount` field. */
  volumeDiscountAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `miaAdjustment` field. */
  miaAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `creditedQty` field. */
  creditedQty?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `repackCode` field. */
  repackCode?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InvoiceItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InvoiceItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<InvoiceItemFilter>;
};

/** A connection to a list of `InvoiceItemHistory` values. */
export type InvoiceItemHistoriesConnection = {
  __typename?: 'InvoiceItemHistoriesConnection';
  /** A list of `InvoiceItemHistory` objects. */
  nodes: Array<Maybe<InvoiceItemHistory>>;
  /** A list of edges which contains the `InvoiceItemHistory` and cursor to aid in pagination. */
  edges: Array<InvoiceItemHistoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InvoiceItemHistory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `InvoiceItemHistory` edge in the connection. */
export type InvoiceItemHistoriesEdge = {
  __typename?: 'InvoiceItemHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InvoiceItemHistory` at the end of the edge. */
  node?: Maybe<InvoiceItemHistory>;
};

/** Methods to use when ordering `InvoiceItemHistory`. */
export enum InvoiceItemHistoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  LineIdAsc = 'LINE_ID_ASC',
  LineIdDesc = 'LINE_ID_DESC',
  SequenceIdAsc = 'SEQUENCE_ID_ASC',
  SequenceIdDesc = 'SEQUENCE_ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  PickedQtyAsc = 'PICKED_QTY_ASC',
  PickedQtyDesc = 'PICKED_QTY_DESC',
  ConditionCodeAsc = 'CONDITION_CODE_ASC',
  ConditionCodeDesc = 'CONDITION_CODE_DESC',
  CreditCodeAsc = 'CREDIT_CODE_ASC',
  CreditCodeDesc = 'CREDIT_CODE_DESC',
  UnitSellPriceAsc = 'UNIT_SELL_PRICE_ASC',
  UnitSellPriceDesc = 'UNIT_SELL_PRICE_DESC',
  PriceAdjustmentAsc = 'PRICE_ADJUSTMENT_ASC',
  PriceAdjustmentDesc = 'PRICE_ADJUSTMENT_DESC',
  DeliveryChargeAsc = 'DELIVERY_CHARGE_ASC',
  DeliveryChargeDesc = 'DELIVERY_CHARGE_DESC',
  FreightAdjustmentAsc = 'FREIGHT_ADJUSTMENT_ASC',
  FreightAdjustmentDesc = 'FREIGHT_ADJUSTMENT_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  MiaAdjustmentAsc = 'MIA_ADJUSTMENT_ASC',
  MiaAdjustmentDesc = 'MIA_ADJUSTMENT_DESC',
  VolumeDiscountAmountAsc = 'VOLUME_DISCOUNT_AMOUNT_ASC',
  VolumeDiscountAmountDesc = 'VOLUME_DISCOUNT_AMOUNT_DESC',
  BrokerageAmountAsc = 'BROKERAGE_AMOUNT_ASC',
  BrokerageAmountDesc = 'BROKERAGE_AMOUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type InvoiceItemHistory = Node & {
  __typename?: 'InvoiceItemHistory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  palletId: Scalars['String'];
  pickedQty?: Maybe<Scalars['BigFloat']>;
  conditionCode?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
  pallet?: Maybe<Pallet>;
};

/**
 * A condition to be used against `InvoiceItemHistory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InvoiceItemHistoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `lineId` field. */
  lineId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `sequenceId` field. */
  sequenceId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pickedQty` field. */
  pickedQty?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `conditionCode` field. */
  conditionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creditCode` field. */
  creditCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `priceAdjustment` field. */
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `freightAdjustment` field. */
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `miaAdjustment` field. */
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `volumeDiscountAmount` field. */
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brokerageAmount` field. */
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `InvoiceItemHistory` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceItemHistoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `lineId` field. */
  lineId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `sequenceId` field. */
  sequenceId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `pickedQty` field. */
  pickedQty?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `conditionCode` field. */
  conditionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `creditCode` field. */
  creditCode?: Maybe<StringFilter>;
  /** Filter by the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `priceAdjustment` field. */
  priceAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `freightAdjustment` field. */
  freightAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `miaAdjustment` field. */
  miaAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `volumeDiscountAmount` field. */
  volumeDiscountAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brokerageAmount` field. */
  brokerageAmount?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InvoiceItemHistoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InvoiceItemHistoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<InvoiceItemHistoryFilter>;
};

/** An input for mutations affecting `InvoiceItemHistory` */
export type InvoiceItemHistoryInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  palletId: Scalars['String'];
  pickedQty?: Maybe<Scalars['BigFloat']>;
  conditionCode?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
};

/** Represents an update to a `InvoiceItemHistory`. Fields that are set will be updated. */
export type InvoiceItemHistoryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  palletId?: Maybe<Scalars['String']>;
  pickedQty?: Maybe<Scalars['BigFloat']>;
  conditionCode?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
};

/** An input for mutations affecting `InvoiceItem` */
export type InvoiceItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  pickedQty?: Maybe<Scalars['BigFloat']>;
  palletId?: Maybe<Scalars['String']>;
  conditionCode?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  creditAmount?: Maybe<Scalars['BigFloat']>;
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
  layerMult?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  flag?: Maybe<Scalars['String']>;
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  creditedQty?: Maybe<Scalars['BigFloat']>;
  repackCode?: Maybe<Scalars['String']>;
};

/** Represents an update to a `InvoiceItem`. Fields that are set will be updated. */
export type InvoiceItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  sequenceId?: Maybe<Scalars['BigFloat']>;
  pickedQty?: Maybe<Scalars['BigFloat']>;
  palletId?: Maybe<Scalars['String']>;
  conditionCode?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  creditAmount?: Maybe<Scalars['BigFloat']>;
  brokerageAmount?: Maybe<Scalars['BigFloat']>;
  layerMult?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  flag?: Maybe<Scalars['String']>;
  volumeDiscountAmount?: Maybe<Scalars['BigFloat']>;
  miaAdjustment?: Maybe<Scalars['BigFloat']>;
  creditedQty?: Maybe<Scalars['BigFloat']>;
  repackCode?: Maybe<Scalars['String']>;
};

/** A connection to a list of `InvoiceItem` values. */
export type InvoiceItemsConnection = {
  __typename?: 'InvoiceItemsConnection';
  /** A list of `InvoiceItem` objects. */
  nodes: Array<Maybe<InvoiceItem>>;
  /** A list of edges which contains the `InvoiceItem` and cursor to aid in pagination. */
  edges: Array<InvoiceItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InvoiceItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `InvoiceItem` edge in the connection. */
export type InvoiceItemsEdge = {
  __typename?: 'InvoiceItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InvoiceItem` at the end of the edge. */
  node?: Maybe<InvoiceItem>;
};

/** Methods to use when ordering `InvoiceItem`. */
export enum InvoiceItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletStatusAsc = 'PALLET_STATUS_ASC',
  PalletStatusDesc = 'PALLET_STATUS_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  LineIdAsc = 'LINE_ID_ASC',
  LineIdDesc = 'LINE_ID_DESC',
  SequenceIdAsc = 'SEQUENCE_ID_ASC',
  SequenceIdDesc = 'SEQUENCE_ID_DESC',
  PickedQtyAsc = 'PICKED_QTY_ASC',
  PickedQtyDesc = 'PICKED_QTY_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ConditionCodeAsc = 'CONDITION_CODE_ASC',
  ConditionCodeDesc = 'CONDITION_CODE_DESC',
  CreditCodeAsc = 'CREDIT_CODE_ASC',
  CreditCodeDesc = 'CREDIT_CODE_DESC',
  UnitSellPriceAsc = 'UNIT_SELL_PRICE_ASC',
  UnitSellPriceDesc = 'UNIT_SELL_PRICE_DESC',
  PriceAdjustmentAsc = 'PRICE_ADJUSTMENT_ASC',
  PriceAdjustmentDesc = 'PRICE_ADJUSTMENT_DESC',
  DeliveryChargeAsc = 'DELIVERY_CHARGE_ASC',
  DeliveryChargeDesc = 'DELIVERY_CHARGE_DESC',
  FreightAdjustmentAsc = 'FREIGHT_ADJUSTMENT_ASC',
  FreightAdjustmentDesc = 'FREIGHT_ADJUSTMENT_DESC',
  CreditAmountAsc = 'CREDIT_AMOUNT_ASC',
  CreditAmountDesc = 'CREDIT_AMOUNT_DESC',
  BrokerageAmountAsc = 'BROKERAGE_AMOUNT_ASC',
  BrokerageAmountDesc = 'BROKERAGE_AMOUNT_DESC',
  LayerMultAsc = 'LAYER_MULT_ASC',
  LayerMultDesc = 'LAYER_MULT_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  FlagAsc = 'FLAG_ASC',
  FlagDesc = 'FLAG_DESC',
  VolumeDiscountAmountAsc = 'VOLUME_DISCOUNT_AMOUNT_ASC',
  VolumeDiscountAmountDesc = 'VOLUME_DISCOUNT_AMOUNT_DESC',
  MiaAdjustmentAsc = 'MIA_ADJUSTMENT_ASC',
  MiaAdjustmentDesc = 'MIA_ADJUSTMENT_DESC',
  CreditedQtyAsc = 'CREDITED_QTY_ASC',
  CreditedQtyDesc = 'CREDITED_QTY_DESC',
  RepackCodeAsc = 'REPACK_CODE_ASC',
  RepackCodeDesc = 'REPACK_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type LoadNumber = Node & {
  __typename?: 'LoadNumber';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  customerId?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  /** Reads a single `User` that is related to this `LoadNumber`. */
  user?: Maybe<User>;
  customer?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `InvoiceHeader`. */
  invoiceHeaders: InvoiceHeadersConnection;
  isUsed?: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `OrderEntry`. */
  orderEntries: OrderEntriesConnection;
  orderMaster?: Maybe<OrderMaster>;
};


export type LoadNumberInvoiceHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceHeaderFilter>;
};


export type LoadNumberOrderEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<OrderEntryFilter>;
};

/**
 * A condition to be used against `LoadNumber` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LoadNumberCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `LoadNumber` object types. All fields are combined with a logical ‘and.’ */
export type LoadNumberFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `isUsed` field. */
  isUsed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LoadNumberFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LoadNumberFilter>>;
  /** Negates the expression. */
  not?: Maybe<LoadNumberFilter>;
};

/** An input for mutations affecting `LoadNumber` */
export type LoadNumberInput = {
  id: Scalars['BigInt'];
  customerId?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<LoadNumberUserIdFkeyInput>;
};

/** The fields on `loadNumber` to look up the row to connect. */
export type LoadNumberLoadNumberPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `loadNumber` to look up the row to delete. */
export type LoadNumberLoadNumberPkeyDelete = {
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LoadNumberNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `loadNumber` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LoadNumberNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `loadNumber` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LoadNumberOnLoadNumberForLoadNumberUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `loadNumber` to look up the row to update. */
export type LoadNumberOnLoadNumberForLoadNumberUserIdFkeyUsingLoadNumberPkeyUpdate = {
  /** An object where the defined keys will be set on the `loadNumber` being updated. */
  patch: UpdateLoadNumberOnLoadNumberForLoadNumberUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `LoadNumber`. Fields that are set will be updated. */
export type LoadNumberPatch = {
  id?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<LoadNumberUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `LoadNumberInput` mutation. */
export type LoadNumberUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<UserUserPinKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<UserUserPinKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnLoadNumberForLoadNumberUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<UserOnLoadNumberForLoadNumberUserIdFkeyUsingUserPinKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<LoadNumberOnLoadNumberForLoadNumberUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<LoadNumberUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `loadNumber` in the `UserInput` mutation. */
export type LoadNumberUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `loadNumber` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `loadNumber` for the far side of the relationship. */
  connectById?: Maybe<Array<LoadNumberLoadNumberPkeyConnect>>;
  /** The primary key(s) for `loadNumber` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LoadNumberNodeIdConnect>>;
  /** The primary key(s) for `loadNumber` for the far side of the relationship. */
  deleteById?: Maybe<Array<LoadNumberLoadNumberPkeyDelete>>;
  /** The primary key(s) for `loadNumber` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LoadNumberNodeIdDelete>>;
  /** The primary key(s) and patch data for `loadNumber` for the far side of the relationship. */
  updateById?: Maybe<Array<LoadNumberOnLoadNumberForLoadNumberUserIdFkeyUsingLoadNumberPkeyUpdate>>;
  /** The primary key(s) and patch data for `loadNumber` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnLoadNumberForLoadNumberUserIdFkeyNodeIdUpdate>>;
  /** A `LoadNumberInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LoadNumberUserIdFkeyLoadNumberCreateInput>>;
};

/** The `loadNumber` to be created by this mutation. */
export type LoadNumberUserIdFkeyLoadNumberCreateInput = {
  id: Scalars['BigInt'];
  customerId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<LoadNumberUserIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type LoadNumberUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** A connection to a list of `LoadNumber` values. */
export type LoadNumbersConnection = {
  __typename?: 'LoadNumbersConnection';
  /** A list of `LoadNumber` objects. */
  nodes: Array<Maybe<LoadNumber>>;
  /** A list of edges which contains the `LoadNumber` and cursor to aid in pagination. */
  edges: Array<LoadNumbersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LoadNumber` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `LoadNumber` edge in the connection. */
export type LoadNumbersEdge = {
  __typename?: 'LoadNumbersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LoadNumber` at the end of the edge. */
  node?: Maybe<LoadNumber>;
};

/** Methods to use when ordering `LoadNumber`. */
export enum LoadNumbersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdPinAsc = 'USER_BY_USER_ID__PIN_ASC',
  UserByUserIdPinDesc = 'USER_BY_USER_ID__PIN_DESC',
  UserByUserIdPersonContactIdAsc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_ASC',
  UserByUserIdPersonContactIdDesc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_DESC',
  UserByUserIdUserCodeAsc = 'USER_BY_USER_ID__USER_CODE_ASC',
  UserByUserIdUserCodeDesc = 'USER_BY_USER_ID__USER_CODE_DESC',
  UserByUserIdDefaultCoastAsc = 'USER_BY_USER_ID__DEFAULT_COAST_ASC',
  UserByUserIdDefaultCoastDesc = 'USER_BY_USER_ID__DEFAULT_COAST_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `OrderNumber`. */
  createOrderNumber?: Maybe<CreateOrderNumberPayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserBookmark`. */
  createUserBookmark?: Maybe<CreateUserBookmarkPayload>;
  /** Creates a single `UserMessage`. */
  createUserMessage?: Maybe<CreateUserMessagePayload>;
  /** Creates a single `UserRole`. */
  createUserRole?: Maybe<CreateUserRolePayload>;
  /** Creates a single `ContactGroup`. */
  createContactGroup?: Maybe<CreateContactGroupPayload>;
  /** Creates a single `ContactGroupPersonContact`. */
  createContactGroupPersonContact?: Maybe<CreateContactGroupPersonContactPayload>;
  /** Creates a single `Country`. */
  createCountry?: Maybe<CreateCountryPayload>;
  /** Creates a single `Customer`. */
  createCustomer?: Maybe<CreateCustomerPayload>;
  /** Creates a single `CustomerPersonContact`. */
  createCustomerPersonContact?: Maybe<CreateCustomerPersonContactPayload>;
  /** Creates a single `CustomerVolumeDiscount`. */
  createCustomerVolumeDiscount?: Maybe<CreateCustomerVolumeDiscountPayload>;
  /** Creates a single `PersonContact`. */
  createPersonContact?: Maybe<CreatePersonContactPayload>;
  /** Creates a single `Shipper`. */
  createShipper?: Maybe<CreateShipperPayload>;
  /** Creates a single `ShipperAdvance`. */
  createShipperAdvance?: Maybe<CreateShipperAdvancePayload>;
  /** Creates a single `ShipperPersonContact`. */
  createShipperPersonContact?: Maybe<CreateShipperPersonContactPayload>;
  /** Creates a single `Vendor`. */
  createVendor?: Maybe<CreateVendorPayload>;
  /** Creates a single `VendorPersonContact`. */
  createVendorPersonContact?: Maybe<CreateVendorPersonContactPayload>;
  /** Creates a single `Warehouse`. */
  createWarehouse?: Maybe<CreateWarehousePayload>;
  /** Creates a single `WarehousePersonContact`. */
  createWarehousePersonContact?: Maybe<CreateWarehousePersonContactPayload>;
  /** Creates a single `ChileDepartureInspectionPallet`. */
  createChileDepartureInspectionPallet?: Maybe<CreateChileDepartureInspectionPalletPayload>;
  /** Creates a single `PeruDepartureInspection`. */
  createPeruDepartureInspection?: Maybe<CreatePeruDepartureInspectionPayload>;
  /** Creates a single `PeruDepartureInspectionPallet`. */
  createPeruDepartureInspectionPallet?: Maybe<CreatePeruDepartureInspectionPalletPayload>;
  /** Creates a single `PsaApplePallet`. */
  createPsaApplePallet?: Maybe<CreatePsaApplePalletPayload>;
  /** Creates a single `PsaArrivalPicture`. */
  createPsaArrivalPicture?: Maybe<CreatePsaArrivalPicturePayload>;
  /** Creates a single `PsaArrivalReport`. */
  createPsaArrivalReport?: Maybe<CreatePsaArrivalReportPayload>;
  /** Creates a single `PsaCherryPallet`. */
  createPsaCherryPallet?: Maybe<CreatePsaCherryPalletPayload>;
  /** Creates a single `PsaCitrusPallet`. */
  createPsaCitrusPallet?: Maybe<CreatePsaCitrusPalletPayload>;
  /** Creates a single `PsaGrapePallet`. */
  createPsaGrapePallet?: Maybe<CreatePsaGrapePalletPayload>;
  /** Creates a single `PsaLemonPallet`. */
  createPsaLemonPallet?: Maybe<CreatePsaLemonPalletPayload>;
  /** Creates a single `PsaPearPallet`. */
  createPsaPearPallet?: Maybe<CreatePsaPearPalletPayload>;
  /** Creates a single `PsaPersimmonPallet`. */
  createPsaPersimmonPallet?: Maybe<CreatePsaPersimmonPalletPayload>;
  /** Creates a single `PsaPomegranatePallet`. */
  createPsaPomegranatePallet?: Maybe<CreatePsaPomegranatePalletPayload>;
  /** Creates a single `PsaStoneFruitPallet`. */
  createPsaStoneFruitPallet?: Maybe<CreatePsaStoneFruitPalletPayload>;
  /** Creates a single `CommonCategory`. */
  createCommonCategory?: Maybe<CreateCommonCategoryPayload>;
  /** Creates a single `CommonPackType`. */
  createCommonPackType?: Maybe<CreateCommonPackTypePayload>;
  /** Creates a single `CommonPackTypePackMaster`. */
  createCommonPackTypePackMaster?: Maybe<CreateCommonPackTypePackMasterPayload>;
  /** Creates a single `CommonPackTypeTag`. */
  createCommonPackTypeTag?: Maybe<CreateCommonPackTypeTagPayload>;
  /** Creates a single `CommonSize`. */
  createCommonSize?: Maybe<CreateCommonSizePayload>;
  /** Creates a single `CommonSizeProductSize`. */
  createCommonSizeProductSize?: Maybe<CreateCommonSizeProductSizePayload>;
  /** Creates a single `CommonSizeTag`. */
  createCommonSizeTag?: Maybe<CreateCommonSizeTagPayload>;
  /** Creates a single `CommonSpecies`. */
  createCommonSpecies?: Maybe<CreateCommonSpeciesPayload>;
  /** Creates a single `CommonSpeciesProductSpecies`. */
  createCommonSpeciesProductSpecies?: Maybe<CreateCommonSpeciesProductSpeciesPayload>;
  /** Creates a single `CommonSpeciesTag`. */
  createCommonSpeciesTag?: Maybe<CreateCommonSpeciesTagPayload>;
  /** Creates a single `CommonVariety`. */
  createCommonVariety?: Maybe<CreateCommonVarietyPayload>;
  /** Creates a single `CommonVarietyProductVariety`. */
  createCommonVarietyProductVariety?: Maybe<CreateCommonVarietyProductVarietyPayload>;
  /** Creates a single `CommonVarietyTag`. */
  createCommonVarietyTag?: Maybe<CreateCommonVarietyTagPayload>;
  /** Creates a single `Container`. */
  createContainer?: Maybe<CreateContainerPayload>;
  /** Creates a single `ContainerTreatment`. */
  createContainerTreatment?: Maybe<CreateContainerTreatmentPayload>;
  /** Creates a single `CustomerProgram`. */
  createCustomerProgram?: Maybe<CreateCustomerProgramPayload>;
  /** Creates a single `CustomerProgramEntry`. */
  createCustomerProgramEntry?: Maybe<CreateCustomerProgramEntryPayload>;
  /** Creates a single `InventoryItem`. */
  createInventoryItem?: Maybe<CreateInventoryItemPayload>;
  /** Creates a single `PackAtmosphere`. */
  createPackAtmosphere?: Maybe<CreatePackAtmospherePayload>;
  /** Creates a single `PackBoxStyle`. */
  createPackBoxStyle?: Maybe<CreatePackBoxStylePayload>;
  /** Creates a single `PackBoxType`. */
  createPackBoxType?: Maybe<CreatePackBoxTypePayload>;
  /** Creates a single `PackDestination`. */
  createPackDestination?: Maybe<CreatePackDestinationPayload>;
  /** Creates a single `PackGrade`. */
  createPackGrade?: Maybe<CreatePackGradePayload>;
  /** Creates a single `PackHold`. */
  createPackHold?: Maybe<CreatePackHoldPayload>;
  /** Creates a single `PackLabel`. */
  createPackLabel?: Maybe<CreatePackLabelPayload>;
  /** Creates a single `PackLiner`. */
  createPackLiner?: Maybe<CreatePackLinerPayload>;
  /** Creates a single `PackMaster`. */
  createPackMaster?: Maybe<CreatePackMasterPayload>;
  /** Creates a single `PackOut`. */
  createPackOut?: Maybe<CreatePackOutPayload>;
  /** Creates a single `PackPalletType`. */
  createPackPalletType?: Maybe<CreatePackPalletTypePayload>;
  /** Creates a single `PackProduction`. */
  createPackProduction?: Maybe<CreatePackProductionPayload>;
  /** Creates a single `PackSpecial`. */
  createPackSpecial?: Maybe<CreatePackSpecialPayload>;
  /** Creates a single `PackStyle`. */
  createPackStyle?: Maybe<CreatePackStylePayload>;
  /** Creates a single `PackTreeRipe`. */
  createPackTreeRipe?: Maybe<CreatePackTreeRipePayload>;
  /** Creates a single `Pallet`. */
  createPallet?: Maybe<CreatePalletPayload>;
  /** Creates a single `PalletSection`. */
  createPalletSection?: Maybe<CreatePalletSectionPayload>;
  /** Creates a single `ProductMaster`. */
  createProductMaster?: Maybe<CreateProductMasterPayload>;
  /** Creates a single `ProductSize`. */
  createProductSize?: Maybe<CreateProductSizePayload>;
  /** Creates a single `ProductSpecies`. */
  createProductSpecies?: Maybe<CreateProductSpeciesPayload>;
  /** Creates a single `ProductVariety`. */
  createProductVariety?: Maybe<CreateProductVarietyPayload>;
  /** Creates a single `RepackStyle`. */
  createRepackStyle?: Maybe<CreateRepackStylePayload>;
  /** Creates a single `ShipperProgram`. */
  createShipperProgram?: Maybe<CreateShipperProgramPayload>;
  /** Creates a single `ShipperProgramEntry`. */
  createShipperProgramEntry?: Maybe<CreateShipperProgramEntryPayload>;
  /** Creates a single `ShipperProgramEntryCustomerProgramEntry`. */
  createShipperProgramEntryCustomerProgramEntry?: Maybe<CreateShipperProgramEntryCustomerProgramEntryPayload>;
  /** Creates a single `ShipperProjection`. */
  createShipperProjection?: Maybe<CreateShipperProjectionPayload>;
  /** Creates a single `ShipperProjectionEntry`. */
  createShipperProjectionEntry?: Maybe<CreateShipperProjectionEntryPayload>;
  /** Creates a single `ShipperProjectionProduct`. */
  createShipperProjectionProduct?: Maybe<CreateShipperProjectionProductPayload>;
  /** Creates a single `ShipperProjectionVessel`. */
  createShipperProjectionVessel?: Maybe<CreateShipperProjectionVesselPayload>;
  /** Creates a single `ShipperProjectionVesselInfo`. */
  createShipperProjectionVesselInfo?: Maybe<CreateShipperProjectionVesselInfoPayload>;
  /** Creates a single `Vessel`. */
  createVessel?: Maybe<CreateVesselPayload>;
  /** Creates a single `AgendaItem`. */
  createAgendaItem?: Maybe<CreateAgendaItemPayload>;
  /** Creates a single `CalendarEvent`. */
  createCalendarEvent?: Maybe<CreateCalendarEventPayload>;
  /** Creates a single `PriceCategory`. */
  createPriceCategory?: Maybe<CreatePriceCategoryPayload>;
  /** Creates a single `PriceEntry`. */
  createPriceEntry?: Maybe<CreatePriceEntryPayload>;
  /** Creates a single `PriceProduct`. */
  createPriceProduct?: Maybe<CreatePriceProductPayload>;
  /** Creates a single `PriceSize`. */
  createPriceSize?: Maybe<CreatePriceSizePayload>;
  /** Creates a single `LoadNumber`. */
  createLoadNumber?: Maybe<CreateLoadNumberPayload>;
  /** Creates a single `OrderComment`. */
  createOrderComment?: Maybe<CreateOrderCommentPayload>;
  /** Creates a single `OrderEntry`. */
  createOrderEntry?: Maybe<CreateOrderEntryPayload>;
  /** Creates a single `OrderEntryItem`. */
  createOrderEntryItem?: Maybe<CreateOrderEntryItemPayload>;
  /** Creates a single `OrderEntryReviewItem`. */
  createOrderEntryReviewItem?: Maybe<CreateOrderEntryReviewItemPayload>;
  /** Creates a single `OrderItem`. */
  createOrderItem?: Maybe<CreateOrderItemPayload>;
  /** Creates a single `OrderMaster`. */
  createOrderMaster?: Maybe<CreateOrderMasterPayload>;
  /** Creates a single `OrderPallet`. */
  createOrderPallet?: Maybe<CreateOrderPalletPayload>;
  /** Creates a single `RepackHeader`. */
  createRepackHeader?: Maybe<CreateRepackHeaderPayload>;
  /** Creates a single `RepackItem`. */
  createRepackItem?: Maybe<CreateRepackItemPayload>;
  /** Creates a single `RepackQueue`. */
  createRepackQueue?: Maybe<CreateRepackQueuePayload>;
  /** Creates a single `TruckLoad`. */
  createTruckLoad?: Maybe<CreateTruckLoadPayload>;
  /** Creates a single `TruckRate`. */
  createTruckRate?: Maybe<CreateTruckRatePayload>;
  /** Creates a single `TruckRateCustomer`. */
  createTruckRateCustomer?: Maybe<CreateTruckRateCustomerPayload>;
  /** Creates a single `CheckHeader`. */
  createCheckHeader?: Maybe<CreateCheckHeaderPayload>;
  /** Creates a single `CustomerPayment`. */
  createCustomerPayment?: Maybe<CreateCustomerPaymentPayload>;
  /** Creates a single `ExpenseHeader`. */
  createExpenseHeader?: Maybe<CreateExpenseHeaderPayload>;
  /** Creates a single `ExpenseHeaderReview`. */
  createExpenseHeaderReview?: Maybe<CreateExpenseHeaderReviewPayload>;
  /** Creates a single `ExpenseItem`. */
  createExpenseItem?: Maybe<CreateExpenseItemPayload>;
  /** Creates a single `InvoiceHeader`. */
  createInvoiceHeader?: Maybe<CreateInvoiceHeaderPayload>;
  /** Creates a single `InvoiceItem`. */
  createInvoiceItem?: Maybe<CreateInvoiceItemPayload>;
  /** Creates a single `InvoiceItemHistory`. */
  createInvoiceItemHistory?: Maybe<CreateInvoiceItemHistoryPayload>;
  /** Creates a single `Unpaid`. */
  createUnpaid?: Maybe<CreateUnpaidPayload>;
  /** Creates a single `VesselControl`. */
  createVesselControl?: Maybe<CreateVesselControlPayload>;
  /** Creates a single `WireRequest`. */
  createWireRequest?: Maybe<CreateWireRequestPayload>;
  /** Creates a single `WireRequestAccountOfSaleItem`. */
  createWireRequestAccountOfSaleItem?: Maybe<CreateWireRequestAccountOfSaleItemPayload>;
  /** Creates a single `WireRequestMiscItem`. */
  createWireRequestMiscItem?: Maybe<CreateWireRequestMiscItemPayload>;
  /** Creates a single `WireRequestOceanFreightItem`. */
  createWireRequestOceanFreightItem?: Maybe<CreateWireRequestOceanFreightItemPayload>;
  /** Creates a single `WireRequestShipperAdvanceItem`. */
  createWireRequestShipperAdvanceItem?: Maybe<CreateWireRequestShipperAdvanceItemPayload>;
  /** Updates a single `OrderNumber` using its globally unique id and a patch. */
  updateOrderNumberByNodeId?: Maybe<UpdateOrderNumberPayload>;
  /** Updates a single `OrderNumber` using a unique key and a patch. */
  updateOrderNumber?: Maybe<UpdateOrderNumberPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByPin?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserBookmark` using its globally unique id and a patch. */
  updateUserBookmarkByNodeId?: Maybe<UpdateUserBookmarkPayload>;
  /** Updates a single `UserBookmark` using a unique key and a patch. */
  updateUserBookmark?: Maybe<UpdateUserBookmarkPayload>;
  /** Updates a single `UserMessage` using its globally unique id and a patch. */
  updateUserMessageByNodeId?: Maybe<UpdateUserMessagePayload>;
  /** Updates a single `UserMessage` using a unique key and a patch. */
  updateUserMessage?: Maybe<UpdateUserMessagePayload>;
  /** Updates a single `UserRole` using a unique key and a patch. */
  updateUserRoleByUserIdAndRoleName?: Maybe<UpdateUserRolePayload>;
  /** Updates a single `ContactGroup` using its globally unique id and a patch. */
  updateContactGroupByNodeId?: Maybe<UpdateContactGroupPayload>;
  /** Updates a single `ContactGroup` using a unique key and a patch. */
  updateContactGroup?: Maybe<UpdateContactGroupPayload>;
  /** Updates a single `ContactGroupPersonContact` using its globally unique id and a patch. */
  updateContactGroupPersonContactByNodeId?: Maybe<UpdateContactGroupPersonContactPayload>;
  /** Updates a single `ContactGroupPersonContact` using a unique key and a patch. */
  updateContactGroupPersonContact?: Maybe<UpdateContactGroupPersonContactPayload>;
  /** Updates a single `Country` using its globally unique id and a patch. */
  updateCountryByNodeId?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Country` using a unique key and a patch. */
  updateCountry?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Customer` using its globally unique id and a patch. */
  updateCustomerByNodeId?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `Customer` using a unique key and a patch. */
  updateCustomer?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `CustomerPersonContact` using its globally unique id and a patch. */
  updateCustomerPersonContactByNodeId?: Maybe<UpdateCustomerPersonContactPayload>;
  /** Updates a single `CustomerPersonContact` using a unique key and a patch. */
  updateCustomerPersonContact?: Maybe<UpdateCustomerPersonContactPayload>;
  /** Updates a single `CustomerVolumeDiscount` using its globally unique id and a patch. */
  updateCustomerVolumeDiscountByNodeId?: Maybe<UpdateCustomerVolumeDiscountPayload>;
  /** Updates a single `CustomerVolumeDiscount` using a unique key and a patch. */
  updateCustomerVolumeDiscount?: Maybe<UpdateCustomerVolumeDiscountPayload>;
  /** Updates a single `PersonContact` using its globally unique id and a patch. */
  updatePersonContactByNodeId?: Maybe<UpdatePersonContactPayload>;
  /** Updates a single `PersonContact` using a unique key and a patch. */
  updatePersonContact?: Maybe<UpdatePersonContactPayload>;
  /** Updates a single `Shipper` using its globally unique id and a patch. */
  updateShipperByNodeId?: Maybe<UpdateShipperPayload>;
  /** Updates a single `Shipper` using a unique key and a patch. */
  updateShipper?: Maybe<UpdateShipperPayload>;
  /** Updates a single `ShipperAdvance` using its globally unique id and a patch. */
  updateShipperAdvanceByNodeId?: Maybe<UpdateShipperAdvancePayload>;
  /** Updates a single `ShipperAdvance` using a unique key and a patch. */
  updateShipperAdvance?: Maybe<UpdateShipperAdvancePayload>;
  /** Updates a single `ShipperPersonContact` using its globally unique id and a patch. */
  updateShipperPersonContactByNodeId?: Maybe<UpdateShipperPersonContactPayload>;
  /** Updates a single `ShipperPersonContact` using a unique key and a patch. */
  updateShipperPersonContact?: Maybe<UpdateShipperPersonContactPayload>;
  /** Updates a single `Vendor` using its globally unique id and a patch. */
  updateVendorByNodeId?: Maybe<UpdateVendorPayload>;
  /** Updates a single `Vendor` using a unique key and a patch. */
  updateVendor?: Maybe<UpdateVendorPayload>;
  /** Updates a single `VendorPersonContact` using its globally unique id and a patch. */
  updateVendorPersonContactByNodeId?: Maybe<UpdateVendorPersonContactPayload>;
  /** Updates a single `VendorPersonContact` using a unique key and a patch. */
  updateVendorPersonContact?: Maybe<UpdateVendorPersonContactPayload>;
  /** Updates a single `Warehouse` using its globally unique id and a patch. */
  updateWarehouseByNodeId?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `Warehouse` using a unique key and a patch. */
  updateWarehouse?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `WarehousePersonContact` using its globally unique id and a patch. */
  updateWarehousePersonContactByNodeId?: Maybe<UpdateWarehousePersonContactPayload>;
  /** Updates a single `WarehousePersonContact` using a unique key and a patch. */
  updateWarehousePersonContact?: Maybe<UpdateWarehousePersonContactPayload>;
  /** Updates a single `ChileDepartureInspectionPallet` using its globally unique id and a patch. */
  updateChileDepartureInspectionPalletByNodeId?: Maybe<UpdateChileDepartureInspectionPalletPayload>;
  /** Updates a single `ChileDepartureInspectionPallet` using a unique key and a patch. */
  updateChileDepartureInspectionPallet?: Maybe<UpdateChileDepartureInspectionPalletPayload>;
  /** Updates a single `PeruDepartureInspection` using its globally unique id and a patch. */
  updatePeruDepartureInspectionByNodeId?: Maybe<UpdatePeruDepartureInspectionPayload>;
  /** Updates a single `PeruDepartureInspection` using a unique key and a patch. */
  updatePeruDepartureInspection?: Maybe<UpdatePeruDepartureInspectionPayload>;
  /** Updates a single `PeruDepartureInspectionPallet` using its globally unique id and a patch. */
  updatePeruDepartureInspectionPalletByNodeId?: Maybe<UpdatePeruDepartureInspectionPalletPayload>;
  /** Updates a single `PeruDepartureInspectionPallet` using a unique key and a patch. */
  updatePeruDepartureInspectionPallet?: Maybe<UpdatePeruDepartureInspectionPalletPayload>;
  /** Updates a single `PsaApplePallet` using its globally unique id and a patch. */
  updatePsaApplePalletByNodeId?: Maybe<UpdatePsaApplePalletPayload>;
  /** Updates a single `PsaApplePallet` using a unique key and a patch. */
  updatePsaApplePallet?: Maybe<UpdatePsaApplePalletPayload>;
  /** Updates a single `PsaArrivalPicture` using its globally unique id and a patch. */
  updatePsaArrivalPictureByNodeId?: Maybe<UpdatePsaArrivalPicturePayload>;
  /** Updates a single `PsaArrivalPicture` using a unique key and a patch. */
  updatePsaArrivalPicture?: Maybe<UpdatePsaArrivalPicturePayload>;
  /** Updates a single `PsaArrivalReport` using its globally unique id and a patch. */
  updatePsaArrivalReportByNodeId?: Maybe<UpdatePsaArrivalReportPayload>;
  /** Updates a single `PsaArrivalReport` using a unique key and a patch. */
  updatePsaArrivalReport?: Maybe<UpdatePsaArrivalReportPayload>;
  /** Updates a single `PsaCherryPallet` using its globally unique id and a patch. */
  updatePsaCherryPalletByNodeId?: Maybe<UpdatePsaCherryPalletPayload>;
  /** Updates a single `PsaCherryPallet` using a unique key and a patch. */
  updatePsaCherryPallet?: Maybe<UpdatePsaCherryPalletPayload>;
  /** Updates a single `PsaCitrusPallet` using its globally unique id and a patch. */
  updatePsaCitrusPalletByNodeId?: Maybe<UpdatePsaCitrusPalletPayload>;
  /** Updates a single `PsaCitrusPallet` using a unique key and a patch. */
  updatePsaCitrusPallet?: Maybe<UpdatePsaCitrusPalletPayload>;
  /** Updates a single `PsaGrapePallet` using its globally unique id and a patch. */
  updatePsaGrapePalletByNodeId?: Maybe<UpdatePsaGrapePalletPayload>;
  /** Updates a single `PsaGrapePallet` using a unique key and a patch. */
  updatePsaGrapePallet?: Maybe<UpdatePsaGrapePalletPayload>;
  /** Updates a single `PsaLemonPallet` using its globally unique id and a patch. */
  updatePsaLemonPalletByNodeId?: Maybe<UpdatePsaLemonPalletPayload>;
  /** Updates a single `PsaLemonPallet` using a unique key and a patch. */
  updatePsaLemonPallet?: Maybe<UpdatePsaLemonPalletPayload>;
  /** Updates a single `PsaPearPallet` using its globally unique id and a patch. */
  updatePsaPearPalletByNodeId?: Maybe<UpdatePsaPearPalletPayload>;
  /** Updates a single `PsaPearPallet` using a unique key and a patch. */
  updatePsaPearPallet?: Maybe<UpdatePsaPearPalletPayload>;
  /** Updates a single `PsaPersimmonPallet` using its globally unique id and a patch. */
  updatePsaPersimmonPalletByNodeId?: Maybe<UpdatePsaPersimmonPalletPayload>;
  /** Updates a single `PsaPersimmonPallet` using a unique key and a patch. */
  updatePsaPersimmonPallet?: Maybe<UpdatePsaPersimmonPalletPayload>;
  /** Updates a single `PsaPomegranatePallet` using its globally unique id and a patch. */
  updatePsaPomegranatePalletByNodeId?: Maybe<UpdatePsaPomegranatePalletPayload>;
  /** Updates a single `PsaPomegranatePallet` using a unique key and a patch. */
  updatePsaPomegranatePallet?: Maybe<UpdatePsaPomegranatePalletPayload>;
  /** Updates a single `PsaStoneFruitPallet` using its globally unique id and a patch. */
  updatePsaStoneFruitPalletByNodeId?: Maybe<UpdatePsaStoneFruitPalletPayload>;
  /** Updates a single `PsaStoneFruitPallet` using a unique key and a patch. */
  updatePsaStoneFruitPallet?: Maybe<UpdatePsaStoneFruitPalletPayload>;
  /** Updates a single `CommonCategory` using its globally unique id and a patch. */
  updateCommonCategoryByNodeId?: Maybe<UpdateCommonCategoryPayload>;
  /** Updates a single `CommonCategory` using a unique key and a patch. */
  updateCommonCategory?: Maybe<UpdateCommonCategoryPayload>;
  /** Updates a single `CommonPackType` using its globally unique id and a patch. */
  updateCommonPackTypeByNodeId?: Maybe<UpdateCommonPackTypePayload>;
  /** Updates a single `CommonPackType` using a unique key and a patch. */
  updateCommonPackType?: Maybe<UpdateCommonPackTypePayload>;
  /** Updates a single `CommonPackTypePackMaster` using its globally unique id and a patch. */
  updateCommonPackTypePackMasterByNodeId?: Maybe<UpdateCommonPackTypePackMasterPayload>;
  /** Updates a single `CommonPackTypePackMaster` using a unique key and a patch. */
  updateCommonPackTypePackMaster?: Maybe<UpdateCommonPackTypePackMasterPayload>;
  /** Updates a single `CommonPackTypeTag` using its globally unique id and a patch. */
  updateCommonPackTypeTagByNodeId?: Maybe<UpdateCommonPackTypeTagPayload>;
  /** Updates a single `CommonPackTypeTag` using a unique key and a patch. */
  updateCommonPackTypeTag?: Maybe<UpdateCommonPackTypeTagPayload>;
  /** Updates a single `CommonSize` using its globally unique id and a patch. */
  updateCommonSizeByNodeId?: Maybe<UpdateCommonSizePayload>;
  /** Updates a single `CommonSize` using a unique key and a patch. */
  updateCommonSize?: Maybe<UpdateCommonSizePayload>;
  /** Updates a single `CommonSizeProductSize` using its globally unique id and a patch. */
  updateCommonSizeProductSizeByNodeId?: Maybe<UpdateCommonSizeProductSizePayload>;
  /** Updates a single `CommonSizeProductSize` using a unique key and a patch. */
  updateCommonSizeProductSize?: Maybe<UpdateCommonSizeProductSizePayload>;
  /** Updates a single `CommonSizeTag` using its globally unique id and a patch. */
  updateCommonSizeTagByNodeId?: Maybe<UpdateCommonSizeTagPayload>;
  /** Updates a single `CommonSizeTag` using a unique key and a patch. */
  updateCommonSizeTag?: Maybe<UpdateCommonSizeTagPayload>;
  /** Updates a single `CommonSpecies` using its globally unique id and a patch. */
  updateCommonSpeciesByNodeId?: Maybe<UpdateCommonSpeciesPayload>;
  /** Updates a single `CommonSpecies` using a unique key and a patch. */
  updateCommonSpecies?: Maybe<UpdateCommonSpeciesPayload>;
  /** Updates a single `CommonSpeciesProductSpecies` using its globally unique id and a patch. */
  updateCommonSpeciesProductSpeciesByNodeId?: Maybe<UpdateCommonSpeciesProductSpeciesPayload>;
  /** Updates a single `CommonSpeciesProductSpecies` using a unique key and a patch. */
  updateCommonSpeciesProductSpecies?: Maybe<UpdateCommonSpeciesProductSpeciesPayload>;
  /** Updates a single `CommonSpeciesTag` using its globally unique id and a patch. */
  updateCommonSpeciesTagByNodeId?: Maybe<UpdateCommonSpeciesTagPayload>;
  /** Updates a single `CommonSpeciesTag` using a unique key and a patch. */
  updateCommonSpeciesTag?: Maybe<UpdateCommonSpeciesTagPayload>;
  /** Updates a single `CommonVariety` using its globally unique id and a patch. */
  updateCommonVarietyByNodeId?: Maybe<UpdateCommonVarietyPayload>;
  /** Updates a single `CommonVariety` using a unique key and a patch. */
  updateCommonVariety?: Maybe<UpdateCommonVarietyPayload>;
  /** Updates a single `CommonVarietyProductVariety` using its globally unique id and a patch. */
  updateCommonVarietyProductVarietyByNodeId?: Maybe<UpdateCommonVarietyProductVarietyPayload>;
  /** Updates a single `CommonVarietyProductVariety` using a unique key and a patch. */
  updateCommonVarietyProductVariety?: Maybe<UpdateCommonVarietyProductVarietyPayload>;
  /** Updates a single `CommonVarietyTag` using its globally unique id and a patch. */
  updateCommonVarietyTagByNodeId?: Maybe<UpdateCommonVarietyTagPayload>;
  /** Updates a single `CommonVarietyTag` using a unique key and a patch. */
  updateCommonVarietyTag?: Maybe<UpdateCommonVarietyTagPayload>;
  /** Updates a single `Container` using its globally unique id and a patch. */
  updateContainerByNodeId?: Maybe<UpdateContainerPayload>;
  /** Updates a single `Container` using a unique key and a patch. */
  updateContainer?: Maybe<UpdateContainerPayload>;
  /** Updates a single `ContainerTreatment` using its globally unique id and a patch. */
  updateContainerTreatmentByNodeId?: Maybe<UpdateContainerTreatmentPayload>;
  /** Updates a single `ContainerTreatment` using a unique key and a patch. */
  updateContainerTreatment?: Maybe<UpdateContainerTreatmentPayload>;
  /** Updates a single `CustomerProgram` using its globally unique id and a patch. */
  updateCustomerProgramByNodeId?: Maybe<UpdateCustomerProgramPayload>;
  /** Updates a single `CustomerProgram` using a unique key and a patch. */
  updateCustomerProgram?: Maybe<UpdateCustomerProgramPayload>;
  /** Updates a single `CustomerProgramEntry` using its globally unique id and a patch. */
  updateCustomerProgramEntryByNodeId?: Maybe<UpdateCustomerProgramEntryPayload>;
  /** Updates a single `CustomerProgramEntry` using a unique key and a patch. */
  updateCustomerProgramEntry?: Maybe<UpdateCustomerProgramEntryPayload>;
  /** Updates a single `InventoryItem` using its globally unique id and a patch. */
  updateInventoryItemByNodeId?: Maybe<UpdateInventoryItemPayload>;
  /** Updates a single `InventoryItem` using a unique key and a patch. */
  updateInventoryItem?: Maybe<UpdateInventoryItemPayload>;
  /** Updates a single `PackAtmosphere` using its globally unique id and a patch. */
  updatePackAtmosphereByNodeId?: Maybe<UpdatePackAtmospherePayload>;
  /** Updates a single `PackAtmosphere` using a unique key and a patch. */
  updatePackAtmosphere?: Maybe<UpdatePackAtmospherePayload>;
  /** Updates a single `PackAtmosphere` using a unique key and a patch. */
  updatePackAtmosphereByShipperIdAndMaCode?: Maybe<UpdatePackAtmospherePayload>;
  /** Updates a single `PackBoxStyle` using its globally unique id and a patch. */
  updatePackBoxStyleByNodeId?: Maybe<UpdatePackBoxStylePayload>;
  /** Updates a single `PackBoxStyle` using a unique key and a patch. */
  updatePackBoxStyle?: Maybe<UpdatePackBoxStylePayload>;
  /** Updates a single `PackBoxStyle` using a unique key and a patch. */
  updatePackBoxStyleByShipperIdAndBoxStyle?: Maybe<UpdatePackBoxStylePayload>;
  /** Updates a single `PackBoxType` using its globally unique id and a patch. */
  updatePackBoxTypeByNodeId?: Maybe<UpdatePackBoxTypePayload>;
  /** Updates a single `PackBoxType` using a unique key and a patch. */
  updatePackBoxType?: Maybe<UpdatePackBoxTypePayload>;
  /** Updates a single `PackBoxType` using a unique key and a patch. */
  updatePackBoxTypeByShipperIdAndBoxType?: Maybe<UpdatePackBoxTypePayload>;
  /** Updates a single `PackDestination` using its globally unique id and a patch. */
  updatePackDestinationByNodeId?: Maybe<UpdatePackDestinationPayload>;
  /** Updates a single `PackDestination` using a unique key and a patch. */
  updatePackDestination?: Maybe<UpdatePackDestinationPayload>;
  /** Updates a single `PackDestination` using a unique key and a patch. */
  updatePackDestinationByShipperIdAndDestinationCode?: Maybe<UpdatePackDestinationPayload>;
  /** Updates a single `PackGrade` using its globally unique id and a patch. */
  updatePackGradeByNodeId?: Maybe<UpdatePackGradePayload>;
  /** Updates a single `PackGrade` using a unique key and a patch. */
  updatePackGrade?: Maybe<UpdatePackGradePayload>;
  /** Updates a single `PackGrade` using a unique key and a patch. */
  updatePackGradeByShipperIdAndGradeCode?: Maybe<UpdatePackGradePayload>;
  /** Updates a single `PackHold` using its globally unique id and a patch. */
  updatePackHoldByNodeId?: Maybe<UpdatePackHoldPayload>;
  /** Updates a single `PackHold` using a unique key and a patch. */
  updatePackHold?: Maybe<UpdatePackHoldPayload>;
  /** Updates a single `PackHold` using a unique key and a patch. */
  updatePackHoldByShipperIdAndHoldCode?: Maybe<UpdatePackHoldPayload>;
  /** Updates a single `PackLabel` using its globally unique id and a patch. */
  updatePackLabelByNodeId?: Maybe<UpdatePackLabelPayload>;
  /** Updates a single `PackLabel` using a unique key and a patch. */
  updatePackLabel?: Maybe<UpdatePackLabelPayload>;
  /** Updates a single `PackLabel` using a unique key and a patch. */
  updatePackLabelByShipperIdAndLabelCode?: Maybe<UpdatePackLabelPayload>;
  /** Updates a single `PackLiner` using its globally unique id and a patch. */
  updatePackLinerByNodeId?: Maybe<UpdatePackLinerPayload>;
  /** Updates a single `PackLiner` using a unique key and a patch. */
  updatePackLiner?: Maybe<UpdatePackLinerPayload>;
  /** Updates a single `PackLiner` using a unique key and a patch. */
  updatePackLinerByShipperIdAndLinerCode?: Maybe<UpdatePackLinerPayload>;
  /** Updates a single `PackMaster` using its globally unique id and a patch. */
  updatePackMasterByNodeId?: Maybe<UpdatePackMasterPayload>;
  /** Updates a single `PackMaster` using a unique key and a patch. */
  updatePackMaster?: Maybe<UpdatePackMasterPayload>;
  /** Updates a single `PackOut` using its globally unique id and a patch. */
  updatePackOutByNodeId?: Maybe<UpdatePackOutPayload>;
  /** Updates a single `PackOut` using a unique key and a patch. */
  updatePackOut?: Maybe<UpdatePackOutPayload>;
  /** Updates a single `PackOut` using a unique key and a patch. */
  updatePackOutByShipperIdAndOutCode?: Maybe<UpdatePackOutPayload>;
  /** Updates a single `PackPalletType` using its globally unique id and a patch. */
  updatePackPalletTypeByNodeId?: Maybe<UpdatePackPalletTypePayload>;
  /** Updates a single `PackPalletType` using a unique key and a patch. */
  updatePackPalletType?: Maybe<UpdatePackPalletTypePayload>;
  /** Updates a single `PackPalletType` using a unique key and a patch. */
  updatePackPalletTypeByShipperIdAndPalletType?: Maybe<UpdatePackPalletTypePayload>;
  /** Updates a single `PackProduction` using its globally unique id and a patch. */
  updatePackProductionByNodeId?: Maybe<UpdatePackProductionPayload>;
  /** Updates a single `PackProduction` using a unique key and a patch. */
  updatePackProduction?: Maybe<UpdatePackProductionPayload>;
  /** Updates a single `PackProduction` using a unique key and a patch. */
  updatePackProductionByShipperIdAndProductionCode?: Maybe<UpdatePackProductionPayload>;
  /** Updates a single `PackSpecial` using its globally unique id and a patch. */
  updatePackSpecialByNodeId?: Maybe<UpdatePackSpecialPayload>;
  /** Updates a single `PackSpecial` using a unique key and a patch. */
  updatePackSpecial?: Maybe<UpdatePackSpecialPayload>;
  /** Updates a single `PackSpecial` using a unique key and a patch. */
  updatePackSpecialByShipperIdAndCustomerCode?: Maybe<UpdatePackSpecialPayload>;
  /** Updates a single `PackStyle` using its globally unique id and a patch. */
  updatePackStyleByNodeId?: Maybe<UpdatePackStylePayload>;
  /** Updates a single `PackStyle` using a unique key and a patch. */
  updatePackStyle?: Maybe<UpdatePackStylePayload>;
  /** Updates a single `PackStyle` using a unique key and a patch. */
  updatePackStyleByShipperIdAndPackStyle?: Maybe<UpdatePackStylePayload>;
  /** Updates a single `PackTreeRipe` using its globally unique id and a patch. */
  updatePackTreeRipeByNodeId?: Maybe<UpdatePackTreeRipePayload>;
  /** Updates a single `PackTreeRipe` using a unique key and a patch. */
  updatePackTreeRipe?: Maybe<UpdatePackTreeRipePayload>;
  /** Updates a single `PackTreeRipe` using a unique key and a patch. */
  updatePackTreeRipeByShipperIdAndTreeRipe?: Maybe<UpdatePackTreeRipePayload>;
  /** Updates a single `Pallet` using its globally unique id and a patch. */
  updatePalletByNodeId?: Maybe<UpdatePalletPayload>;
  /** Updates a single `Pallet` using a unique key and a patch. */
  updatePallet?: Maybe<UpdatePalletPayload>;
  /** Updates a single `PalletSection` using its globally unique id and a patch. */
  updatePalletSectionByNodeId?: Maybe<UpdatePalletSectionPayload>;
  /** Updates a single `PalletSection` using a unique key and a patch. */
  updatePalletSection?: Maybe<UpdatePalletSectionPayload>;
  /** Updates a single `ProductMaster` using its globally unique id and a patch. */
  updateProductMasterByNodeId?: Maybe<UpdateProductMasterPayload>;
  /** Updates a single `ProductMaster` using a unique key and a patch. */
  updateProductMaster?: Maybe<UpdateProductMasterPayload>;
  /** Updates a single `ProductSize` using its globally unique id and a patch. */
  updateProductSizeByNodeId?: Maybe<UpdateProductSizePayload>;
  /** Updates a single `ProductSize` using a unique key and a patch. */
  updateProductSize?: Maybe<UpdateProductSizePayload>;
  /** Updates a single `ProductSpecies` using its globally unique id and a patch. */
  updateProductSpeciesByNodeId?: Maybe<UpdateProductSpeciesPayload>;
  /** Updates a single `ProductSpecies` using a unique key and a patch. */
  updateProductSpecies?: Maybe<UpdateProductSpeciesPayload>;
  /** Updates a single `ProductVariety` using its globally unique id and a patch. */
  updateProductVarietyByNodeId?: Maybe<UpdateProductVarietyPayload>;
  /** Updates a single `ProductVariety` using a unique key and a patch. */
  updateProductVariety?: Maybe<UpdateProductVarietyPayload>;
  /** Updates a single `RepackStyle` using its globally unique id and a patch. */
  updateRepackStyleByNodeId?: Maybe<UpdateRepackStylePayload>;
  /** Updates a single `RepackStyle` using a unique key and a patch. */
  updateRepackStyle?: Maybe<UpdateRepackStylePayload>;
  /** Updates a single `ShipperProgram` using its globally unique id and a patch. */
  updateShipperProgramByNodeId?: Maybe<UpdateShipperProgramPayload>;
  /** Updates a single `ShipperProgram` using a unique key and a patch. */
  updateShipperProgram?: Maybe<UpdateShipperProgramPayload>;
  /** Updates a single `ShipperProgramEntry` using its globally unique id and a patch. */
  updateShipperProgramEntryByNodeId?: Maybe<UpdateShipperProgramEntryPayload>;
  /** Updates a single `ShipperProgramEntry` using a unique key and a patch. */
  updateShipperProgramEntry?: Maybe<UpdateShipperProgramEntryPayload>;
  /** Updates a single `ShipperProgramEntryCustomerProgramEntry` using its globally unique id and a patch. */
  updateShipperProgramEntryCustomerProgramEntryByNodeId?: Maybe<UpdateShipperProgramEntryCustomerProgramEntryPayload>;
  /** Updates a single `ShipperProgramEntryCustomerProgramEntry` using a unique key and a patch. */
  updateShipperProgramEntryCustomerProgramEntry?: Maybe<UpdateShipperProgramEntryCustomerProgramEntryPayload>;
  /** Updates a single `ShipperProjection` using its globally unique id and a patch. */
  updateShipperProjectionByNodeId?: Maybe<UpdateShipperProjectionPayload>;
  /** Updates a single `ShipperProjection` using a unique key and a patch. */
  updateShipperProjection?: Maybe<UpdateShipperProjectionPayload>;
  /** Updates a single `ShipperProjectionEntry` using its globally unique id and a patch. */
  updateShipperProjectionEntryByNodeId?: Maybe<UpdateShipperProjectionEntryPayload>;
  /** Updates a single `ShipperProjectionEntry` using a unique key and a patch. */
  updateShipperProjectionEntry?: Maybe<UpdateShipperProjectionEntryPayload>;
  /** Updates a single `ShipperProjectionProduct` using its globally unique id and a patch. */
  updateShipperProjectionProductByNodeId?: Maybe<UpdateShipperProjectionProductPayload>;
  /** Updates a single `ShipperProjectionProduct` using a unique key and a patch. */
  updateShipperProjectionProduct?: Maybe<UpdateShipperProjectionProductPayload>;
  /** Updates a single `ShipperProjectionVessel` using its globally unique id and a patch. */
  updateShipperProjectionVesselByNodeId?: Maybe<UpdateShipperProjectionVesselPayload>;
  /** Updates a single `ShipperProjectionVessel` using a unique key and a patch. */
  updateShipperProjectionVessel?: Maybe<UpdateShipperProjectionVesselPayload>;
  /** Updates a single `ShipperProjectionVesselInfo` using its globally unique id and a patch. */
  updateShipperProjectionVesselInfoByNodeId?: Maybe<UpdateShipperProjectionVesselInfoPayload>;
  /** Updates a single `ShipperProjectionVesselInfo` using a unique key and a patch. */
  updateShipperProjectionVesselInfo?: Maybe<UpdateShipperProjectionVesselInfoPayload>;
  /** Updates a single `Vessel` using its globally unique id and a patch. */
  updateVesselByNodeId?: Maybe<UpdateVesselPayload>;
  /** Updates a single `Vessel` using a unique key and a patch. */
  updateVessel?: Maybe<UpdateVesselPayload>;
  /** Updates a single `AgendaItem` using its globally unique id and a patch. */
  updateAgendaItemByNodeId?: Maybe<UpdateAgendaItemPayload>;
  /** Updates a single `AgendaItem` using a unique key and a patch. */
  updateAgendaItem?: Maybe<UpdateAgendaItemPayload>;
  /** Updates a single `CalendarEvent` using its globally unique id and a patch. */
  updateCalendarEventByNodeId?: Maybe<UpdateCalendarEventPayload>;
  /** Updates a single `CalendarEvent` using a unique key and a patch. */
  updateCalendarEvent?: Maybe<UpdateCalendarEventPayload>;
  /** Updates a single `PriceCategory` using its globally unique id and a patch. */
  updatePriceCategoryByNodeId?: Maybe<UpdatePriceCategoryPayload>;
  /** Updates a single `PriceCategory` using a unique key and a patch. */
  updatePriceCategory?: Maybe<UpdatePriceCategoryPayload>;
  /** Updates a single `PriceEntry` using its globally unique id and a patch. */
  updatePriceEntryByNodeId?: Maybe<UpdatePriceEntryPayload>;
  /** Updates a single `PriceEntry` using a unique key and a patch. */
  updatePriceEntry?: Maybe<UpdatePriceEntryPayload>;
  /** Updates a single `PriceProduct` using its globally unique id and a patch. */
  updatePriceProductByNodeId?: Maybe<UpdatePriceProductPayload>;
  /** Updates a single `PriceProduct` using a unique key and a patch. */
  updatePriceProduct?: Maybe<UpdatePriceProductPayload>;
  /** Updates a single `PriceSize` using its globally unique id and a patch. */
  updatePriceSizeByNodeId?: Maybe<UpdatePriceSizePayload>;
  /** Updates a single `PriceSize` using a unique key and a patch. */
  updatePriceSize?: Maybe<UpdatePriceSizePayload>;
  /** Updates a single `LoadNumber` using its globally unique id and a patch. */
  updateLoadNumberByNodeId?: Maybe<UpdateLoadNumberPayload>;
  /** Updates a single `LoadNumber` using a unique key and a patch. */
  updateLoadNumber?: Maybe<UpdateLoadNumberPayload>;
  /** Updates a single `OrderComment` using its globally unique id and a patch. */
  updateOrderCommentByNodeId?: Maybe<UpdateOrderCommentPayload>;
  /** Updates a single `OrderComment` using a unique key and a patch. */
  updateOrderComment?: Maybe<UpdateOrderCommentPayload>;
  /** Updates a single `OrderEntry` using its globally unique id and a patch. */
  updateOrderEntryByNodeId?: Maybe<UpdateOrderEntryPayload>;
  /** Updates a single `OrderEntry` using a unique key and a patch. */
  updateOrderEntry?: Maybe<UpdateOrderEntryPayload>;
  /** Updates a single `OrderEntryItem` using its globally unique id and a patch. */
  updateOrderEntryItemByNodeId?: Maybe<UpdateOrderEntryItemPayload>;
  /** Updates a single `OrderEntryItem` using a unique key and a patch. */
  updateOrderEntryItem?: Maybe<UpdateOrderEntryItemPayload>;
  /** Updates a single `OrderEntryReviewItem` using its globally unique id and a patch. */
  updateOrderEntryReviewItemByNodeId?: Maybe<UpdateOrderEntryReviewItemPayload>;
  /** Updates a single `OrderEntryReviewItem` using a unique key and a patch. */
  updateOrderEntryReviewItem?: Maybe<UpdateOrderEntryReviewItemPayload>;
  /** Updates a single `OrderItem` using its globally unique id and a patch. */
  updateOrderItemByNodeId?: Maybe<UpdateOrderItemPayload>;
  /** Updates a single `OrderItem` using a unique key and a patch. */
  updateOrderItem?: Maybe<UpdateOrderItemPayload>;
  /** Updates a single `OrderMaster` using its globally unique id and a patch. */
  updateOrderMasterByNodeId?: Maybe<UpdateOrderMasterPayload>;
  /** Updates a single `OrderMaster` using a unique key and a patch. */
  updateOrderMaster?: Maybe<UpdateOrderMasterPayload>;
  /** Updates a single `OrderPallet` using its globally unique id and a patch. */
  updateOrderPalletByNodeId?: Maybe<UpdateOrderPalletPayload>;
  /** Updates a single `OrderPallet` using a unique key and a patch. */
  updateOrderPallet?: Maybe<UpdateOrderPalletPayload>;
  /** Updates a single `RepackHeader` using its globally unique id and a patch. */
  updateRepackHeaderByNodeId?: Maybe<UpdateRepackHeaderPayload>;
  /** Updates a single `RepackHeader` using a unique key and a patch. */
  updateRepackHeader?: Maybe<UpdateRepackHeaderPayload>;
  /** Updates a single `RepackItem` using its globally unique id and a patch. */
  updateRepackItemByNodeId?: Maybe<UpdateRepackItemPayload>;
  /** Updates a single `RepackItem` using a unique key and a patch. */
  updateRepackItem?: Maybe<UpdateRepackItemPayload>;
  /** Updates a single `RepackQueue` using its globally unique id and a patch. */
  updateRepackQueueByNodeId?: Maybe<UpdateRepackQueuePayload>;
  /** Updates a single `RepackQueue` using a unique key and a patch. */
  updateRepackQueue?: Maybe<UpdateRepackQueuePayload>;
  /** Updates a single `TruckLoad` using its globally unique id and a patch. */
  updateTruckLoadByNodeId?: Maybe<UpdateTruckLoadPayload>;
  /** Updates a single `TruckLoad` using a unique key and a patch. */
  updateTruckLoad?: Maybe<UpdateTruckLoadPayload>;
  /** Updates a single `TruckRate` using its globally unique id and a patch. */
  updateTruckRateByNodeId?: Maybe<UpdateTruckRatePayload>;
  /** Updates a single `TruckRate` using a unique key and a patch. */
  updateTruckRate?: Maybe<UpdateTruckRatePayload>;
  /** Updates a single `TruckRateCustomer` using its globally unique id and a patch. */
  updateTruckRateCustomerByNodeId?: Maybe<UpdateTruckRateCustomerPayload>;
  /** Updates a single `TruckRateCustomer` using a unique key and a patch. */
  updateTruckRateCustomer?: Maybe<UpdateTruckRateCustomerPayload>;
  /** Updates a single `CheckHeader` using its globally unique id and a patch. */
  updateCheckHeaderByNodeId?: Maybe<UpdateCheckHeaderPayload>;
  /** Updates a single `CheckHeader` using a unique key and a patch. */
  updateCheckHeader?: Maybe<UpdateCheckHeaderPayload>;
  /** Updates a single `CustomerPayment` using its globally unique id and a patch. */
  updateCustomerPaymentByNodeId?: Maybe<UpdateCustomerPaymentPayload>;
  /** Updates a single `CustomerPayment` using a unique key and a patch. */
  updateCustomerPayment?: Maybe<UpdateCustomerPaymentPayload>;
  /** Updates a single `ExpenseHeader` using its globally unique id and a patch. */
  updateExpenseHeaderByNodeId?: Maybe<UpdateExpenseHeaderPayload>;
  /** Updates a single `ExpenseHeader` using a unique key and a patch. */
  updateExpenseHeader?: Maybe<UpdateExpenseHeaderPayload>;
  /** Updates a single `ExpenseHeaderReview` using its globally unique id and a patch. */
  updateExpenseHeaderReviewByNodeId?: Maybe<UpdateExpenseHeaderReviewPayload>;
  /** Updates a single `ExpenseHeaderReview` using a unique key and a patch. */
  updateExpenseHeaderReview?: Maybe<UpdateExpenseHeaderReviewPayload>;
  /** Updates a single `ExpenseItem` using its globally unique id and a patch. */
  updateExpenseItemByNodeId?: Maybe<UpdateExpenseItemPayload>;
  /** Updates a single `ExpenseItem` using a unique key and a patch. */
  updateExpenseItem?: Maybe<UpdateExpenseItemPayload>;
  /** Updates a single `InvoiceHeader` using its globally unique id and a patch. */
  updateInvoiceHeaderByNodeId?: Maybe<UpdateInvoiceHeaderPayload>;
  /** Updates a single `InvoiceHeader` using a unique key and a patch. */
  updateInvoiceHeader?: Maybe<UpdateInvoiceHeaderPayload>;
  /** Updates a single `InvoiceItem` using its globally unique id and a patch. */
  updateInvoiceItemByNodeId?: Maybe<UpdateInvoiceItemPayload>;
  /** Updates a single `InvoiceItem` using a unique key and a patch. */
  updateInvoiceItem?: Maybe<UpdateInvoiceItemPayload>;
  /** Updates a single `InvoiceItemHistory` using its globally unique id and a patch. */
  updateInvoiceItemHistoryByNodeId?: Maybe<UpdateInvoiceItemHistoryPayload>;
  /** Updates a single `InvoiceItemHistory` using a unique key and a patch. */
  updateInvoiceItemHistory?: Maybe<UpdateInvoiceItemHistoryPayload>;
  /** Updates a single `Unpaid` using its globally unique id and a patch. */
  updateUnpaidByNodeId?: Maybe<UpdateUnpaidPayload>;
  /** Updates a single `Unpaid` using a unique key and a patch. */
  updateUnpaid?: Maybe<UpdateUnpaidPayload>;
  /** Updates a single `VesselControl` using its globally unique id and a patch. */
  updateVesselControlByNodeId?: Maybe<UpdateVesselControlPayload>;
  /** Updates a single `VesselControl` using a unique key and a patch. */
  updateVesselControl?: Maybe<UpdateVesselControlPayload>;
  /** Updates a single `WireRequest` using its globally unique id and a patch. */
  updateWireRequestByNodeId?: Maybe<UpdateWireRequestPayload>;
  /** Updates a single `WireRequest` using a unique key and a patch. */
  updateWireRequest?: Maybe<UpdateWireRequestPayload>;
  /** Updates a single `WireRequestAccountOfSaleItem` using its globally unique id and a patch. */
  updateWireRequestAccountOfSaleItemByNodeId?: Maybe<UpdateWireRequestAccountOfSaleItemPayload>;
  /** Updates a single `WireRequestAccountOfSaleItem` using a unique key and a patch. */
  updateWireRequestAccountOfSaleItem?: Maybe<UpdateWireRequestAccountOfSaleItemPayload>;
  /** Updates a single `WireRequestMiscItem` using its globally unique id and a patch. */
  updateWireRequestMiscItemByNodeId?: Maybe<UpdateWireRequestMiscItemPayload>;
  /** Updates a single `WireRequestMiscItem` using a unique key and a patch. */
  updateWireRequestMiscItem?: Maybe<UpdateWireRequestMiscItemPayload>;
  /** Updates a single `WireRequestOceanFreightItem` using its globally unique id and a patch. */
  updateWireRequestOceanFreightItemByNodeId?: Maybe<UpdateWireRequestOceanFreightItemPayload>;
  /** Updates a single `WireRequestOceanFreightItem` using a unique key and a patch. */
  updateWireRequestOceanFreightItem?: Maybe<UpdateWireRequestOceanFreightItemPayload>;
  /** Updates a single `WireRequestShipperAdvanceItem` using its globally unique id and a patch. */
  updateWireRequestShipperAdvanceItemByNodeId?: Maybe<UpdateWireRequestShipperAdvanceItemPayload>;
  /** Updates a single `WireRequestShipperAdvanceItem` using a unique key and a patch. */
  updateWireRequestShipperAdvanceItem?: Maybe<UpdateWireRequestShipperAdvanceItemPayload>;
  /** Deletes a single `OrderNumber` using its globally unique id. */
  deleteOrderNumberByNodeId?: Maybe<DeleteOrderNumberPayload>;
  /** Deletes a single `OrderNumber` using a unique key. */
  deleteOrderNumber?: Maybe<DeleteOrderNumberPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByPin?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserBookmark` using its globally unique id. */
  deleteUserBookmarkByNodeId?: Maybe<DeleteUserBookmarkPayload>;
  /** Deletes a single `UserBookmark` using a unique key. */
  deleteUserBookmark?: Maybe<DeleteUserBookmarkPayload>;
  /** Deletes a single `UserMessage` using its globally unique id. */
  deleteUserMessageByNodeId?: Maybe<DeleteUserMessagePayload>;
  /** Deletes a single `UserMessage` using a unique key. */
  deleteUserMessage?: Maybe<DeleteUserMessagePayload>;
  /** Deletes a single `UserRole` using a unique key. */
  deleteUserRoleByUserIdAndRoleName?: Maybe<DeleteUserRolePayload>;
  /** Deletes a single `ContactGroup` using its globally unique id. */
  deleteContactGroupByNodeId?: Maybe<DeleteContactGroupPayload>;
  /** Deletes a single `ContactGroup` using a unique key. */
  deleteContactGroup?: Maybe<DeleteContactGroupPayload>;
  /** Deletes a single `ContactGroupPersonContact` using its globally unique id. */
  deleteContactGroupPersonContactByNodeId?: Maybe<DeleteContactGroupPersonContactPayload>;
  /** Deletes a single `ContactGroupPersonContact` using a unique key. */
  deleteContactGroupPersonContact?: Maybe<DeleteContactGroupPersonContactPayload>;
  /** Deletes a single `Country` using its globally unique id. */
  deleteCountryByNodeId?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Country` using a unique key. */
  deleteCountry?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Customer` using its globally unique id. */
  deleteCustomerByNodeId?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `Customer` using a unique key. */
  deleteCustomer?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `CustomerPersonContact` using its globally unique id. */
  deleteCustomerPersonContactByNodeId?: Maybe<DeleteCustomerPersonContactPayload>;
  /** Deletes a single `CustomerPersonContact` using a unique key. */
  deleteCustomerPersonContact?: Maybe<DeleteCustomerPersonContactPayload>;
  /** Deletes a single `CustomerVolumeDiscount` using its globally unique id. */
  deleteCustomerVolumeDiscountByNodeId?: Maybe<DeleteCustomerVolumeDiscountPayload>;
  /** Deletes a single `CustomerVolumeDiscount` using a unique key. */
  deleteCustomerVolumeDiscount?: Maybe<DeleteCustomerVolumeDiscountPayload>;
  /** Deletes a single `PersonContact` using its globally unique id. */
  deletePersonContactByNodeId?: Maybe<DeletePersonContactPayload>;
  /** Deletes a single `PersonContact` using a unique key. */
  deletePersonContact?: Maybe<DeletePersonContactPayload>;
  /** Deletes a single `Shipper` using its globally unique id. */
  deleteShipperByNodeId?: Maybe<DeleteShipperPayload>;
  /** Deletes a single `Shipper` using a unique key. */
  deleteShipper?: Maybe<DeleteShipperPayload>;
  /** Deletes a single `ShipperAdvance` using its globally unique id. */
  deleteShipperAdvanceByNodeId?: Maybe<DeleteShipperAdvancePayload>;
  /** Deletes a single `ShipperAdvance` using a unique key. */
  deleteShipperAdvance?: Maybe<DeleteShipperAdvancePayload>;
  /** Deletes a single `ShipperPersonContact` using its globally unique id. */
  deleteShipperPersonContactByNodeId?: Maybe<DeleteShipperPersonContactPayload>;
  /** Deletes a single `ShipperPersonContact` using a unique key. */
  deleteShipperPersonContact?: Maybe<DeleteShipperPersonContactPayload>;
  /** Deletes a single `Vendor` using its globally unique id. */
  deleteVendorByNodeId?: Maybe<DeleteVendorPayload>;
  /** Deletes a single `Vendor` using a unique key. */
  deleteVendor?: Maybe<DeleteVendorPayload>;
  /** Deletes a single `VendorPersonContact` using its globally unique id. */
  deleteVendorPersonContactByNodeId?: Maybe<DeleteVendorPersonContactPayload>;
  /** Deletes a single `VendorPersonContact` using a unique key. */
  deleteVendorPersonContact?: Maybe<DeleteVendorPersonContactPayload>;
  /** Deletes a single `Warehouse` using its globally unique id. */
  deleteWarehouseByNodeId?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `Warehouse` using a unique key. */
  deleteWarehouse?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `WarehousePersonContact` using its globally unique id. */
  deleteWarehousePersonContactByNodeId?: Maybe<DeleteWarehousePersonContactPayload>;
  /** Deletes a single `WarehousePersonContact` using a unique key. */
  deleteWarehousePersonContact?: Maybe<DeleteWarehousePersonContactPayload>;
  /** Deletes a single `ChileDepartureInspectionPallet` using its globally unique id. */
  deleteChileDepartureInspectionPalletByNodeId?: Maybe<DeleteChileDepartureInspectionPalletPayload>;
  /** Deletes a single `ChileDepartureInspectionPallet` using a unique key. */
  deleteChileDepartureInspectionPallet?: Maybe<DeleteChileDepartureInspectionPalletPayload>;
  /** Deletes a single `PeruDepartureInspection` using its globally unique id. */
  deletePeruDepartureInspectionByNodeId?: Maybe<DeletePeruDepartureInspectionPayload>;
  /** Deletes a single `PeruDepartureInspection` using a unique key. */
  deletePeruDepartureInspection?: Maybe<DeletePeruDepartureInspectionPayload>;
  /** Deletes a single `PeruDepartureInspectionPallet` using its globally unique id. */
  deletePeruDepartureInspectionPalletByNodeId?: Maybe<DeletePeruDepartureInspectionPalletPayload>;
  /** Deletes a single `PeruDepartureInspectionPallet` using a unique key. */
  deletePeruDepartureInspectionPallet?: Maybe<DeletePeruDepartureInspectionPalletPayload>;
  /** Deletes a single `PsaApplePallet` using its globally unique id. */
  deletePsaApplePalletByNodeId?: Maybe<DeletePsaApplePalletPayload>;
  /** Deletes a single `PsaApplePallet` using a unique key. */
  deletePsaApplePallet?: Maybe<DeletePsaApplePalletPayload>;
  /** Deletes a single `PsaArrivalPicture` using its globally unique id. */
  deletePsaArrivalPictureByNodeId?: Maybe<DeletePsaArrivalPicturePayload>;
  /** Deletes a single `PsaArrivalPicture` using a unique key. */
  deletePsaArrivalPicture?: Maybe<DeletePsaArrivalPicturePayload>;
  /** Deletes a single `PsaArrivalReport` using its globally unique id. */
  deletePsaArrivalReportByNodeId?: Maybe<DeletePsaArrivalReportPayload>;
  /** Deletes a single `PsaArrivalReport` using a unique key. */
  deletePsaArrivalReport?: Maybe<DeletePsaArrivalReportPayload>;
  /** Deletes a single `PsaCherryPallet` using its globally unique id. */
  deletePsaCherryPalletByNodeId?: Maybe<DeletePsaCherryPalletPayload>;
  /** Deletes a single `PsaCherryPallet` using a unique key. */
  deletePsaCherryPallet?: Maybe<DeletePsaCherryPalletPayload>;
  /** Deletes a single `PsaCitrusPallet` using its globally unique id. */
  deletePsaCitrusPalletByNodeId?: Maybe<DeletePsaCitrusPalletPayload>;
  /** Deletes a single `PsaCitrusPallet` using a unique key. */
  deletePsaCitrusPallet?: Maybe<DeletePsaCitrusPalletPayload>;
  /** Deletes a single `PsaGrapePallet` using its globally unique id. */
  deletePsaGrapePalletByNodeId?: Maybe<DeletePsaGrapePalletPayload>;
  /** Deletes a single `PsaGrapePallet` using a unique key. */
  deletePsaGrapePallet?: Maybe<DeletePsaGrapePalletPayload>;
  /** Deletes a single `PsaLemonPallet` using its globally unique id. */
  deletePsaLemonPalletByNodeId?: Maybe<DeletePsaLemonPalletPayload>;
  /** Deletes a single `PsaLemonPallet` using a unique key. */
  deletePsaLemonPallet?: Maybe<DeletePsaLemonPalletPayload>;
  /** Deletes a single `PsaPearPallet` using its globally unique id. */
  deletePsaPearPalletByNodeId?: Maybe<DeletePsaPearPalletPayload>;
  /** Deletes a single `PsaPearPallet` using a unique key. */
  deletePsaPearPallet?: Maybe<DeletePsaPearPalletPayload>;
  /** Deletes a single `PsaPersimmonPallet` using its globally unique id. */
  deletePsaPersimmonPalletByNodeId?: Maybe<DeletePsaPersimmonPalletPayload>;
  /** Deletes a single `PsaPersimmonPallet` using a unique key. */
  deletePsaPersimmonPallet?: Maybe<DeletePsaPersimmonPalletPayload>;
  /** Deletes a single `PsaPomegranatePallet` using its globally unique id. */
  deletePsaPomegranatePalletByNodeId?: Maybe<DeletePsaPomegranatePalletPayload>;
  /** Deletes a single `PsaPomegranatePallet` using a unique key. */
  deletePsaPomegranatePallet?: Maybe<DeletePsaPomegranatePalletPayload>;
  /** Deletes a single `PsaStoneFruitPallet` using its globally unique id. */
  deletePsaStoneFruitPalletByNodeId?: Maybe<DeletePsaStoneFruitPalletPayload>;
  /** Deletes a single `PsaStoneFruitPallet` using a unique key. */
  deletePsaStoneFruitPallet?: Maybe<DeletePsaStoneFruitPalletPayload>;
  /** Deletes a single `CommonCategory` using its globally unique id. */
  deleteCommonCategoryByNodeId?: Maybe<DeleteCommonCategoryPayload>;
  /** Deletes a single `CommonCategory` using a unique key. */
  deleteCommonCategory?: Maybe<DeleteCommonCategoryPayload>;
  /** Deletes a single `CommonPackType` using its globally unique id. */
  deleteCommonPackTypeByNodeId?: Maybe<DeleteCommonPackTypePayload>;
  /** Deletes a single `CommonPackType` using a unique key. */
  deleteCommonPackType?: Maybe<DeleteCommonPackTypePayload>;
  /** Deletes a single `CommonPackTypePackMaster` using its globally unique id. */
  deleteCommonPackTypePackMasterByNodeId?: Maybe<DeleteCommonPackTypePackMasterPayload>;
  /** Deletes a single `CommonPackTypePackMaster` using a unique key. */
  deleteCommonPackTypePackMaster?: Maybe<DeleteCommonPackTypePackMasterPayload>;
  /** Deletes a single `CommonPackTypeTag` using its globally unique id. */
  deleteCommonPackTypeTagByNodeId?: Maybe<DeleteCommonPackTypeTagPayload>;
  /** Deletes a single `CommonPackTypeTag` using a unique key. */
  deleteCommonPackTypeTag?: Maybe<DeleteCommonPackTypeTagPayload>;
  /** Deletes a single `CommonSize` using its globally unique id. */
  deleteCommonSizeByNodeId?: Maybe<DeleteCommonSizePayload>;
  /** Deletes a single `CommonSize` using a unique key. */
  deleteCommonSize?: Maybe<DeleteCommonSizePayload>;
  /** Deletes a single `CommonSizeProductSize` using its globally unique id. */
  deleteCommonSizeProductSizeByNodeId?: Maybe<DeleteCommonSizeProductSizePayload>;
  /** Deletes a single `CommonSizeProductSize` using a unique key. */
  deleteCommonSizeProductSize?: Maybe<DeleteCommonSizeProductSizePayload>;
  /** Deletes a single `CommonSizeTag` using its globally unique id. */
  deleteCommonSizeTagByNodeId?: Maybe<DeleteCommonSizeTagPayload>;
  /** Deletes a single `CommonSizeTag` using a unique key. */
  deleteCommonSizeTag?: Maybe<DeleteCommonSizeTagPayload>;
  /** Deletes a single `CommonSpecies` using its globally unique id. */
  deleteCommonSpeciesByNodeId?: Maybe<DeleteCommonSpeciesPayload>;
  /** Deletes a single `CommonSpecies` using a unique key. */
  deleteCommonSpecies?: Maybe<DeleteCommonSpeciesPayload>;
  /** Deletes a single `CommonSpeciesProductSpecies` using its globally unique id. */
  deleteCommonSpeciesProductSpeciesByNodeId?: Maybe<DeleteCommonSpeciesProductSpeciesPayload>;
  /** Deletes a single `CommonSpeciesProductSpecies` using a unique key. */
  deleteCommonSpeciesProductSpecies?: Maybe<DeleteCommonSpeciesProductSpeciesPayload>;
  /** Deletes a single `CommonSpeciesTag` using its globally unique id. */
  deleteCommonSpeciesTagByNodeId?: Maybe<DeleteCommonSpeciesTagPayload>;
  /** Deletes a single `CommonSpeciesTag` using a unique key. */
  deleteCommonSpeciesTag?: Maybe<DeleteCommonSpeciesTagPayload>;
  /** Deletes a single `CommonVariety` using its globally unique id. */
  deleteCommonVarietyByNodeId?: Maybe<DeleteCommonVarietyPayload>;
  /** Deletes a single `CommonVariety` using a unique key. */
  deleteCommonVariety?: Maybe<DeleteCommonVarietyPayload>;
  /** Deletes a single `CommonVarietyProductVariety` using its globally unique id. */
  deleteCommonVarietyProductVarietyByNodeId?: Maybe<DeleteCommonVarietyProductVarietyPayload>;
  /** Deletes a single `CommonVarietyProductVariety` using a unique key. */
  deleteCommonVarietyProductVariety?: Maybe<DeleteCommonVarietyProductVarietyPayload>;
  /** Deletes a single `CommonVarietyTag` using its globally unique id. */
  deleteCommonVarietyTagByNodeId?: Maybe<DeleteCommonVarietyTagPayload>;
  /** Deletes a single `CommonVarietyTag` using a unique key. */
  deleteCommonVarietyTag?: Maybe<DeleteCommonVarietyTagPayload>;
  /** Deletes a single `Container` using its globally unique id. */
  deleteContainerByNodeId?: Maybe<DeleteContainerPayload>;
  /** Deletes a single `Container` using a unique key. */
  deleteContainer?: Maybe<DeleteContainerPayload>;
  /** Deletes a single `ContainerTreatment` using its globally unique id. */
  deleteContainerTreatmentByNodeId?: Maybe<DeleteContainerTreatmentPayload>;
  /** Deletes a single `ContainerTreatment` using a unique key. */
  deleteContainerTreatment?: Maybe<DeleteContainerTreatmentPayload>;
  /** Deletes a single `CustomerProgram` using its globally unique id. */
  deleteCustomerProgramByNodeId?: Maybe<DeleteCustomerProgramPayload>;
  /** Deletes a single `CustomerProgram` using a unique key. */
  deleteCustomerProgram?: Maybe<DeleteCustomerProgramPayload>;
  /** Deletes a single `CustomerProgramEntry` using its globally unique id. */
  deleteCustomerProgramEntryByNodeId?: Maybe<DeleteCustomerProgramEntryPayload>;
  /** Deletes a single `CustomerProgramEntry` using a unique key. */
  deleteCustomerProgramEntry?: Maybe<DeleteCustomerProgramEntryPayload>;
  /** Deletes a single `InventoryItem` using its globally unique id. */
  deleteInventoryItemByNodeId?: Maybe<DeleteInventoryItemPayload>;
  /** Deletes a single `InventoryItem` using a unique key. */
  deleteInventoryItem?: Maybe<DeleteInventoryItemPayload>;
  /** Deletes a single `PackAtmosphere` using its globally unique id. */
  deletePackAtmosphereByNodeId?: Maybe<DeletePackAtmospherePayload>;
  /** Deletes a single `PackAtmosphere` using a unique key. */
  deletePackAtmosphere?: Maybe<DeletePackAtmospherePayload>;
  /** Deletes a single `PackAtmosphere` using a unique key. */
  deletePackAtmosphereByShipperIdAndMaCode?: Maybe<DeletePackAtmospherePayload>;
  /** Deletes a single `PackBoxStyle` using its globally unique id. */
  deletePackBoxStyleByNodeId?: Maybe<DeletePackBoxStylePayload>;
  /** Deletes a single `PackBoxStyle` using a unique key. */
  deletePackBoxStyle?: Maybe<DeletePackBoxStylePayload>;
  /** Deletes a single `PackBoxStyle` using a unique key. */
  deletePackBoxStyleByShipperIdAndBoxStyle?: Maybe<DeletePackBoxStylePayload>;
  /** Deletes a single `PackBoxType` using its globally unique id. */
  deletePackBoxTypeByNodeId?: Maybe<DeletePackBoxTypePayload>;
  /** Deletes a single `PackBoxType` using a unique key. */
  deletePackBoxType?: Maybe<DeletePackBoxTypePayload>;
  /** Deletes a single `PackBoxType` using a unique key. */
  deletePackBoxTypeByShipperIdAndBoxType?: Maybe<DeletePackBoxTypePayload>;
  /** Deletes a single `PackDestination` using its globally unique id. */
  deletePackDestinationByNodeId?: Maybe<DeletePackDestinationPayload>;
  /** Deletes a single `PackDestination` using a unique key. */
  deletePackDestination?: Maybe<DeletePackDestinationPayload>;
  /** Deletes a single `PackDestination` using a unique key. */
  deletePackDestinationByShipperIdAndDestinationCode?: Maybe<DeletePackDestinationPayload>;
  /** Deletes a single `PackGrade` using its globally unique id. */
  deletePackGradeByNodeId?: Maybe<DeletePackGradePayload>;
  /** Deletes a single `PackGrade` using a unique key. */
  deletePackGrade?: Maybe<DeletePackGradePayload>;
  /** Deletes a single `PackGrade` using a unique key. */
  deletePackGradeByShipperIdAndGradeCode?: Maybe<DeletePackGradePayload>;
  /** Deletes a single `PackHold` using its globally unique id. */
  deletePackHoldByNodeId?: Maybe<DeletePackHoldPayload>;
  /** Deletes a single `PackHold` using a unique key. */
  deletePackHold?: Maybe<DeletePackHoldPayload>;
  /** Deletes a single `PackHold` using a unique key. */
  deletePackHoldByShipperIdAndHoldCode?: Maybe<DeletePackHoldPayload>;
  /** Deletes a single `PackLabel` using its globally unique id. */
  deletePackLabelByNodeId?: Maybe<DeletePackLabelPayload>;
  /** Deletes a single `PackLabel` using a unique key. */
  deletePackLabel?: Maybe<DeletePackLabelPayload>;
  /** Deletes a single `PackLabel` using a unique key. */
  deletePackLabelByShipperIdAndLabelCode?: Maybe<DeletePackLabelPayload>;
  /** Deletes a single `PackLiner` using its globally unique id. */
  deletePackLinerByNodeId?: Maybe<DeletePackLinerPayload>;
  /** Deletes a single `PackLiner` using a unique key. */
  deletePackLiner?: Maybe<DeletePackLinerPayload>;
  /** Deletes a single `PackLiner` using a unique key. */
  deletePackLinerByShipperIdAndLinerCode?: Maybe<DeletePackLinerPayload>;
  /** Deletes a single `PackMaster` using its globally unique id. */
  deletePackMasterByNodeId?: Maybe<DeletePackMasterPayload>;
  /** Deletes a single `PackMaster` using a unique key. */
  deletePackMaster?: Maybe<DeletePackMasterPayload>;
  /** Deletes a single `PackOut` using its globally unique id. */
  deletePackOutByNodeId?: Maybe<DeletePackOutPayload>;
  /** Deletes a single `PackOut` using a unique key. */
  deletePackOut?: Maybe<DeletePackOutPayload>;
  /** Deletes a single `PackOut` using a unique key. */
  deletePackOutByShipperIdAndOutCode?: Maybe<DeletePackOutPayload>;
  /** Deletes a single `PackPalletType` using its globally unique id. */
  deletePackPalletTypeByNodeId?: Maybe<DeletePackPalletTypePayload>;
  /** Deletes a single `PackPalletType` using a unique key. */
  deletePackPalletType?: Maybe<DeletePackPalletTypePayload>;
  /** Deletes a single `PackPalletType` using a unique key. */
  deletePackPalletTypeByShipperIdAndPalletType?: Maybe<DeletePackPalletTypePayload>;
  /** Deletes a single `PackProduction` using its globally unique id. */
  deletePackProductionByNodeId?: Maybe<DeletePackProductionPayload>;
  /** Deletes a single `PackProduction` using a unique key. */
  deletePackProduction?: Maybe<DeletePackProductionPayload>;
  /** Deletes a single `PackProduction` using a unique key. */
  deletePackProductionByShipperIdAndProductionCode?: Maybe<DeletePackProductionPayload>;
  /** Deletes a single `PackSpecial` using its globally unique id. */
  deletePackSpecialByNodeId?: Maybe<DeletePackSpecialPayload>;
  /** Deletes a single `PackSpecial` using a unique key. */
  deletePackSpecial?: Maybe<DeletePackSpecialPayload>;
  /** Deletes a single `PackSpecial` using a unique key. */
  deletePackSpecialByShipperIdAndCustomerCode?: Maybe<DeletePackSpecialPayload>;
  /** Deletes a single `PackStyle` using its globally unique id. */
  deletePackStyleByNodeId?: Maybe<DeletePackStylePayload>;
  /** Deletes a single `PackStyle` using a unique key. */
  deletePackStyle?: Maybe<DeletePackStylePayload>;
  /** Deletes a single `PackStyle` using a unique key. */
  deletePackStyleByShipperIdAndPackStyle?: Maybe<DeletePackStylePayload>;
  /** Deletes a single `PackTreeRipe` using its globally unique id. */
  deletePackTreeRipeByNodeId?: Maybe<DeletePackTreeRipePayload>;
  /** Deletes a single `PackTreeRipe` using a unique key. */
  deletePackTreeRipe?: Maybe<DeletePackTreeRipePayload>;
  /** Deletes a single `PackTreeRipe` using a unique key. */
  deletePackTreeRipeByShipperIdAndTreeRipe?: Maybe<DeletePackTreeRipePayload>;
  /** Deletes a single `Pallet` using its globally unique id. */
  deletePalletByNodeId?: Maybe<DeletePalletPayload>;
  /** Deletes a single `Pallet` using a unique key. */
  deletePallet?: Maybe<DeletePalletPayload>;
  /** Deletes a single `PalletSection` using its globally unique id. */
  deletePalletSectionByNodeId?: Maybe<DeletePalletSectionPayload>;
  /** Deletes a single `PalletSection` using a unique key. */
  deletePalletSection?: Maybe<DeletePalletSectionPayload>;
  /** Deletes a single `ProductMaster` using its globally unique id. */
  deleteProductMasterByNodeId?: Maybe<DeleteProductMasterPayload>;
  /** Deletes a single `ProductMaster` using a unique key. */
  deleteProductMaster?: Maybe<DeleteProductMasterPayload>;
  /** Deletes a single `ProductSize` using its globally unique id. */
  deleteProductSizeByNodeId?: Maybe<DeleteProductSizePayload>;
  /** Deletes a single `ProductSize` using a unique key. */
  deleteProductSize?: Maybe<DeleteProductSizePayload>;
  /** Deletes a single `ProductSpecies` using its globally unique id. */
  deleteProductSpeciesByNodeId?: Maybe<DeleteProductSpeciesPayload>;
  /** Deletes a single `ProductSpecies` using a unique key. */
  deleteProductSpecies?: Maybe<DeleteProductSpeciesPayload>;
  /** Deletes a single `ProductVariety` using its globally unique id. */
  deleteProductVarietyByNodeId?: Maybe<DeleteProductVarietyPayload>;
  /** Deletes a single `ProductVariety` using a unique key. */
  deleteProductVariety?: Maybe<DeleteProductVarietyPayload>;
  /** Deletes a single `RepackStyle` using its globally unique id. */
  deleteRepackStyleByNodeId?: Maybe<DeleteRepackStylePayload>;
  /** Deletes a single `RepackStyle` using a unique key. */
  deleteRepackStyle?: Maybe<DeleteRepackStylePayload>;
  /** Deletes a single `ShipperProgram` using its globally unique id. */
  deleteShipperProgramByNodeId?: Maybe<DeleteShipperProgramPayload>;
  /** Deletes a single `ShipperProgram` using a unique key. */
  deleteShipperProgram?: Maybe<DeleteShipperProgramPayload>;
  /** Deletes a single `ShipperProgramEntry` using its globally unique id. */
  deleteShipperProgramEntryByNodeId?: Maybe<DeleteShipperProgramEntryPayload>;
  /** Deletes a single `ShipperProgramEntry` using a unique key. */
  deleteShipperProgramEntry?: Maybe<DeleteShipperProgramEntryPayload>;
  /** Deletes a single `ShipperProgramEntryCustomerProgramEntry` using its globally unique id. */
  deleteShipperProgramEntryCustomerProgramEntryByNodeId?: Maybe<DeleteShipperProgramEntryCustomerProgramEntryPayload>;
  /** Deletes a single `ShipperProgramEntryCustomerProgramEntry` using a unique key. */
  deleteShipperProgramEntryCustomerProgramEntry?: Maybe<DeleteShipperProgramEntryCustomerProgramEntryPayload>;
  /** Deletes a single `ShipperProjection` using its globally unique id. */
  deleteShipperProjectionByNodeId?: Maybe<DeleteShipperProjectionPayload>;
  /** Deletes a single `ShipperProjection` using a unique key. */
  deleteShipperProjection?: Maybe<DeleteShipperProjectionPayload>;
  /** Deletes a single `ShipperProjectionEntry` using its globally unique id. */
  deleteShipperProjectionEntryByNodeId?: Maybe<DeleteShipperProjectionEntryPayload>;
  /** Deletes a single `ShipperProjectionEntry` using a unique key. */
  deleteShipperProjectionEntry?: Maybe<DeleteShipperProjectionEntryPayload>;
  /** Deletes a single `ShipperProjectionProduct` using its globally unique id. */
  deleteShipperProjectionProductByNodeId?: Maybe<DeleteShipperProjectionProductPayload>;
  /** Deletes a single `ShipperProjectionProduct` using a unique key. */
  deleteShipperProjectionProduct?: Maybe<DeleteShipperProjectionProductPayload>;
  /** Deletes a single `ShipperProjectionVessel` using its globally unique id. */
  deleteShipperProjectionVesselByNodeId?: Maybe<DeleteShipperProjectionVesselPayload>;
  /** Deletes a single `ShipperProjectionVessel` using a unique key. */
  deleteShipperProjectionVessel?: Maybe<DeleteShipperProjectionVesselPayload>;
  /** Deletes a single `ShipperProjectionVesselInfo` using its globally unique id. */
  deleteShipperProjectionVesselInfoByNodeId?: Maybe<DeleteShipperProjectionVesselInfoPayload>;
  /** Deletes a single `ShipperProjectionVesselInfo` using a unique key. */
  deleteShipperProjectionVesselInfo?: Maybe<DeleteShipperProjectionVesselInfoPayload>;
  /** Deletes a single `Vessel` using its globally unique id. */
  deleteVesselByNodeId?: Maybe<DeleteVesselPayload>;
  /** Deletes a single `Vessel` using a unique key. */
  deleteVessel?: Maybe<DeleteVesselPayload>;
  /** Deletes a single `AgendaItem` using its globally unique id. */
  deleteAgendaItemByNodeId?: Maybe<DeleteAgendaItemPayload>;
  /** Deletes a single `AgendaItem` using a unique key. */
  deleteAgendaItem?: Maybe<DeleteAgendaItemPayload>;
  /** Deletes a single `CalendarEvent` using its globally unique id. */
  deleteCalendarEventByNodeId?: Maybe<DeleteCalendarEventPayload>;
  /** Deletes a single `CalendarEvent` using a unique key. */
  deleteCalendarEvent?: Maybe<DeleteCalendarEventPayload>;
  /** Deletes a single `PriceCategory` using its globally unique id. */
  deletePriceCategoryByNodeId?: Maybe<DeletePriceCategoryPayload>;
  /** Deletes a single `PriceCategory` using a unique key. */
  deletePriceCategory?: Maybe<DeletePriceCategoryPayload>;
  /** Deletes a single `PriceEntry` using its globally unique id. */
  deletePriceEntryByNodeId?: Maybe<DeletePriceEntryPayload>;
  /** Deletes a single `PriceEntry` using a unique key. */
  deletePriceEntry?: Maybe<DeletePriceEntryPayload>;
  /** Deletes a single `PriceProduct` using its globally unique id. */
  deletePriceProductByNodeId?: Maybe<DeletePriceProductPayload>;
  /** Deletes a single `PriceProduct` using a unique key. */
  deletePriceProduct?: Maybe<DeletePriceProductPayload>;
  /** Deletes a single `PriceSize` using its globally unique id. */
  deletePriceSizeByNodeId?: Maybe<DeletePriceSizePayload>;
  /** Deletes a single `PriceSize` using a unique key. */
  deletePriceSize?: Maybe<DeletePriceSizePayload>;
  /** Deletes a single `LoadNumber` using its globally unique id. */
  deleteLoadNumberByNodeId?: Maybe<DeleteLoadNumberPayload>;
  /** Deletes a single `LoadNumber` using a unique key. */
  deleteLoadNumber?: Maybe<DeleteLoadNumberPayload>;
  /** Deletes a single `OrderComment` using its globally unique id. */
  deleteOrderCommentByNodeId?: Maybe<DeleteOrderCommentPayload>;
  /** Deletes a single `OrderComment` using a unique key. */
  deleteOrderComment?: Maybe<DeleteOrderCommentPayload>;
  /** Deletes a single `OrderEntry` using its globally unique id. */
  deleteOrderEntryByNodeId?: Maybe<DeleteOrderEntryPayload>;
  /** Deletes a single `OrderEntry` using a unique key. */
  deleteOrderEntry?: Maybe<DeleteOrderEntryPayload>;
  /** Deletes a single `OrderEntryItem` using its globally unique id. */
  deleteOrderEntryItemByNodeId?: Maybe<DeleteOrderEntryItemPayload>;
  /** Deletes a single `OrderEntryItem` using a unique key. */
  deleteOrderEntryItem?: Maybe<DeleteOrderEntryItemPayload>;
  /** Deletes a single `OrderEntryReviewItem` using its globally unique id. */
  deleteOrderEntryReviewItemByNodeId?: Maybe<DeleteOrderEntryReviewItemPayload>;
  /** Deletes a single `OrderEntryReviewItem` using a unique key. */
  deleteOrderEntryReviewItem?: Maybe<DeleteOrderEntryReviewItemPayload>;
  /** Deletes a single `OrderItem` using its globally unique id. */
  deleteOrderItemByNodeId?: Maybe<DeleteOrderItemPayload>;
  /** Deletes a single `OrderItem` using a unique key. */
  deleteOrderItem?: Maybe<DeleteOrderItemPayload>;
  /** Deletes a single `OrderMaster` using its globally unique id. */
  deleteOrderMasterByNodeId?: Maybe<DeleteOrderMasterPayload>;
  /** Deletes a single `OrderMaster` using a unique key. */
  deleteOrderMaster?: Maybe<DeleteOrderMasterPayload>;
  /** Deletes a single `OrderPallet` using its globally unique id. */
  deleteOrderPalletByNodeId?: Maybe<DeleteOrderPalletPayload>;
  /** Deletes a single `OrderPallet` using a unique key. */
  deleteOrderPallet?: Maybe<DeleteOrderPalletPayload>;
  /** Deletes a single `RepackHeader` using its globally unique id. */
  deleteRepackHeaderByNodeId?: Maybe<DeleteRepackHeaderPayload>;
  /** Deletes a single `RepackHeader` using a unique key. */
  deleteRepackHeader?: Maybe<DeleteRepackHeaderPayload>;
  /** Deletes a single `RepackItem` using its globally unique id. */
  deleteRepackItemByNodeId?: Maybe<DeleteRepackItemPayload>;
  /** Deletes a single `RepackItem` using a unique key. */
  deleteRepackItem?: Maybe<DeleteRepackItemPayload>;
  /** Deletes a single `RepackQueue` using its globally unique id. */
  deleteRepackQueueByNodeId?: Maybe<DeleteRepackQueuePayload>;
  /** Deletes a single `RepackQueue` using a unique key. */
  deleteRepackQueue?: Maybe<DeleteRepackQueuePayload>;
  /** Deletes a single `TruckLoad` using its globally unique id. */
  deleteTruckLoadByNodeId?: Maybe<DeleteTruckLoadPayload>;
  /** Deletes a single `TruckLoad` using a unique key. */
  deleteTruckLoad?: Maybe<DeleteTruckLoadPayload>;
  /** Deletes a single `TruckRate` using its globally unique id. */
  deleteTruckRateByNodeId?: Maybe<DeleteTruckRatePayload>;
  /** Deletes a single `TruckRate` using a unique key. */
  deleteTruckRate?: Maybe<DeleteTruckRatePayload>;
  /** Deletes a single `TruckRateCustomer` using its globally unique id. */
  deleteTruckRateCustomerByNodeId?: Maybe<DeleteTruckRateCustomerPayload>;
  /** Deletes a single `TruckRateCustomer` using a unique key. */
  deleteTruckRateCustomer?: Maybe<DeleteTruckRateCustomerPayload>;
  /** Deletes a single `CheckHeader` using its globally unique id. */
  deleteCheckHeaderByNodeId?: Maybe<DeleteCheckHeaderPayload>;
  /** Deletes a single `CheckHeader` using a unique key. */
  deleteCheckHeader?: Maybe<DeleteCheckHeaderPayload>;
  /** Deletes a single `CustomerPayment` using its globally unique id. */
  deleteCustomerPaymentByNodeId?: Maybe<DeleteCustomerPaymentPayload>;
  /** Deletes a single `CustomerPayment` using a unique key. */
  deleteCustomerPayment?: Maybe<DeleteCustomerPaymentPayload>;
  /** Deletes a single `ExpenseHeader` using its globally unique id. */
  deleteExpenseHeaderByNodeId?: Maybe<DeleteExpenseHeaderPayload>;
  /** Deletes a single `ExpenseHeader` using a unique key. */
  deleteExpenseHeader?: Maybe<DeleteExpenseHeaderPayload>;
  /** Deletes a single `ExpenseHeaderReview` using its globally unique id. */
  deleteExpenseHeaderReviewByNodeId?: Maybe<DeleteExpenseHeaderReviewPayload>;
  /** Deletes a single `ExpenseHeaderReview` using a unique key. */
  deleteExpenseHeaderReview?: Maybe<DeleteExpenseHeaderReviewPayload>;
  /** Deletes a single `ExpenseItem` using its globally unique id. */
  deleteExpenseItemByNodeId?: Maybe<DeleteExpenseItemPayload>;
  /** Deletes a single `ExpenseItem` using a unique key. */
  deleteExpenseItem?: Maybe<DeleteExpenseItemPayload>;
  /** Deletes a single `InvoiceHeader` using its globally unique id. */
  deleteInvoiceHeaderByNodeId?: Maybe<DeleteInvoiceHeaderPayload>;
  /** Deletes a single `InvoiceHeader` using a unique key. */
  deleteInvoiceHeader?: Maybe<DeleteInvoiceHeaderPayload>;
  /** Deletes a single `InvoiceItem` using its globally unique id. */
  deleteInvoiceItemByNodeId?: Maybe<DeleteInvoiceItemPayload>;
  /** Deletes a single `InvoiceItem` using a unique key. */
  deleteInvoiceItem?: Maybe<DeleteInvoiceItemPayload>;
  /** Deletes a single `InvoiceItemHistory` using its globally unique id. */
  deleteInvoiceItemHistoryByNodeId?: Maybe<DeleteInvoiceItemHistoryPayload>;
  /** Deletes a single `InvoiceItemHistory` using a unique key. */
  deleteInvoiceItemHistory?: Maybe<DeleteInvoiceItemHistoryPayload>;
  /** Deletes a single `Unpaid` using its globally unique id. */
  deleteUnpaidByNodeId?: Maybe<DeleteUnpaidPayload>;
  /** Deletes a single `Unpaid` using a unique key. */
  deleteUnpaid?: Maybe<DeleteUnpaidPayload>;
  /** Deletes a single `VesselControl` using its globally unique id. */
  deleteVesselControlByNodeId?: Maybe<DeleteVesselControlPayload>;
  /** Deletes a single `VesselControl` using a unique key. */
  deleteVesselControl?: Maybe<DeleteVesselControlPayload>;
  /** Deletes a single `WireRequest` using its globally unique id. */
  deleteWireRequestByNodeId?: Maybe<DeleteWireRequestPayload>;
  /** Deletes a single `WireRequest` using a unique key. */
  deleteWireRequest?: Maybe<DeleteWireRequestPayload>;
  /** Deletes a single `WireRequestAccountOfSaleItem` using its globally unique id. */
  deleteWireRequestAccountOfSaleItemByNodeId?: Maybe<DeleteWireRequestAccountOfSaleItemPayload>;
  /** Deletes a single `WireRequestAccountOfSaleItem` using a unique key. */
  deleteWireRequestAccountOfSaleItem?: Maybe<DeleteWireRequestAccountOfSaleItemPayload>;
  /** Deletes a single `WireRequestMiscItem` using its globally unique id. */
  deleteWireRequestMiscItemByNodeId?: Maybe<DeleteWireRequestMiscItemPayload>;
  /** Deletes a single `WireRequestMiscItem` using a unique key. */
  deleteWireRequestMiscItem?: Maybe<DeleteWireRequestMiscItemPayload>;
  /** Deletes a single `WireRequestOceanFreightItem` using its globally unique id. */
  deleteWireRequestOceanFreightItemByNodeId?: Maybe<DeleteWireRequestOceanFreightItemPayload>;
  /** Deletes a single `WireRequestOceanFreightItem` using a unique key. */
  deleteWireRequestOceanFreightItem?: Maybe<DeleteWireRequestOceanFreightItemPayload>;
  /** Deletes a single `WireRequestShipperAdvanceItem` using its globally unique id. */
  deleteWireRequestShipperAdvanceItemByNodeId?: Maybe<DeleteWireRequestShipperAdvanceItemPayload>;
  /** Deletes a single `WireRequestShipperAdvanceItem` using a unique key. */
  deleteWireRequestShipperAdvanceItem?: Maybe<DeleteWireRequestShipperAdvanceItemPayload>;
  bulkCreateUserMessage?: Maybe<BulkCreateUserMessagePayload>;
  bulkUpsertUserBookmark?: Maybe<BulkUpsertUserBookmarkPayload>;
  bulkAddContactsToGroup?: Maybe<BulkAddContactsToGroupPayload>;
  bulkDeleteCountry?: Maybe<BulkDeleteCountryPayload>;
  bulkDeleteCustomer?: Maybe<BulkDeleteCustomerPayload>;
  bulkDeleteCustomerVolumeDiscount?: Maybe<BulkDeleteCustomerVolumeDiscountPayload>;
  bulkDeleteShipper?: Maybe<BulkDeleteShipperPayload>;
  bulkDeleteVendor?: Maybe<BulkDeleteVendorPayload>;
  bulkDeleteWarehouse?: Maybe<BulkDeleteWarehousePayload>;
  bulkRemoveContactGroupPersonContact?: Maybe<BulkRemoveContactGroupPersonContactPayload>;
  bulkUpsertCountry?: Maybe<BulkUpsertCountryPayload>;
  bulkUpsertCustomer?: Maybe<BulkUpsertCustomerPayload>;
  bulkUpsertCustomerVolumeDiscount?: Maybe<BulkUpsertCustomerVolumeDiscountPayload>;
  bulkUpsertShipper?: Maybe<BulkUpsertShipperPayload>;
  bulkUpsertUnpaid?: Maybe<BulkUpsertUnpaidPayload>;
  bulkUpsertVendor?: Maybe<BulkUpsertVendorPayload>;
  bulkUpsertVesselControl?: Maybe<BulkUpsertVesselControlPayload>;
  bulkUpsertWarehouse?: Maybe<BulkUpsertWarehousePayload>;
  batchCreateChileDepartureInspectionPallet?: Maybe<BatchCreateChileDepartureInspectionPalletPayload>;
  batchCreatePsaApplePallet?: Maybe<BatchCreatePsaApplePalletPayload>;
  batchCreatePsaCherryPallet?: Maybe<BatchCreatePsaCherryPalletPayload>;
  batchCreatePsaCitrusPallet?: Maybe<BatchCreatePsaCitrusPalletPayload>;
  batchCreatePsaGrapePallet?: Maybe<BatchCreatePsaGrapePalletPayload>;
  batchCreatePsaLemonPallet?: Maybe<BatchCreatePsaLemonPalletPayload>;
  batchCreatePsaPearPallet?: Maybe<BatchCreatePsaPearPalletPayload>;
  batchCreatePsaPersimmonPallet?: Maybe<BatchCreatePsaPersimmonPalletPayload>;
  batchCreatePsaPomegranatePallet?: Maybe<BatchCreatePsaPomegranatePalletPayload>;
  batchCreatePsaStoneFruitPallet?: Maybe<BatchCreatePsaStoneFruitPalletPayload>;
  bulkDeleteActiveInventoryItem?: Maybe<BulkDeleteActiveInventoryItemPayload>;
  bulkDeleteCustomerProgram?: Maybe<BulkDeleteCustomerProgramPayload>;
  bulkDeleteInventoryItem?: Maybe<BulkDeleteInventoryItemPayload>;
  bulkDeletePackMaster?: Maybe<BulkDeletePackMasterPayload>;
  bulkDeletePallet?: Maybe<BulkDeletePalletPayload>;
  bulkDeletePalletSection?: Maybe<BulkDeletePalletSectionPayload>;
  bulkDeleteProductMaster?: Maybe<BulkDeleteProductMasterPayload>;
  bulkDeleteProductSize?: Maybe<BulkDeleteProductSizePayload>;
  bulkDeleteProductSpecies?: Maybe<BulkDeleteProductSpeciesPayload>;
  bulkDeleteProductVariety?: Maybe<BulkDeleteProductVarietyPayload>;
  bulkDeleteRepackStyle?: Maybe<BulkDeleteRepackStylePayload>;
  bulkDeleteShipperProgram?: Maybe<BulkDeleteShipperProgramPayload>;
  bulkDeleteShipperProgramEntryCustomerProgramEntry?: Maybe<BulkDeleteShipperProgramEntryCustomerProgramEntryPayload>;
  bulkDeleteShipperProjectionEntry?: Maybe<BulkDeleteShipperProjectionEntryPayload>;
  bulkDeleteVessel?: Maybe<BulkDeleteVesselPayload>;
  bulkUpsertContainer?: Maybe<BulkUpsertContainerPayload>;
  bulkUpsertCustomerProgram?: Maybe<BulkUpsertCustomerProgramPayload>;
  bulkUpsertCustomerProgramEntry?: Maybe<BulkUpsertCustomerProgramEntryPayload>;
  bulkUpsertInventoryItem?: Maybe<BulkUpsertInventoryItemPayload>;
  bulkUpsertPackAtmosphere?: Maybe<BulkUpsertPackAtmospherePayload>;
  bulkUpsertPackBoxStyle?: Maybe<BulkUpsertPackBoxStylePayload>;
  bulkUpsertPackBoxType?: Maybe<BulkUpsertPackBoxTypePayload>;
  bulkUpsertPackDestination?: Maybe<BulkUpsertPackDestinationPayload>;
  bulkUpsertPackGrade?: Maybe<BulkUpsertPackGradePayload>;
  bulkUpsertPackHold?: Maybe<BulkUpsertPackHoldPayload>;
  bulkUpsertPackLabel?: Maybe<BulkUpsertPackLabelPayload>;
  bulkUpsertPackLiner?: Maybe<BulkUpsertPackLinerPayload>;
  bulkUpsertPackMaster?: Maybe<BulkUpsertPackMasterPayload>;
  bulkUpsertPackOut?: Maybe<BulkUpsertPackOutPayload>;
  bulkUpsertPackPalletType?: Maybe<BulkUpsertPackPalletTypePayload>;
  bulkUpsertPackProduction?: Maybe<BulkUpsertPackProductionPayload>;
  bulkUpsertPackSpecial?: Maybe<BulkUpsertPackSpecialPayload>;
  bulkUpsertPackStyle?: Maybe<BulkUpsertPackStylePayload>;
  bulkUpsertPackTreeRipe?: Maybe<BulkUpsertPackTreeRipePayload>;
  bulkUpsertPallet?: Maybe<BulkUpsertPalletPayload>;
  bulkUpsertPalletSection?: Maybe<BulkUpsertPalletSectionPayload>;
  bulkUpsertProductMaster?: Maybe<BulkUpsertProductMasterPayload>;
  bulkUpsertProductSize?: Maybe<BulkUpsertProductSizePayload>;
  bulkUpsertProductSpecies?: Maybe<BulkUpsertProductSpeciesPayload>;
  bulkUpsertProductVariety?: Maybe<BulkUpsertProductVarietyPayload>;
  bulkUpsertRepackStyle?: Maybe<BulkUpsertRepackStylePayload>;
  bulkUpsertShipperProgram?: Maybe<BulkUpsertShipperProgramPayload>;
  bulkUpsertShipperProgramEntry?: Maybe<BulkUpsertShipperProgramEntryPayload>;
  bulkUpsertShipperProgramEntryCustomerProgramEntry?: Maybe<BulkUpsertShipperProgramEntryCustomerProgramEntryPayload>;
  bulkUpsertShipperProjectionProduct?: Maybe<BulkUpsertShipperProjectionProductPayload>;
  bulkUpsertShipperProjectionVessel?: Maybe<BulkUpsertShipperProjectionVesselPayload>;
  bulkUpsertVessel?: Maybe<BulkUpsertVesselPayload>;
  generateNewContainers?: Maybe<GenerateNewContainersPayload>;
  bulkUpsertAgendaItem?: Maybe<BulkUpsertAgendaItemPayload>;
  bulkUpsertPriceCategory?: Maybe<BulkUpsertPriceCategoryPayload>;
  bulkUpsertPriceEntry?: Maybe<BulkUpsertPriceEntryPayload>;
  bulkUpsertPriceProduct?: Maybe<BulkUpsertPriceProductPayload>;
  bulkUpsertPriceSize?: Maybe<BulkUpsertPriceSizePayload>;
  deletePriceCategoryEntries?: Maybe<DeletePriceCategoryEntriesPayload>;
  deletePriceProductEntries?: Maybe<DeletePriceProductEntriesPayload>;
  deletePriceSizeEntries?: Maybe<DeletePriceSizeEntriesPayload>;
  bulkDeleteOrderComment?: Maybe<BulkDeleteOrderCommentPayload>;
  bulkDeleteOrderItem?: Maybe<BulkDeleteOrderItemPayload>;
  bulkDeleteOrderMaster?: Maybe<BulkDeleteOrderMasterPayload>;
  bulkDeleteOrderPallet?: Maybe<BulkDeleteOrderPalletPayload>;
  bulkDeleteRepackHeader?: Maybe<BulkDeleteRepackHeaderPayload>;
  bulkDeleteRepackItem?: Maybe<BulkDeleteRepackItemPayload>;
  bulkDeleteRepackQueue?: Maybe<BulkDeleteRepackQueuePayload>;
  bulkDeleteTruckLoad?: Maybe<BulkDeleteTruckLoadPayload>;
  bulkUpsertLoadNumber?: Maybe<BulkUpsertLoadNumberPayload>;
  bulkUpsertOrderComment?: Maybe<BulkUpsertOrderCommentPayload>;
  bulkUpsertOrderItem?: Maybe<BulkUpsertOrderItemPayload>;
  bulkUpsertOrderMaster?: Maybe<BulkUpsertOrderMasterPayload>;
  bulkUpsertOrderPallet?: Maybe<BulkUpsertOrderPalletPayload>;
  bulkUpsertRepackHeader?: Maybe<BulkUpsertRepackHeaderPayload>;
  bulkUpsertRepackItem?: Maybe<BulkUpsertRepackItemPayload>;
  bulkUpsertRepackQueue?: Maybe<BulkUpsertRepackQueuePayload>;
  bulkUpsertTruckLoad?: Maybe<BulkUpsertTruckLoadPayload>;
  bulkDeleteCheckHeader?: Maybe<BulkDeleteCheckHeaderPayload>;
  bulkDeleteCustomerPayment?: Maybe<BulkDeleteCustomerPaymentPayload>;
  bulkDeleteExpenseHeader?: Maybe<BulkDeleteExpenseHeaderPayload>;
  bulkDeleteExpenseItem?: Maybe<BulkDeleteExpenseItemPayload>;
  bulkDeleteInvoiceHeader?: Maybe<BulkDeleteInvoiceHeaderPayload>;
  bulkDeleteInvoiceItem?: Maybe<BulkDeleteInvoiceItemPayload>;
  bulkDeleteInvoiceItemHistory?: Maybe<BulkDeleteInvoiceItemHistoryPayload>;
  bulkUpsertCheckHeader?: Maybe<BulkUpsertCheckHeaderPayload>;
  bulkUpsertCustomerPayment?: Maybe<BulkUpsertCustomerPaymentPayload>;
  bulkUpsertExpenseHeader?: Maybe<BulkUpsertExpenseHeaderPayload>;
  bulkUpsertExpenseHeaderReview?: Maybe<BulkUpsertExpenseHeaderReviewPayload>;
  bulkUpsertExpenseItem?: Maybe<BulkUpsertExpenseItemPayload>;
  bulkUpsertInvoiceHeader?: Maybe<BulkUpsertInvoiceHeaderPayload>;
  bulkUpsertInvoiceItem?: Maybe<BulkUpsertInvoiceItemPayload>;
  bulkUpsertInvoiceItemHistory?: Maybe<BulkUpsertInvoiceItemHistoryPayload>;
  /** Upserts a single `OrderNumber`. */
  upsertOrderNumber?: Maybe<UpsertOrderNumberPayload>;
  /** Upserts a single `User`. */
  upsertUser?: Maybe<UpsertUserPayload>;
  /** Upserts a single `UserBookmark`. */
  upsertUserBookmark?: Maybe<UpsertUserBookmarkPayload>;
  /** Upserts a single `UserMessage`. */
  upsertUserMessage?: Maybe<UpsertUserMessagePayload>;
  /** Upserts a single `UserRole`. */
  upsertUserRole?: Maybe<UpsertUserRolePayload>;
  /** Upserts a single `ContactGroup`. */
  upsertContactGroup?: Maybe<UpsertContactGroupPayload>;
  /** Upserts a single `ContactGroupPersonContact`. */
  upsertContactGroupPersonContact?: Maybe<UpsertContactGroupPersonContactPayload>;
  /** Upserts a single `Country`. */
  upsertCountry?: Maybe<UpsertCountryPayload>;
  /** Upserts a single `Customer`. */
  upsertCustomer?: Maybe<UpsertCustomerPayload>;
  /** Upserts a single `CustomerPersonContact`. */
  upsertCustomerPersonContact?: Maybe<UpsertCustomerPersonContactPayload>;
  /** Upserts a single `CustomerVolumeDiscount`. */
  upsertCustomerVolumeDiscount?: Maybe<UpsertCustomerVolumeDiscountPayload>;
  /** Upserts a single `PersonContact`. */
  upsertPersonContact?: Maybe<UpsertPersonContactPayload>;
  /** Upserts a single `Shipper`. */
  upsertShipper?: Maybe<UpsertShipperPayload>;
  /** Upserts a single `ShipperAdvance`. */
  upsertShipperAdvance?: Maybe<UpsertShipperAdvancePayload>;
  /** Upserts a single `ShipperPersonContact`. */
  upsertShipperPersonContact?: Maybe<UpsertShipperPersonContactPayload>;
  /** Upserts a single `Vendor`. */
  upsertVendor?: Maybe<UpsertVendorPayload>;
  /** Upserts a single `VendorPersonContact`. */
  upsertVendorPersonContact?: Maybe<UpsertVendorPersonContactPayload>;
  /** Upserts a single `Warehouse`. */
  upsertWarehouse?: Maybe<UpsertWarehousePayload>;
  /** Upserts a single `WarehousePersonContact`. */
  upsertWarehousePersonContact?: Maybe<UpsertWarehousePersonContactPayload>;
  /** Upserts a single `ChileDepartureInspectionPallet`. */
  upsertChileDepartureInspectionPallet?: Maybe<UpsertChileDepartureInspectionPalletPayload>;
  /** Upserts a single `PeruDepartureInspection`. */
  upsertPeruDepartureInspection?: Maybe<UpsertPeruDepartureInspectionPayload>;
  /** Upserts a single `PeruDepartureInspectionPallet`. */
  upsertPeruDepartureInspectionPallet?: Maybe<UpsertPeruDepartureInspectionPalletPayload>;
  /** Upserts a single `PsaApplePallet`. */
  upsertPsaApplePallet?: Maybe<UpsertPsaApplePalletPayload>;
  /** Upserts a single `PsaArrivalPicture`. */
  upsertPsaArrivalPicture?: Maybe<UpsertPsaArrivalPicturePayload>;
  /** Upserts a single `PsaArrivalReport`. */
  upsertPsaArrivalReport?: Maybe<UpsertPsaArrivalReportPayload>;
  /** Upserts a single `PsaCherryPallet`. */
  upsertPsaCherryPallet?: Maybe<UpsertPsaCherryPalletPayload>;
  /** Upserts a single `PsaCitrusPallet`. */
  upsertPsaCitrusPallet?: Maybe<UpsertPsaCitrusPalletPayload>;
  /** Upserts a single `PsaGrapePallet`. */
  upsertPsaGrapePallet?: Maybe<UpsertPsaGrapePalletPayload>;
  /** Upserts a single `PsaLemonPallet`. */
  upsertPsaLemonPallet?: Maybe<UpsertPsaLemonPalletPayload>;
  /** Upserts a single `PsaPearPallet`. */
  upsertPsaPearPallet?: Maybe<UpsertPsaPearPalletPayload>;
  /** Upserts a single `PsaPersimmonPallet`. */
  upsertPsaPersimmonPallet?: Maybe<UpsertPsaPersimmonPalletPayload>;
  /** Upserts a single `PsaPomegranatePallet`. */
  upsertPsaPomegranatePallet?: Maybe<UpsertPsaPomegranatePalletPayload>;
  /** Upserts a single `PsaStoneFruitPallet`. */
  upsertPsaStoneFruitPallet?: Maybe<UpsertPsaStoneFruitPalletPayload>;
  /** Upserts a single `CommonCategory`. */
  upsertCommonCategory?: Maybe<UpsertCommonCategoryPayload>;
  /** Upserts a single `CommonPackType`. */
  upsertCommonPackType?: Maybe<UpsertCommonPackTypePayload>;
  /** Upserts a single `CommonPackTypePackMaster`. */
  upsertCommonPackTypePackMaster?: Maybe<UpsertCommonPackTypePackMasterPayload>;
  /** Upserts a single `CommonPackTypeTag`. */
  upsertCommonPackTypeTag?: Maybe<UpsertCommonPackTypeTagPayload>;
  /** Upserts a single `CommonSize`. */
  upsertCommonSize?: Maybe<UpsertCommonSizePayload>;
  /** Upserts a single `CommonSizeProductSize`. */
  upsertCommonSizeProductSize?: Maybe<UpsertCommonSizeProductSizePayload>;
  /** Upserts a single `CommonSizeTag`. */
  upsertCommonSizeTag?: Maybe<UpsertCommonSizeTagPayload>;
  /** Upserts a single `CommonSpecies`. */
  upsertCommonSpecies?: Maybe<UpsertCommonSpeciesPayload>;
  /** Upserts a single `CommonSpeciesProductSpecies`. */
  upsertCommonSpeciesProductSpecies?: Maybe<UpsertCommonSpeciesProductSpeciesPayload>;
  /** Upserts a single `CommonSpeciesTag`. */
  upsertCommonSpeciesTag?: Maybe<UpsertCommonSpeciesTagPayload>;
  /** Upserts a single `CommonVariety`. */
  upsertCommonVariety?: Maybe<UpsertCommonVarietyPayload>;
  /** Upserts a single `CommonVarietyProductVariety`. */
  upsertCommonVarietyProductVariety?: Maybe<UpsertCommonVarietyProductVarietyPayload>;
  /** Upserts a single `CommonVarietyTag`. */
  upsertCommonVarietyTag?: Maybe<UpsertCommonVarietyTagPayload>;
  /** Upserts a single `Container`. */
  upsertContainer?: Maybe<UpsertContainerPayload>;
  /** Upserts a single `ContainerTreatment`. */
  upsertContainerTreatment?: Maybe<UpsertContainerTreatmentPayload>;
  /** Upserts a single `CustomerProgram`. */
  upsertCustomerProgram?: Maybe<UpsertCustomerProgramPayload>;
  /** Upserts a single `CustomerProgramEntry`. */
  upsertCustomerProgramEntry?: Maybe<UpsertCustomerProgramEntryPayload>;
  /** Upserts a single `InventoryItem`. */
  upsertInventoryItem?: Maybe<UpsertInventoryItemPayload>;
  /** Upserts a single `PackAtmosphere`. */
  upsertPackAtmosphere?: Maybe<UpsertPackAtmospherePayload>;
  /** Upserts a single `PackBoxStyle`. */
  upsertPackBoxStyle?: Maybe<UpsertPackBoxStylePayload>;
  /** Upserts a single `PackBoxType`. */
  upsertPackBoxType?: Maybe<UpsertPackBoxTypePayload>;
  /** Upserts a single `PackDestination`. */
  upsertPackDestination?: Maybe<UpsertPackDestinationPayload>;
  /** Upserts a single `PackGrade`. */
  upsertPackGrade?: Maybe<UpsertPackGradePayload>;
  /** Upserts a single `PackHold`. */
  upsertPackHold?: Maybe<UpsertPackHoldPayload>;
  /** Upserts a single `PackLabel`. */
  upsertPackLabel?: Maybe<UpsertPackLabelPayload>;
  /** Upserts a single `PackLiner`. */
  upsertPackLiner?: Maybe<UpsertPackLinerPayload>;
  /** Upserts a single `PackMaster`. */
  upsertPackMaster?: Maybe<UpsertPackMasterPayload>;
  /** Upserts a single `PackOut`. */
  upsertPackOut?: Maybe<UpsertPackOutPayload>;
  /** Upserts a single `PackPalletType`. */
  upsertPackPalletType?: Maybe<UpsertPackPalletTypePayload>;
  /** Upserts a single `PackProduction`. */
  upsertPackProduction?: Maybe<UpsertPackProductionPayload>;
  /** Upserts a single `PackSpecial`. */
  upsertPackSpecial?: Maybe<UpsertPackSpecialPayload>;
  /** Upserts a single `PackStyle`. */
  upsertPackStyle?: Maybe<UpsertPackStylePayload>;
  /** Upserts a single `PackTreeRipe`. */
  upsertPackTreeRipe?: Maybe<UpsertPackTreeRipePayload>;
  /** Upserts a single `Pallet`. */
  upsertPallet?: Maybe<UpsertPalletPayload>;
  /** Upserts a single `PalletSection`. */
  upsertPalletSection?: Maybe<UpsertPalletSectionPayload>;
  /** Upserts a single `ProductMaster`. */
  upsertProductMaster?: Maybe<UpsertProductMasterPayload>;
  /** Upserts a single `ProductSize`. */
  upsertProductSize?: Maybe<UpsertProductSizePayload>;
  /** Upserts a single `ProductSpecies`. */
  upsertProductSpecies?: Maybe<UpsertProductSpeciesPayload>;
  /** Upserts a single `ProductVariety`. */
  upsertProductVariety?: Maybe<UpsertProductVarietyPayload>;
  /** Upserts a single `RepackStyle`. */
  upsertRepackStyle?: Maybe<UpsertRepackStylePayload>;
  /** Upserts a single `ShipperProgram`. */
  upsertShipperProgram?: Maybe<UpsertShipperProgramPayload>;
  /** Upserts a single `ShipperProgramEntry`. */
  upsertShipperProgramEntry?: Maybe<UpsertShipperProgramEntryPayload>;
  /** Upserts a single `ShipperProgramEntryCustomerProgramEntry`. */
  upsertShipperProgramEntryCustomerProgramEntry?: Maybe<UpsertShipperProgramEntryCustomerProgramEntryPayload>;
  /** Upserts a single `ShipperProjection`. */
  upsertShipperProjection?: Maybe<UpsertShipperProjectionPayload>;
  /** Upserts a single `ShipperProjectionEntry`. */
  upsertShipperProjectionEntry?: Maybe<UpsertShipperProjectionEntryPayload>;
  /** Upserts a single `ShipperProjectionProduct`. */
  upsertShipperProjectionProduct?: Maybe<UpsertShipperProjectionProductPayload>;
  /** Upserts a single `ShipperProjectionVessel`. */
  upsertShipperProjectionVessel?: Maybe<UpsertShipperProjectionVesselPayload>;
  /** Upserts a single `ShipperProjectionVesselInfo`. */
  upsertShipperProjectionVesselInfo?: Maybe<UpsertShipperProjectionVesselInfoPayload>;
  /** Upserts a single `Vessel`. */
  upsertVessel?: Maybe<UpsertVesselPayload>;
  /** Upserts a single `AgendaItem`. */
  upsertAgendaItem?: Maybe<UpsertAgendaItemPayload>;
  /** Upserts a single `CalendarEvent`. */
  upsertCalendarEvent?: Maybe<UpsertCalendarEventPayload>;
  /** Upserts a single `PriceCategory`. */
  upsertPriceCategory?: Maybe<UpsertPriceCategoryPayload>;
  /** Upserts a single `PriceEntry`. */
  upsertPriceEntry?: Maybe<UpsertPriceEntryPayload>;
  /** Upserts a single `PriceProduct`. */
  upsertPriceProduct?: Maybe<UpsertPriceProductPayload>;
  /** Upserts a single `PriceSize`. */
  upsertPriceSize?: Maybe<UpsertPriceSizePayload>;
  /** Upserts a single `LoadNumber`. */
  upsertLoadNumber?: Maybe<UpsertLoadNumberPayload>;
  /** Upserts a single `OrderComment`. */
  upsertOrderComment?: Maybe<UpsertOrderCommentPayload>;
  /** Upserts a single `OrderEntry`. */
  upsertOrderEntry?: Maybe<UpsertOrderEntryPayload>;
  /** Upserts a single `OrderEntryItem`. */
  upsertOrderEntryItem?: Maybe<UpsertOrderEntryItemPayload>;
  /** Upserts a single `OrderEntryReviewItem`. */
  upsertOrderEntryReviewItem?: Maybe<UpsertOrderEntryReviewItemPayload>;
  /** Upserts a single `OrderItem`. */
  upsertOrderItem?: Maybe<UpsertOrderItemPayload>;
  /** Upserts a single `OrderMaster`. */
  upsertOrderMaster?: Maybe<UpsertOrderMasterPayload>;
  /** Upserts a single `OrderPallet`. */
  upsertOrderPallet?: Maybe<UpsertOrderPalletPayload>;
  /** Upserts a single `RepackHeader`. */
  upsertRepackHeader?: Maybe<UpsertRepackHeaderPayload>;
  /** Upserts a single `RepackItem`. */
  upsertRepackItem?: Maybe<UpsertRepackItemPayload>;
  /** Upserts a single `RepackQueue`. */
  upsertRepackQueue?: Maybe<UpsertRepackQueuePayload>;
  /** Upserts a single `TruckLoad`. */
  upsertTruckLoad?: Maybe<UpsertTruckLoadPayload>;
  /** Upserts a single `TruckRate`. */
  upsertTruckRate?: Maybe<UpsertTruckRatePayload>;
  /** Upserts a single `TruckRateCustomer`. */
  upsertTruckRateCustomer?: Maybe<UpsertTruckRateCustomerPayload>;
  /** Upserts a single `CheckHeader`. */
  upsertCheckHeader?: Maybe<UpsertCheckHeaderPayload>;
  /** Upserts a single `CustomerPayment`. */
  upsertCustomerPayment?: Maybe<UpsertCustomerPaymentPayload>;
  /** Upserts a single `ExpenseHeader`. */
  upsertExpenseHeader?: Maybe<UpsertExpenseHeaderPayload>;
  /** Upserts a single `ExpenseHeaderReview`. */
  upsertExpenseHeaderReview?: Maybe<UpsertExpenseHeaderReviewPayload>;
  /** Upserts a single `ExpenseItem`. */
  upsertExpenseItem?: Maybe<UpsertExpenseItemPayload>;
  /** Upserts a single `InvoiceHeader`. */
  upsertInvoiceHeader?: Maybe<UpsertInvoiceHeaderPayload>;
  /** Upserts a single `InvoiceItem`. */
  upsertInvoiceItem?: Maybe<UpsertInvoiceItemPayload>;
  /** Upserts a single `InvoiceItemHistory`. */
  upsertInvoiceItemHistory?: Maybe<UpsertInvoiceItemHistoryPayload>;
  /** Upserts a single `Unpaid`. */
  upsertUnpaid?: Maybe<UpsertUnpaidPayload>;
  /** Upserts a single `VesselControl`. */
  upsertVesselControl?: Maybe<UpsertVesselControlPayload>;
  /** Upserts a single `WireRequest`. */
  upsertWireRequest?: Maybe<UpsertWireRequestPayload>;
  /** Upserts a single `WireRequestAccountOfSaleItem`. */
  upsertWireRequestAccountOfSaleItem?: Maybe<UpsertWireRequestAccountOfSaleItemPayload>;
  /** Upserts a single `WireRequestMiscItem`. */
  upsertWireRequestMiscItem?: Maybe<UpsertWireRequestMiscItemPayload>;
  /** Upserts a single `WireRequestOceanFreightItem`. */
  upsertWireRequestOceanFreightItem?: Maybe<UpsertWireRequestOceanFreightItemPayload>;
  /** Upserts a single `WireRequestShipperAdvanceItem`. */
  upsertWireRequestShipperAdvanceItem?: Maybe<UpsertWireRequestShipperAdvanceItemPayload>;
  containerScheduleUpdateNotify: Scalars['String'];
  sendUnpaidsNotificationEmails: Scalars['String'];
  sendPriceSheetUpdateEmail: Scalars['String'];
  reviewShipperProjection: Scalars['String'];
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderNumberArgs = {
  input: CreateOrderNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserBookmarkArgs = {
  input: CreateUserBookmarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserMessageArgs = {
  input: CreateUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserRoleArgs = {
  input: CreateUserRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateContactGroupArgs = {
  input: CreateContactGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateContactGroupPersonContactArgs = {
  input: CreateContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCountryArgs = {
  input: CreateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerPersonContactArgs = {
  input: CreateCustomerPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerVolumeDiscountArgs = {
  input: CreateCustomerVolumeDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePersonContactArgs = {
  input: CreatePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperArgs = {
  input: CreateShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperAdvanceArgs = {
  input: CreateShipperAdvanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperPersonContactArgs = {
  input: CreateShipperPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVendorArgs = {
  input: CreateVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVendorPersonContactArgs = {
  input: CreateVendorPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWarehouseArgs = {
  input: CreateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWarehousePersonContactArgs = {
  input: CreateWarehousePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateChileDepartureInspectionPalletArgs = {
  input: CreateChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePeruDepartureInspectionArgs = {
  input: CreatePeruDepartureInspectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePeruDepartureInspectionPalletArgs = {
  input: CreatePeruDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaApplePalletArgs = {
  input: CreatePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaArrivalPictureArgs = {
  input: CreatePsaArrivalPictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaArrivalReportArgs = {
  input: CreatePsaArrivalReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaCherryPalletArgs = {
  input: CreatePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaCitrusPalletArgs = {
  input: CreatePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaGrapePalletArgs = {
  input: CreatePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaLemonPalletArgs = {
  input: CreatePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaPearPalletArgs = {
  input: CreatePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaPersimmonPalletArgs = {
  input: CreatePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaPomegranatePalletArgs = {
  input: CreatePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePsaStoneFruitPalletArgs = {
  input: CreatePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonCategoryArgs = {
  input: CreateCommonCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonPackTypeArgs = {
  input: CreateCommonPackTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonPackTypePackMasterArgs = {
  input: CreateCommonPackTypePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonPackTypeTagArgs = {
  input: CreateCommonPackTypeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonSizeArgs = {
  input: CreateCommonSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonSizeProductSizeArgs = {
  input: CreateCommonSizeProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonSizeTagArgs = {
  input: CreateCommonSizeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonSpeciesArgs = {
  input: CreateCommonSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonSpeciesProductSpeciesArgs = {
  input: CreateCommonSpeciesProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonSpeciesTagArgs = {
  input: CreateCommonSpeciesTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonVarietyArgs = {
  input: CreateCommonVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonVarietyProductVarietyArgs = {
  input: CreateCommonVarietyProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCommonVarietyTagArgs = {
  input: CreateCommonVarietyTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateContainerArgs = {
  input: CreateContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateContainerTreatmentArgs = {
  input: CreateContainerTreatmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerProgramArgs = {
  input: CreateCustomerProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerProgramEntryArgs = {
  input: CreateCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInventoryItemArgs = {
  input: CreateInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackAtmosphereArgs = {
  input: CreatePackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackBoxStyleArgs = {
  input: CreatePackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackBoxTypeArgs = {
  input: CreatePackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackDestinationArgs = {
  input: CreatePackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackGradeArgs = {
  input: CreatePackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackHoldArgs = {
  input: CreatePackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackLabelArgs = {
  input: CreatePackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackLinerArgs = {
  input: CreatePackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackMasterArgs = {
  input: CreatePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackOutArgs = {
  input: CreatePackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackPalletTypeArgs = {
  input: CreatePackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackProductionArgs = {
  input: CreatePackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackSpecialArgs = {
  input: CreatePackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackStyleArgs = {
  input: CreatePackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePackTreeRipeArgs = {
  input: CreatePackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePalletArgs = {
  input: CreatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePalletSectionArgs = {
  input: CreatePalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductMasterArgs = {
  input: CreateProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductSizeArgs = {
  input: CreateProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductSpeciesArgs = {
  input: CreateProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductVarietyArgs = {
  input: CreateProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRepackStyleArgs = {
  input: CreateRepackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProgramArgs = {
  input: CreateShipperProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProgramEntryArgs = {
  input: CreateShipperProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProgramEntryCustomerProgramEntryArgs = {
  input: CreateShipperProgramEntryCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionArgs = {
  input: CreateShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionEntryArgs = {
  input: CreateShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionProductArgs = {
  input: CreateShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionVesselArgs = {
  input: CreateShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateShipperProjectionVesselInfoArgs = {
  input: CreateShipperProjectionVesselInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVesselArgs = {
  input: CreateVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAgendaItemArgs = {
  input: CreateAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCalendarEventArgs = {
  input: CreateCalendarEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceCategoryArgs = {
  input: CreatePriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceEntryArgs = {
  input: CreatePriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceProductArgs = {
  input: CreatePriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePriceSizeArgs = {
  input: CreatePriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLoadNumberArgs = {
  input: CreateLoadNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderCommentArgs = {
  input: CreateOrderCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderEntryArgs = {
  input: CreateOrderEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderEntryItemArgs = {
  input: CreateOrderEntryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderEntryReviewItemArgs = {
  input: CreateOrderEntryReviewItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderItemArgs = {
  input: CreateOrderItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderMasterArgs = {
  input: CreateOrderMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrderPalletArgs = {
  input: CreateOrderPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRepackHeaderArgs = {
  input: CreateRepackHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRepackItemArgs = {
  input: CreateRepackItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRepackQueueArgs = {
  input: CreateRepackQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTruckLoadArgs = {
  input: CreateTruckLoadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTruckRateArgs = {
  input: CreateTruckRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTruckRateCustomerArgs = {
  input: CreateTruckRateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCheckHeaderArgs = {
  input: CreateCheckHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerPaymentArgs = {
  input: CreateCustomerPaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateExpenseHeaderArgs = {
  input: CreateExpenseHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateExpenseHeaderReviewArgs = {
  input: CreateExpenseHeaderReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateExpenseItemArgs = {
  input: CreateExpenseItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInvoiceHeaderArgs = {
  input: CreateInvoiceHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInvoiceItemArgs = {
  input: CreateInvoiceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInvoiceItemHistoryArgs = {
  input: CreateInvoiceItemHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUnpaidArgs = {
  input: CreateUnpaidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVesselControlArgs = {
  input: CreateVesselControlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWireRequestArgs = {
  input: CreateWireRequestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWireRequestAccountOfSaleItemArgs = {
  input: CreateWireRequestAccountOfSaleItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWireRequestMiscItemArgs = {
  input: CreateWireRequestMiscItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWireRequestOceanFreightItemArgs = {
  input: CreateWireRequestOceanFreightItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWireRequestShipperAdvanceItemArgs = {
  input: CreateWireRequestShipperAdvanceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderNumberByNodeIdArgs = {
  input: UpdateOrderNumberByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderNumberArgs = {
  input: UpdateOrderNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByPinArgs = {
  input: UpdateUserByPinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserBookmarkByNodeIdArgs = {
  input: UpdateUserBookmarkByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserBookmarkArgs = {
  input: UpdateUserBookmarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserMessageByNodeIdArgs = {
  input: UpdateUserMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserMessageArgs = {
  input: UpdateUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserRoleByUserIdAndRoleNameArgs = {
  input: UpdateUserRoleByUserIdAndRoleNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupByNodeIdArgs = {
  input: UpdateContactGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupArgs = {
  input: UpdateContactGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupPersonContactByNodeIdArgs = {
  input: UpdateContactGroupPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContactGroupPersonContactArgs = {
  input: UpdateContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCountryByNodeIdArgs = {
  input: UpdateCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCountryArgs = {
  input: UpdateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerByNodeIdArgs = {
  input: UpdateCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerPersonContactByNodeIdArgs = {
  input: UpdateCustomerPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerPersonContactArgs = {
  input: UpdateCustomerPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerVolumeDiscountByNodeIdArgs = {
  input: UpdateCustomerVolumeDiscountByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerVolumeDiscountArgs = {
  input: UpdateCustomerVolumeDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonContactByNodeIdArgs = {
  input: UpdatePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersonContactArgs = {
  input: UpdatePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperByNodeIdArgs = {
  input: UpdateShipperByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperArgs = {
  input: UpdateShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperAdvanceByNodeIdArgs = {
  input: UpdateShipperAdvanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperAdvanceArgs = {
  input: UpdateShipperAdvanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperPersonContactByNodeIdArgs = {
  input: UpdateShipperPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperPersonContactArgs = {
  input: UpdateShipperPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVendorByNodeIdArgs = {
  input: UpdateVendorByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVendorArgs = {
  input: UpdateVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVendorPersonContactByNodeIdArgs = {
  input: UpdateVendorPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVendorPersonContactArgs = {
  input: UpdateVendorPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehouseByNodeIdArgs = {
  input: UpdateWarehouseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehouseArgs = {
  input: UpdateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehousePersonContactByNodeIdArgs = {
  input: UpdateWarehousePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWarehousePersonContactArgs = {
  input: UpdateWarehousePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChileDepartureInspectionPalletByNodeIdArgs = {
  input: UpdateChileDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChileDepartureInspectionPalletArgs = {
  input: UpdateChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionByNodeIdArgs = {
  input: UpdatePeruDepartureInspectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionArgs = {
  input: UpdatePeruDepartureInspectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionPalletByNodeIdArgs = {
  input: UpdatePeruDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePeruDepartureInspectionPalletArgs = {
  input: UpdatePeruDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaApplePalletByNodeIdArgs = {
  input: UpdatePsaApplePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaApplePalletArgs = {
  input: UpdatePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalPictureByNodeIdArgs = {
  input: UpdatePsaArrivalPictureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalPictureArgs = {
  input: UpdatePsaArrivalPictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalReportByNodeIdArgs = {
  input: UpdatePsaArrivalReportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaArrivalReportArgs = {
  input: UpdatePsaArrivalReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCherryPalletByNodeIdArgs = {
  input: UpdatePsaCherryPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCherryPalletArgs = {
  input: UpdatePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCitrusPalletByNodeIdArgs = {
  input: UpdatePsaCitrusPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaCitrusPalletArgs = {
  input: UpdatePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaGrapePalletByNodeIdArgs = {
  input: UpdatePsaGrapePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaGrapePalletArgs = {
  input: UpdatePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaLemonPalletByNodeIdArgs = {
  input: UpdatePsaLemonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaLemonPalletArgs = {
  input: UpdatePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPearPalletByNodeIdArgs = {
  input: UpdatePsaPearPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPearPalletArgs = {
  input: UpdatePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPersimmonPalletByNodeIdArgs = {
  input: UpdatePsaPersimmonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPersimmonPalletArgs = {
  input: UpdatePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPomegranatePalletByNodeIdArgs = {
  input: UpdatePsaPomegranatePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaPomegranatePalletArgs = {
  input: UpdatePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaStoneFruitPalletByNodeIdArgs = {
  input: UpdatePsaStoneFruitPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePsaStoneFruitPalletArgs = {
  input: UpdatePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonCategoryByNodeIdArgs = {
  input: UpdateCommonCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonCategoryArgs = {
  input: UpdateCommonCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonPackTypeByNodeIdArgs = {
  input: UpdateCommonPackTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonPackTypeArgs = {
  input: UpdateCommonPackTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonPackTypePackMasterByNodeIdArgs = {
  input: UpdateCommonPackTypePackMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonPackTypePackMasterArgs = {
  input: UpdateCommonPackTypePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonPackTypeTagByNodeIdArgs = {
  input: UpdateCommonPackTypeTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonPackTypeTagArgs = {
  input: UpdateCommonPackTypeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSizeByNodeIdArgs = {
  input: UpdateCommonSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSizeArgs = {
  input: UpdateCommonSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSizeProductSizeByNodeIdArgs = {
  input: UpdateCommonSizeProductSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSizeProductSizeArgs = {
  input: UpdateCommonSizeProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSizeTagByNodeIdArgs = {
  input: UpdateCommonSizeTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSizeTagArgs = {
  input: UpdateCommonSizeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSpeciesByNodeIdArgs = {
  input: UpdateCommonSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSpeciesArgs = {
  input: UpdateCommonSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSpeciesProductSpeciesByNodeIdArgs = {
  input: UpdateCommonSpeciesProductSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSpeciesProductSpeciesArgs = {
  input: UpdateCommonSpeciesProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSpeciesTagByNodeIdArgs = {
  input: UpdateCommonSpeciesTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonSpeciesTagArgs = {
  input: UpdateCommonSpeciesTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonVarietyByNodeIdArgs = {
  input: UpdateCommonVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonVarietyArgs = {
  input: UpdateCommonVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonVarietyProductVarietyByNodeIdArgs = {
  input: UpdateCommonVarietyProductVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonVarietyProductVarietyArgs = {
  input: UpdateCommonVarietyProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonVarietyTagByNodeIdArgs = {
  input: UpdateCommonVarietyTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCommonVarietyTagArgs = {
  input: UpdateCommonVarietyTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContainerByNodeIdArgs = {
  input: UpdateContainerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContainerArgs = {
  input: UpdateContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContainerTreatmentByNodeIdArgs = {
  input: UpdateContainerTreatmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateContainerTreatmentArgs = {
  input: UpdateContainerTreatmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerProgramByNodeIdArgs = {
  input: UpdateCustomerProgramByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerProgramArgs = {
  input: UpdateCustomerProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerProgramEntryByNodeIdArgs = {
  input: UpdateCustomerProgramEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerProgramEntryArgs = {
  input: UpdateCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInventoryItemByNodeIdArgs = {
  input: UpdateInventoryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInventoryItemArgs = {
  input: UpdateInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackAtmosphereByNodeIdArgs = {
  input: UpdatePackAtmosphereByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackAtmosphereArgs = {
  input: UpdatePackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackAtmosphereByShipperIdAndMaCodeArgs = {
  input: UpdatePackAtmosphereByShipperIdAndMaCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxStyleByNodeIdArgs = {
  input: UpdatePackBoxStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxStyleArgs = {
  input: UpdatePackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxStyleByShipperIdAndBoxStyleArgs = {
  input: UpdatePackBoxStyleByShipperIdAndBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxTypeByNodeIdArgs = {
  input: UpdatePackBoxTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxTypeArgs = {
  input: UpdatePackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackBoxTypeByShipperIdAndBoxTypeArgs = {
  input: UpdatePackBoxTypeByShipperIdAndBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackDestinationByNodeIdArgs = {
  input: UpdatePackDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackDestinationArgs = {
  input: UpdatePackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackDestinationByShipperIdAndDestinationCodeArgs = {
  input: UpdatePackDestinationByShipperIdAndDestinationCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackGradeByNodeIdArgs = {
  input: UpdatePackGradeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackGradeArgs = {
  input: UpdatePackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackGradeByShipperIdAndGradeCodeArgs = {
  input: UpdatePackGradeByShipperIdAndGradeCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackHoldByNodeIdArgs = {
  input: UpdatePackHoldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackHoldArgs = {
  input: UpdatePackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackHoldByShipperIdAndHoldCodeArgs = {
  input: UpdatePackHoldByShipperIdAndHoldCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLabelByNodeIdArgs = {
  input: UpdatePackLabelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLabelArgs = {
  input: UpdatePackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLabelByShipperIdAndLabelCodeArgs = {
  input: UpdatePackLabelByShipperIdAndLabelCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLinerByNodeIdArgs = {
  input: UpdatePackLinerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLinerArgs = {
  input: UpdatePackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackLinerByShipperIdAndLinerCodeArgs = {
  input: UpdatePackLinerByShipperIdAndLinerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackMasterByNodeIdArgs = {
  input: UpdatePackMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackMasterArgs = {
  input: UpdatePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackOutByNodeIdArgs = {
  input: UpdatePackOutByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackOutArgs = {
  input: UpdatePackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackOutByShipperIdAndOutCodeArgs = {
  input: UpdatePackOutByShipperIdAndOutCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackPalletTypeByNodeIdArgs = {
  input: UpdatePackPalletTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackPalletTypeArgs = {
  input: UpdatePackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackPalletTypeByShipperIdAndPalletTypeArgs = {
  input: UpdatePackPalletTypeByShipperIdAndPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackProductionByNodeIdArgs = {
  input: UpdatePackProductionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackProductionArgs = {
  input: UpdatePackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackProductionByShipperIdAndProductionCodeArgs = {
  input: UpdatePackProductionByShipperIdAndProductionCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackSpecialByNodeIdArgs = {
  input: UpdatePackSpecialByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackSpecialArgs = {
  input: UpdatePackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackSpecialByShipperIdAndCustomerCodeArgs = {
  input: UpdatePackSpecialByShipperIdAndCustomerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackStyleByNodeIdArgs = {
  input: UpdatePackStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackStyleArgs = {
  input: UpdatePackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackStyleByShipperIdAndPackStyleArgs = {
  input: UpdatePackStyleByShipperIdAndPackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackTreeRipeByNodeIdArgs = {
  input: UpdatePackTreeRipeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackTreeRipeArgs = {
  input: UpdatePackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePackTreeRipeByShipperIdAndTreeRipeArgs = {
  input: UpdatePackTreeRipeByShipperIdAndTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletByNodeIdArgs = {
  input: UpdatePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletArgs = {
  input: UpdatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletSectionByNodeIdArgs = {
  input: UpdatePalletSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePalletSectionArgs = {
  input: UpdatePalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductMasterByNodeIdArgs = {
  input: UpdateProductMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductMasterArgs = {
  input: UpdateProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSizeByNodeIdArgs = {
  input: UpdateProductSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSizeArgs = {
  input: UpdateProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSpeciesByNodeIdArgs = {
  input: UpdateProductSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductSpeciesArgs = {
  input: UpdateProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductVarietyByNodeIdArgs = {
  input: UpdateProductVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductVarietyArgs = {
  input: UpdateProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackStyleByNodeIdArgs = {
  input: UpdateRepackStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackStyleArgs = {
  input: UpdateRepackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProgramByNodeIdArgs = {
  input: UpdateShipperProgramByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProgramArgs = {
  input: UpdateShipperProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProgramEntryByNodeIdArgs = {
  input: UpdateShipperProgramEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProgramEntryArgs = {
  input: UpdateShipperProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProgramEntryCustomerProgramEntryByNodeIdArgs = {
  input: UpdateShipperProgramEntryCustomerProgramEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProgramEntryCustomerProgramEntryArgs = {
  input: UpdateShipperProgramEntryCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionByNodeIdArgs = {
  input: UpdateShipperProjectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionArgs = {
  input: UpdateShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionEntryByNodeIdArgs = {
  input: UpdateShipperProjectionEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionEntryArgs = {
  input: UpdateShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionProductByNodeIdArgs = {
  input: UpdateShipperProjectionProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionProductArgs = {
  input: UpdateShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionVesselByNodeIdArgs = {
  input: UpdateShipperProjectionVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionVesselArgs = {
  input: UpdateShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionVesselInfoByNodeIdArgs = {
  input: UpdateShipperProjectionVesselInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateShipperProjectionVesselInfoArgs = {
  input: UpdateShipperProjectionVesselInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVesselByNodeIdArgs = {
  input: UpdateVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVesselArgs = {
  input: UpdateVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgendaItemByNodeIdArgs = {
  input: UpdateAgendaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgendaItemArgs = {
  input: UpdateAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCalendarEventByNodeIdArgs = {
  input: UpdateCalendarEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCalendarEventArgs = {
  input: UpdateCalendarEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceCategoryByNodeIdArgs = {
  input: UpdatePriceCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceCategoryArgs = {
  input: UpdatePriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceEntryByNodeIdArgs = {
  input: UpdatePriceEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceEntryArgs = {
  input: UpdatePriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceProductByNodeIdArgs = {
  input: UpdatePriceProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceProductArgs = {
  input: UpdatePriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceSizeByNodeIdArgs = {
  input: UpdatePriceSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePriceSizeArgs = {
  input: UpdatePriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLoadNumberByNodeIdArgs = {
  input: UpdateLoadNumberByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLoadNumberArgs = {
  input: UpdateLoadNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderCommentByNodeIdArgs = {
  input: UpdateOrderCommentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderCommentArgs = {
  input: UpdateOrderCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderEntryByNodeIdArgs = {
  input: UpdateOrderEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderEntryArgs = {
  input: UpdateOrderEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderEntryItemByNodeIdArgs = {
  input: UpdateOrderEntryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderEntryItemArgs = {
  input: UpdateOrderEntryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderEntryReviewItemByNodeIdArgs = {
  input: UpdateOrderEntryReviewItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderEntryReviewItemArgs = {
  input: UpdateOrderEntryReviewItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderItemByNodeIdArgs = {
  input: UpdateOrderItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderItemArgs = {
  input: UpdateOrderItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderMasterByNodeIdArgs = {
  input: UpdateOrderMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderMasterArgs = {
  input: UpdateOrderMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderPalletByNodeIdArgs = {
  input: UpdateOrderPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrderPalletArgs = {
  input: UpdateOrderPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackHeaderByNodeIdArgs = {
  input: UpdateRepackHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackHeaderArgs = {
  input: UpdateRepackHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackItemByNodeIdArgs = {
  input: UpdateRepackItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackItemArgs = {
  input: UpdateRepackItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackQueueByNodeIdArgs = {
  input: UpdateRepackQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRepackQueueArgs = {
  input: UpdateRepackQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTruckLoadByNodeIdArgs = {
  input: UpdateTruckLoadByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTruckLoadArgs = {
  input: UpdateTruckLoadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTruckRateByNodeIdArgs = {
  input: UpdateTruckRateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTruckRateArgs = {
  input: UpdateTruckRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTruckRateCustomerByNodeIdArgs = {
  input: UpdateTruckRateCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTruckRateCustomerArgs = {
  input: UpdateTruckRateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCheckHeaderByNodeIdArgs = {
  input: UpdateCheckHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCheckHeaderArgs = {
  input: UpdateCheckHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerPaymentByNodeIdArgs = {
  input: UpdateCustomerPaymentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerPaymentArgs = {
  input: UpdateCustomerPaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseHeaderByNodeIdArgs = {
  input: UpdateExpenseHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseHeaderArgs = {
  input: UpdateExpenseHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseHeaderReviewByNodeIdArgs = {
  input: UpdateExpenseHeaderReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseHeaderReviewArgs = {
  input: UpdateExpenseHeaderReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseItemByNodeIdArgs = {
  input: UpdateExpenseItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseItemArgs = {
  input: UpdateExpenseItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceHeaderByNodeIdArgs = {
  input: UpdateInvoiceHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceHeaderArgs = {
  input: UpdateInvoiceHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceItemByNodeIdArgs = {
  input: UpdateInvoiceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceItemArgs = {
  input: UpdateInvoiceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceItemHistoryByNodeIdArgs = {
  input: UpdateInvoiceItemHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceItemHistoryArgs = {
  input: UpdateInvoiceItemHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUnpaidByNodeIdArgs = {
  input: UpdateUnpaidByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUnpaidArgs = {
  input: UpdateUnpaidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVesselControlByNodeIdArgs = {
  input: UpdateVesselControlByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVesselControlArgs = {
  input: UpdateVesselControlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestByNodeIdArgs = {
  input: UpdateWireRequestByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestArgs = {
  input: UpdateWireRequestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestAccountOfSaleItemByNodeIdArgs = {
  input: UpdateWireRequestAccountOfSaleItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestAccountOfSaleItemArgs = {
  input: UpdateWireRequestAccountOfSaleItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestMiscItemByNodeIdArgs = {
  input: UpdateWireRequestMiscItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestMiscItemArgs = {
  input: UpdateWireRequestMiscItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestOceanFreightItemByNodeIdArgs = {
  input: UpdateWireRequestOceanFreightItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestOceanFreightItemArgs = {
  input: UpdateWireRequestOceanFreightItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestShipperAdvanceItemByNodeIdArgs = {
  input: UpdateWireRequestShipperAdvanceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWireRequestShipperAdvanceItemArgs = {
  input: UpdateWireRequestShipperAdvanceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderNumberByNodeIdArgs = {
  input: DeleteOrderNumberByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderNumberArgs = {
  input: DeleteOrderNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByPinArgs = {
  input: DeleteUserByPinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserBookmarkByNodeIdArgs = {
  input: DeleteUserBookmarkByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserBookmarkArgs = {
  input: DeleteUserBookmarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserMessageByNodeIdArgs = {
  input: DeleteUserMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserMessageArgs = {
  input: DeleteUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserRoleByUserIdAndRoleNameArgs = {
  input: DeleteUserRoleByUserIdAndRoleNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupByNodeIdArgs = {
  input: DeleteContactGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupArgs = {
  input: DeleteContactGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupPersonContactByNodeIdArgs = {
  input: DeleteContactGroupPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContactGroupPersonContactArgs = {
  input: DeleteContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCountryByNodeIdArgs = {
  input: DeleteCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCountryArgs = {
  input: DeleteCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerByNodeIdArgs = {
  input: DeleteCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerArgs = {
  input: DeleteCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerPersonContactByNodeIdArgs = {
  input: DeleteCustomerPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerPersonContactArgs = {
  input: DeleteCustomerPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerVolumeDiscountByNodeIdArgs = {
  input: DeleteCustomerVolumeDiscountByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerVolumeDiscountArgs = {
  input: DeleteCustomerVolumeDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonContactByNodeIdArgs = {
  input: DeletePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersonContactArgs = {
  input: DeletePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperByNodeIdArgs = {
  input: DeleteShipperByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperArgs = {
  input: DeleteShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperAdvanceByNodeIdArgs = {
  input: DeleteShipperAdvanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperAdvanceArgs = {
  input: DeleteShipperAdvanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperPersonContactByNodeIdArgs = {
  input: DeleteShipperPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperPersonContactArgs = {
  input: DeleteShipperPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVendorByNodeIdArgs = {
  input: DeleteVendorByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVendorArgs = {
  input: DeleteVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVendorPersonContactByNodeIdArgs = {
  input: DeleteVendorPersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVendorPersonContactArgs = {
  input: DeleteVendorPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehouseByNodeIdArgs = {
  input: DeleteWarehouseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehouseArgs = {
  input: DeleteWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehousePersonContactByNodeIdArgs = {
  input: DeleteWarehousePersonContactByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWarehousePersonContactArgs = {
  input: DeleteWarehousePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChileDepartureInspectionPalletByNodeIdArgs = {
  input: DeleteChileDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChileDepartureInspectionPalletArgs = {
  input: DeleteChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionByNodeIdArgs = {
  input: DeletePeruDepartureInspectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionArgs = {
  input: DeletePeruDepartureInspectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionPalletByNodeIdArgs = {
  input: DeletePeruDepartureInspectionPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePeruDepartureInspectionPalletArgs = {
  input: DeletePeruDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaApplePalletByNodeIdArgs = {
  input: DeletePsaApplePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaApplePalletArgs = {
  input: DeletePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalPictureByNodeIdArgs = {
  input: DeletePsaArrivalPictureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalPictureArgs = {
  input: DeletePsaArrivalPictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalReportByNodeIdArgs = {
  input: DeletePsaArrivalReportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaArrivalReportArgs = {
  input: DeletePsaArrivalReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCherryPalletByNodeIdArgs = {
  input: DeletePsaCherryPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCherryPalletArgs = {
  input: DeletePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCitrusPalletByNodeIdArgs = {
  input: DeletePsaCitrusPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaCitrusPalletArgs = {
  input: DeletePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaGrapePalletByNodeIdArgs = {
  input: DeletePsaGrapePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaGrapePalletArgs = {
  input: DeletePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaLemonPalletByNodeIdArgs = {
  input: DeletePsaLemonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaLemonPalletArgs = {
  input: DeletePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPearPalletByNodeIdArgs = {
  input: DeletePsaPearPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPearPalletArgs = {
  input: DeletePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPersimmonPalletByNodeIdArgs = {
  input: DeletePsaPersimmonPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPersimmonPalletArgs = {
  input: DeletePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPomegranatePalletByNodeIdArgs = {
  input: DeletePsaPomegranatePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaPomegranatePalletArgs = {
  input: DeletePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaStoneFruitPalletByNodeIdArgs = {
  input: DeletePsaStoneFruitPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePsaStoneFruitPalletArgs = {
  input: DeletePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonCategoryByNodeIdArgs = {
  input: DeleteCommonCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonCategoryArgs = {
  input: DeleteCommonCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonPackTypeByNodeIdArgs = {
  input: DeleteCommonPackTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonPackTypeArgs = {
  input: DeleteCommonPackTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonPackTypePackMasterByNodeIdArgs = {
  input: DeleteCommonPackTypePackMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonPackTypePackMasterArgs = {
  input: DeleteCommonPackTypePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonPackTypeTagByNodeIdArgs = {
  input: DeleteCommonPackTypeTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonPackTypeTagArgs = {
  input: DeleteCommonPackTypeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSizeByNodeIdArgs = {
  input: DeleteCommonSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSizeArgs = {
  input: DeleteCommonSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSizeProductSizeByNodeIdArgs = {
  input: DeleteCommonSizeProductSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSizeProductSizeArgs = {
  input: DeleteCommonSizeProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSizeTagByNodeIdArgs = {
  input: DeleteCommonSizeTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSizeTagArgs = {
  input: DeleteCommonSizeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSpeciesByNodeIdArgs = {
  input: DeleteCommonSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSpeciesArgs = {
  input: DeleteCommonSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSpeciesProductSpeciesByNodeIdArgs = {
  input: DeleteCommonSpeciesProductSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSpeciesProductSpeciesArgs = {
  input: DeleteCommonSpeciesProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSpeciesTagByNodeIdArgs = {
  input: DeleteCommonSpeciesTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonSpeciesTagArgs = {
  input: DeleteCommonSpeciesTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonVarietyByNodeIdArgs = {
  input: DeleteCommonVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonVarietyArgs = {
  input: DeleteCommonVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonVarietyProductVarietyByNodeIdArgs = {
  input: DeleteCommonVarietyProductVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonVarietyProductVarietyArgs = {
  input: DeleteCommonVarietyProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonVarietyTagByNodeIdArgs = {
  input: DeleteCommonVarietyTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCommonVarietyTagArgs = {
  input: DeleteCommonVarietyTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContainerByNodeIdArgs = {
  input: DeleteContainerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContainerArgs = {
  input: DeleteContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContainerTreatmentByNodeIdArgs = {
  input: DeleteContainerTreatmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteContainerTreatmentArgs = {
  input: DeleteContainerTreatmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerProgramByNodeIdArgs = {
  input: DeleteCustomerProgramByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerProgramArgs = {
  input: DeleteCustomerProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerProgramEntryByNodeIdArgs = {
  input: DeleteCustomerProgramEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerProgramEntryArgs = {
  input: DeleteCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInventoryItemByNodeIdArgs = {
  input: DeleteInventoryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInventoryItemArgs = {
  input: DeleteInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackAtmosphereByNodeIdArgs = {
  input: DeletePackAtmosphereByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackAtmosphereArgs = {
  input: DeletePackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackAtmosphereByShipperIdAndMaCodeArgs = {
  input: DeletePackAtmosphereByShipperIdAndMaCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxStyleByNodeIdArgs = {
  input: DeletePackBoxStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxStyleArgs = {
  input: DeletePackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxStyleByShipperIdAndBoxStyleArgs = {
  input: DeletePackBoxStyleByShipperIdAndBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxTypeByNodeIdArgs = {
  input: DeletePackBoxTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxTypeArgs = {
  input: DeletePackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackBoxTypeByShipperIdAndBoxTypeArgs = {
  input: DeletePackBoxTypeByShipperIdAndBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackDestinationByNodeIdArgs = {
  input: DeletePackDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackDestinationArgs = {
  input: DeletePackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackDestinationByShipperIdAndDestinationCodeArgs = {
  input: DeletePackDestinationByShipperIdAndDestinationCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackGradeByNodeIdArgs = {
  input: DeletePackGradeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackGradeArgs = {
  input: DeletePackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackGradeByShipperIdAndGradeCodeArgs = {
  input: DeletePackGradeByShipperIdAndGradeCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackHoldByNodeIdArgs = {
  input: DeletePackHoldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackHoldArgs = {
  input: DeletePackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackHoldByShipperIdAndHoldCodeArgs = {
  input: DeletePackHoldByShipperIdAndHoldCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLabelByNodeIdArgs = {
  input: DeletePackLabelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLabelArgs = {
  input: DeletePackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLabelByShipperIdAndLabelCodeArgs = {
  input: DeletePackLabelByShipperIdAndLabelCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLinerByNodeIdArgs = {
  input: DeletePackLinerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLinerArgs = {
  input: DeletePackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackLinerByShipperIdAndLinerCodeArgs = {
  input: DeletePackLinerByShipperIdAndLinerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackMasterByNodeIdArgs = {
  input: DeletePackMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackMasterArgs = {
  input: DeletePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackOutByNodeIdArgs = {
  input: DeletePackOutByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackOutArgs = {
  input: DeletePackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackOutByShipperIdAndOutCodeArgs = {
  input: DeletePackOutByShipperIdAndOutCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackPalletTypeByNodeIdArgs = {
  input: DeletePackPalletTypeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackPalletTypeArgs = {
  input: DeletePackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackPalletTypeByShipperIdAndPalletTypeArgs = {
  input: DeletePackPalletTypeByShipperIdAndPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackProductionByNodeIdArgs = {
  input: DeletePackProductionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackProductionArgs = {
  input: DeletePackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackProductionByShipperIdAndProductionCodeArgs = {
  input: DeletePackProductionByShipperIdAndProductionCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackSpecialByNodeIdArgs = {
  input: DeletePackSpecialByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackSpecialArgs = {
  input: DeletePackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackSpecialByShipperIdAndCustomerCodeArgs = {
  input: DeletePackSpecialByShipperIdAndCustomerCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackStyleByNodeIdArgs = {
  input: DeletePackStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackStyleArgs = {
  input: DeletePackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackStyleByShipperIdAndPackStyleArgs = {
  input: DeletePackStyleByShipperIdAndPackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackTreeRipeByNodeIdArgs = {
  input: DeletePackTreeRipeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackTreeRipeArgs = {
  input: DeletePackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePackTreeRipeByShipperIdAndTreeRipeArgs = {
  input: DeletePackTreeRipeByShipperIdAndTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletByNodeIdArgs = {
  input: DeletePalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletArgs = {
  input: DeletePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletSectionByNodeIdArgs = {
  input: DeletePalletSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePalletSectionArgs = {
  input: DeletePalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductMasterByNodeIdArgs = {
  input: DeleteProductMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductMasterArgs = {
  input: DeleteProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSizeByNodeIdArgs = {
  input: DeleteProductSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSizeArgs = {
  input: DeleteProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSpeciesByNodeIdArgs = {
  input: DeleteProductSpeciesByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductSpeciesArgs = {
  input: DeleteProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductVarietyByNodeIdArgs = {
  input: DeleteProductVarietyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductVarietyArgs = {
  input: DeleteProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackStyleByNodeIdArgs = {
  input: DeleteRepackStyleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackStyleArgs = {
  input: DeleteRepackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProgramByNodeIdArgs = {
  input: DeleteShipperProgramByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProgramArgs = {
  input: DeleteShipperProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProgramEntryByNodeIdArgs = {
  input: DeleteShipperProgramEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProgramEntryArgs = {
  input: DeleteShipperProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProgramEntryCustomerProgramEntryByNodeIdArgs = {
  input: DeleteShipperProgramEntryCustomerProgramEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProgramEntryCustomerProgramEntryArgs = {
  input: DeleteShipperProgramEntryCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionByNodeIdArgs = {
  input: DeleteShipperProjectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionArgs = {
  input: DeleteShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionEntryByNodeIdArgs = {
  input: DeleteShipperProjectionEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionEntryArgs = {
  input: DeleteShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionProductByNodeIdArgs = {
  input: DeleteShipperProjectionProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionProductArgs = {
  input: DeleteShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionVesselByNodeIdArgs = {
  input: DeleteShipperProjectionVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionVesselArgs = {
  input: DeleteShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionVesselInfoByNodeIdArgs = {
  input: DeleteShipperProjectionVesselInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteShipperProjectionVesselInfoArgs = {
  input: DeleteShipperProjectionVesselInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVesselByNodeIdArgs = {
  input: DeleteVesselByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVesselArgs = {
  input: DeleteVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgendaItemByNodeIdArgs = {
  input: DeleteAgendaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgendaItemArgs = {
  input: DeleteAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCalendarEventByNodeIdArgs = {
  input: DeleteCalendarEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCalendarEventArgs = {
  input: DeleteCalendarEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceCategoryByNodeIdArgs = {
  input: DeletePriceCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceCategoryArgs = {
  input: DeletePriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceEntryByNodeIdArgs = {
  input: DeletePriceEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceEntryArgs = {
  input: DeletePriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceProductByNodeIdArgs = {
  input: DeletePriceProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceProductArgs = {
  input: DeletePriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceSizeByNodeIdArgs = {
  input: DeletePriceSizeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceSizeArgs = {
  input: DeletePriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLoadNumberByNodeIdArgs = {
  input: DeleteLoadNumberByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLoadNumberArgs = {
  input: DeleteLoadNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderCommentByNodeIdArgs = {
  input: DeleteOrderCommentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderCommentArgs = {
  input: DeleteOrderCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderEntryByNodeIdArgs = {
  input: DeleteOrderEntryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderEntryArgs = {
  input: DeleteOrderEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderEntryItemByNodeIdArgs = {
  input: DeleteOrderEntryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderEntryItemArgs = {
  input: DeleteOrderEntryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderEntryReviewItemByNodeIdArgs = {
  input: DeleteOrderEntryReviewItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderEntryReviewItemArgs = {
  input: DeleteOrderEntryReviewItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderItemByNodeIdArgs = {
  input: DeleteOrderItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderItemArgs = {
  input: DeleteOrderItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderMasterByNodeIdArgs = {
  input: DeleteOrderMasterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderMasterArgs = {
  input: DeleteOrderMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderPalletByNodeIdArgs = {
  input: DeleteOrderPalletByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrderPalletArgs = {
  input: DeleteOrderPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackHeaderByNodeIdArgs = {
  input: DeleteRepackHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackHeaderArgs = {
  input: DeleteRepackHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackItemByNodeIdArgs = {
  input: DeleteRepackItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackItemArgs = {
  input: DeleteRepackItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackQueueByNodeIdArgs = {
  input: DeleteRepackQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRepackQueueArgs = {
  input: DeleteRepackQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTruckLoadByNodeIdArgs = {
  input: DeleteTruckLoadByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTruckLoadArgs = {
  input: DeleteTruckLoadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTruckRateByNodeIdArgs = {
  input: DeleteTruckRateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTruckRateArgs = {
  input: DeleteTruckRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTruckRateCustomerByNodeIdArgs = {
  input: DeleteTruckRateCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTruckRateCustomerArgs = {
  input: DeleteTruckRateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCheckHeaderByNodeIdArgs = {
  input: DeleteCheckHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCheckHeaderArgs = {
  input: DeleteCheckHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerPaymentByNodeIdArgs = {
  input: DeleteCustomerPaymentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerPaymentArgs = {
  input: DeleteCustomerPaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseHeaderByNodeIdArgs = {
  input: DeleteExpenseHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseHeaderArgs = {
  input: DeleteExpenseHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseHeaderReviewByNodeIdArgs = {
  input: DeleteExpenseHeaderReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseHeaderReviewArgs = {
  input: DeleteExpenseHeaderReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseItemByNodeIdArgs = {
  input: DeleteExpenseItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseItemArgs = {
  input: DeleteExpenseItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceHeaderByNodeIdArgs = {
  input: DeleteInvoiceHeaderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceHeaderArgs = {
  input: DeleteInvoiceHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceItemByNodeIdArgs = {
  input: DeleteInvoiceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceItemArgs = {
  input: DeleteInvoiceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceItemHistoryByNodeIdArgs = {
  input: DeleteInvoiceItemHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceItemHistoryArgs = {
  input: DeleteInvoiceItemHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUnpaidByNodeIdArgs = {
  input: DeleteUnpaidByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUnpaidArgs = {
  input: DeleteUnpaidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVesselControlByNodeIdArgs = {
  input: DeleteVesselControlByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVesselControlArgs = {
  input: DeleteVesselControlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestByNodeIdArgs = {
  input: DeleteWireRequestByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestArgs = {
  input: DeleteWireRequestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestAccountOfSaleItemByNodeIdArgs = {
  input: DeleteWireRequestAccountOfSaleItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestAccountOfSaleItemArgs = {
  input: DeleteWireRequestAccountOfSaleItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestMiscItemByNodeIdArgs = {
  input: DeleteWireRequestMiscItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestMiscItemArgs = {
  input: DeleteWireRequestMiscItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestOceanFreightItemByNodeIdArgs = {
  input: DeleteWireRequestOceanFreightItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestOceanFreightItemArgs = {
  input: DeleteWireRequestOceanFreightItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestShipperAdvanceItemByNodeIdArgs = {
  input: DeleteWireRequestShipperAdvanceItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWireRequestShipperAdvanceItemArgs = {
  input: DeleteWireRequestShipperAdvanceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkCreateUserMessageArgs = {
  input: BulkCreateUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertUserBookmarkArgs = {
  input: BulkUpsertUserBookmarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkAddContactsToGroupArgs = {
  input: BulkAddContactsToGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteCountryArgs = {
  input: BulkDeleteCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteCustomerArgs = {
  input: BulkDeleteCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteCustomerVolumeDiscountArgs = {
  input: BulkDeleteCustomerVolumeDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteShipperArgs = {
  input: BulkDeleteShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteVendorArgs = {
  input: BulkDeleteVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteWarehouseArgs = {
  input: BulkDeleteWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkRemoveContactGroupPersonContactArgs = {
  input: BulkRemoveContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertCountryArgs = {
  input: BulkUpsertCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertCustomerArgs = {
  input: BulkUpsertCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertCustomerVolumeDiscountArgs = {
  input: BulkUpsertCustomerVolumeDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperArgs = {
  input: BulkUpsertShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertUnpaidArgs = {
  input: BulkUpsertUnpaidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertVendorArgs = {
  input: BulkUpsertVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertVesselControlArgs = {
  input: BulkUpsertVesselControlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertWarehouseArgs = {
  input: BulkUpsertWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreateChileDepartureInspectionPalletArgs = {
  input: BatchCreateChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaApplePalletArgs = {
  input: BatchCreatePsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaCherryPalletArgs = {
  input: BatchCreatePsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaCitrusPalletArgs = {
  input: BatchCreatePsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaGrapePalletArgs = {
  input: BatchCreatePsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaLemonPalletArgs = {
  input: BatchCreatePsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaPearPalletArgs = {
  input: BatchCreatePsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaPersimmonPalletArgs = {
  input: BatchCreatePsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaPomegranatePalletArgs = {
  input: BatchCreatePsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBatchCreatePsaStoneFruitPalletArgs = {
  input: BatchCreatePsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteActiveInventoryItemArgs = {
  input: BulkDeleteActiveInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteCustomerProgramArgs = {
  input: BulkDeleteCustomerProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteInventoryItemArgs = {
  input: BulkDeleteInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeletePackMasterArgs = {
  input: BulkDeletePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeletePalletArgs = {
  input: BulkDeletePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeletePalletSectionArgs = {
  input: BulkDeletePalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteProductMasterArgs = {
  input: BulkDeleteProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteProductSizeArgs = {
  input: BulkDeleteProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteProductSpeciesArgs = {
  input: BulkDeleteProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteProductVarietyArgs = {
  input: BulkDeleteProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteRepackStyleArgs = {
  input: BulkDeleteRepackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteShipperProgramArgs = {
  input: BulkDeleteShipperProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteShipperProgramEntryCustomerProgramEntryArgs = {
  input: BulkDeleteShipperProgramEntryCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteShipperProjectionEntryArgs = {
  input: BulkDeleteShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteVesselArgs = {
  input: BulkDeleteVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertContainerArgs = {
  input: BulkUpsertContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertCustomerProgramArgs = {
  input: BulkUpsertCustomerProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertCustomerProgramEntryArgs = {
  input: BulkUpsertCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertInventoryItemArgs = {
  input: BulkUpsertInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackAtmosphereArgs = {
  input: BulkUpsertPackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackBoxStyleArgs = {
  input: BulkUpsertPackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackBoxTypeArgs = {
  input: BulkUpsertPackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackDestinationArgs = {
  input: BulkUpsertPackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackGradeArgs = {
  input: BulkUpsertPackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackHoldArgs = {
  input: BulkUpsertPackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackLabelArgs = {
  input: BulkUpsertPackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackLinerArgs = {
  input: BulkUpsertPackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackMasterArgs = {
  input: BulkUpsertPackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackOutArgs = {
  input: BulkUpsertPackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackPalletTypeArgs = {
  input: BulkUpsertPackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackProductionArgs = {
  input: BulkUpsertPackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackSpecialArgs = {
  input: BulkUpsertPackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackStyleArgs = {
  input: BulkUpsertPackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPackTreeRipeArgs = {
  input: BulkUpsertPackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPalletArgs = {
  input: BulkUpsertPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPalletSectionArgs = {
  input: BulkUpsertPalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertProductMasterArgs = {
  input: BulkUpsertProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertProductSizeArgs = {
  input: BulkUpsertProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertProductSpeciesArgs = {
  input: BulkUpsertProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertProductVarietyArgs = {
  input: BulkUpsertProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertRepackStyleArgs = {
  input: BulkUpsertRepackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProgramArgs = {
  input: BulkUpsertShipperProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProgramEntryArgs = {
  input: BulkUpsertShipperProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProgramEntryCustomerProgramEntryArgs = {
  input: BulkUpsertShipperProgramEntryCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProjectionProductArgs = {
  input: BulkUpsertShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertShipperProjectionVesselArgs = {
  input: BulkUpsertShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertVesselArgs = {
  input: BulkUpsertVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationGenerateNewContainersArgs = {
  input: GenerateNewContainersInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertAgendaItemArgs = {
  input: BulkUpsertAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceCategoryArgs = {
  input: BulkUpsertPriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceEntryArgs = {
  input: BulkUpsertPriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceProductArgs = {
  input: BulkUpsertPriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertPriceSizeArgs = {
  input: BulkUpsertPriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceCategoryEntriesArgs = {
  input: DeletePriceCategoryEntriesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceProductEntriesArgs = {
  input: DeletePriceProductEntriesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePriceSizeEntriesArgs = {
  input: DeletePriceSizeEntriesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteOrderCommentArgs = {
  input: BulkDeleteOrderCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteOrderItemArgs = {
  input: BulkDeleteOrderItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteOrderMasterArgs = {
  input: BulkDeleteOrderMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteOrderPalletArgs = {
  input: BulkDeleteOrderPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteRepackHeaderArgs = {
  input: BulkDeleteRepackHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteRepackItemArgs = {
  input: BulkDeleteRepackItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteRepackQueueArgs = {
  input: BulkDeleteRepackQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteTruckLoadArgs = {
  input: BulkDeleteTruckLoadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertLoadNumberArgs = {
  input: BulkUpsertLoadNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertOrderCommentArgs = {
  input: BulkUpsertOrderCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertOrderItemArgs = {
  input: BulkUpsertOrderItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertOrderMasterArgs = {
  input: BulkUpsertOrderMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertOrderPalletArgs = {
  input: BulkUpsertOrderPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertRepackHeaderArgs = {
  input: BulkUpsertRepackHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertRepackItemArgs = {
  input: BulkUpsertRepackItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertRepackQueueArgs = {
  input: BulkUpsertRepackQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertTruckLoadArgs = {
  input: BulkUpsertTruckLoadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteCheckHeaderArgs = {
  input: BulkDeleteCheckHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteCustomerPaymentArgs = {
  input: BulkDeleteCustomerPaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteExpenseHeaderArgs = {
  input: BulkDeleteExpenseHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteExpenseItemArgs = {
  input: BulkDeleteExpenseItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteInvoiceHeaderArgs = {
  input: BulkDeleteInvoiceHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteInvoiceItemArgs = {
  input: BulkDeleteInvoiceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteInvoiceItemHistoryArgs = {
  input: BulkDeleteInvoiceItemHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertCheckHeaderArgs = {
  input: BulkUpsertCheckHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertCustomerPaymentArgs = {
  input: BulkUpsertCustomerPaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertExpenseHeaderArgs = {
  input: BulkUpsertExpenseHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertExpenseHeaderReviewArgs = {
  input: BulkUpsertExpenseHeaderReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertExpenseItemArgs = {
  input: BulkUpsertExpenseItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertInvoiceHeaderArgs = {
  input: BulkUpsertInvoiceHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertInvoiceItemArgs = {
  input: BulkUpsertInvoiceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpsertInvoiceItemHistoryArgs = {
  input: BulkUpsertInvoiceItemHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderNumberArgs = {
  input: UpsertOrderNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserArgs = {
  input: UpsertUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserBookmarkArgs = {
  input: UpsertUserBookmarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserMessageArgs = {
  input: UpsertUserMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserRoleArgs = {
  input: UpsertUserRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertContactGroupArgs = {
  input: UpsertContactGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertContactGroupPersonContactArgs = {
  input: UpsertContactGroupPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCountryArgs = {
  input: UpsertCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCustomerArgs = {
  input: UpsertCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCustomerPersonContactArgs = {
  input: UpsertCustomerPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCustomerVolumeDiscountArgs = {
  input: UpsertCustomerVolumeDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPersonContactArgs = {
  input: UpsertPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperArgs = {
  input: UpsertShipperInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperAdvanceArgs = {
  input: UpsertShipperAdvanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperPersonContactArgs = {
  input: UpsertShipperPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertVendorArgs = {
  input: UpsertVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertVendorPersonContactArgs = {
  input: UpsertVendorPersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWarehouseArgs = {
  input: UpsertWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWarehousePersonContactArgs = {
  input: UpsertWarehousePersonContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertChileDepartureInspectionPalletArgs = {
  input: UpsertChileDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPeruDepartureInspectionArgs = {
  input: UpsertPeruDepartureInspectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPeruDepartureInspectionPalletArgs = {
  input: UpsertPeruDepartureInspectionPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaApplePalletArgs = {
  input: UpsertPsaApplePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaArrivalPictureArgs = {
  input: UpsertPsaArrivalPictureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaArrivalReportArgs = {
  input: UpsertPsaArrivalReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaCherryPalletArgs = {
  input: UpsertPsaCherryPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaCitrusPalletArgs = {
  input: UpsertPsaCitrusPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaGrapePalletArgs = {
  input: UpsertPsaGrapePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaLemonPalletArgs = {
  input: UpsertPsaLemonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaPearPalletArgs = {
  input: UpsertPsaPearPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaPersimmonPalletArgs = {
  input: UpsertPsaPersimmonPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaPomegranatePalletArgs = {
  input: UpsertPsaPomegranatePalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPsaStoneFruitPalletArgs = {
  input: UpsertPsaStoneFruitPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonCategoryArgs = {
  input: UpsertCommonCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonPackTypeArgs = {
  input: UpsertCommonPackTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonPackTypePackMasterArgs = {
  input: UpsertCommonPackTypePackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonPackTypeTagArgs = {
  input: UpsertCommonPackTypeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonSizeArgs = {
  input: UpsertCommonSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonSizeProductSizeArgs = {
  input: UpsertCommonSizeProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonSizeTagArgs = {
  input: UpsertCommonSizeTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonSpeciesArgs = {
  input: UpsertCommonSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonSpeciesProductSpeciesArgs = {
  input: UpsertCommonSpeciesProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonSpeciesTagArgs = {
  input: UpsertCommonSpeciesTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonVarietyArgs = {
  input: UpsertCommonVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonVarietyProductVarietyArgs = {
  input: UpsertCommonVarietyProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCommonVarietyTagArgs = {
  input: UpsertCommonVarietyTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertContainerArgs = {
  input: UpsertContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertContainerTreatmentArgs = {
  input: UpsertContainerTreatmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCustomerProgramArgs = {
  input: UpsertCustomerProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCustomerProgramEntryArgs = {
  input: UpsertCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertInventoryItemArgs = {
  input: UpsertInventoryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackAtmosphereArgs = {
  input: UpsertPackAtmosphereInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackBoxStyleArgs = {
  input: UpsertPackBoxStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackBoxTypeArgs = {
  input: UpsertPackBoxTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackDestinationArgs = {
  input: UpsertPackDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackGradeArgs = {
  input: UpsertPackGradeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackHoldArgs = {
  input: UpsertPackHoldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackLabelArgs = {
  input: UpsertPackLabelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackLinerArgs = {
  input: UpsertPackLinerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackMasterArgs = {
  input: UpsertPackMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackOutArgs = {
  input: UpsertPackOutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackPalletTypeArgs = {
  input: UpsertPackPalletTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackProductionArgs = {
  input: UpsertPackProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackSpecialArgs = {
  input: UpsertPackSpecialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackStyleArgs = {
  input: UpsertPackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPackTreeRipeArgs = {
  input: UpsertPackTreeRipeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPalletArgs = {
  input: UpsertPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPalletSectionArgs = {
  input: UpsertPalletSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertProductMasterArgs = {
  input: UpsertProductMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertProductSizeArgs = {
  input: UpsertProductSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertProductSpeciesArgs = {
  input: UpsertProductSpeciesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertProductVarietyArgs = {
  input: UpsertProductVarietyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRepackStyleArgs = {
  input: UpsertRepackStyleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProgramArgs = {
  input: UpsertShipperProgramInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProgramEntryArgs = {
  input: UpsertShipperProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProgramEntryCustomerProgramEntryArgs = {
  input: UpsertShipperProgramEntryCustomerProgramEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProjectionArgs = {
  input: UpsertShipperProjectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProjectionEntryArgs = {
  input: UpsertShipperProjectionEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProjectionProductArgs = {
  input: UpsertShipperProjectionProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProjectionVesselArgs = {
  input: UpsertShipperProjectionVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertShipperProjectionVesselInfoArgs = {
  input: UpsertShipperProjectionVesselInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertVesselArgs = {
  input: UpsertVesselInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertAgendaItemArgs = {
  input: UpsertAgendaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCalendarEventArgs = {
  input: UpsertCalendarEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPriceCategoryArgs = {
  input: UpsertPriceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPriceEntryArgs = {
  input: UpsertPriceEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPriceProductArgs = {
  input: UpsertPriceProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertPriceSizeArgs = {
  input: UpsertPriceSizeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertLoadNumberArgs = {
  input: UpsertLoadNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderCommentArgs = {
  input: UpsertOrderCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderEntryArgs = {
  input: UpsertOrderEntryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderEntryItemArgs = {
  input: UpsertOrderEntryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderEntryReviewItemArgs = {
  input: UpsertOrderEntryReviewItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderItemArgs = {
  input: UpsertOrderItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderMasterArgs = {
  input: UpsertOrderMasterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertOrderPalletArgs = {
  input: UpsertOrderPalletInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRepackHeaderArgs = {
  input: UpsertRepackHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRepackItemArgs = {
  input: UpsertRepackItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRepackQueueArgs = {
  input: UpsertRepackQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertTruckLoadArgs = {
  input: UpsertTruckLoadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertTruckRateArgs = {
  input: UpsertTruckRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertTruckRateCustomerArgs = {
  input: UpsertTruckRateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCheckHeaderArgs = {
  input: UpsertCheckHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCustomerPaymentArgs = {
  input: UpsertCustomerPaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertExpenseHeaderArgs = {
  input: UpsertExpenseHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertExpenseHeaderReviewArgs = {
  input: UpsertExpenseHeaderReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertExpenseItemArgs = {
  input: UpsertExpenseItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertInvoiceHeaderArgs = {
  input: UpsertInvoiceHeaderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertInvoiceItemArgs = {
  input: UpsertInvoiceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertInvoiceItemHistoryArgs = {
  input: UpsertInvoiceItemHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUnpaidArgs = {
  input: UpsertUnpaidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertVesselControlArgs = {
  input: UpsertVesselControlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWireRequestArgs = {
  input: UpsertWireRequestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWireRequestAccountOfSaleItemArgs = {
  input: UpsertWireRequestAccountOfSaleItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWireRequestMiscItemArgs = {
  input: UpsertWireRequestMiscItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWireRequestOceanFreightItemArgs = {
  input: UpsertWireRequestOceanFreightItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWireRequestShipperAdvanceItemArgs = {
  input: UpsertWireRequestShipperAdvanceItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationContainerScheduleUpdateNotifyArgs = {
  input?: Maybe<ContainerScheduleUpdateInput>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSendUnpaidsNotificationEmailsArgs = {
  input?: Maybe<UnpaidRemindersInput>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSendPriceSheetUpdateEmailArgs = {
  input?: Maybe<PriceSheetUpdateInput>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationReviewShipperProjectionArgs = {
  input?: Maybe<ReviewShipperProjectionInput>;
};

/** A `String` edge in the connection. */
export type NewRepackQueueEdge = {
  __typename?: 'NewRepackQueueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type NewRepackQueuesConnection = {
  __typename?: 'NewRepackQueuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<NewRepackQueueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type OrderComment = Node & {
  __typename?: 'OrderComment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  printCode?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `OrderComment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrderCommentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `lineId` field. */
  lineId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `printCode` field. */
  printCode?: Maybe<Scalars['String']>;
};

/** A filter to be used against `OrderComment` object types. All fields are combined with a logical ‘and.’ */
export type OrderCommentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `lineId` field. */
  lineId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `printCode` field. */
  printCode?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderCommentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderCommentFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderCommentFilter>;
};

/** An input for mutations affecting `OrderComment` */
export type OrderCommentInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  printCode?: Maybe<Scalars['String']>;
};

/** Represents an update to a `OrderComment`. Fields that are set will be updated. */
export type OrderCommentPatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  printCode?: Maybe<Scalars['String']>;
};

/** A connection to a list of `OrderComment` values. */
export type OrderCommentsConnection = {
  __typename?: 'OrderCommentsConnection';
  /** A list of `OrderComment` objects. */
  nodes: Array<Maybe<OrderComment>>;
  /** A list of edges which contains the `OrderComment` and cursor to aid in pagination. */
  edges: Array<OrderCommentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderComment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderComment` edge in the connection. */
export type OrderCommentsEdge = {
  __typename?: 'OrderCommentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderComment` at the end of the edge. */
  node?: Maybe<OrderComment>;
};

/** Methods to use when ordering `OrderComment`. */
export enum OrderCommentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  LineIdAsc = 'LINE_ID_ASC',
  LineIdDesc = 'LINE_ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrintCodeAsc = 'PRINT_CODE_ASC',
  PrintCodeDesc = 'PRINT_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `OrderEntry` values. */
export type OrderEntriesConnection = {
  __typename?: 'OrderEntriesConnection';
  /** A list of `OrderEntry` objects. */
  nodes: Array<Maybe<OrderEntry>>;
  /** A list of edges which contains the `OrderEntry` and cursor to aid in pagination. */
  edges: Array<OrderEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderEntry` edge in the connection. */
export type OrderEntriesEdge = {
  __typename?: 'OrderEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderEntry` at the end of the edge. */
  node?: Maybe<OrderEntry>;
};

/** Methods to use when ordering `OrderEntry`. */
export enum OrderEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  TruckLoadIdAsc = 'TRUCK_LOAD_ID_ASC',
  TruckLoadIdDesc = 'TRUCK_LOAD_ID_DESC',
  FobAsc = 'FOB_ASC',
  FobDesc = 'FOB_DESC',
  BillingCustomerIdAsc = 'BILLING_CUSTOMER_ID_ASC',
  BillingCustomerIdDesc = 'BILLING_CUSTOMER_ID_DESC',
  SalesUserCodeAsc = 'SALES_USER_CODE_ASC',
  SalesUserCodeDesc = 'SALES_USER_CODE_DESC',
  CustomerPoAsc = 'CUSTOMER_PO_ASC',
  CustomerPoDesc = 'CUSTOMER_PO_DESC',
  FobDateAsc = 'FOB_DATE_ASC',
  FobDateDesc = 'FOB_DATE_DESC',
  DeliveredDateAsc = 'DELIVERED_DATE_ASC',
  DeliveredDateDesc = 'DELIVERED_DATE_DESC',
  OrderDateAsc = 'ORDER_DATE_ASC',
  OrderDateDesc = 'ORDER_DATE_DESC',
  ReviewUserCodeAsc = 'REVIEW_USER_CODE_ASC',
  ReviewUserCodeDesc = 'REVIEW_USER_CODE_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  ReviewDateAsc = 'REVIEW_DATE_ASC',
  ReviewDateDesc = 'REVIEW_DATE_DESC',
  SubmittedByUserCodeAsc = 'SUBMITTED_BY_USER_CODE_ASC',
  SubmittedByUserCodeDesc = 'SUBMITTED_BY_USER_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  OrderEntryItemsByOrderEntryIdCountAsc = 'ORDER_ENTRY_ITEMS_BY_ORDER_ENTRY_ID__COUNT_ASC',
  OrderEntryItemsByOrderEntryIdCountDesc = 'ORDER_ENTRY_ITEMS_BY_ORDER_ENTRY_ID__COUNT_DESC'
}

export type OrderEntry = Node & {
  __typename?: 'OrderEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  fobDate?: Maybe<Scalars['Date']>;
  deliveredDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Datetime']>;
  reviewUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  reviewDate?: Maybe<Scalars['Datetime']>;
  submittedByUserCode?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `OrderEntryItem`. */
  orderEntryItems: OrderEntryItemsConnection;
  billingCustomer?: Maybe<Customer>;
  reviewUser?: Maybe<User>;
  salesUser?: Maybe<User>;
  searchText?: Maybe<Scalars['String']>;
  submittedByUser?: Maybe<User>;
};


export type OrderEntryOrderEntryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderEntryItemsOrderBy>>;
  condition?: Maybe<OrderEntryItemCondition>;
  filter?: Maybe<OrderEntryItemFilter>;
};

/**
 * A condition to be used against `OrderEntry` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OrderEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fob` field. */
  fob?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `billingCustomerId` field. */
  billingCustomerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerPo` field. */
  customerPo?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fobDate` field. */
  fobDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `deliveredDate` field. */
  deliveredDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `orderDate` field. */
  orderDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `reviewUserCode` field. */
  reviewUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `reviewDate` field. */
  reviewDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `submittedByUserCode` field. */
  submittedByUserCode?: Maybe<Scalars['String']>;
};

/** A filter to be used against `OrderEntry` object types. All fields are combined with a logical ‘and.’ */
export type OrderEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<StringFilter>;
  /** Filter by the object’s `fob` field. */
  fob?: Maybe<BooleanFilter>;
  /** Filter by the object’s `billingCustomerId` field. */
  billingCustomerId?: Maybe<StringFilter>;
  /** Filter by the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `customerPo` field. */
  customerPo?: Maybe<StringFilter>;
  /** Filter by the object’s `fobDate` field. */
  fobDate?: Maybe<DateFilter>;
  /** Filter by the object’s `deliveredDate` field. */
  deliveredDate?: Maybe<DateFilter>;
  /** Filter by the object’s `orderDate` field. */
  orderDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `reviewUserCode` field. */
  reviewUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `reviewDate` field. */
  reviewDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `submittedByUserCode` field. */
  submittedByUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `orderEntryItems` relation. */
  orderEntryItems?: Maybe<OrderEntryToManyOrderEntryItemFilter>;
  /** Some related `orderEntryItems` exist. */
  orderEntryItemsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderEntryFilter>;
};

/** An input for mutations affecting `OrderEntry` */
export type OrderEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  fobDate?: Maybe<Scalars['Date']>;
  deliveredDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Datetime']>;
  reviewUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  reviewDate?: Maybe<Scalars['Datetime']>;
  submittedByUserCode?: Maybe<Scalars['String']>;
  orderEntryItemsUsingId?: Maybe<OrderEntryItemOrderEntryIdFkeyInverseInput>;
};

export type OrderEntryItem = Node & {
  __typename?: 'OrderEntryItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  orderEntryId: Scalars['BigInt'];
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  /** Reads a single `OrderEntry` that is related to this `OrderEntryItem`. */
  orderEntry?: Maybe<OrderEntry>;
  /** Reads and enables pagination through a set of `OrderEntryReviewItem`. */
  orderEntryReviewItems: OrderEntryReviewItemsConnection;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
  warehouse?: Maybe<Warehouse>;
};


export type OrderEntryItemOrderEntryReviewItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderEntryReviewItemsOrderBy>>;
  condition?: Maybe<OrderEntryReviewItemCondition>;
  filter?: Maybe<OrderEntryReviewItemFilter>;
};

/**
 * A condition to be used against `OrderEntryItem` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrderEntryItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderEntryId` field. */
  orderEntryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `lineId` field. */
  lineId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `species` field. */
  species?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packType` field. */
  packType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxCount` field. */
  boxCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletWeight` field. */
  palletWeight?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `OrderEntryItem` object types. All fields are combined with a logical ‘and.’ */
export type OrderEntryItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orderEntryId` field. */
  orderEntryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `lineId` field. */
  lineId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `species` field. */
  species?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `packType` field. */
  packType?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `label` field. */
  label?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `boxCount` field. */
  boxCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletWeight` field. */
  palletWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `orderEntryReviewItems` relation. */
  orderEntryReviewItems?: Maybe<OrderEntryItemToManyOrderEntryReviewItemFilter>;
  /** Some related `orderEntryReviewItems` exist. */
  orderEntryReviewItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `orderEntry` relation. */
  orderEntry?: Maybe<OrderEntryFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderEntryItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderEntryItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderEntryItemFilter>;
};

/** An input for mutations affecting `OrderEntryItem` */
export type OrderEntryItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderEntryId?: Maybe<Scalars['BigInt']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryToOrderEntryId?: Maybe<OrderEntryItemOrderEntryIdFkeyInput>;
  orderEntryReviewItemsUsingId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OrderEntryItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `orderEntryItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrderEntryItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `orderEntryItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrderEntryItemOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `orderEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `orderEntry` being updated. */
  patch: OrderEntryPatch;
};

/** The fields on `orderEntryItem` to look up the row to update. */
export type OrderEntryItemOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyUsingOrderEntryItemPkeyUpdate = {
  /** An object where the defined keys will be set on the `orderEntryItem` being updated. */
  patch: UpdateOrderEntryItemOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrderEntryItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `orderEntryReviewItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `orderEntryReviewItem` being updated. */
  patch: OrderEntryReviewItemPatch;
};

/** The fields on `orderEntryItem` to look up the row to update. */
export type OrderEntryItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyUsingOrderEntryItemPkeyUpdate = {
  /** An object where the defined keys will be set on the `orderEntryItem` being updated. */
  patch: UpdateOrderEntryItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `orderEntry` in the `OrderEntryItemInput` mutation. */
export type OrderEntryItemOrderEntryIdFkeyInput = {
  /** The primary key(s) for `orderEntry` for the far side of the relationship. */
  connectById?: Maybe<OrderEntryOrderEntryPkeyConnect>;
  /** The primary key(s) for `orderEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<OrderEntryNodeIdConnect>;
  /** The primary key(s) for `orderEntry` for the far side of the relationship. */
  deleteById?: Maybe<OrderEntryOrderEntryPkeyDelete>;
  /** The primary key(s) for `orderEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<OrderEntryNodeIdDelete>;
  /** The primary key(s) and patch data for `orderEntry` for the far side of the relationship. */
  updateById?: Maybe<OrderEntryOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyUsingOrderEntryPkeyUpdate>;
  /** The primary key(s) and patch data for `orderEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<OrderEntryItemOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyNodeIdUpdate>;
  /** A `OrderEntryInput` object that will be created and connected to this object. */
  create?: Maybe<OrderEntryItemOrderEntryIdFkeyOrderEntryCreateInput>;
};

/** Input for the nested mutation of `orderEntryItem` in the `OrderEntryInput` mutation. */
export type OrderEntryItemOrderEntryIdFkeyInverseInput = {
  /** Flag indicating whether all other `orderEntryItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  connectById?: Maybe<Array<OrderEntryItemOrderEntryItemPkeyConnect>>;
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OrderEntryItemNodeIdConnect>>;
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<OrderEntryItemOrderEntryItemPkeyDelete>>;
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OrderEntryItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `orderEntryItem` for the far side of the relationship. */
  updateById?: Maybe<Array<OrderEntryItemOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyUsingOrderEntryItemPkeyUpdate>>;
  /** The primary key(s) and patch data for `orderEntryItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<OrderEntryOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyNodeIdUpdate>>;
  /** A `OrderEntryItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OrderEntryItemOrderEntryIdFkeyOrderEntryItemCreateInput>>;
};

/** The `orderEntry` to be created by this mutation. */
export type OrderEntryItemOrderEntryIdFkeyOrderEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  fobDate?: Maybe<Scalars['Date']>;
  deliveredDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Datetime']>;
  reviewUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  reviewDate?: Maybe<Scalars['Datetime']>;
  submittedByUserCode?: Maybe<Scalars['String']>;
  orderEntryItemsUsingId?: Maybe<OrderEntryItemOrderEntryIdFkeyInverseInput>;
};

/** The `orderEntryItem` to be created by this mutation. */
export type OrderEntryItemOrderEntryIdFkeyOrderEntryItemCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryToOrderEntryId?: Maybe<OrderEntryItemOrderEntryIdFkeyInput>;
  orderEntryReviewItemsUsingId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInverseInput>;
};

/** The fields on `orderEntryItem` to look up the row to connect. */
export type OrderEntryItemOrderEntryItemPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `orderEntryItem` to look up the row to delete. */
export type OrderEntryItemOrderEntryItemPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Represents an update to a `OrderEntryItem`. Fields that are set will be updated. */
export type OrderEntryItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderEntryId?: Maybe<Scalars['BigInt']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryToOrderEntryId?: Maybe<OrderEntryItemOrderEntryIdFkeyInput>;
  orderEntryReviewItemsUsingId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInverseInput>;
};

/** A filter to be used against many `OrderEntryReviewItem` object types. All fields are combined with a logical ‘and.’ */
export type OrderEntryItemToManyOrderEntryReviewItemFilter = {
  /** Every related `OrderEntryReviewItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<OrderEntryReviewItemFilter>;
  /** Some related `OrderEntryReviewItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<OrderEntryReviewItemFilter>;
  /** No related `OrderEntryReviewItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<OrderEntryReviewItemFilter>;
};

/** A connection to a list of `OrderEntryItem` values. */
export type OrderEntryItemsConnection = {
  __typename?: 'OrderEntryItemsConnection';
  /** A list of `OrderEntryItem` objects. */
  nodes: Array<Maybe<OrderEntryItem>>;
  /** A list of edges which contains the `OrderEntryItem` and cursor to aid in pagination. */
  edges: Array<OrderEntryItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderEntryItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderEntryItem` edge in the connection. */
export type OrderEntryItemsEdge = {
  __typename?: 'OrderEntryItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderEntryItem` at the end of the edge. */
  node?: Maybe<OrderEntryItem>;
};

/** Methods to use when ordering `OrderEntryItem`. */
export enum OrderEntryItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderEntryIdAsc = 'ORDER_ENTRY_ID_ASC',
  OrderEntryIdDesc = 'ORDER_ENTRY_ID_DESC',
  LineIdAsc = 'LINE_ID_ASC',
  LineIdDesc = 'LINE_ID_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  UnitSellPriceAsc = 'UNIT_SELL_PRICE_ASC',
  UnitSellPriceDesc = 'UNIT_SELL_PRICE_DESC',
  DeliveryChargeAsc = 'DELIVERY_CHARGE_ASC',
  DeliveryChargeDesc = 'DELIVERY_CHARGE_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  SpeciesAsc = 'SPECIES_ASC',
  SpeciesDesc = 'SPECIES_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  PackTypeAsc = 'PACK_TYPE_ASC',
  PackTypeDesc = 'PACK_TYPE_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  BoxCountAsc = 'BOX_COUNT_ASC',
  BoxCountDesc = 'BOX_COUNT_DESC',
  PalletWeightAsc = 'PALLET_WEIGHT_ASC',
  PalletWeightDesc = 'PALLET_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  OrderEntryByOrderEntryIdIdAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__ID_ASC',
  OrderEntryByOrderEntryIdIdDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__ID_DESC',
  OrderEntryByOrderEntryIdBackOrderIdAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__BACK_ORDER_ID_ASC',
  OrderEntryByOrderEntryIdBackOrderIdDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__BACK_ORDER_ID_DESC',
  OrderEntryByOrderEntryIdTruckLoadIdAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__TRUCK_LOAD_ID_ASC',
  OrderEntryByOrderEntryIdTruckLoadIdDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__TRUCK_LOAD_ID_DESC',
  OrderEntryByOrderEntryIdFobAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__FOB_ASC',
  OrderEntryByOrderEntryIdFobDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__FOB_DESC',
  OrderEntryByOrderEntryIdBillingCustomerIdAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__BILLING_CUSTOMER_ID_ASC',
  OrderEntryByOrderEntryIdBillingCustomerIdDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__BILLING_CUSTOMER_ID_DESC',
  OrderEntryByOrderEntryIdSalesUserCodeAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__SALES_USER_CODE_ASC',
  OrderEntryByOrderEntryIdSalesUserCodeDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__SALES_USER_CODE_DESC',
  OrderEntryByOrderEntryIdCustomerPoAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__CUSTOMER_PO_ASC',
  OrderEntryByOrderEntryIdCustomerPoDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__CUSTOMER_PO_DESC',
  OrderEntryByOrderEntryIdFobDateAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__FOB_DATE_ASC',
  OrderEntryByOrderEntryIdFobDateDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__FOB_DATE_DESC',
  OrderEntryByOrderEntryIdDeliveredDateAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__DELIVERED_DATE_ASC',
  OrderEntryByOrderEntryIdDeliveredDateDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__DELIVERED_DATE_DESC',
  OrderEntryByOrderEntryIdOrderDateAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__ORDER_DATE_ASC',
  OrderEntryByOrderEntryIdOrderDateDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__ORDER_DATE_DESC',
  OrderEntryByOrderEntryIdReviewUserCodeAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__REVIEW_USER_CODE_ASC',
  OrderEntryByOrderEntryIdReviewUserCodeDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__REVIEW_USER_CODE_DESC',
  OrderEntryByOrderEntryIdNotesAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__NOTES_ASC',
  OrderEntryByOrderEntryIdNotesDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__NOTES_DESC',
  OrderEntryByOrderEntryIdOrderIdAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__ORDER_ID_ASC',
  OrderEntryByOrderEntryIdOrderIdDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__ORDER_ID_DESC',
  OrderEntryByOrderEntryIdReviewDateAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__REVIEW_DATE_ASC',
  OrderEntryByOrderEntryIdReviewDateDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__REVIEW_DATE_DESC',
  OrderEntryByOrderEntryIdSubmittedByUserCodeAsc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__SUBMITTED_BY_USER_CODE_ASC',
  OrderEntryByOrderEntryIdSubmittedByUserCodeDesc = 'ORDER_ENTRY_BY_ORDER_ENTRY_ID__SUBMITTED_BY_USER_CODE_DESC',
  OrderEntryReviewItemsByOrderEntryItemIdCountAsc = 'ORDER_ENTRY_REVIEW_ITEMS_BY_ORDER_ENTRY_ITEM_ID__COUNT_ASC',
  OrderEntryReviewItemsByOrderEntryItemIdCountDesc = 'ORDER_ENTRY_REVIEW_ITEMS_BY_ORDER_ENTRY_ITEM_ID__COUNT_DESC'
}

/** The globally unique `ID` look up for the row to connect. */
export type OrderEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `orderEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrderEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `orderEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrderEntryOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `orderEntryItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `orderEntryItem` being updated. */
  patch: OrderEntryItemPatch;
};

/** The fields on `orderEntry` to look up the row to update. */
export type OrderEntryOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyUsingOrderEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `orderEntry` being updated. */
  patch: UpdateOrderEntryOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The fields on `orderEntry` to look up the row to connect. */
export type OrderEntryOrderEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `orderEntry` to look up the row to delete. */
export type OrderEntryOrderEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Represents an update to a `OrderEntry`. Fields that are set will be updated. */
export type OrderEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  fobDate?: Maybe<Scalars['Date']>;
  deliveredDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Datetime']>;
  reviewUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  reviewDate?: Maybe<Scalars['Datetime']>;
  submittedByUserCode?: Maybe<Scalars['String']>;
  orderEntryItemsUsingId?: Maybe<OrderEntryItemOrderEntryIdFkeyInverseInput>;
};

export type OrderEntryReviewItem = Node & {
  __typename?: 'OrderEntryReviewItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  orderEntryItemId: Scalars['BigInt'];
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  /** Reads a single `OrderEntryItem` that is related to this `OrderEntryReviewItem`. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
  warehouse?: Maybe<Warehouse>;
};

/**
 * A condition to be used against `OrderEntryReviewItem` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type OrderEntryReviewItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderEntryItemId` field. */
  orderEntryItemId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `species` field. */
  species?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packType` field. */
  packType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `label` field. */
  label?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxCount` field. */
  boxCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletWeight` field. */
  palletWeight?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `OrderEntryReviewItem` object types. All fields are combined with a logical ‘and.’ */
export type OrderEntryReviewItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orderEntryItemId` field. */
  orderEntryItemId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `species` field. */
  species?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `packType` field. */
  packType?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `label` field. */
  label?: Maybe<StringFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxCount` field. */
  boxCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletWeight` field. */
  palletWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `orderEntryItem` relation. */
  orderEntryItem?: Maybe<OrderEntryItemFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderEntryReviewItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderEntryReviewItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderEntryReviewItemFilter>;
};

/** An input for mutations affecting `OrderEntryReviewItem` */
export type OrderEntryReviewItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderEntryItemId?: Maybe<Scalars['BigInt']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryItemToOrderEntryItemId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OrderEntryReviewItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `orderEntryReviewItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrderEntryReviewItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `orderEntryReviewItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrderEntryReviewItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `orderEntryItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `orderEntryItem` being updated. */
  patch: OrderEntryItemPatch;
};

/** The fields on `orderEntryReviewItem` to look up the row to update. */
export type OrderEntryReviewItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyUsingOrderEntryReviewItemPkeyUpdate = {
  /** An object where the defined keys will be set on the `orderEntryReviewItem` being updated. */
  patch: UpdateOrderEntryReviewItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `orderEntryItem` in the `OrderEntryReviewItemInput` mutation. */
export type OrderEntryReviewItemOrderEntryItemIdFkeyInput = {
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  connectById?: Maybe<OrderEntryItemOrderEntryItemPkeyConnect>;
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<OrderEntryItemNodeIdConnect>;
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  deleteById?: Maybe<OrderEntryItemOrderEntryItemPkeyDelete>;
  /** The primary key(s) for `orderEntryItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<OrderEntryItemNodeIdDelete>;
  /** The primary key(s) and patch data for `orderEntryItem` for the far side of the relationship. */
  updateById?: Maybe<OrderEntryItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyUsingOrderEntryItemPkeyUpdate>;
  /** The primary key(s) and patch data for `orderEntryItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<OrderEntryReviewItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyNodeIdUpdate>;
  /** A `OrderEntryItemInput` object that will be created and connected to this object. */
  create?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyOrderEntryItemCreateInput>;
};

/** Input for the nested mutation of `orderEntryReviewItem` in the `OrderEntryItemInput` mutation. */
export type OrderEntryReviewItemOrderEntryItemIdFkeyInverseInput = {
  /** Flag indicating whether all other `orderEntryReviewItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `orderEntryReviewItem` for the far side of the relationship. */
  connectById?: Maybe<Array<OrderEntryReviewItemOrderEntryReviewItemPkeyConnect>>;
  /** The primary key(s) for `orderEntryReviewItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OrderEntryReviewItemNodeIdConnect>>;
  /** The primary key(s) for `orderEntryReviewItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<OrderEntryReviewItemOrderEntryReviewItemPkeyDelete>>;
  /** The primary key(s) for `orderEntryReviewItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OrderEntryReviewItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `orderEntryReviewItem` for the far side of the relationship. */
  updateById?: Maybe<Array<OrderEntryReviewItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyUsingOrderEntryReviewItemPkeyUpdate>>;
  /** The primary key(s) and patch data for `orderEntryReviewItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<OrderEntryItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyNodeIdUpdate>>;
  /** A `OrderEntryReviewItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OrderEntryReviewItemOrderEntryItemIdFkeyOrderEntryReviewItemCreateInput>>;
};

/** The `orderEntryItem` to be created by this mutation. */
export type OrderEntryReviewItemOrderEntryItemIdFkeyOrderEntryItemCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderEntryId?: Maybe<Scalars['BigInt']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryToOrderEntryId?: Maybe<OrderEntryItemOrderEntryIdFkeyInput>;
  orderEntryReviewItemsUsingId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInverseInput>;
};

/** The `orderEntryReviewItem` to be created by this mutation. */
export type OrderEntryReviewItemOrderEntryItemIdFkeyOrderEntryReviewItemCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryItemToOrderEntryItemId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInput>;
};

/** The fields on `orderEntryReviewItem` to look up the row to connect. */
export type OrderEntryReviewItemOrderEntryReviewItemPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `orderEntryReviewItem` to look up the row to delete. */
export type OrderEntryReviewItemOrderEntryReviewItemPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Represents an update to a `OrderEntryReviewItem`. Fields that are set will be updated. */
export type OrderEntryReviewItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderEntryItemId?: Maybe<Scalars['BigInt']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryItemToOrderEntryItemId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInput>;
};

/** A connection to a list of `OrderEntryReviewItem` values. */
export type OrderEntryReviewItemsConnection = {
  __typename?: 'OrderEntryReviewItemsConnection';
  /** A list of `OrderEntryReviewItem` objects. */
  nodes: Array<Maybe<OrderEntryReviewItem>>;
  /** A list of edges which contains the `OrderEntryReviewItem` and cursor to aid in pagination. */
  edges: Array<OrderEntryReviewItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderEntryReviewItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderEntryReviewItem` edge in the connection. */
export type OrderEntryReviewItemsEdge = {
  __typename?: 'OrderEntryReviewItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderEntryReviewItem` at the end of the edge. */
  node?: Maybe<OrderEntryReviewItem>;
};

/** Methods to use when ordering `OrderEntryReviewItem`. */
export enum OrderEntryReviewItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderEntryItemIdAsc = 'ORDER_ENTRY_ITEM_ID_ASC',
  OrderEntryItemIdDesc = 'ORDER_ENTRY_ITEM_ID_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  SpeciesAsc = 'SPECIES_ASC',
  SpeciesDesc = 'SPECIES_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  PackTypeAsc = 'PACK_TYPE_ASC',
  PackTypeDesc = 'PACK_TYPE_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  BoxCountAsc = 'BOX_COUNT_ASC',
  BoxCountDesc = 'BOX_COUNT_DESC',
  PalletWeightAsc = 'PALLET_WEIGHT_ASC',
  PalletWeightDesc = 'PALLET_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  OrderEntryItemByOrderEntryItemIdIdAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__ID_ASC',
  OrderEntryItemByOrderEntryItemIdIdDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__ID_DESC',
  OrderEntryItemByOrderEntryItemIdOrderEntryIdAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__ORDER_ENTRY_ID_ASC',
  OrderEntryItemByOrderEntryItemIdOrderEntryIdDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__ORDER_ENTRY_ID_DESC',
  OrderEntryItemByOrderEntryItemIdLineIdAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__LINE_ID_ASC',
  OrderEntryItemByOrderEntryItemIdLineIdDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__LINE_ID_DESC',
  OrderEntryItemByOrderEntryItemIdPalletCountAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PALLET_COUNT_ASC',
  OrderEntryItemByOrderEntryItemIdPalletCountDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PALLET_COUNT_DESC',
  OrderEntryItemByOrderEntryItemIdUnitSellPriceAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__UNIT_SELL_PRICE_ASC',
  OrderEntryItemByOrderEntryItemIdUnitSellPriceDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__UNIT_SELL_PRICE_DESC',
  OrderEntryItemByOrderEntryItemIdDeliveryChargeAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__DELIVERY_CHARGE_ASC',
  OrderEntryItemByOrderEntryItemIdDeliveryChargeDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__DELIVERY_CHARGE_DESC',
  OrderEntryItemByOrderEntryItemIdLocationIdAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__LOCATION_ID_ASC',
  OrderEntryItemByOrderEntryItemIdLocationIdDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__LOCATION_ID_DESC',
  OrderEntryItemByOrderEntryItemIdVesselCodeAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__VESSEL_CODE_ASC',
  OrderEntryItemByOrderEntryItemIdVesselCodeDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__VESSEL_CODE_DESC',
  OrderEntryItemByOrderEntryItemIdShipperIdAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__SHIPPER_ID_ASC',
  OrderEntryItemByOrderEntryItemIdShipperIdDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__SHIPPER_ID_DESC',
  OrderEntryItemByOrderEntryItemIdSpeciesAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__SPECIES_ASC',
  OrderEntryItemByOrderEntryItemIdSpeciesDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__SPECIES_DESC',
  OrderEntryItemByOrderEntryItemIdVarietyAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__VARIETY_ASC',
  OrderEntryItemByOrderEntryItemIdVarietyDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__VARIETY_DESC',
  OrderEntryItemByOrderEntryItemIdSizeAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__SIZE_ASC',
  OrderEntryItemByOrderEntryItemIdSizeDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__SIZE_DESC',
  OrderEntryItemByOrderEntryItemIdPackTypeAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PACK_TYPE_ASC',
  OrderEntryItemByOrderEntryItemIdPackTypeDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PACK_TYPE_DESC',
  OrderEntryItemByOrderEntryItemIdPluAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PLU_ASC',
  OrderEntryItemByOrderEntryItemIdPluDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PLU_DESC',
  OrderEntryItemByOrderEntryItemIdLabelAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__LABEL_ASC',
  OrderEntryItemByOrderEntryItemIdLabelDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__LABEL_DESC',
  OrderEntryItemByOrderEntryItemIdNotesAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__NOTES_ASC',
  OrderEntryItemByOrderEntryItemIdNotesDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__NOTES_DESC',
  OrderEntryItemByOrderEntryItemIdCountryOfOriginAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__COUNTRY_OF_ORIGIN_ASC',
  OrderEntryItemByOrderEntryItemIdCountryOfOriginDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__COUNTRY_OF_ORIGIN_DESC',
  OrderEntryItemByOrderEntryItemIdBoxCountAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__BOX_COUNT_ASC',
  OrderEntryItemByOrderEntryItemIdBoxCountDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__BOX_COUNT_DESC',
  OrderEntryItemByOrderEntryItemIdPalletWeightAsc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PALLET_WEIGHT_ASC',
  OrderEntryItemByOrderEntryItemIdPalletWeightDesc = 'ORDER_ENTRY_ITEM_BY_ORDER_ENTRY_ITEM_ID__PALLET_WEIGHT_DESC'
}

/** A filter to be used against many `OrderEntryItem` object types. All fields are combined with a logical ‘and.’ */
export type OrderEntryToManyOrderEntryItemFilter = {
  /** Every related `OrderEntryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<OrderEntryItemFilter>;
  /** Some related `OrderEntryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<OrderEntryItemFilter>;
  /** No related `OrderEntryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<OrderEntryItemFilter>;
};

export type OrderItem = Node & {
  __typename?: 'OrderItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  itemStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  isBundle?: Maybe<Scalars['Boolean']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
  inventoryItem?: Maybe<InventoryItem>;
  order?: Maybe<OrderMaster>;
  product?: Maybe<ProductMaster>;
  searchText?: Maybe<Scalars['String']>;
  vessel?: Maybe<Vessel>;
};

/**
 * A condition to be used against `OrderItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OrderItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `itemStatus` field. */
  itemStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `lineId` field. */
  lineId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `isBundle` field. */
  isBundle?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `boxCount` field. */
  boxCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `specialLotNumber` field. */
  specialLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPre` field. */
  isPre?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `OrderItem` object types. All fields are combined with a logical ‘and.’ */
export type OrderItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `itemStatus` field. */
  itemStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `lineId` field. */
  lineId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `unitSellPrice` field. */
  unitSellPrice?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `deliveryCharge` field. */
  deliveryCharge?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `isBundle` field. */
  isBundle?: Maybe<BooleanFilter>;
  /** Filter by the object’s `boxCount` field. */
  boxCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<StringFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `specialLotNumber` field. */
  specialLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `isPre` field. */
  isPre?: Maybe<BooleanFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderItemFilter>;
};

/** An input for mutations affecting `OrderItem` */
export type OrderItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  itemStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  isBundle?: Maybe<Scalars['Boolean']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
};

/** Represents an update to a `OrderItem`. Fields that are set will be updated. */
export type OrderItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  itemStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  isBundle?: Maybe<Scalars['Boolean']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  productId?: Maybe<Scalars['String']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  specialLotNumber?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
};

/** A connection to a list of `OrderItem` values. */
export type OrderItemsConnection = {
  __typename?: 'OrderItemsConnection';
  /** A list of `OrderItem` objects. */
  nodes: Array<Maybe<OrderItem>>;
  /** A list of edges which contains the `OrderItem` and cursor to aid in pagination. */
  edges: Array<OrderItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderItem` edge in the connection. */
export type OrderItemsEdge = {
  __typename?: 'OrderItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderItem` at the end of the edge. */
  node?: Maybe<OrderItem>;
};

/** Methods to use when ordering `OrderItem`. */
export enum OrderItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ItemStatusAsc = 'ITEM_STATUS_ASC',
  ItemStatusDesc = 'ITEM_STATUS_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  LineIdAsc = 'LINE_ID_ASC',
  LineIdDesc = 'LINE_ID_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  UnitSellPriceAsc = 'UNIT_SELL_PRICE_ASC',
  UnitSellPriceDesc = 'UNIT_SELL_PRICE_DESC',
  DeliveryChargeAsc = 'DELIVERY_CHARGE_ASC',
  DeliveryChargeDesc = 'DELIVERY_CHARGE_DESC',
  IsBundleAsc = 'IS_BUNDLE_ASC',
  IsBundleDesc = 'IS_BUNDLE_DESC',
  BoxCountAsc = 'BOX_COUNT_ASC',
  BoxCountDesc = 'BOX_COUNT_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  JvLotNumberAsc = 'JV_LOT_NUMBER_ASC',
  JvLotNumberDesc = 'JV_LOT_NUMBER_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  SpecialLotNumberAsc = 'SPECIAL_LOT_NUMBER_ASC',
  SpecialLotNumberDesc = 'SPECIAL_LOT_NUMBER_DESC',
  IsPreAsc = 'IS_PRE_ASC',
  IsPreDesc = 'IS_PRE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type OrderMaster = Node & {
  __typename?: 'OrderMaster';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  orderStatus?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  shipWarehouseId?: Maybe<Scalars['String']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  expectedShipDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Date']>;
  entryDate?: Maybe<Scalars['Date']>;
  actualShipDate?: Maybe<Scalars['Date']>;
  shippingCustomerId?: Maybe<Scalars['String']>;
  entryUserCode?: Maybe<Scalars['String']>;
  deliveryZone?: Maybe<Scalars['String']>;
  loadLocation?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  billingCustomer?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `OrderComment`. */
  comments: OrderCommentsConnection;
  entryUser?: Maybe<User>;
  /** Reads and enables pagination through a set of `OrderItem`. */
  items: OrderItemsConnection;
  /** Reads and enables pagination through a set of `RepackQueue`. */
  repackQueues: RepackQueuesConnection;
  salesUser?: Maybe<User>;
  searchText?: Maybe<Scalars['String']>;
  shipWarehouse?: Maybe<Warehouse>;
  shippingCustomer?: Maybe<Customer>;
  truckLoad?: Maybe<TruckLoad>;
  vendor?: Maybe<Vendor>;
};


export type OrderMasterCommentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<OrderCommentFilter>;
};


export type OrderMasterItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<OrderItemFilter>;
};


export type OrderMasterRepackQueuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<RepackQueueFilter>;
};

/**
 * A condition to be used against `OrderMaster` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OrderMasterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderStatus` field. */
  orderStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `loadStatus` field. */
  loadStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `shipWarehouseId` field. */
  shipWarehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fob` field. */
  fob?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `billingCustomerId` field. */
  billingCustomerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerPo` field. */
  customerPo?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `expectedShipDate` field. */
  expectedShipDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `orderDate` field. */
  orderDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `entryDate` field. */
  entryDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `actualShipDate` field. */
  actualShipDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `shippingCustomerId` field. */
  shippingCustomerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `entryUserCode` field. */
  entryUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deliveryZone` field. */
  deliveryZone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `loadLocation` field. */
  loadLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
};

/** A `String` edge in the connection. */
export type OrderMasterCustomerDistinctValueEdge = {
  __typename?: 'OrderMasterCustomerDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type OrderMasterCustomerDistinctValuesConnection = {
  __typename?: 'OrderMasterCustomerDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<OrderMasterCustomerDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A filter to be used against `OrderMaster` object types. All fields are combined with a logical ‘and.’ */
export type OrderMasterFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orderStatus` field. */
  orderStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `loadStatus` field. */
  loadStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `shipWarehouseId` field. */
  shipWarehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `truckLoadId` field. */
  truckLoadId?: Maybe<StringFilter>;
  /** Filter by the object’s `fob` field. */
  fob?: Maybe<BooleanFilter>;
  /** Filter by the object’s `billingCustomerId` field. */
  billingCustomerId?: Maybe<StringFilter>;
  /** Filter by the object’s `salesUserCode` field. */
  salesUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `customerPo` field. */
  customerPo?: Maybe<StringFilter>;
  /** Filter by the object’s `expectedShipDate` field. */
  expectedShipDate?: Maybe<DateFilter>;
  /** Filter by the object’s `orderDate` field. */
  orderDate?: Maybe<DateFilter>;
  /** Filter by the object’s `entryDate` field. */
  entryDate?: Maybe<DateFilter>;
  /** Filter by the object’s `actualShipDate` field. */
  actualShipDate?: Maybe<DateFilter>;
  /** Filter by the object’s `shippingCustomerId` field. */
  shippingCustomerId?: Maybe<StringFilter>;
  /** Filter by the object’s `entryUserCode` field. */
  entryUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `deliveryZone` field. */
  deliveryZone?: Maybe<StringFilter>;
  /** Filter by the object’s `loadLocation` field. */
  loadLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderMasterFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderMasterFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderMasterFilter>;
};

/** An input for mutations affecting `OrderMaster` */
export type OrderMasterInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderStatus?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  shipWarehouseId?: Maybe<Scalars['String']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  expectedShipDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Date']>;
  entryDate?: Maybe<Scalars['Date']>;
  actualShipDate?: Maybe<Scalars['Date']>;
  shippingCustomerId?: Maybe<Scalars['String']>;
  entryUserCode?: Maybe<Scalars['String']>;
  deliveryZone?: Maybe<Scalars['String']>;
  loadLocation?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
};

/** Represents an update to a `OrderMaster`. Fields that are set will be updated. */
export type OrderMasterPatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderStatus?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  shipWarehouseId?: Maybe<Scalars['String']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  expectedShipDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Date']>;
  entryDate?: Maybe<Scalars['Date']>;
  actualShipDate?: Maybe<Scalars['Date']>;
  shippingCustomerId?: Maybe<Scalars['String']>;
  entryUserCode?: Maybe<Scalars['String']>;
  deliveryZone?: Maybe<Scalars['String']>;
  loadLocation?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `OrderMaster` values. */
export type OrderMastersConnection = {
  __typename?: 'OrderMastersConnection';
  /** A list of `OrderMaster` objects. */
  nodes: Array<Maybe<OrderMaster>>;
  /** A list of edges which contains the `OrderMaster` and cursor to aid in pagination. */
  edges: Array<OrderMastersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderMaster` edge in the connection. */
export type OrderMastersEdge = {
  __typename?: 'OrderMastersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderMaster` at the end of the edge. */
  node?: Maybe<OrderMaster>;
};

/** Methods to use when ordering `OrderMaster`. */
export enum OrderMastersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderStatusAsc = 'ORDER_STATUS_ASC',
  OrderStatusDesc = 'ORDER_STATUS_DESC',
  LoadStatusAsc = 'LOAD_STATUS_ASC',
  LoadStatusDesc = 'LOAD_STATUS_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  ShipWarehouseIdAsc = 'SHIP_WAREHOUSE_ID_ASC',
  ShipWarehouseIdDesc = 'SHIP_WAREHOUSE_ID_DESC',
  TruckLoadIdAsc = 'TRUCK_LOAD_ID_ASC',
  TruckLoadIdDesc = 'TRUCK_LOAD_ID_DESC',
  FobAsc = 'FOB_ASC',
  FobDesc = 'FOB_DESC',
  BillingCustomerIdAsc = 'BILLING_CUSTOMER_ID_ASC',
  BillingCustomerIdDesc = 'BILLING_CUSTOMER_ID_DESC',
  SalesUserCodeAsc = 'SALES_USER_CODE_ASC',
  SalesUserCodeDesc = 'SALES_USER_CODE_DESC',
  CustomerPoAsc = 'CUSTOMER_PO_ASC',
  CustomerPoDesc = 'CUSTOMER_PO_DESC',
  ExpectedShipDateAsc = 'EXPECTED_SHIP_DATE_ASC',
  ExpectedShipDateDesc = 'EXPECTED_SHIP_DATE_DESC',
  OrderDateAsc = 'ORDER_DATE_ASC',
  OrderDateDesc = 'ORDER_DATE_DESC',
  EntryDateAsc = 'ENTRY_DATE_ASC',
  EntryDateDesc = 'ENTRY_DATE_DESC',
  ActualShipDateAsc = 'ACTUAL_SHIP_DATE_ASC',
  ActualShipDateDesc = 'ACTUAL_SHIP_DATE_DESC',
  ShippingCustomerIdAsc = 'SHIPPING_CUSTOMER_ID_ASC',
  ShippingCustomerIdDesc = 'SHIPPING_CUSTOMER_ID_DESC',
  EntryUserCodeAsc = 'ENTRY_USER_CODE_ASC',
  EntryUserCodeDesc = 'ENTRY_USER_CODE_DESC',
  DeliveryZoneAsc = 'DELIVERY_ZONE_ASC',
  DeliveryZoneDesc = 'DELIVERY_ZONE_DESC',
  LoadLocationAsc = 'LOAD_LOCATION_ASC',
  LoadLocationDesc = 'LOAD_LOCATION_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type OrderNumber = Node & {
  __typename?: 'OrderNumber';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
};

/**
 * A condition to be used against `OrderNumber` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OrderNumberCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `OrderNumber` object types. All fields are combined with a logical ‘and.’ */
export type OrderNumberFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderNumberFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderNumberFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderNumberFilter>;
};

/** An input for mutations affecting `OrderNumber` */
export type OrderNumberInput = {
  id?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `OrderNumber`. Fields that are set will be updated. */
export type OrderNumberPatch = {
  id?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `OrderNumber` values. */
export type OrderNumbersConnection = {
  __typename?: 'OrderNumbersConnection';
  /** A list of `OrderNumber` objects. */
  nodes: Array<Maybe<OrderNumber>>;
  /** A list of edges which contains the `OrderNumber` and cursor to aid in pagination. */
  edges: Array<OrderNumbersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderNumber` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderNumber` edge in the connection. */
export type OrderNumbersEdge = {
  __typename?: 'OrderNumbersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderNumber` at the end of the edge. */
  node?: Maybe<OrderNumber>;
};

/** Methods to use when ordering `OrderNumber`. */
export enum OrderNumbersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type OrderPallet = Node & {
  __typename?: 'OrderPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletId?: Maybe<Scalars['String']>;
  conditionCode?: Maybe<Scalars['String']>;
  repackId?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  orderItem?: Maybe<OrderItem>;
  productPallet?: Maybe<Pallet>;
};

/**
 * A condition to be used against `OrderPallet` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OrderPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletStatus` field. */
  palletStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `lineId` field. */
  lineId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `conditionCode` field. */
  conditionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `repackId` field. */
  repackId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creditCode` field. */
  creditCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `priceAdjustment` field. */
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `freightAdjustment` field. */
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `OrderPallet` object types. All fields are combined with a logical ‘and.’ */
export type OrderPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletStatus` field. */
  palletStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `lineId` field. */
  lineId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `conditionCode` field. */
  conditionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `repackId` field. */
  repackId?: Maybe<StringFilter>;
  /** Filter by the object’s `creditCode` field. */
  creditCode?: Maybe<StringFilter>;
  /** Filter by the object’s `priceAdjustment` field. */
  priceAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `freightAdjustment` field. */
  freightAdjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrderPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrderPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrderPalletFilter>;
};

/** An input for mutations affecting `OrderPallet` */
export type OrderPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletId?: Maybe<Scalars['String']>;
  conditionCode?: Maybe<Scalars['String']>;
  repackId?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
};

/** Represents an update to a `OrderPallet`. Fields that are set will be updated. */
export type OrderPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletStatus?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletId?: Maybe<Scalars['String']>;
  conditionCode?: Maybe<Scalars['String']>;
  repackId?: Maybe<Scalars['String']>;
  creditCode?: Maybe<Scalars['String']>;
  priceAdjustment?: Maybe<Scalars['BigFloat']>;
  freightAdjustment?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
};

/** A connection to a list of `OrderPallet` values. */
export type OrderPalletsConnection = {
  __typename?: 'OrderPalletsConnection';
  /** A list of `OrderPallet` objects. */
  nodes: Array<Maybe<OrderPallet>>;
  /** A list of edges which contains the `OrderPallet` and cursor to aid in pagination. */
  edges: Array<OrderPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrderPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `OrderPallet` edge in the connection. */
export type OrderPalletsEdge = {
  __typename?: 'OrderPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `OrderPallet` at the end of the edge. */
  node?: Maybe<OrderPallet>;
};

/** Methods to use when ordering `OrderPallet`. */
export enum OrderPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletStatusAsc = 'PALLET_STATUS_ASC',
  PalletStatusDesc = 'PALLET_STATUS_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  LineIdAsc = 'LINE_ID_ASC',
  LineIdDesc = 'LINE_ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ConditionCodeAsc = 'CONDITION_CODE_ASC',
  ConditionCodeDesc = 'CONDITION_CODE_DESC',
  RepackIdAsc = 'REPACK_ID_ASC',
  RepackIdDesc = 'REPACK_ID_DESC',
  CreditCodeAsc = 'CREDIT_CODE_ASC',
  CreditCodeDesc = 'CREDIT_CODE_DESC',
  PriceAdjustmentAsc = 'PRICE_ADJUSTMENT_ASC',
  PriceAdjustmentDesc = 'PRICE_ADJUSTMENT_DESC',
  FreightAdjustmentAsc = 'FREIGHT_ADJUSTMENT_ASC',
  FreightAdjustmentDesc = 'FREIGHT_ADJUSTMENT_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackAtmosphere = Node & {
  __typename?: 'PackAtmosphere';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  maCode?: Maybe<Scalars['String']>;
  maDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackAtmosphere` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackAtmosphereCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `maCode` field. */
  maCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `maDescription` field. */
  maDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackAtmosphere` object types. All fields are combined with a logical ‘and.’ */
export type PackAtmosphereFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `maCode` field. */
  maCode?: Maybe<StringFilter>;
  /** Filter by the object’s `maDescription` field. */
  maDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackAtmosphereFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackAtmosphereFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackAtmosphereFilter>;
};

/** An input for mutations affecting `PackAtmosphere` */
export type PackAtmosphereInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  maCode?: Maybe<Scalars['String']>;
  maDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackAtmosphere`. Fields that are set will be updated. */
export type PackAtmospherePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  maCode?: Maybe<Scalars['String']>;
  maDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackAtmosphere` values. */
export type PackAtmospheresConnection = {
  __typename?: 'PackAtmospheresConnection';
  /** A list of `PackAtmosphere` objects. */
  nodes: Array<Maybe<PackAtmosphere>>;
  /** A list of edges which contains the `PackAtmosphere` and cursor to aid in pagination. */
  edges: Array<PackAtmospheresEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackAtmosphere` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackAtmosphere` edge in the connection. */
export type PackAtmospheresEdge = {
  __typename?: 'PackAtmospheresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackAtmosphere` at the end of the edge. */
  node?: Maybe<PackAtmosphere>;
};

/** Methods to use when ordering `PackAtmosphere`. */
export enum PackAtmospheresOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  MaCodeAsc = 'MA_CODE_ASC',
  MaCodeDesc = 'MA_CODE_DESC',
  MaDescriptionAsc = 'MA_DESCRIPTION_ASC',
  MaDescriptionDesc = 'MA_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackBoxStyle = Node & {
  __typename?: 'PackBoxStyle';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  boxStyle?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackBoxStyle` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackBoxStyleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxStyle` field. */
  boxStyle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxDescription` field. */
  boxDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineDescription` field. */
  combineDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackBoxStyle` object types. All fields are combined with a logical ‘and.’ */
export type PackBoxStyleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxStyle` field. */
  boxStyle?: Maybe<StringFilter>;
  /** Filter by the object’s `boxDescription` field. */
  boxDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Filter by the object’s `combineDescription` field. */
  combineDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackBoxStyleFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackBoxStyleFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackBoxStyleFilter>;
};

/** An input for mutations affecting `PackBoxStyle` */
export type PackBoxStyleInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxStyle?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackBoxStyle`. Fields that are set will be updated. */
export type PackBoxStylePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxStyle?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackBoxStyle` values. */
export type PackBoxStylesConnection = {
  __typename?: 'PackBoxStylesConnection';
  /** A list of `PackBoxStyle` objects. */
  nodes: Array<Maybe<PackBoxStyle>>;
  /** A list of edges which contains the `PackBoxStyle` and cursor to aid in pagination. */
  edges: Array<PackBoxStylesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackBoxStyle` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackBoxStyle` edge in the connection. */
export type PackBoxStylesEdge = {
  __typename?: 'PackBoxStylesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackBoxStyle` at the end of the edge. */
  node?: Maybe<PackBoxStyle>;
};

/** Methods to use when ordering `PackBoxStyle`. */
export enum PackBoxStylesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  BoxStyleAsc = 'BOX_STYLE_ASC',
  BoxStyleDesc = 'BOX_STYLE_DESC',
  BoxDescriptionAsc = 'BOX_DESCRIPTION_ASC',
  BoxDescriptionDesc = 'BOX_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  CombineDescriptionAsc = 'COMBINE_DESCRIPTION_ASC',
  CombineDescriptionDesc = 'COMBINE_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackBoxType = Node & {
  __typename?: 'PackBoxType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  boxType?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackBoxType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackBoxTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxType` field. */
  boxType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxDescription` field. */
  boxDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackBoxType` object types. All fields are combined with a logical ‘and.’ */
export type PackBoxTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxType` field. */
  boxType?: Maybe<StringFilter>;
  /** Filter by the object’s `boxDescription` field. */
  boxDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackBoxTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackBoxTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackBoxTypeFilter>;
};

/** An input for mutations affecting `PackBoxType` */
export type PackBoxTypeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxType?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackBoxType`. Fields that are set will be updated. */
export type PackBoxTypePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  boxType?: Maybe<Scalars['String']>;
  boxDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackBoxType` values. */
export type PackBoxTypesConnection = {
  __typename?: 'PackBoxTypesConnection';
  /** A list of `PackBoxType` objects. */
  nodes: Array<Maybe<PackBoxType>>;
  /** A list of edges which contains the `PackBoxType` and cursor to aid in pagination. */
  edges: Array<PackBoxTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackBoxType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackBoxType` edge in the connection. */
export type PackBoxTypesEdge = {
  __typename?: 'PackBoxTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackBoxType` at the end of the edge. */
  node?: Maybe<PackBoxType>;
};

/** Methods to use when ordering `PackBoxType`. */
export enum PackBoxTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  BoxTypeAsc = 'BOX_TYPE_ASC',
  BoxTypeDesc = 'BOX_TYPE_DESC',
  BoxDescriptionAsc = 'BOX_DESCRIPTION_ASC',
  BoxDescriptionDesc = 'BOX_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackDestination = Node & {
  __typename?: 'PackDestination';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  destinationCode?: Maybe<Scalars['String']>;
  destinationDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackDestination` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackDestinationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destinationCode` field. */
  destinationCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destinationDescription` field. */
  destinationDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackDestination` object types. All fields are combined with a logical ‘and.’ */
export type PackDestinationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `destinationCode` field. */
  destinationCode?: Maybe<StringFilter>;
  /** Filter by the object’s `destinationDescription` field. */
  destinationDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackDestinationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackDestinationFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackDestinationFilter>;
};

/** An input for mutations affecting `PackDestination` */
export type PackDestinationInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  destinationCode?: Maybe<Scalars['String']>;
  destinationDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackDestination`. Fields that are set will be updated. */
export type PackDestinationPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  destinationCode?: Maybe<Scalars['String']>;
  destinationDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackDestination` values. */
export type PackDestinationsConnection = {
  __typename?: 'PackDestinationsConnection';
  /** A list of `PackDestination` objects. */
  nodes: Array<Maybe<PackDestination>>;
  /** A list of edges which contains the `PackDestination` and cursor to aid in pagination. */
  edges: Array<PackDestinationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackDestination` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackDestination` edge in the connection. */
export type PackDestinationsEdge = {
  __typename?: 'PackDestinationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackDestination` at the end of the edge. */
  node?: Maybe<PackDestination>;
};

/** Methods to use when ordering `PackDestination`. */
export enum PackDestinationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  DestinationCodeAsc = 'DESTINATION_CODE_ASC',
  DestinationCodeDesc = 'DESTINATION_CODE_DESC',
  DestinationDescriptionAsc = 'DESTINATION_DESCRIPTION_ASC',
  DestinationDescriptionDesc = 'DESTINATION_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackGrade = Node & {
  __typename?: 'PackGrade';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  gradeCode?: Maybe<Scalars['String']>;
  gradeDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackGrade` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackGradeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gradeCode` field. */
  gradeCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gradeDescription` field. */
  gradeDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackGrade` object types. All fields are combined with a logical ‘and.’ */
export type PackGradeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `gradeCode` field. */
  gradeCode?: Maybe<StringFilter>;
  /** Filter by the object’s `gradeDescription` field. */
  gradeDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackGradeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackGradeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackGradeFilter>;
};

/** An input for mutations affecting `PackGrade` */
export type PackGradeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  gradeCode?: Maybe<Scalars['String']>;
  gradeDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackGrade`. Fields that are set will be updated. */
export type PackGradePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  gradeCode?: Maybe<Scalars['String']>;
  gradeDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackGrade` values. */
export type PackGradesConnection = {
  __typename?: 'PackGradesConnection';
  /** A list of `PackGrade` objects. */
  nodes: Array<Maybe<PackGrade>>;
  /** A list of edges which contains the `PackGrade` and cursor to aid in pagination. */
  edges: Array<PackGradesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackGrade` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackGrade` edge in the connection. */
export type PackGradesEdge = {
  __typename?: 'PackGradesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackGrade` at the end of the edge. */
  node?: Maybe<PackGrade>;
};

/** Methods to use when ordering `PackGrade`. */
export enum PackGradesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  GradeCodeAsc = 'GRADE_CODE_ASC',
  GradeCodeDesc = 'GRADE_CODE_DESC',
  GradeDescriptionAsc = 'GRADE_DESCRIPTION_ASC',
  GradeDescriptionDesc = 'GRADE_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackHold = Node & {
  __typename?: 'PackHold';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  holdCode?: Maybe<Scalars['String']>;
  holdDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackHold` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackHoldCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `holdCode` field. */
  holdCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `holdDescription` field. */
  holdDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackHold` object types. All fields are combined with a logical ‘and.’ */
export type PackHoldFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `holdCode` field. */
  holdCode?: Maybe<StringFilter>;
  /** Filter by the object’s `holdDescription` field. */
  holdDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackHoldFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackHoldFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackHoldFilter>;
};

/** An input for mutations affecting `PackHold` */
export type PackHoldInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  holdCode?: Maybe<Scalars['String']>;
  holdDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackHold`. Fields that are set will be updated. */
export type PackHoldPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  holdCode?: Maybe<Scalars['String']>;
  holdDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackHold` values. */
export type PackHoldsConnection = {
  __typename?: 'PackHoldsConnection';
  /** A list of `PackHold` objects. */
  nodes: Array<Maybe<PackHold>>;
  /** A list of edges which contains the `PackHold` and cursor to aid in pagination. */
  edges: Array<PackHoldsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackHold` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackHold` edge in the connection. */
export type PackHoldsEdge = {
  __typename?: 'PackHoldsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackHold` at the end of the edge. */
  node?: Maybe<PackHold>;
};

/** Methods to use when ordering `PackHold`. */
export enum PackHoldsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  HoldCodeAsc = 'HOLD_CODE_ASC',
  HoldCodeDesc = 'HOLD_CODE_DESC',
  HoldDescriptionAsc = 'HOLD_DESCRIPTION_ASC',
  HoldDescriptionDesc = 'HOLD_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackLabel = Node & {
  __typename?: 'PackLabel';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  labelCode?: Maybe<Scalars['String']>;
  labelName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackLabel` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackLabelCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelName` field. */
  labelName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperName` field. */
  shipperName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackLabel` object types. All fields are combined with a logical ‘and.’ */
export type PackLabelFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `labelName` field. */
  labelName?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperName` field. */
  shipperName?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackLabelFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackLabelFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackLabelFilter>;
};

/** An input for mutations affecting `PackLabel` */
export type PackLabelInput = {
  id?: Maybe<Scalars['BigInt']>;
  labelCode?: Maybe<Scalars['String']>;
  labelName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackLabel`. Fields that are set will be updated. */
export type PackLabelPatch = {
  id?: Maybe<Scalars['BigInt']>;
  labelCode?: Maybe<Scalars['String']>;
  labelName?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackLabel` values. */
export type PackLabelsConnection = {
  __typename?: 'PackLabelsConnection';
  /** A list of `PackLabel` objects. */
  nodes: Array<Maybe<PackLabel>>;
  /** A list of edges which contains the `PackLabel` and cursor to aid in pagination. */
  edges: Array<PackLabelsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackLabel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackLabel` edge in the connection. */
export type PackLabelsEdge = {
  __typename?: 'PackLabelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackLabel` at the end of the edge. */
  node?: Maybe<PackLabel>;
};

/** Methods to use when ordering `PackLabel`. */
export enum PackLabelsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  LabelNameAsc = 'LABEL_NAME_ASC',
  LabelNameDesc = 'LABEL_NAME_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  ShipperNameAsc = 'SHIPPER_NAME_ASC',
  ShipperNameDesc = 'SHIPPER_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackLiner = Node & {
  __typename?: 'PackLiner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  linerCode?: Maybe<Scalars['String']>;
  linerDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackLiner` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackLinerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linerCode` field. */
  linerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linerDescription` field. */
  linerDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackLiner` object types. All fields are combined with a logical ‘and.’ */
export type PackLinerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `linerCode` field. */
  linerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `linerDescription` field. */
  linerDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackLinerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackLinerFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackLinerFilter>;
};

/** An input for mutations affecting `PackLiner` */
export type PackLinerInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  linerCode?: Maybe<Scalars['String']>;
  linerDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackLiner`. Fields that are set will be updated. */
export type PackLinerPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  linerCode?: Maybe<Scalars['String']>;
  linerDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackLiner` values. */
export type PackLinersConnection = {
  __typename?: 'PackLinersConnection';
  /** A list of `PackLiner` objects. */
  nodes: Array<Maybe<PackLiner>>;
  /** A list of edges which contains the `PackLiner` and cursor to aid in pagination. */
  edges: Array<PackLinersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackLiner` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackLiner` edge in the connection. */
export type PackLinersEdge = {
  __typename?: 'PackLinersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackLiner` at the end of the edge. */
  node?: Maybe<PackLiner>;
};

/** Methods to use when ordering `PackLiner`. */
export enum PackLinersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  LinerCodeAsc = 'LINER_CODE_ASC',
  LinerCodeDesc = 'LINER_CODE_DESC',
  LinerDescriptionAsc = 'LINER_DESCRIPTION_ASC',
  LinerDescriptionDesc = 'LINER_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackMaster = Node & {
  __typename?: 'PackMaster';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypes: CommonPackTypesConnection;
  /** Reads and enables pagination through a set of `CommonPackTypePackMaster`. */
  commonPackTypePackMasters: CommonPackTypePackMastersConnection;
  atmosphere?: Maybe<PackAtmosphere>;
  boxStyle?: Maybe<PackBoxStyle>;
  boxType?: Maybe<PackBoxType>;
  commonPackType?: Maybe<CommonPackType>;
  customerSpecial?: Maybe<PackSpecial>;
  destination?: Maybe<PackDestination>;
  grade?: Maybe<PackGrade>;
  hold?: Maybe<PackHold>;
  label?: Maybe<PackLabel>;
  liner?: Maybe<PackLiner>;
  out?: Maybe<PackOut>;
  packStyle?: Maybe<PackStyle>;
  palletType?: Maybe<PackPalletType>;
  production?: Maybe<PackProduction>;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  species?: Maybe<ProductSpecies>;
  treeRipe?: Maybe<PackTreeRipe>;
  variety?: Maybe<ProductVariety>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesId: PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeId: PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdManyToManyConnection;
};


export type PackMasterCommonPackTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type PackMasterCommonPackTypePackMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
  condition?: Maybe<CommonPackTypePackMasterCondition>;
  filter?: Maybe<CommonPackTypePackMasterFilter>;
};


export type PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `CommonPackTypePackMaster`. */
export type PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `CommonPackTypePackMaster`, and the cursor to aid in pagination. */
  edges: Array<PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `CommonPackTypePackMaster`. */
export type PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `CommonPackTypePackMaster`. */
  commonPackTypePackMasters: CommonPackTypePackMastersConnection;
};


/** A `CommonPackType` edge in the connection, with data from `CommonPackTypePackMaster`. */
export type PackMasterCommonPackTypesByCommonPackTypePackMasterPackMasterIdAndCommonPackTypeIdManyToManyEdgeCommonPackTypePackMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
  condition?: Maybe<CommonPackTypePackMasterCondition>;
  filter?: Maybe<CommonPackTypePackMasterFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `CommonPackType`. */
export type PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CommonPackType`, and the cursor to aid in pagination. */
  edges: Array<PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CommonPackType`. */
export type PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypes: CommonPackTypesConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CommonPackType`. */
export type PackMasterCommonSpeciesByCommonPackTypePackMasterIdAndCommonSpeciesIdManyToManyEdgeCommonPackTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};

/**
 * A condition to be used against `PackMaster` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackMasterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCodeId` field. */
  labelCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerCodeId` field. */
  customerCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxTypeId` field. */
  boxTypeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxStyleId` field. */
  boxStyleId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packStyleId` field. */
  packStyleId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outCodeId` field. */
  outCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outQuantity` field. */
  outQuantity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outWeight` field. */
  outWeight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productionCodeId` field. */
  productionCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treeRipeId` field. */
  treeRipeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gradeCodeId` field. */
  gradeCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `maCodeId` field. */
  maCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linerCodeId` field. */
  linerCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `netWeightContents` field. */
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `netWeightBox` field. */
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxLength` field. */
  boxLength?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxWidth` field. */
  boxWidth?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxHeight` field. */
  boxHeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletTypeId` field. */
  palletTypeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `pluUpcCode` field. */
  pluUpcCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destinationCodeId` field. */
  destinationCodeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oldLabelCode` field. */
  oldLabelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvPackCode` field. */
  jvPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyId` field. */
  varietyId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `speciesId` field. */
  speciesId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `holdCodeId` field. */
  holdCodeId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackMaster` object types. All fields are combined with a logical ‘and.’ */
export type PackMasterFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCodeId` field. */
  labelCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `customerCodeId` field. */
  customerCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxTypeId` field. */
  boxTypeId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxStyleId` field. */
  boxStyleId?: Maybe<StringFilter>;
  /** Filter by the object’s `packStyleId` field. */
  packStyleId?: Maybe<StringFilter>;
  /** Filter by the object’s `outCodeId` field. */
  outCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `outQuantity` field. */
  outQuantity?: Maybe<StringFilter>;
  /** Filter by the object’s `outWeight` field. */
  outWeight?: Maybe<StringFilter>;
  /** Filter by the object’s `productionCodeId` field. */
  productionCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `treeRipeId` field. */
  treeRipeId?: Maybe<StringFilter>;
  /** Filter by the object’s `gradeCodeId` field. */
  gradeCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `maCodeId` field. */
  maCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `linerCodeId` field. */
  linerCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `netWeightContents` field. */
  netWeightContents?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `netWeightBox` field. */
  netWeightBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxLength` field. */
  boxLength?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxWidth` field. */
  boxWidth?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxHeight` field. */
  boxHeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletTypeId` field. */
  palletTypeId?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `pluUpcCode` field. */
  pluUpcCode?: Maybe<StringFilter>;
  /** Filter by the object’s `destinationCodeId` field. */
  destinationCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `oldLabelCode` field. */
  oldLabelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `jvPackCode` field. */
  jvPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyId` field. */
  varietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `speciesId` field. */
  speciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `holdCodeId` field. */
  holdCodeId?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonPackTypes` relation. */
  commonPackTypes?: Maybe<PackMasterToManyCommonPackTypeFilter>;
  /** Some related `commonPackTypes` exist. */
  commonPackTypesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonPackTypePackMasters` relation. */
  commonPackTypePackMasters?: Maybe<PackMasterToManyCommonPackTypePackMasterFilter>;
  /** Some related `commonPackTypePackMasters` exist. */
  commonPackTypePackMastersExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackMasterFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackMasterFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackMasterFilter>;
};

/** An input for mutations affecting `PackMaster` */
export type PackMasterInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  commonPackTypesUsingId?: Maybe<CommonPackTypePackMasterIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PackMasterNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `packMaster` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PackMasterNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `packMaster` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PackMasterOnCommonPackTypeForCommonPackTypePackMasterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** The fields on `packMaster` to look up the row to update. */
export type PackMasterOnCommonPackTypeForCommonPackTypePackMasterIdFkeyUsingPackMasterPkeyUpdate = {
  /** An object where the defined keys will be set on the `packMaster` being updated. */
  patch: UpdatePackMasterOnCommonPackTypeForCommonPackTypePackMasterIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackTypePackMaster` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackTypePackMaster` being updated. */
  patch: CommonPackTypePackMasterPatch;
};

/** The fields on `packMaster` to look up the row to update. */
export type PackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyUsingPackMasterPkeyUpdate = {
  /** An object where the defined keys will be set on the `packMaster` being updated. */
  patch: UpdatePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The fields on `packMaster` to look up the row to connect. */
export type PackMasterPackMasterPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `packMaster` to look up the row to delete. */
export type PackMasterPackMasterPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Represents an update to a `PackMaster`. Fields that are set will be updated. */
export type PackMasterPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  commonPackTypesUsingId?: Maybe<CommonPackTypePackMasterIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInverseInput>;
};

/** A filter to be used against many `CommonPackType` object types. All fields are combined with a logical ‘and.’ */
export type PackMasterToManyCommonPackTypeFilter = {
  /** Every related `CommonPackType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonPackTypeFilter>;
  /** Some related `CommonPackType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonPackTypeFilter>;
  /** No related `CommonPackType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonPackTypeFilter>;
};

/** A filter to be used against many `CommonPackTypePackMaster` object types. All fields are combined with a logical ‘and.’ */
export type PackMasterToManyCommonPackTypePackMasterFilter = {
  /** Every related `CommonPackTypePackMaster` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonPackTypePackMasterFilter>;
  /** Some related `CommonPackTypePackMaster` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonPackTypePackMasterFilter>;
  /** No related `CommonPackTypePackMaster` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonPackTypePackMasterFilter>;
};

/** A connection to a list of `PackMaster` values. */
export type PackMastersConnection = {
  __typename?: 'PackMastersConnection';
  /** A list of `PackMaster` objects. */
  nodes: Array<Maybe<PackMaster>>;
  /** A list of edges which contains the `PackMaster` and cursor to aid in pagination. */
  edges: Array<PackMastersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackMaster` edge in the connection. */
export type PackMastersEdge = {
  __typename?: 'PackMastersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackMaster` at the end of the edge. */
  node?: Maybe<PackMaster>;
};

/** Methods to use when ordering `PackMaster`. */
export enum PackMastersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  LabelCodeIdAsc = 'LABEL_CODE_ID_ASC',
  LabelCodeIdDesc = 'LABEL_CODE_ID_DESC',
  CustomerCodeIdAsc = 'CUSTOMER_CODE_ID_ASC',
  CustomerCodeIdDesc = 'CUSTOMER_CODE_ID_DESC',
  BoxTypeIdAsc = 'BOX_TYPE_ID_ASC',
  BoxTypeIdDesc = 'BOX_TYPE_ID_DESC',
  BoxStyleIdAsc = 'BOX_STYLE_ID_ASC',
  BoxStyleIdDesc = 'BOX_STYLE_ID_DESC',
  PackStyleIdAsc = 'PACK_STYLE_ID_ASC',
  PackStyleIdDesc = 'PACK_STYLE_ID_DESC',
  OutCodeIdAsc = 'OUT_CODE_ID_ASC',
  OutCodeIdDesc = 'OUT_CODE_ID_DESC',
  OutQuantityAsc = 'OUT_QUANTITY_ASC',
  OutQuantityDesc = 'OUT_QUANTITY_DESC',
  OutWeightAsc = 'OUT_WEIGHT_ASC',
  OutWeightDesc = 'OUT_WEIGHT_DESC',
  ProductionCodeIdAsc = 'PRODUCTION_CODE_ID_ASC',
  ProductionCodeIdDesc = 'PRODUCTION_CODE_ID_DESC',
  TreeRipeIdAsc = 'TREE_RIPE_ID_ASC',
  TreeRipeIdDesc = 'TREE_RIPE_ID_DESC',
  GradeCodeIdAsc = 'GRADE_CODE_ID_ASC',
  GradeCodeIdDesc = 'GRADE_CODE_ID_DESC',
  MaCodeIdAsc = 'MA_CODE_ID_ASC',
  MaCodeIdDesc = 'MA_CODE_ID_DESC',
  LinerCodeIdAsc = 'LINER_CODE_ID_ASC',
  LinerCodeIdDesc = 'LINER_CODE_ID_DESC',
  NetWeightContentsAsc = 'NET_WEIGHT_CONTENTS_ASC',
  NetWeightContentsDesc = 'NET_WEIGHT_CONTENTS_DESC',
  NetWeightBoxAsc = 'NET_WEIGHT_BOX_ASC',
  NetWeightBoxDesc = 'NET_WEIGHT_BOX_DESC',
  BoxLengthAsc = 'BOX_LENGTH_ASC',
  BoxLengthDesc = 'BOX_LENGTH_DESC',
  BoxWidthAsc = 'BOX_WIDTH_ASC',
  BoxWidthDesc = 'BOX_WIDTH_DESC',
  BoxHeightAsc = 'BOX_HEIGHT_ASC',
  BoxHeightDesc = 'BOX_HEIGHT_DESC',
  PalletTypeIdAsc = 'PALLET_TYPE_ID_ASC',
  PalletTypeIdDesc = 'PALLET_TYPE_ID_DESC',
  DefaultPalletQuantityAsc = 'DEFAULT_PALLET_QUANTITY_ASC',
  DefaultPalletQuantityDesc = 'DEFAULT_PALLET_QUANTITY_DESC',
  PluUpcCodeAsc = 'PLU_UPC_CODE_ASC',
  PluUpcCodeDesc = 'PLU_UPC_CODE_DESC',
  DestinationCodeIdAsc = 'DESTINATION_CODE_ID_ASC',
  DestinationCodeIdDesc = 'DESTINATION_CODE_ID_DESC',
  OldPackCodeAsc = 'OLD_PACK_CODE_ASC',
  OldPackCodeDesc = 'OLD_PACK_CODE_DESC',
  OldLabelCodeAsc = 'OLD_LABEL_CODE_ASC',
  OldLabelCodeDesc = 'OLD_LABEL_CODE_DESC',
  JvPackCodeAsc = 'JV_PACK_CODE_ASC',
  JvPackCodeDesc = 'JV_PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  VarietyIdAsc = 'VARIETY_ID_ASC',
  VarietyIdDesc = 'VARIETY_ID_DESC',
  SpeciesIdAsc = 'SPECIES_ID_ASC',
  SpeciesIdDesc = 'SPECIES_ID_DESC',
  HoldCodeIdAsc = 'HOLD_CODE_ID_ASC',
  HoldCodeIdDesc = 'HOLD_CODE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonPackTypesByPackMasterIdCountAsc = 'COMMON_PACK_TYPES_BY_PACK_MASTER_ID__COUNT_ASC',
  CommonPackTypesByPackMasterIdCountDesc = 'COMMON_PACK_TYPES_BY_PACK_MASTER_ID__COUNT_DESC',
  CommonPackTypePackMastersByPackMasterIdCountAsc = 'COMMON_PACK_TYPE_PACK_MASTERS_BY_PACK_MASTER_ID__COUNT_ASC',
  CommonPackTypePackMastersByPackMasterIdCountDesc = 'COMMON_PACK_TYPE_PACK_MASTERS_BY_PACK_MASTER_ID__COUNT_DESC'
}

export type PackOut = Node & {
  __typename?: 'PackOut';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  outCode?: Maybe<Scalars['String']>;
  outDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/** A condition to be used against `PackOut` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PackOutCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outCode` field. */
  outCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outDescription` field. */
  outDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackOut` object types. All fields are combined with a logical ‘and.’ */
export type PackOutFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `outCode` field. */
  outCode?: Maybe<StringFilter>;
  /** Filter by the object’s `outDescription` field. */
  outDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackOutFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackOutFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackOutFilter>;
};

/** An input for mutations affecting `PackOut` */
export type PackOutInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  outCode?: Maybe<Scalars['String']>;
  outDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackOut`. Fields that are set will be updated. */
export type PackOutPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  outCode?: Maybe<Scalars['String']>;
  outDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackOut` values. */
export type PackOutsConnection = {
  __typename?: 'PackOutsConnection';
  /** A list of `PackOut` objects. */
  nodes: Array<Maybe<PackOut>>;
  /** A list of edges which contains the `PackOut` and cursor to aid in pagination. */
  edges: Array<PackOutsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackOut` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackOut` edge in the connection. */
export type PackOutsEdge = {
  __typename?: 'PackOutsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackOut` at the end of the edge. */
  node?: Maybe<PackOut>;
};

/** Methods to use when ordering `PackOut`. */
export enum PackOutsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  OutCodeAsc = 'OUT_CODE_ASC',
  OutCodeDesc = 'OUT_CODE_DESC',
  OutDescriptionAsc = 'OUT_DESCRIPTION_ASC',
  OutDescriptionDesc = 'OUT_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackPalletType = Node & {
  __typename?: 'PackPalletType';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  palletType?: Maybe<Scalars['String']>;
  palletTypeDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackPalletType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackPalletTypeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletType` field. */
  palletType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletTypeDescription` field. */
  palletTypeDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackPalletType` object types. All fields are combined with a logical ‘and.’ */
export type PackPalletTypeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `palletType` field. */
  palletType?: Maybe<StringFilter>;
  /** Filter by the object’s `palletTypeDescription` field. */
  palletTypeDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackPalletTypeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackPalletTypeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackPalletTypeFilter>;
};

/** An input for mutations affecting `PackPalletType` */
export type PackPalletTypeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  palletType?: Maybe<Scalars['String']>;
  palletTypeDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackPalletType`. Fields that are set will be updated. */
export type PackPalletTypePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  palletType?: Maybe<Scalars['String']>;
  palletTypeDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackPalletType` values. */
export type PackPalletTypesConnection = {
  __typename?: 'PackPalletTypesConnection';
  /** A list of `PackPalletType` objects. */
  nodes: Array<Maybe<PackPalletType>>;
  /** A list of edges which contains the `PackPalletType` and cursor to aid in pagination. */
  edges: Array<PackPalletTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackPalletType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackPalletType` edge in the connection. */
export type PackPalletTypesEdge = {
  __typename?: 'PackPalletTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackPalletType` at the end of the edge. */
  node?: Maybe<PackPalletType>;
};

/** Methods to use when ordering `PackPalletType`. */
export enum PackPalletTypesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PalletTypeAsc = 'PALLET_TYPE_ASC',
  PalletTypeDesc = 'PALLET_TYPE_DESC',
  PalletTypeDescriptionAsc = 'PALLET_TYPE_DESCRIPTION_ASC',
  PalletTypeDescriptionDesc = 'PALLET_TYPE_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackProduction = Node & {
  __typename?: 'PackProduction';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  productionCode?: Maybe<Scalars['String']>;
  productionDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackProduction` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackProductionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productionCode` field. */
  productionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productionDescription` field. */
  productionDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackProduction` object types. All fields are combined with a logical ‘and.’ */
export type PackProductionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `productionCode` field. */
  productionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `productionDescription` field. */
  productionDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackProductionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackProductionFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackProductionFilter>;
};

/** An input for mutations affecting `PackProduction` */
export type PackProductionInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  productionCode?: Maybe<Scalars['String']>;
  productionDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackProduction`. Fields that are set will be updated. */
export type PackProductionPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  productionCode?: Maybe<Scalars['String']>;
  productionDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackProduction` values. */
export type PackProductionsConnection = {
  __typename?: 'PackProductionsConnection';
  /** A list of `PackProduction` objects. */
  nodes: Array<Maybe<PackProduction>>;
  /** A list of edges which contains the `PackProduction` and cursor to aid in pagination. */
  edges: Array<PackProductionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackProduction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackProduction` edge in the connection. */
export type PackProductionsEdge = {
  __typename?: 'PackProductionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackProduction` at the end of the edge. */
  node?: Maybe<PackProduction>;
};

/** Methods to use when ordering `PackProduction`. */
export enum PackProductionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  ProductionCodeAsc = 'PRODUCTION_CODE_ASC',
  ProductionCodeDesc = 'PRODUCTION_CODE_DESC',
  ProductionDescriptionAsc = 'PRODUCTION_DESCRIPTION_ASC',
  ProductionDescriptionDesc = 'PRODUCTION_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackSpecial = Node & {
  __typename?: 'PackSpecial';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  customerCode?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  customer?: Maybe<Customer>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackSpecial` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackSpecialCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerCode` field. */
  customerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerName` field. */
  customerName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackSpecial` object types. All fields are combined with a logical ‘and.’ */
export type PackSpecialFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `customerCode` field. */
  customerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `customerName` field. */
  customerName?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackSpecialFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackSpecialFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackSpecialFilter>;
};

/** An input for mutations affecting `PackSpecial` */
export type PackSpecialInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  customerCode?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackSpecial`. Fields that are set will be updated. */
export type PackSpecialPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  customerCode?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackSpecial` values. */
export type PackSpecialsConnection = {
  __typename?: 'PackSpecialsConnection';
  /** A list of `PackSpecial` objects. */
  nodes: Array<Maybe<PackSpecial>>;
  /** A list of edges which contains the `PackSpecial` and cursor to aid in pagination. */
  edges: Array<PackSpecialsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackSpecial` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackSpecial` edge in the connection. */
export type PackSpecialsEdge = {
  __typename?: 'PackSpecialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackSpecial` at the end of the edge. */
  node?: Maybe<PackSpecial>;
};

/** Methods to use when ordering `PackSpecial`. */
export enum PackSpecialsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  CustomerCodeAsc = 'CUSTOMER_CODE_ASC',
  CustomerCodeDesc = 'CUSTOMER_CODE_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  CustomerNameAsc = 'CUSTOMER_NAME_ASC',
  CustomerNameDesc = 'CUSTOMER_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackStyle = Node & {
  __typename?: 'PackStyle';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  packStyle?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackStyle` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PackStyleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packStyle` field. */
  packStyle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `styleDescription` field. */
  styleDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackStyle` object types. All fields are combined with a logical ‘and.’ */
export type PackStyleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `packStyle` field. */
  packStyle?: Maybe<StringFilter>;
  /** Filter by the object’s `styleDescription` field. */
  styleDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackStyleFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackStyleFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackStyleFilter>;
};

/** An input for mutations affecting `PackStyle` */
export type PackStyleInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  packStyle?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackStyle`. Fields that are set will be updated. */
export type PackStylePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  packStyle?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackStyle` values. */
export type PackStylesConnection = {
  __typename?: 'PackStylesConnection';
  /** A list of `PackStyle` objects. */
  nodes: Array<Maybe<PackStyle>>;
  /** A list of edges which contains the `PackStyle` and cursor to aid in pagination. */
  edges: Array<PackStylesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackStyle` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackStyle` edge in the connection. */
export type PackStylesEdge = {
  __typename?: 'PackStylesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackStyle` at the end of the edge. */
  node?: Maybe<PackStyle>;
};

/** Methods to use when ordering `PackStyle`. */
export enum PackStylesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PackStyleAsc = 'PACK_STYLE_ASC',
  PackStyleDesc = 'PACK_STYLE_DESC',
  StyleDescriptionAsc = 'STYLE_DESCRIPTION_ASC',
  StyleDescriptionDesc = 'STYLE_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PackTreeRipe = Node & {
  __typename?: 'PackTreeRipe';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  treeRipe?: Maybe<Scalars['String']>;
  treeRipeDescription?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `PackTreeRipe` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PackTreeRipeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treeRipe` field. */
  treeRipe?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `treeRipeDescription` field. */
  treeRipeDescription?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PackTreeRipe` object types. All fields are combined with a logical ‘and.’ */
export type PackTreeRipeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `treeRipe` field. */
  treeRipe?: Maybe<StringFilter>;
  /** Filter by the object’s `treeRipeDescription` field. */
  treeRipeDescription?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PackTreeRipeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PackTreeRipeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PackTreeRipeFilter>;
};

/** An input for mutations affecting `PackTreeRipe` */
export type PackTreeRipeInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  treeRipe?: Maybe<Scalars['String']>;
  treeRipeDescription?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PackTreeRipe`. Fields that are set will be updated. */
export type PackTreeRipePatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  treeRipe?: Maybe<Scalars['String']>;
  treeRipeDescription?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PackTreeRipe` values. */
export type PackTreeRipesConnection = {
  __typename?: 'PackTreeRipesConnection';
  /** A list of `PackTreeRipe` objects. */
  nodes: Array<Maybe<PackTreeRipe>>;
  /** A list of edges which contains the `PackTreeRipe` and cursor to aid in pagination. */
  edges: Array<PackTreeRipesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PackTreeRipe` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PackTreeRipe` edge in the connection. */
export type PackTreeRipesEdge = {
  __typename?: 'PackTreeRipesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PackTreeRipe` at the end of the edge. */
  node?: Maybe<PackTreeRipe>;
};

/** Methods to use when ordering `PackTreeRipe`. */
export enum PackTreeRipesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  TreeRipeAsc = 'TREE_RIPE_ASC',
  TreeRipeDesc = 'TREE_RIPE_DESC',
  TreeRipeDescriptionAsc = 'TREE_RIPE_DESCRIPTION_ASC',
  TreeRipeDescriptionDesc = 'TREE_RIPE_DESCRIPTION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

export type Pallet = Node & {
  __typename?: 'Pallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselCode: Scalars['String'];
  palletId: Scalars['String'];
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
  filler?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
  container?: Maybe<Container>;
  /** Reads and enables pagination through a set of `InvoiceItem`. */
  invoiceItems: InvoiceItemsConnection;
  /** Reads and enables pagination through a set of `InvoiceHeader`. */
  invoices: InvoiceHeadersConnection;
  originalLocation?: Maybe<Warehouse>;
  packType?: Maybe<PackMaster>;
  /** Reads and enables pagination through a set of `PalletSection`. */
  palletSections: PalletSectionsConnection;
  product?: Maybe<ProductMaster>;
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  /** Reads and enables pagination through a set of `RepackHeader`. */
  repacks: RepackHeadersConnection;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ProductSize`. */
  sizes: ProductSizesConnection;
  vessel?: Maybe<Vessel>;
  warehouse?: Maybe<Warehouse>;
};


export type PalletInvoiceItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceItemFilter>;
};


export type PalletInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceHeaderFilter>;
};


export type PalletPalletSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletSectionFilter>;
};


export type PalletRepacksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<RepackHeaderFilter>;
};


export type PalletSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ProductSizeFilter>;
};

/** A condition to be used against `Pallet` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `currentBoxQuantity` field. */
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `receivedBoxQuantity` field. */
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `returnedBoxQuantity` field. */
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `locationId` field. */
  locationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `room` field. */
  room?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `section` field. */
  section?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `row` field. */
  row?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateTransferredToStorage` field. */
  dateTransferredToStorage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `backOrderId` field. */
  backOrderId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipped` field. */
  shipped?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `age` field. */
  age?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `originalLocationId` field. */
  originalLocationId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `filler` field. */
  filler?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerId` field. */
  growerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `billOfLading` field. */
  billOfLading?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `temperatureRecording` field. */
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Pallet` object types. All fields are combined with a logical ‘and.’ */
export type PalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<StringFilter>;
  /** Filter by the object’s `currentBoxQuantity` field. */
  currentBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `receivedBoxQuantity` field. */
  receivedBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `returnedBoxQuantity` field. */
  returnedBoxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `locationId` field. */
  locationId?: Maybe<StringFilter>;
  /** Filter by the object’s `room` field. */
  room?: Maybe<StringFilter>;
  /** Filter by the object’s `section` field. */
  section?: Maybe<StringFilter>;
  /** Filter by the object’s `row` field. */
  row?: Maybe<StringFilter>;
  /** Filter by the object’s `jvLotNumber` field. */
  jvLotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `dateTransferredToStorage` field. */
  dateTransferredToStorage?: Maybe<StringFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<StringFilter>;
  /** Filter by the object’s `backOrderId` field. */
  backOrderId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipped` field. */
  shipped?: Maybe<BooleanFilter>;
  /** Filter by the object’s `age` field. */
  age?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `volumeDiscountCode` field. */
  volumeDiscountCode?: Maybe<StringFilter>;
  /** Filter by the object’s `originalLocationId` field. */
  originalLocationId?: Maybe<StringFilter>;
  /** Filter by the object’s `filler` field. */
  filler?: Maybe<StringFilter>;
  /** Filter by the object’s `growerId` field. */
  growerId?: Maybe<StringFilter>;
  /** Filter by the object’s `oldPackCode` field. */
  oldPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `billOfLading` field. */
  billOfLading?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `temperatureRecording` field. */
  temperatureRecording?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PalletFilter>;
};

/** An input for mutations affecting `Pallet` */
export type PalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  palletId: Scalars['String'];
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
  filler?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
};

/** Represents an update to a `Pallet`. Fields that are set will be updated. */
export type PalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  productId?: Maybe<Scalars['String']>;
  currentBoxQuantity?: Maybe<Scalars['BigFloat']>;
  receivedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  returnedBoxQuantity?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  room?: Maybe<Scalars['String']>;
  section?: Maybe<Scalars['String']>;
  row?: Maybe<Scalars['String']>;
  jvLotNumber?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  dateTransferredToStorage?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['String']>;
  backOrderId?: Maybe<Scalars['String']>;
  shipped?: Maybe<Scalars['Boolean']>;
  age?: Maybe<Scalars['BigFloat']>;
  volumeDiscountCode?: Maybe<Scalars['String']>;
  originalLocationId?: Maybe<Scalars['String']>;
  filler?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  billOfLading?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  temperatureRecording?: Maybe<Scalars['String']>;
};

export type PalletSection = Node & {
  __typename?: 'PalletSection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletId: Scalars['String'];
  growerId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  sizeId?: Maybe<Scalars['String']>;
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  packDate?: Maybe<Scalars['String']>;
  variety?: Maybe<ProductVariety>;
};

/**
 * A condition to be used against `PalletSection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PalletSectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerId` field. */
  growerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyId` field. */
  varietyId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeId` field. */
  sizeId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxQuantity` field. */
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PalletSection` object types. All fields are combined with a logical ‘and.’ */
export type PalletSectionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerId` field. */
  growerId?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyId` field. */
  varietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeId` field. */
  sizeId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxQuantity` field. */
  boxQuantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PalletSectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PalletSectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<PalletSectionFilter>;
};

/** An input for mutations affecting `PalletSection` */
export type PalletSectionInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletId: Scalars['String'];
  growerId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  sizeId?: Maybe<Scalars['String']>;
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  packDate?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PalletSection`. Fields that are set will be updated. */
export type PalletSectionPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  growerId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  sizeId?: Maybe<Scalars['String']>;
  boxQuantity?: Maybe<Scalars['BigFloat']>;
  packDate?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PalletSection` values. */
export type PalletSectionsConnection = {
  __typename?: 'PalletSectionsConnection';
  /** A list of `PalletSection` objects. */
  nodes: Array<Maybe<PalletSection>>;
  /** A list of edges which contains the `PalletSection` and cursor to aid in pagination. */
  edges: Array<PalletSectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PalletSection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PalletSection` edge in the connection. */
export type PalletSectionsEdge = {
  __typename?: 'PalletSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PalletSection` at the end of the edge. */
  node?: Maybe<PalletSection>;
};

/** Methods to use when ordering `PalletSection`. */
export enum PalletSectionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerIdAsc = 'GROWER_ID_ASC',
  GrowerIdDesc = 'GROWER_ID_DESC',
  VarietyIdAsc = 'VARIETY_ID_ASC',
  VarietyIdDesc = 'VARIETY_ID_DESC',
  SizeIdAsc = 'SIZE_ID_ASC',
  SizeIdDesc = 'SIZE_ID_DESC',
  BoxQuantityAsc = 'BOX_QUANTITY_ASC',
  BoxQuantityDesc = 'BOX_QUANTITY_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Pallet` values. */
export type PalletsConnection = {
  __typename?: 'PalletsConnection';
  /** A list of `Pallet` objects. */
  nodes: Array<Maybe<Pallet>>;
  /** A list of edges which contains the `Pallet` and cursor to aid in pagination. */
  edges: Array<PalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Pallet` edge in the connection. */
export type PalletsEdge = {
  __typename?: 'PalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Pallet` at the end of the edge. */
  node?: Maybe<Pallet>;
};

/** Methods to use when ordering `Pallet`. */
export enum PalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  CurrentBoxQuantityAsc = 'CURRENT_BOX_QUANTITY_ASC',
  CurrentBoxQuantityDesc = 'CURRENT_BOX_QUANTITY_DESC',
  ReceivedBoxQuantityAsc = 'RECEIVED_BOX_QUANTITY_ASC',
  ReceivedBoxQuantityDesc = 'RECEIVED_BOX_QUANTITY_DESC',
  ReturnedBoxQuantityAsc = 'RETURNED_BOX_QUANTITY_ASC',
  ReturnedBoxQuantityDesc = 'RETURNED_BOX_QUANTITY_DESC',
  LocationIdAsc = 'LOCATION_ID_ASC',
  LocationIdDesc = 'LOCATION_ID_DESC',
  RoomAsc = 'ROOM_ASC',
  RoomDesc = 'ROOM_DESC',
  SectionAsc = 'SECTION_ASC',
  SectionDesc = 'SECTION_DESC',
  RowAsc = 'ROW_ASC',
  RowDesc = 'ROW_DESC',
  JvLotNumberAsc = 'JV_LOT_NUMBER_ASC',
  JvLotNumberDesc = 'JV_LOT_NUMBER_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  DateTransferredToStorageAsc = 'DATE_TRANSFERRED_TO_STORAGE_ASC',
  DateTransferredToStorageDesc = 'DATE_TRANSFERRED_TO_STORAGE_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  BackOrderIdAsc = 'BACK_ORDER_ID_ASC',
  BackOrderIdDesc = 'BACK_ORDER_ID_DESC',
  ShippedAsc = 'SHIPPED_ASC',
  ShippedDesc = 'SHIPPED_DESC',
  AgeAsc = 'AGE_ASC',
  AgeDesc = 'AGE_DESC',
  VolumeDiscountCodeAsc = 'VOLUME_DISCOUNT_CODE_ASC',
  VolumeDiscountCodeDesc = 'VOLUME_DISCOUNT_CODE_DESC',
  OriginalLocationIdAsc = 'ORIGINAL_LOCATION_ID_ASC',
  OriginalLocationIdDesc = 'ORIGINAL_LOCATION_ID_DESC',
  FillerAsc = 'FILLER_ASC',
  FillerDesc = 'FILLER_DESC',
  GrowerIdAsc = 'GROWER_ID_ASC',
  GrowerIdDesc = 'GROWER_ID_DESC',
  OldPackCodeAsc = 'OLD_PACK_CODE_ASC',
  OldPackCodeDesc = 'OLD_PACK_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  BillOfLadingAsc = 'BILL_OF_LADING_ASC',
  BillOfLadingDesc = 'BILL_OF_LADING_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  TemperatureRecordingAsc = 'TEMPERATURE_RECORDING_ASC',
  TemperatureRecordingDesc = 'TEMPERATURE_RECORDING_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PersonContact = Node & {
  __typename?: 'PersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `ContactGroupPersonContact`. */
  contactGroupPersonContacts: ContactGroupPersonContactsConnection;
  /** Reads and enables pagination through a set of `User`. */
  users: UsersConnection;
  /** Reads and enables pagination through a set of `CustomerPersonContact`. */
  customerPersonContacts: CustomerPersonContactsConnection;
  /** Reads and enables pagination through a set of `ShipperPersonContact`. */
  shipperPersonContacts: ShipperPersonContactsConnection;
  /** Reads and enables pagination through a set of `WarehousePersonContact`. */
  warehousePersonContacts: WarehousePersonContactsConnection;
  /** Reads and enables pagination through a set of `VendorPersonContact`. */
  vendorPersonContacts: VendorPersonContactsConnection;
  searchText?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `ContactGroup`. */
  contactGroupsByContactGroupPersonContactPersonContactIdAndGroupId: PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByCustomerPersonContactPersonContactIdAndCustomerId: PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperPersonContactPersonContactIdAndShipperId: PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Warehouse`. */
  warehousesByWarehousePersonContactPersonContactIdAndWarehouseId: PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Vendor`. */
  vendorsByVendorPersonContactPersonContactIdAndVendorId: PersonContactVendorsByVendorPersonContactPersonContactIdAndVendorIdManyToManyConnection;
};


export type PersonContactContactGroupPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
  condition?: Maybe<ContactGroupPersonContactCondition>;
  filter?: Maybe<ContactGroupPersonContactFilter>;
};


export type PersonContactUsersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
};


export type PersonContactCustomerPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
  condition?: Maybe<CustomerPersonContactCondition>;
  filter?: Maybe<CustomerPersonContactFilter>;
};


export type PersonContactShipperPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
  condition?: Maybe<ShipperPersonContactCondition>;
  filter?: Maybe<ShipperPersonContactFilter>;
};


export type PersonContactWarehousePersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
  condition?: Maybe<WarehousePersonContactCondition>;
  filter?: Maybe<WarehousePersonContactFilter>;
};


export type PersonContactVendorPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VendorPersonContactsOrderBy>>;
  condition?: Maybe<VendorPersonContactCondition>;
  filter?: Maybe<VendorPersonContactFilter>;
};


export type PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
  condition?: Maybe<ContactGroupCondition>;
  filter?: Maybe<ContactGroupFilter>;
};


export type PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


export type PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
  condition?: Maybe<WarehouseCondition>;
  filter?: Maybe<WarehouseFilter>;
};


export type PersonContactVendorsByVendorPersonContactPersonContactIdAndVendorIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VendorsOrderBy>>;
  condition?: Maybe<VendorCondition>;
  filter?: Maybe<VendorFilter>;
};

/**
 * A condition to be used against `PersonContact` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PersonContactCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPrimary` field. */
  isPrimary?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryEmail` field. */
  secondaryEmail?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `homePhone` field. */
  homePhone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cellPhone` field. */
  cellPhone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `workPhone` field. */
  workPhone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `workExtension` field. */
  workExtension?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imageSrc` field. */
  imageSrc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isInternal` field. */
  isInternal?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `roles` field. */
  roles?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `homeExtension` field. */
  homeExtension?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ContactGroup` values, with data from `ContactGroupPersonContact`. */
export type PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyConnection = {
  __typename?: 'PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyConnection';
  /** A list of `ContactGroup` objects. */
  nodes: Array<Maybe<ContactGroup>>;
  /** A list of edges which contains the `ContactGroup`, info from the `ContactGroupPersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContactGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ContactGroup` edge in the connection, with data from `ContactGroupPersonContact`. */
export type PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyEdge = {
  __typename?: 'PersonContactContactGroupsByContactGroupPersonContactPersonContactIdAndGroupIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContactGroup` at the end of the edge. */
  node?: Maybe<ContactGroup>;
};

/** A connection to a list of `Customer` values, with data from `CustomerPersonContact`. */
export type PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyConnection = {
  __typename?: 'PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `CustomerPersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `CustomerPersonContact`. */
export type PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyEdge = {
  __typename?: 'PersonContactCustomersByCustomerPersonContactPersonContactIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** A filter to be used against `PersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `isPrimary` field. */
  isPrimary?: Maybe<BooleanFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryEmail` field. */
  secondaryEmail?: Maybe<StringFilter>;
  /** Filter by the object’s `homePhone` field. */
  homePhone?: Maybe<StringFilter>;
  /** Filter by the object’s `cellPhone` field. */
  cellPhone?: Maybe<StringFilter>;
  /** Filter by the object’s `workPhone` field. */
  workPhone?: Maybe<StringFilter>;
  /** Filter by the object’s `workExtension` field. */
  workExtension?: Maybe<StringFilter>;
  /** Filter by the object’s `imageSrc` field. */
  imageSrc?: Maybe<StringFilter>;
  /** Filter by the object’s `isInternal` field. */
  isInternal?: Maybe<BooleanFilter>;
  /** Filter by the object’s `roles` field. */
  roles?: Maybe<StringFilter>;
  /** Filter by the object’s `homeExtension` field. */
  homeExtension?: Maybe<StringFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `contactGroupPersonContacts` relation. */
  contactGroupPersonContacts?: Maybe<PersonContactToManyContactGroupPersonContactFilter>;
  /** Some related `contactGroupPersonContacts` exist. */
  contactGroupPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `users` relation. */
  users?: Maybe<PersonContactToManyUserFilter>;
  /** Some related `users` exist. */
  usersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customerPersonContacts` relation. */
  customerPersonContacts?: Maybe<PersonContactToManyCustomerPersonContactFilter>;
  /** Some related `customerPersonContacts` exist. */
  customerPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPersonContacts` relation. */
  shipperPersonContacts?: Maybe<PersonContactToManyShipperPersonContactFilter>;
  /** Some related `shipperPersonContacts` exist. */
  shipperPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `warehousePersonContacts` relation. */
  warehousePersonContacts?: Maybe<PersonContactToManyWarehousePersonContactFilter>;
  /** Some related `warehousePersonContacts` exist. */
  warehousePersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `vendorPersonContacts` relation. */
  vendorPersonContacts?: Maybe<PersonContactToManyVendorPersonContactFilter>;
  /** Some related `vendorPersonContacts` exist. */
  vendorPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<PersonContactFilter>;
};

/** An input for mutations affecting `PersonContact` */
export type PersonContactInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `personContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroupPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnUserForUserPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnUserForUserPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnUserForUserPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `vendorPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `vendorPersonContact` being updated. */
  patch: VendorPersonContactPatch;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
};

/** The fields on `personContact` to look up the row to update. */
export type PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: UpdatePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `PersonContact`. Fields that are set will be updated. */
export type PersonContactPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** The fields on `personContact` to look up the row to connect. */
export type PersonContactPersonContactPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `personContact` to look up the row to delete. */
export type PersonContactPersonContactPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `Shipper` values, with data from `ShipperPersonContact`. */
export type PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyConnection = {
  __typename?: 'PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperPersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperPersonContact`. */
export type PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyEdge = {
  __typename?: 'PersonContactShippersByShipperPersonContactPersonContactIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
};

/** A filter to be used against many `ContactGroupPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyContactGroupPersonContactFilter = {
  /** Every related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ContactGroupPersonContactFilter>;
  /** Some related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ContactGroupPersonContactFilter>;
  /** No related `ContactGroupPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ContactGroupPersonContactFilter>;
};

/** A filter to be used against many `CustomerPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyCustomerPersonContactFilter = {
  /** Every related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerPersonContactFilter>;
  /** Some related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerPersonContactFilter>;
  /** No related `CustomerPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerPersonContactFilter>;
};

/** A filter to be used against many `ShipperPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyShipperPersonContactFilter = {
  /** Every related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperPersonContactFilter>;
  /** Some related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperPersonContactFilter>;
  /** No related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperPersonContactFilter>;
};

/** A filter to be used against many `User` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyUserFilter = {
  /** Every related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserFilter>;
  /** Some related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserFilter>;
  /** No related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserFilter>;
};

/** A filter to be used against many `VendorPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyVendorPersonContactFilter = {
  /** Every related `VendorPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<VendorPersonContactFilter>;
  /** Some related `VendorPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<VendorPersonContactFilter>;
  /** No related `VendorPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<VendorPersonContactFilter>;
};

/** A filter to be used against many `WarehousePersonContact` object types. All fields are combined with a logical ‘and.’ */
export type PersonContactToManyWarehousePersonContactFilter = {
  /** Every related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WarehousePersonContactFilter>;
  /** Some related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WarehousePersonContactFilter>;
  /** No related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WarehousePersonContactFilter>;
};

/** A connection to a list of `Vendor` values, with data from `VendorPersonContact`. */
export type PersonContactVendorsByVendorPersonContactPersonContactIdAndVendorIdManyToManyConnection = {
  __typename?: 'PersonContactVendorsByVendorPersonContactPersonContactIdAndVendorIdManyToManyConnection';
  /** A list of `Vendor` objects. */
  nodes: Array<Maybe<Vendor>>;
  /** A list of edges which contains the `Vendor`, info from the `VendorPersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactVendorsByVendorPersonContactPersonContactIdAndVendorIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vendor` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Vendor` edge in the connection, with data from `VendorPersonContact`. */
export type PersonContactVendorsByVendorPersonContactPersonContactIdAndVendorIdManyToManyEdge = {
  __typename?: 'PersonContactVendorsByVendorPersonContactPersonContactIdAndVendorIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vendor` at the end of the edge. */
  node?: Maybe<Vendor>;
};

/** A connection to a list of `Warehouse` values, with data from `WarehousePersonContact`. */
export type PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyConnection = {
  __typename?: 'PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyConnection';
  /** A list of `Warehouse` objects. */
  nodes: Array<Maybe<Warehouse>>;
  /** A list of edges which contains the `Warehouse`, info from the `WarehousePersonContact`, and the cursor to aid in pagination. */
  edges: Array<PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Warehouse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Warehouse` edge in the connection, with data from `WarehousePersonContact`. */
export type PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyEdge = {
  __typename?: 'PersonContactWarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Warehouse` at the end of the edge. */
  node?: Maybe<Warehouse>;
};

/** A connection to a list of `PersonContact` values. */
export type PersonContactsConnection = {
  __typename?: 'PersonContactsConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact` and cursor to aid in pagination. */
  edges: Array<PersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection. */
export type PersonContactsEdge = {
  __typename?: 'PersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** Methods to use when ordering `PersonContact`. */
export enum PersonContactsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  IsPrimaryAsc = 'IS_PRIMARY_ASC',
  IsPrimaryDesc = 'IS_PRIMARY_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  SecondaryEmailAsc = 'SECONDARY_EMAIL_ASC',
  SecondaryEmailDesc = 'SECONDARY_EMAIL_DESC',
  HomePhoneAsc = 'HOME_PHONE_ASC',
  HomePhoneDesc = 'HOME_PHONE_DESC',
  CellPhoneAsc = 'CELL_PHONE_ASC',
  CellPhoneDesc = 'CELL_PHONE_DESC',
  WorkPhoneAsc = 'WORK_PHONE_ASC',
  WorkPhoneDesc = 'WORK_PHONE_DESC',
  WorkExtensionAsc = 'WORK_EXTENSION_ASC',
  WorkExtensionDesc = 'WORK_EXTENSION_DESC',
  ImageSrcAsc = 'IMAGE_SRC_ASC',
  ImageSrcDesc = 'IMAGE_SRC_DESC',
  IsInternalAsc = 'IS_INTERNAL_ASC',
  IsInternalDesc = 'IS_INTERNAL_DESC',
  RolesAsc = 'ROLES_ASC',
  RolesDesc = 'ROLES_DESC',
  HomeExtensionAsc = 'HOME_EXTENSION_ASC',
  HomeExtensionDesc = 'HOME_EXTENSION_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ContactGroupPersonContactsByPersonContactIdCountAsc = 'CONTACT_GROUP_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_ASC',
  ContactGroupPersonContactsByPersonContactIdCountDesc = 'CONTACT_GROUP_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_DESC',
  UsersByPersonContactIdCountAsc = 'USERS_BY_PERSON_CONTACT_ID__COUNT_ASC',
  UsersByPersonContactIdCountDesc = 'USERS_BY_PERSON_CONTACT_ID__COUNT_DESC',
  CustomerPersonContactsByPersonContactIdCountAsc = 'CUSTOMER_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_ASC',
  CustomerPersonContactsByPersonContactIdCountDesc = 'CUSTOMER_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_DESC',
  ShipperPersonContactsByPersonContactIdCountAsc = 'SHIPPER_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_ASC',
  ShipperPersonContactsByPersonContactIdCountDesc = 'SHIPPER_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_DESC',
  WarehousePersonContactsByPersonContactIdCountAsc = 'WAREHOUSE_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_ASC',
  WarehousePersonContactsByPersonContactIdCountDesc = 'WAREHOUSE_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_DESC',
  VendorPersonContactsByPersonContactIdCountAsc = 'VENDOR_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_ASC',
  VendorPersonContactsByPersonContactIdCountDesc = 'VENDOR_PERSON_CONTACTS_BY_PERSON_CONTACT_ID__COUNT_DESC',
  CustomersByCustomerPersonContactPersonContactIdAndCustomerIdAsc = 'CUSTOMERS_BY_CUSTOMER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_CUSTOMER_ID_ASC',
  CustomersByCustomerPersonContactPersonContactIdAndCustomerIdDesc = 'CUSTOMERS_BY_CUSTOMER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_CUSTOMER_ID_DESC',
  ShippersByShipperPersonContactPersonContactIdAndShipperIdAsc = 'SHIPPERS_BY_SHIPPER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_SHIPPER_ID_ASC',
  ShippersByShipperPersonContactPersonContactIdAndShipperIdDesc = 'SHIPPERS_BY_SHIPPER_PERSON_CONTACT_PERSON_CONTACT_ID_AND_SHIPPER_ID_DESC',
  WarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdAsc = 'WAREHOUSES_BY_WAREHOUSE_PERSON_CONTACT_PERSON_CONTACT_ID_AND_WAREHOUSE_ID_ASC',
  WarehousesByWarehousePersonContactPersonContactIdAndWarehouseIdDesc = 'WAREHOUSES_BY_WAREHOUSE_PERSON_CONTACT_PERSON_CONTACT_ID_AND_WAREHOUSE_ID_DESC'
}

export type PeruDepartureInspection = Node & {
  __typename?: 'PeruDepartureInspection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  containerId: Scalars['String'];
  avgBunchesPerBox: Scalars['BigFloat'];
  avgNetWeight: Scalars['BigFloat'];
  bagsPerBox: Scalars['BigFloat'];
  bagType?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  brixAvg: Scalars['BigFloat'];
  brixMax: Scalars['BigFloat'];
  brixMin: Scalars['BigFloat'];
  category: Scalars['String'];
  comments: Scalars['String'];
  conditionScore: Scalars['BigFloat'];
  departureWeek: Scalars['String'];
  destination: Scalars['String'];
  exporter: Scalars['String'];
  inspectionDate: Scalars['Date'];
  packingDate: Scalars['Date'];
  packingHouse: Scalars['String'];
  packingMaterial: Scalars['String'];
  presentation: Scalars['String'];
  qualityScore: Scalars['BigFloat'];
  variety: Scalars['String'];
  /** Reads and enables pagination through a set of `PeruDepartureInspectionPallet`. */
  peruDepartureInspectionPalletsByContainerId: PeruDepartureInspectionPalletsConnection;
  searchText?: Maybe<Scalars['String']>;
  imageUrls?: Maybe<Array<Scalars['String']>>;
};


export type PeruDepartureInspectionPeruDepartureInspectionPalletsByContainerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
  condition?: Maybe<PeruDepartureInspectionPalletCondition>;
  filter?: Maybe<PeruDepartureInspectionPalletFilter>;
};

/**
 * A condition to be used against `PeruDepartureInspection` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type PeruDepartureInspectionCondition = {
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `avgBunchesPerBox` field. */
  avgBunchesPerBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `avgNetWeight` field. */
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `bagsPerBox` field. */
  bagsPerBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `bagType` field. */
  bagType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brand` field. */
  brand?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixAvg` field. */
  brixAvg?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brixMax` field. */
  brixMax?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brixMin` field. */
  brixMin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `category` field. */
  category?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comments` field. */
  comments?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `conditionScore` field. */
  conditionScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `departureWeek` field. */
  departureWeek?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destination` field. */
  destination?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporter` field. */
  exporter?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `packingDate` field. */
  packingDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `packingHouse` field. */
  packingHouse?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packingMaterial` field. */
  packingMaterial?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `presentation` field. */
  presentation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `qualityScore` field. */
  qualityScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PeruDepartureInspection` object types. All fields are combined with a logical ‘and.’ */
export type PeruDepartureInspectionFilter = {
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `avgBunchesPerBox` field. */
  avgBunchesPerBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `avgNetWeight` field. */
  avgNetWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `bagsPerBox` field. */
  bagsPerBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `bagType` field. */
  bagType?: Maybe<StringFilter>;
  /** Filter by the object’s `brand` field. */
  brand?: Maybe<StringFilter>;
  /** Filter by the object’s `brixAvg` field. */
  brixAvg?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `category` field. */
  category?: Maybe<StringFilter>;
  /** Filter by the object’s `comments` field. */
  comments?: Maybe<StringFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `departureWeek` field. */
  departureWeek?: Maybe<StringFilter>;
  /** Filter by the object’s `destination` field. */
  destination?: Maybe<StringFilter>;
  /** Filter by the object’s `exporter` field. */
  exporter?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionDate` field. */
  inspectionDate?: Maybe<DateFilter>;
  /** Filter by the object’s `packingDate` field. */
  packingDate?: Maybe<DateFilter>;
  /** Filter by the object’s `packingHouse` field. */
  packingHouse?: Maybe<StringFilter>;
  /** Filter by the object’s `packingMaterial` field. */
  packingMaterial?: Maybe<StringFilter>;
  /** Filter by the object’s `presentation` field. */
  presentation?: Maybe<StringFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `peruDepartureInspectionPalletsByContainerId` relation. */
  peruDepartureInspectionPalletsByContainerId?: Maybe<PeruDepartureInspectionToManyPeruDepartureInspectionPalletFilter>;
  /** Some related `peruDepartureInspectionPalletsByContainerId` exist. */
  peruDepartureInspectionPalletsByContainerIdExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PeruDepartureInspectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PeruDepartureInspectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<PeruDepartureInspectionFilter>;
};

/** An input for mutations affecting `PeruDepartureInspection` */
export type PeruDepartureInspectionInput = {
  containerId: Scalars['String'];
  avgBunchesPerBox: Scalars['BigFloat'];
  avgNetWeight: Scalars['BigFloat'];
  bagsPerBox: Scalars['BigFloat'];
  bagType?: Maybe<Scalars['String']>;
  brand: Scalars['String'];
  brixAvg: Scalars['BigFloat'];
  brixMax: Scalars['BigFloat'];
  brixMin: Scalars['BigFloat'];
  category: Scalars['String'];
  comments: Scalars['String'];
  conditionScore: Scalars['BigFloat'];
  departureWeek: Scalars['String'];
  destination: Scalars['String'];
  exporter: Scalars['String'];
  inspectionDate: Scalars['Date'];
  packingDate: Scalars['Date'];
  packingHouse: Scalars['String'];
  packingMaterial: Scalars['String'];
  presentation: Scalars['String'];
  qualityScore: Scalars['BigFloat'];
  variety: Scalars['String'];
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PeruDepartureInspectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspection` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PeruDepartureInspectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspectionPallet` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `peruDepartureInspectionPallet` being updated. */
  patch: PeruDepartureInspectionPalletPatch;
};

/** The fields on `peruDepartureInspection` to look up the row to update. */
export type PeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `peruDepartureInspection` being updated. */
  patch: UpdatePeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerPatch;
  containerId: Scalars['String'];
};

export type PeruDepartureInspectionPallet = Node & {
  __typename?: 'PeruDepartureInspectionPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletId: Scalars['String'];
  containerId: Scalars['String'];
  size: Scalars['String'];
  netWeight: Scalars['BigFloat'];
  openingScore: Scalars['BigFloat'];
  colorScore: Scalars['BigFloat'];
  stemScore: Scalars['BigFloat'];
  textureScore: Scalars['BigFloat'];
  bunchesPerBox: Scalars['BigFloat'];
  brix: Scalars['BigFloat'];
  qualityScore: Scalars['BigFloat'];
  conditionScore: Scalars['BigFloat'];
  stragglyTightPct: Scalars['BigFloat'];
  surfaceDiscPct: Scalars['BigFloat'];
  russetScarsPct: Scalars['BigFloat'];
  sunburnPct: Scalars['BigFloat'];
  undersizedBunchesPct: Scalars['BigFloat'];
  otherDefectsPct: Scalars['BigFloat'];
  totalQualityDefectsPct: Scalars['BigFloat'];
  stemDehyPct: Scalars['BigFloat'];
  glassyWeakPct: Scalars['BigFloat'];
  decayPct: Scalars['BigFloat'];
  splitCrushedPct: Scalars['BigFloat'];
  drySplitPct: Scalars['BigFloat'];
  wetStickyPct: Scalars['BigFloat'];
  waterberriesPct: Scalars['BigFloat'];
  shatterPct: Scalars['BigFloat'];
  totalConditionDefectsPct: Scalars['BigFloat'];
  totalDefectsPct: Scalars['BigFloat'];
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
};

/**
 * A condition to be used against `PeruDepartureInspectionPallet` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type PeruDepartureInspectionPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `netWeight` field. */
  netWeight?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `openingScore` field. */
  openingScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `colorScore` field. */
  colorScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stemScore` field. */
  stemScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `textureScore` field. */
  textureScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `bunchesPerBox` field. */
  bunchesPerBox?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `qualityScore` field. */
  qualityScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `conditionScore` field. */
  conditionScore?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `shatterPct` field. */
  shatterPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `totalDefectsPct` field. */
  totalDefectsPct?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `PeruDepartureInspectionPallet` object types. All fields are combined with a logical ‘and.’ */
export type PeruDepartureInspectionPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `netWeight` field. */
  netWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `openingScore` field. */
  openingScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `colorScore` field. */
  colorScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stemScore` field. */
  stemScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `textureScore` field. */
  textureScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `bunchesPerBox` field. */
  bunchesPerBox?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `qualityScore` field. */
  qualityScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `conditionScore` field. */
  conditionScore?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stragglyTightPct` field. */
  stragglyTightPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `surfaceDiscPct` field. */
  surfaceDiscPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `russetScarsPct` field. */
  russetScarsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `undersizedBunchesPct` field. */
  undersizedBunchesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `otherDefectsPct` field. */
  otherDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalQualityDefectsPct` field. */
  totalQualityDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `stemDehyPct` field. */
  stemDehyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `glassyWeakPct` field. */
  glassyWeakPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `splitCrushedPct` field. */
  splitCrushedPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `drySplitPct` field. */
  drySplitPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `wetStickyPct` field. */
  wetStickyPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `waterberriesPct` field. */
  waterberriesPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `shatterPct` field. */
  shatterPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalConditionDefectsPct` field. */
  totalConditionDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `totalDefectsPct` field. */
  totalDefectsPct?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `container` relation. */
  container?: Maybe<PeruDepartureInspectionFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PeruDepartureInspectionPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PeruDepartureInspectionPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PeruDepartureInspectionPalletFilter>;
};

/** An input for mutations affecting `PeruDepartureInspectionPallet` */
export type PeruDepartureInspectionPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletId: Scalars['String'];
  containerId?: Maybe<Scalars['String']>;
  size: Scalars['String'];
  netWeight: Scalars['BigFloat'];
  openingScore: Scalars['BigFloat'];
  colorScore: Scalars['BigFloat'];
  stemScore: Scalars['BigFloat'];
  textureScore: Scalars['BigFloat'];
  bunchesPerBox: Scalars['BigFloat'];
  brix: Scalars['BigFloat'];
  qualityScore: Scalars['BigFloat'];
  conditionScore: Scalars['BigFloat'];
  stragglyTightPct: Scalars['BigFloat'];
  surfaceDiscPct: Scalars['BigFloat'];
  russetScarsPct: Scalars['BigFloat'];
  sunburnPct: Scalars['BigFloat'];
  undersizedBunchesPct: Scalars['BigFloat'];
  otherDefectsPct: Scalars['BigFloat'];
  totalQualityDefectsPct: Scalars['BigFloat'];
  stemDehyPct: Scalars['BigFloat'];
  glassyWeakPct: Scalars['BigFloat'];
  decayPct: Scalars['BigFloat'];
  splitCrushedPct: Scalars['BigFloat'];
  drySplitPct: Scalars['BigFloat'];
  wetStickyPct: Scalars['BigFloat'];
  waterberriesPct: Scalars['BigFloat'];
  shatterPct: Scalars['BigFloat'];
  totalConditionDefectsPct: Scalars['BigFloat'];
  totalDefectsPct: Scalars['BigFloat'];
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PeruDepartureInspectionPalletNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspectionPallet` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PeruDepartureInspectionPalletNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspectionPallet` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `peruDepartureInspection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `peruDepartureInspection` being updated. */
  patch: PeruDepartureInspectionPatch;
};

/** The fields on `peruDepartureInspectionPallet` to look up the row to update. */
export type PeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerUsingPeruDepartureInspectionPalletPkeyUpdate = {
  /** An object where the defined keys will be set on the `peruDepartureInspectionPallet` being updated. */
  patch: UpdatePeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `PeruDepartureInspectionPallet`. Fields that are set will be updated. */
export type PeruDepartureInspectionPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  openingScore?: Maybe<Scalars['BigFloat']>;
  colorScore?: Maybe<Scalars['BigFloat']>;
  stemScore?: Maybe<Scalars['BigFloat']>;
  textureScore?: Maybe<Scalars['BigFloat']>;
  bunchesPerBox?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalDefectsPct?: Maybe<Scalars['BigFloat']>;
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** The fields on `peruDepartureInspectionPallet` to look up the row to connect. */
export type PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `peruDepartureInspectionPallet` to look up the row to delete. */
export type PeruDepartureInspectionPalletPeruDepartureInspectionPalletPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `PeruDepartureInspectionPallet` values. */
export type PeruDepartureInspectionPalletsConnection = {
  __typename?: 'PeruDepartureInspectionPalletsConnection';
  /** A list of `PeruDepartureInspectionPallet` objects. */
  nodes: Array<Maybe<PeruDepartureInspectionPallet>>;
  /** A list of edges which contains the `PeruDepartureInspectionPallet` and cursor to aid in pagination. */
  edges: Array<PeruDepartureInspectionPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PeruDepartureInspectionPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PeruDepartureInspectionPallet` edge in the connection. */
export type PeruDepartureInspectionPalletsEdge = {
  __typename?: 'PeruDepartureInspectionPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PeruDepartureInspectionPallet` at the end of the edge. */
  node?: Maybe<PeruDepartureInspectionPallet>;
};

/** Methods to use when ordering `PeruDepartureInspectionPallet`. */
export enum PeruDepartureInspectionPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  NetWeightAsc = 'NET_WEIGHT_ASC',
  NetWeightDesc = 'NET_WEIGHT_DESC',
  OpeningScoreAsc = 'OPENING_SCORE_ASC',
  OpeningScoreDesc = 'OPENING_SCORE_DESC',
  ColorScoreAsc = 'COLOR_SCORE_ASC',
  ColorScoreDesc = 'COLOR_SCORE_DESC',
  StemScoreAsc = 'STEM_SCORE_ASC',
  StemScoreDesc = 'STEM_SCORE_DESC',
  TextureScoreAsc = 'TEXTURE_SCORE_ASC',
  TextureScoreDesc = 'TEXTURE_SCORE_DESC',
  BunchesPerBoxAsc = 'BUNCHES_PER_BOX_ASC',
  BunchesPerBoxDesc = 'BUNCHES_PER_BOX_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  QualityScoreAsc = 'QUALITY_SCORE_ASC',
  QualityScoreDesc = 'QUALITY_SCORE_DESC',
  ConditionScoreAsc = 'CONDITION_SCORE_ASC',
  ConditionScoreDesc = 'CONDITION_SCORE_DESC',
  StragglyTightPctAsc = 'STRAGGLY_TIGHT_PCT_ASC',
  StragglyTightPctDesc = 'STRAGGLY_TIGHT_PCT_DESC',
  SurfaceDiscPctAsc = 'SURFACE_DISC_PCT_ASC',
  SurfaceDiscPctDesc = 'SURFACE_DISC_PCT_DESC',
  RussetScarsPctAsc = 'RUSSET_SCARS_PCT_ASC',
  RussetScarsPctDesc = 'RUSSET_SCARS_PCT_DESC',
  SunburnPctAsc = 'SUNBURN_PCT_ASC',
  SunburnPctDesc = 'SUNBURN_PCT_DESC',
  UndersizedBunchesPctAsc = 'UNDERSIZED_BUNCHES_PCT_ASC',
  UndersizedBunchesPctDesc = 'UNDERSIZED_BUNCHES_PCT_DESC',
  OtherDefectsPctAsc = 'OTHER_DEFECTS_PCT_ASC',
  OtherDefectsPctDesc = 'OTHER_DEFECTS_PCT_DESC',
  TotalQualityDefectsPctAsc = 'TOTAL_QUALITY_DEFECTS_PCT_ASC',
  TotalQualityDefectsPctDesc = 'TOTAL_QUALITY_DEFECTS_PCT_DESC',
  StemDehyPctAsc = 'STEM_DEHY_PCT_ASC',
  StemDehyPctDesc = 'STEM_DEHY_PCT_DESC',
  GlassyWeakPctAsc = 'GLASSY_WEAK_PCT_ASC',
  GlassyWeakPctDesc = 'GLASSY_WEAK_PCT_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  SplitCrushedPctAsc = 'SPLIT_CRUSHED_PCT_ASC',
  SplitCrushedPctDesc = 'SPLIT_CRUSHED_PCT_DESC',
  DrySplitPctAsc = 'DRY_SPLIT_PCT_ASC',
  DrySplitPctDesc = 'DRY_SPLIT_PCT_DESC',
  WetStickyPctAsc = 'WET_STICKY_PCT_ASC',
  WetStickyPctDesc = 'WET_STICKY_PCT_DESC',
  WaterberriesPctAsc = 'WATERBERRIES_PCT_ASC',
  WaterberriesPctDesc = 'WATERBERRIES_PCT_DESC',
  ShatterPctAsc = 'SHATTER_PCT_ASC',
  ShatterPctDesc = 'SHATTER_PCT_DESC',
  TotalConditionDefectsPctAsc = 'TOTAL_CONDITION_DEFECTS_PCT_ASC',
  TotalConditionDefectsPctDesc = 'TOTAL_CONDITION_DEFECTS_PCT_DESC',
  TotalDefectsPctAsc = 'TOTAL_DEFECTS_PCT_ASC',
  TotalDefectsPctDesc = 'TOTAL_DEFECTS_PCT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PeruDepartureInspectionByContainerIdContainerIdAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__CONTAINER_ID_ASC',
  PeruDepartureInspectionByContainerIdContainerIdDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__CONTAINER_ID_DESC',
  PeruDepartureInspectionByContainerIdAvgBunchesPerBoxAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__AVG_BUNCHES_PER_BOX_ASC',
  PeruDepartureInspectionByContainerIdAvgBunchesPerBoxDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__AVG_BUNCHES_PER_BOX_DESC',
  PeruDepartureInspectionByContainerIdAvgNetWeightAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__AVG_NET_WEIGHT_ASC',
  PeruDepartureInspectionByContainerIdAvgNetWeightDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__AVG_NET_WEIGHT_DESC',
  PeruDepartureInspectionByContainerIdBagsPerBoxAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BAGS_PER_BOX_ASC',
  PeruDepartureInspectionByContainerIdBagsPerBoxDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BAGS_PER_BOX_DESC',
  PeruDepartureInspectionByContainerIdBagTypeAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BAG_TYPE_ASC',
  PeruDepartureInspectionByContainerIdBagTypeDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BAG_TYPE_DESC',
  PeruDepartureInspectionByContainerIdBrandAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRAND_ASC',
  PeruDepartureInspectionByContainerIdBrandDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRAND_DESC',
  PeruDepartureInspectionByContainerIdBrixAvgAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRIX_AVG_ASC',
  PeruDepartureInspectionByContainerIdBrixAvgDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRIX_AVG_DESC',
  PeruDepartureInspectionByContainerIdBrixMaxAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRIX_MAX_ASC',
  PeruDepartureInspectionByContainerIdBrixMaxDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRIX_MAX_DESC',
  PeruDepartureInspectionByContainerIdBrixMinAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRIX_MIN_ASC',
  PeruDepartureInspectionByContainerIdBrixMinDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__BRIX_MIN_DESC',
  PeruDepartureInspectionByContainerIdCategoryAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__CATEGORY_ASC',
  PeruDepartureInspectionByContainerIdCategoryDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__CATEGORY_DESC',
  PeruDepartureInspectionByContainerIdCommentsAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__COMMENTS_ASC',
  PeruDepartureInspectionByContainerIdCommentsDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__COMMENTS_DESC',
  PeruDepartureInspectionByContainerIdConditionScoreAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__CONDITION_SCORE_ASC',
  PeruDepartureInspectionByContainerIdConditionScoreDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__CONDITION_SCORE_DESC',
  PeruDepartureInspectionByContainerIdDepartureWeekAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__DEPARTURE_WEEK_ASC',
  PeruDepartureInspectionByContainerIdDepartureWeekDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__DEPARTURE_WEEK_DESC',
  PeruDepartureInspectionByContainerIdDestinationAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__DESTINATION_ASC',
  PeruDepartureInspectionByContainerIdDestinationDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__DESTINATION_DESC',
  PeruDepartureInspectionByContainerIdExporterAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__EXPORTER_ASC',
  PeruDepartureInspectionByContainerIdExporterDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__EXPORTER_DESC',
  PeruDepartureInspectionByContainerIdInspectionDateAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__INSPECTION_DATE_ASC',
  PeruDepartureInspectionByContainerIdInspectionDateDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__INSPECTION_DATE_DESC',
  PeruDepartureInspectionByContainerIdPackingDateAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PACKING_DATE_ASC',
  PeruDepartureInspectionByContainerIdPackingDateDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PACKING_DATE_DESC',
  PeruDepartureInspectionByContainerIdPackingHouseAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PACKING_HOUSE_ASC',
  PeruDepartureInspectionByContainerIdPackingHouseDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PACKING_HOUSE_DESC',
  PeruDepartureInspectionByContainerIdPackingMaterialAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PACKING_MATERIAL_ASC',
  PeruDepartureInspectionByContainerIdPackingMaterialDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PACKING_MATERIAL_DESC',
  PeruDepartureInspectionByContainerIdPresentationAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PRESENTATION_ASC',
  PeruDepartureInspectionByContainerIdPresentationDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__PRESENTATION_DESC',
  PeruDepartureInspectionByContainerIdQualityScoreAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__QUALITY_SCORE_ASC',
  PeruDepartureInspectionByContainerIdQualityScoreDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__QUALITY_SCORE_DESC',
  PeruDepartureInspectionByContainerIdVarietyAsc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__VARIETY_ASC',
  PeruDepartureInspectionByContainerIdVarietyDesc = 'PERU_DEPARTURE_INSPECTION_BY_CONTAINER_ID__VARIETY_DESC'
}

/** Represents an update to a `PeruDepartureInspection`. Fields that are set will be updated. */
export type PeruDepartureInspectionPatch = {
  containerId?: Maybe<Scalars['String']>;
  avgBunchesPerBox?: Maybe<Scalars['BigFloat']>;
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  bagsPerBox?: Maybe<Scalars['BigFloat']>;
  bagType?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  brixAvg?: Maybe<Scalars['BigFloat']>;
  brixMax?: Maybe<Scalars['BigFloat']>;
  brixMin?: Maybe<Scalars['BigFloat']>;
  category?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  departureWeek?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  exporter?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  packingDate?: Maybe<Scalars['Date']>;
  packingHouse?: Maybe<Scalars['String']>;
  packingMaterial?: Maybe<Scalars['String']>;
  presentation?: Maybe<Scalars['String']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  variety?: Maybe<Scalars['String']>;
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** The fields on `peruDepartureInspection` to look up the row to connect. */
export type PeruDepartureInspectionPeruDepartureInspectionPkeyConnect = {
  containerId: Scalars['String'];
};

/** The fields on `peruDepartureInspection` to look up the row to delete. */
export type PeruDepartureInspectionPeruDepartureInspectionPkeyDelete = {
  containerId: Scalars['String'];
};

/** A filter to be used against many `PeruDepartureInspectionPallet` object types. All fields are combined with a logical ‘and.’ */
export type PeruDepartureInspectionToManyPeruDepartureInspectionPalletFilter = {
  /** Every related `PeruDepartureInspectionPallet` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PeruDepartureInspectionPalletFilter>;
  /** Some related `PeruDepartureInspectionPallet` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PeruDepartureInspectionPalletFilter>;
  /** No related `PeruDepartureInspectionPallet` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PeruDepartureInspectionPalletFilter>;
};

/** A connection to a list of `PeruDepartureInspection` values. */
export type PeruDepartureInspectionsConnection = {
  __typename?: 'PeruDepartureInspectionsConnection';
  /** A list of `PeruDepartureInspection` objects. */
  nodes: Array<Maybe<PeruDepartureInspection>>;
  /** A list of edges which contains the `PeruDepartureInspection` and cursor to aid in pagination. */
  edges: Array<PeruDepartureInspectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PeruDepartureInspection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PeruDepartureInspection` edge in the connection. */
export type PeruDepartureInspectionsEdge = {
  __typename?: 'PeruDepartureInspectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PeruDepartureInspection` at the end of the edge. */
  node?: Maybe<PeruDepartureInspection>;
};

/** Methods to use when ordering `PeruDepartureInspection`. */
export enum PeruDepartureInspectionsOrderBy {
  Natural = 'NATURAL',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  AvgBunchesPerBoxAsc = 'AVG_BUNCHES_PER_BOX_ASC',
  AvgBunchesPerBoxDesc = 'AVG_BUNCHES_PER_BOX_DESC',
  AvgNetWeightAsc = 'AVG_NET_WEIGHT_ASC',
  AvgNetWeightDesc = 'AVG_NET_WEIGHT_DESC',
  BagsPerBoxAsc = 'BAGS_PER_BOX_ASC',
  BagsPerBoxDesc = 'BAGS_PER_BOX_DESC',
  BagTypeAsc = 'BAG_TYPE_ASC',
  BagTypeDesc = 'BAG_TYPE_DESC',
  BrandAsc = 'BRAND_ASC',
  BrandDesc = 'BRAND_DESC',
  BrixAvgAsc = 'BRIX_AVG_ASC',
  BrixAvgDesc = 'BRIX_AVG_DESC',
  BrixMaxAsc = 'BRIX_MAX_ASC',
  BrixMaxDesc = 'BRIX_MAX_DESC',
  BrixMinAsc = 'BRIX_MIN_ASC',
  BrixMinDesc = 'BRIX_MIN_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CommentsAsc = 'COMMENTS_ASC',
  CommentsDesc = 'COMMENTS_DESC',
  ConditionScoreAsc = 'CONDITION_SCORE_ASC',
  ConditionScoreDesc = 'CONDITION_SCORE_DESC',
  DepartureWeekAsc = 'DEPARTURE_WEEK_ASC',
  DepartureWeekDesc = 'DEPARTURE_WEEK_DESC',
  DestinationAsc = 'DESTINATION_ASC',
  DestinationDesc = 'DESTINATION_DESC',
  ExporterAsc = 'EXPORTER_ASC',
  ExporterDesc = 'EXPORTER_DESC',
  InspectionDateAsc = 'INSPECTION_DATE_ASC',
  InspectionDateDesc = 'INSPECTION_DATE_DESC',
  PackingDateAsc = 'PACKING_DATE_ASC',
  PackingDateDesc = 'PACKING_DATE_DESC',
  PackingHouseAsc = 'PACKING_HOUSE_ASC',
  PackingHouseDesc = 'PACKING_HOUSE_DESC',
  PackingMaterialAsc = 'PACKING_MATERIAL_ASC',
  PackingMaterialDesc = 'PACKING_MATERIAL_DESC',
  PresentationAsc = 'PRESENTATION_ASC',
  PresentationDesc = 'PRESENTATION_DESC',
  QualityScoreAsc = 'QUALITY_SCORE_ASC',
  QualityScoreDesc = 'QUALITY_SCORE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PeruDepartureInspectionPalletsByContainerIdCountAsc = 'PERU_DEPARTURE_INSPECTION_PALLETS_BY_CONTAINER_ID__COUNT_ASC',
  PeruDepartureInspectionPalletsByContainerIdCountDesc = 'PERU_DEPARTURE_INSPECTION_PALLETS_BY_CONTAINER_ID__COUNT_DESC'
}

/** A connection to a list of `PriceCategory` values. */
export type PriceCategoriesConnection = {
  __typename?: 'PriceCategoriesConnection';
  /** A list of `PriceCategory` objects. */
  nodes: Array<Maybe<PriceCategory>>;
  /** A list of edges which contains the `PriceCategory` and cursor to aid in pagination. */
  edges: Array<PriceCategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PriceCategory` edge in the connection. */
export type PriceCategoriesEdge = {
  __typename?: 'PriceCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceCategory` at the end of the edge. */
  node?: Maybe<PriceCategory>;
};

/** Methods to use when ordering `PriceCategory`. */
export enum PriceCategoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CategoryNameAsc = 'CATEGORY_NAME_ASC',
  CategoryNameDesc = 'CATEGORY_NAME_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriceProductsByCategoryIdCountAsc = 'PRICE_PRODUCTS_BY_CATEGORY_ID__COUNT_ASC',
  PriceProductsByCategoryIdCountDesc = 'PRICE_PRODUCTS_BY_CATEGORY_ID__COUNT_DESC'
}

export type PriceCategory = Node & {
  __typename?: 'PriceCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  categoryName: Scalars['String'];
  sortOrder: Scalars['Int'];
  /** Reads and enables pagination through a set of `PriceProduct`. */
  priceProductsByCategoryId: PriceProductsConnection;
};


export type PriceCategoryPriceProductsByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
  condition?: Maybe<PriceProductCondition>;
  filter?: Maybe<PriceProductFilter>;
};

/**
 * A condition to be used against `PriceCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PriceCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `categoryName` field. */
  categoryName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `PriceCategory` object types. All fields are combined with a logical ‘and.’ */
export type PriceCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `categoryName` field. */
  categoryName?: Maybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `priceProductsByCategoryId` relation. */
  priceProductsByCategoryId?: Maybe<PriceCategoryToManyPriceProductFilter>;
  /** Some related `priceProductsByCategoryId` exist. */
  priceProductsByCategoryIdExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceCategoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceCategoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceCategoryFilter>;
};

/** An input for mutations affecting `PriceCategory` */
export type PriceCategoryInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceCategoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceCategory` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceCategoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: PriceProductPatch;
};

/** The fields on `priceCategory` to look up the row to update. */
export type PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyUsingPriceCategoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceCategory` being updated. */
  patch: UpdatePriceCategoryOnPriceProductForPriceProductCategoryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `PriceCategory`. Fields that are set will be updated. */
export type PriceCategoryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** The fields on `priceCategory` to look up the row to connect. */
export type PriceCategoryPriceCategoryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `priceCategory` to look up the row to delete. */
export type PriceCategoryPriceCategoryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against many `PriceProduct` object types. All fields are combined with a logical ‘and.’ */
export type PriceCategoryToManyPriceProductFilter = {
  /** Every related `PriceProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PriceProductFilter>;
  /** Some related `PriceProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PriceProductFilter>;
  /** No related `PriceProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PriceProductFilter>;
};

/** A connection to a list of `PriceEntry` values. */
export type PriceEntriesConnection = {
  __typename?: 'PriceEntriesConnection';
  /** A list of `PriceEntry` objects. */
  nodes: Array<Maybe<PriceEntry>>;
  /** A list of edges which contains the `PriceEntry` and cursor to aid in pagination. */
  edges: Array<PriceEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PriceEntry` edge in the connection. */
export type PriceEntriesEdge = {
  __typename?: 'PriceEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceEntry` at the end of the edge. */
  node?: Maybe<PriceEntry>;
};

/** Methods to use when ordering `PriceEntry`. */
export enum PriceEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SizeIdAsc = 'SIZE_ID_ASC',
  SizeIdDesc = 'SIZE_ID_DESC',
  EntryDateAsc = 'ENTRY_DATE_ASC',
  EntryDateDesc = 'ENTRY_DATE_DESC',
  EntryDescriptionAsc = 'ENTRY_DESCRIPTION_ASC',
  EntryDescriptionDesc = 'ENTRY_DESCRIPTION_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  HighlightAsc = 'HIGHLIGHT_ASC',
  HighlightDesc = 'HIGHLIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriceSizeBySizeIdIdAsc = 'PRICE_SIZE_BY_SIZE_ID__ID_ASC',
  PriceSizeBySizeIdIdDesc = 'PRICE_SIZE_BY_SIZE_ID__ID_DESC',
  PriceSizeBySizeIdProductIdAsc = 'PRICE_SIZE_BY_SIZE_ID__PRODUCT_ID_ASC',
  PriceSizeBySizeIdProductIdDesc = 'PRICE_SIZE_BY_SIZE_ID__PRODUCT_ID_DESC',
  PriceSizeBySizeIdSizeNameAsc = 'PRICE_SIZE_BY_SIZE_ID__SIZE_NAME_ASC',
  PriceSizeBySizeIdSizeNameDesc = 'PRICE_SIZE_BY_SIZE_ID__SIZE_NAME_DESC',
  PriceSizeBySizeIdSortOrderAsc = 'PRICE_SIZE_BY_SIZE_ID__SORT_ORDER_ASC',
  PriceSizeBySizeIdSortOrderDesc = 'PRICE_SIZE_BY_SIZE_ID__SORT_ORDER_DESC'
}

export type PriceEntry = Node & {
  __typename?: 'PriceEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  sizeId: Scalars['BigInt'];
  entryDate: Scalars['Date'];
  entryDescription: Scalars['String'];
  content: Scalars['String'];
  highlight: Scalars['Boolean'];
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
};

/**
 * A condition to be used against `PriceEntry` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PriceEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sizeId` field. */
  sizeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `entryDate` field. */
  entryDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `entryDescription` field. */
  entryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `highlight` field. */
  highlight?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `PriceEntry` object types. All fields are combined with a logical ‘and.’ */
export type PriceEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `sizeId` field. */
  sizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `entryDate` field. */
  entryDate?: Maybe<DateFilter>;
  /** Filter by the object’s `entryDescription` field. */
  entryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `content` field. */
  content?: Maybe<StringFilter>;
  /** Filter by the object’s `highlight` field. */
  highlight?: Maybe<BooleanFilter>;
  /** Filter by the object’s `size` relation. */
  size?: Maybe<PriceSizeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceEntryFilter>;
};

/** An input for mutations affecting `PriceEntry` */
export type PriceEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeId?: Maybe<Scalars['BigInt']>;
  entryDate: Scalars['Date'];
  entryDescription: Scalars['String'];
  content: Scalars['String'];
  highlight: Scalars['Boolean'];
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: PriceSizePatch;
};

/** The fields on `priceEntry` to look up the row to update. */
export type PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceEntry` being updated. */
  patch: UpdatePriceEntryOnPriceEntryForPriceEntrySizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `PriceEntry`. Fields that are set will be updated. */
export type PriceEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeId?: Maybe<Scalars['BigInt']>;
  entryDate?: Maybe<Scalars['Date']>;
  entryDescription?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  highlight?: Maybe<Scalars['Boolean']>;
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** The fields on `priceEntry` to look up the row to connect. */
export type PriceEntryPriceEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `priceEntry` to look up the row to delete. */
export type PriceEntryPriceEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `priceSize` in the `PriceEntryInput` mutation. */
export type PriceEntrySizeIdFkeyInput = {
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectById?: Maybe<PriceSizePriceSizePkeyConnect>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<PriceSizeNodeIdConnect>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteById?: Maybe<PriceSizePriceSizePkeyDelete>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PriceSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateById?: Maybe<PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceSizePkeyUpdate>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate>;
  /** A `PriceSizeInput` object that will be created and connected to this object. */
  create?: Maybe<PriceEntrySizeIdFkeyPriceSizeCreateInput>;
};

/** Input for the nested mutation of `priceEntry` in the `PriceSizeInput` mutation. */
export type PriceEntrySizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `priceEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<PriceEntryPriceEntryPkeyConnect>>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PriceEntryNodeIdConnect>>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<PriceEntryPriceEntryPkeyDelete>>;
  /** The primary key(s) for `priceEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PriceEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `priceEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<PriceEntryOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `priceEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate>>;
  /** A `PriceEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PriceEntrySizeIdFkeyPriceEntryCreateInput>>;
};

/** The `priceEntry` to be created by this mutation. */
export type PriceEntrySizeIdFkeyPriceEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  entryDate: Scalars['Date'];
  entryDescription: Scalars['String'];
  content: Scalars['String'];
  highlight: Scalars['Boolean'];
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** The `priceSize` to be created by this mutation. */
export type PriceEntrySizeIdFkeyPriceSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

export type PriceProduct = Node & {
  __typename?: 'PriceProduct';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  categoryId: Scalars['BigInt'];
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** Reads and enables pagination through a set of `PriceSize`. */
  priceSizesByProductId: PriceSizesConnection;
  productRootId?: Maybe<Scalars['BigInt']>;
};


export type PriceProductPriceSizesByProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
  condition?: Maybe<PriceSizeCondition>;
  filter?: Maybe<PriceSizeFilter>;
};

/** Input for the nested mutation of `priceCategory` in the `PriceProductInput` mutation. */
export type PriceProductCategoryIdFkeyInput = {
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  connectById?: Maybe<PriceCategoryPriceCategoryPkeyConnect>;
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<PriceCategoryNodeIdConnect>;
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  deleteById?: Maybe<PriceCategoryPriceCategoryPkeyDelete>;
  /** The primary key(s) for `priceCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PriceCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `priceCategory` for the far side of the relationship. */
  updateById?: Maybe<PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyUsingPriceCategoryPkeyUpdate>;
  /** The primary key(s) and patch data for `priceCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<PriceProductOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate>;
  /** A `PriceCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<PriceProductCategoryIdFkeyPriceCategoryCreateInput>;
};

/** Input for the nested mutation of `priceProduct` in the `PriceCategoryInput` mutation. */
export type PriceProductCategoryIdFkeyInverseInput = {
  /** Flag indicating whether all other `priceProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<PriceProductPriceProductPkeyConnect>>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PriceProductNodeIdConnect>>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<PriceProductPriceProductPkeyDelete>>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PriceProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<PriceProductOnPriceProductForPriceProductCategoryIdFkeyUsingPriceProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PriceCategoryOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate>>;
  /** A `PriceProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PriceProductCategoryIdFkeyPriceProductCreateInput>>;
};

/** The `priceCategory` to be created by this mutation. */
export type PriceProductCategoryIdFkeyPriceCategoryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** The `priceProduct` to be created by this mutation. */
export type PriceProductCategoryIdFkeyPriceProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/**
 * A condition to be used against `PriceProduct` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PriceProductCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productName` field. */
  productName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `PriceProduct` object types. All fields are combined with a logical ‘and.’ */
export type PriceProductFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `productName` field. */
  productName?: Maybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `productRootId` field. */
  productRootId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `priceSizesByProductId` relation. */
  priceSizesByProductId?: Maybe<PriceProductToManyPriceSizeFilter>;
  /** Some related `priceSizesByProductId` exist. */
  priceSizesByProductIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `category` relation. */
  category?: Maybe<PriceCategoryFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceProductFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceProductFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceProductFilter>;
};

/** An input for mutations affecting `PriceProduct` */
export type PriceProductInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceProductNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceProductNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PriceProductOnPriceProductForPriceProductCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceCategory` being updated. */
  patch: PriceCategoryPatch;
};

/** The fields on `priceProduct` to look up the row to update. */
export type PriceProductOnPriceProductForPriceProductCategoryIdFkeyUsingPriceProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: UpdatePriceProductOnPriceProductForPriceProductCategoryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PriceProductOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: PriceSizePatch;
};

/** The fields on `priceProduct` to look up the row to update. */
export type PriceProductOnPriceSizeForPriceSizeProductIdFkeyUsingPriceProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: UpdatePriceProductOnPriceSizeForPriceSizeProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `PriceProduct`. Fields that are set will be updated. */
export type PriceProductPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color?: Maybe<Scalars['String']>;
  productName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** The fields on `priceProduct` to look up the row to connect. */
export type PriceProductPriceProductPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `priceProduct` to look up the row to delete. */
export type PriceProductPriceProductPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against many `PriceSize` object types. All fields are combined with a logical ‘and.’ */
export type PriceProductToManyPriceSizeFilter = {
  /** Every related `PriceSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PriceSizeFilter>;
  /** Some related `PriceSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PriceSizeFilter>;
  /** No related `PriceSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PriceSizeFilter>;
};

/** A connection to a list of `PriceProduct` values. */
export type PriceProductsConnection = {
  __typename?: 'PriceProductsConnection';
  /** A list of `PriceProduct` objects. */
  nodes: Array<Maybe<PriceProduct>>;
  /** A list of edges which contains the `PriceProduct` and cursor to aid in pagination. */
  edges: Array<PriceProductsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceProduct` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PriceProduct` edge in the connection. */
export type PriceProductsEdge = {
  __typename?: 'PriceProductsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceProduct` at the end of the edge. */
  node?: Maybe<PriceProduct>;
};

/** Methods to use when ordering `PriceProduct`. */
export enum PriceProductsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  ProductNameAsc = 'PRODUCT_NAME_ASC',
  ProductNameDesc = 'PRODUCT_NAME_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriceCategoryByCategoryIdIdAsc = 'PRICE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  PriceCategoryByCategoryIdIdDesc = 'PRICE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  PriceCategoryByCategoryIdCategoryNameAsc = 'PRICE_CATEGORY_BY_CATEGORY_ID__CATEGORY_NAME_ASC',
  PriceCategoryByCategoryIdCategoryNameDesc = 'PRICE_CATEGORY_BY_CATEGORY_ID__CATEGORY_NAME_DESC',
  PriceCategoryByCategoryIdSortOrderAsc = 'PRICE_CATEGORY_BY_CATEGORY_ID__SORT_ORDER_ASC',
  PriceCategoryByCategoryIdSortOrderDesc = 'PRICE_CATEGORY_BY_CATEGORY_ID__SORT_ORDER_DESC',
  PriceSizesByProductIdCountAsc = 'PRICE_SIZES_BY_PRODUCT_ID__COUNT_ASC',
  PriceSizesByProductIdCountDesc = 'PRICE_SIZES_BY_PRODUCT_ID__COUNT_DESC'
}

export type PriceSheetUpdateInput = {
  message: Scalars['String'];
};

export type PriceSize = Node & {
  __typename?: 'PriceSize';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  productId: Scalars['BigInt'];
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** Reads and enables pagination through a set of `PriceEntry`. */
  priceEntriesBySizeId: PriceEntriesConnection;
};


export type PriceSizePriceEntriesBySizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
  condition?: Maybe<PriceEntryCondition>;
  filter?: Maybe<PriceEntryFilter>;
};

/**
 * A condition to be used against `PriceSize` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PriceSizeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `sizeName` field. */
  sizeName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `PriceSize` object types. All fields are combined with a logical ‘and.’ */
export type PriceSizeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `sizeName` field. */
  sizeName?: Maybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `priceEntriesBySizeId` relation. */
  priceEntriesBySizeId?: Maybe<PriceSizeToManyPriceEntryFilter>;
  /** Some related `priceEntriesBySizeId` exist. */
  priceEntriesBySizeIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `product` relation. */
  product?: Maybe<PriceProductFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PriceSizeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PriceSizeFilter>>;
  /** Negates the expression. */
  not?: Maybe<PriceSizeFilter>;
};

/** An input for mutations affecting `PriceSize` */
export type PriceSizeInput = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PriceSizeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `priceSize` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PriceSizeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `priceSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceEntry` being updated. */
  patch: PriceEntryPatch;
};

/** The fields on `priceSize` to look up the row to update. */
export type PriceSizeOnPriceEntryForPriceEntrySizeIdFkeyUsingPriceSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: UpdatePriceSizeOnPriceEntryForPriceEntrySizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type PriceSizeOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `priceProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `priceProduct` being updated. */
  patch: PriceProductPatch;
};

/** The fields on `priceSize` to look up the row to update. */
export type PriceSizeOnPriceSizeForPriceSizeProductIdFkeyUsingPriceSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `priceSize` being updated. */
  patch: UpdatePriceSizeOnPriceSizeForPriceSizeProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `PriceSize`. Fields that are set will be updated. */
export type PriceSizePatch = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** The fields on `priceSize` to look up the row to connect. */
export type PriceSizePriceSizePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `priceSize` to look up the row to delete. */
export type PriceSizePriceSizePkeyDelete = {
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `priceProduct` in the `PriceSizeInput` mutation. */
export type PriceSizeProductIdFkeyInput = {
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectById?: Maybe<PriceProductPriceProductPkeyConnect>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<PriceProductNodeIdConnect>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteById?: Maybe<PriceProductPriceProductPkeyDelete>;
  /** The primary key(s) for `priceProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PriceProductNodeIdDelete>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateById?: Maybe<PriceProductOnPriceSizeForPriceSizeProductIdFkeyUsingPriceProductPkeyUpdate>;
  /** The primary key(s) and patch data for `priceProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<PriceSizeOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate>;
  /** A `PriceProductInput` object that will be created and connected to this object. */
  create?: Maybe<PriceSizeProductIdFkeyPriceProductCreateInput>;
};

/** Input for the nested mutation of `priceSize` in the `PriceProductInput` mutation. */
export type PriceSizeProductIdFkeyInverseInput = {
  /** Flag indicating whether all other `priceSize` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectById?: Maybe<Array<PriceSizePriceSizePkeyConnect>>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PriceSizeNodeIdConnect>>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteById?: Maybe<Array<PriceSizePriceSizePkeyDelete>>;
  /** The primary key(s) for `priceSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PriceSizeNodeIdDelete>>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateById?: Maybe<Array<PriceSizeOnPriceSizeForPriceSizeProductIdFkeyUsingPriceSizePkeyUpdate>>;
  /** The primary key(s) and patch data for `priceSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PriceProductOnPriceSizeForPriceSizeProductIdFkeyNodeIdUpdate>>;
  /** A `PriceSizeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PriceSizeProductIdFkeyPriceSizeCreateInput>>;
};

/** The `priceProduct` to be created by this mutation. */
export type PriceSizeProductIdFkeyPriceProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color: Scalars['String'];
  productName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** The `priceSize` to be created by this mutation. */
export type PriceSizeProductIdFkeyPriceSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName: Scalars['String'];
  sortOrder: Scalars['Int'];
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** A filter to be used against many `PriceEntry` object types. All fields are combined with a logical ‘and.’ */
export type PriceSizeToManyPriceEntryFilter = {
  /** Every related `PriceEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PriceEntryFilter>;
  /** Some related `PriceEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PriceEntryFilter>;
  /** No related `PriceEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PriceEntryFilter>;
};

/** A connection to a list of `PriceSize` values. */
export type PriceSizesConnection = {
  __typename?: 'PriceSizesConnection';
  /** A list of `PriceSize` objects. */
  nodes: Array<Maybe<PriceSize>>;
  /** A list of edges which contains the `PriceSize` and cursor to aid in pagination. */
  edges: Array<PriceSizesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PriceSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PriceSize` edge in the connection. */
export type PriceSizesEdge = {
  __typename?: 'PriceSizesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PriceSize` at the end of the edge. */
  node?: Maybe<PriceSize>;
};

/** Methods to use when ordering `PriceSize`. */
export enum PriceSizesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  SizeNameAsc = 'SIZE_NAME_ASC',
  SizeNameDesc = 'SIZE_NAME_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriceProductByProductIdIdAsc = 'PRICE_PRODUCT_BY_PRODUCT_ID__ID_ASC',
  PriceProductByProductIdIdDesc = 'PRICE_PRODUCT_BY_PRODUCT_ID__ID_DESC',
  PriceProductByProductIdCategoryIdAsc = 'PRICE_PRODUCT_BY_PRODUCT_ID__CATEGORY_ID_ASC',
  PriceProductByProductIdCategoryIdDesc = 'PRICE_PRODUCT_BY_PRODUCT_ID__CATEGORY_ID_DESC',
  PriceProductByProductIdColorAsc = 'PRICE_PRODUCT_BY_PRODUCT_ID__COLOR_ASC',
  PriceProductByProductIdColorDesc = 'PRICE_PRODUCT_BY_PRODUCT_ID__COLOR_DESC',
  PriceProductByProductIdProductNameAsc = 'PRICE_PRODUCT_BY_PRODUCT_ID__PRODUCT_NAME_ASC',
  PriceProductByProductIdProductNameDesc = 'PRICE_PRODUCT_BY_PRODUCT_ID__PRODUCT_NAME_DESC',
  PriceProductByProductIdSortOrderAsc = 'PRICE_PRODUCT_BY_PRODUCT_ID__SORT_ORDER_ASC',
  PriceProductByProductIdSortOrderDesc = 'PRICE_PRODUCT_BY_PRODUCT_ID__SORT_ORDER_DESC',
  PriceEntriesBySizeIdCountAsc = 'PRICE_ENTRIES_BY_SIZE_ID__COUNT_ASC',
  PriceEntriesBySizeIdCountDesc = 'PRICE_ENTRIES_BY_SIZE_ID__COUNT_DESC'
}

export type ProductMaster = Node & {
  __typename?: 'ProductMaster';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
  searchText?: Maybe<Scalars['String']>;
  species?: Maybe<ProductSpecies>;
  variety?: Maybe<ProductVariety>;
};

/**
 * A condition to be used against `ProductMaster` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ProductMasterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotNumber` field. */
  lotNumber?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ProductMaster` object types. All fields are combined with a logical ‘and.’ */
export type ProductMasterFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultPalletQuantity` field. */
  defaultPalletQuantity?: Maybe<StringFilter>;
  /** Filter by the object’s `lotNumber` field. */
  lotNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductMasterFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductMasterFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductMasterFilter>;
};

/** An input for mutations affecting `ProductMaster` */
export type ProductMasterInput = {
  id: Scalars['String'];
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
};

/** Represents an update to a `ProductMaster`. Fields that are set will be updated. */
export type ProductMasterPatch = {
  id?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['String']>;
  lotNumber?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ProductMaster` values. */
export type ProductMastersConnection = {
  __typename?: 'ProductMastersConnection';
  /** A list of `ProductMaster` objects. */
  nodes: Array<Maybe<ProductMaster>>;
  /** A list of edges which contains the `ProductMaster` and cursor to aid in pagination. */
  edges: Array<ProductMastersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductMaster` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductMaster` edge in the connection. */
export type ProductMastersEdge = {
  __typename?: 'ProductMastersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductMaster` at the end of the edge. */
  node?: Maybe<ProductMaster>;
};

/** Methods to use when ordering `ProductMaster`. */
export enum ProductMastersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DefaultPalletQuantityAsc = 'DEFAULT_PALLET_QUANTITY_ASC',
  DefaultPalletQuantityDesc = 'DEFAULT_PALLET_QUANTITY_DESC',
  LotNumberAsc = 'LOT_NUMBER_ASC',
  LotNumberDesc = 'LOT_NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ProductSize = Node & {
  __typename?: 'ProductSize';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizes: CommonSizesConnection;
  /** Reads and enables pagination through a set of `CommonSizeProductSize`. */
  commonSizeProductSizes: CommonSizeProductSizesConnection;
  commonSize?: Maybe<CommonSize>;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  species?: Maybe<ProductSpecies>;
  variety?: Maybe<ProductVariety>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesId: ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeId: ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdManyToManyConnection;
};


export type ProductSizeCommonSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type ProductSizeCommonSizeProductSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
  condition?: Maybe<CommonSizeProductSizeCondition>;
  filter?: Maybe<CommonSizeProductSizeFilter>;
};


export type ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `CommonSizeProductSize`. */
export type ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `CommonSizeProductSize`, and the cursor to aid in pagination. */
  edges: Array<ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `CommonSizeProductSize`. */
export type ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `CommonSizeProductSize`. */
  commonSizeProductSizes: CommonSizeProductSizesConnection;
};


/** A `CommonSize` edge in the connection, with data from `CommonSizeProductSize`. */
export type ProductSizeCommonSizesByCommonSizeProductSizeProductSizeIdAndCommonSizeIdManyToManyEdgeCommonSizeProductSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
  condition?: Maybe<CommonSizeProductSizeCondition>;
  filter?: Maybe<CommonSizeProductSizeFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `CommonSize`. */
export type ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CommonSize`, and the cursor to aid in pagination. */
  edges: Array<ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CommonSize`. */
export type ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizes: CommonSizesConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CommonSize`. */
export type ProductSizeCommonSpeciesByCommonSizeProductSizeIdAndCommonSpeciesIdManyToManyEdgeCommonSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};

/**
 * A condition to be used against `ProductSize` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ProductSizeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `speciesId` field. */
  speciesId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyId` field. */
  varietyId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvCode` field. */
  jvCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvDescription` field. */
  jvDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperCode` field. */
  shipperCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperDescription` field. */
  shipperDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineDescription` field. */
  combineDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ProductSize` object types. All fields are combined with a logical ‘and.’ */
export type ProductSizeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `speciesId` field. */
  speciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyId` field. */
  varietyId?: Maybe<StringFilter>;
  /** Filter by the object’s `jvCode` field. */
  jvCode?: Maybe<StringFilter>;
  /** Filter by the object’s `jvDescription` field. */
  jvDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperCode` field. */
  shipperCode?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperDescription` field. */
  shipperDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Filter by the object’s `combineDescription` field. */
  combineDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSizes` relation. */
  commonSizes?: Maybe<ProductSizeToManyCommonSizeFilter>;
  /** Some related `commonSizes` exist. */
  commonSizesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSizeProductSizes` relation. */
  commonSizeProductSizes?: Maybe<ProductSizeToManyCommonSizeProductSizeFilter>;
  /** Some related `commonSizeProductSizes` exist. */
  commonSizeProductSizesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductSizeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductSizeFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductSizeFilter>;
};

/** An input for mutations affecting `ProductSize` */
export type ProductSizeInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSizesUsingId?: Maybe<CommonSizeProductSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ProductSizeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `productSize` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ProductSizeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `productSize` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ProductSizeOnCommonSizeForCommonSizeProductSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: CommonSizePatch;
};

/** The fields on `productSize` to look up the row to update. */
export type ProductSizeOnCommonSizeForCommonSizeProductSizeIdFkeyUsingProductSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `productSize` being updated. */
  patch: UpdateProductSizeOnCommonSizeForCommonSizeProductSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSizeProductSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSizeProductSize` being updated. */
  patch: CommonSizeProductSizePatch;
};

/** The fields on `productSize` to look up the row to update. */
export type ProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyUsingProductSizePkeyUpdate = {
  /** An object where the defined keys will be set on the `productSize` being updated. */
  patch: UpdateProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ProductSize`. Fields that are set will be updated. */
export type ProductSizePatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSizesUsingId?: Maybe<CommonSizeProductSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInverseInput>;
};

/** The fields on `productSize` to look up the row to connect. */
export type ProductSizeProductSizePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `productSize` to look up the row to delete. */
export type ProductSizeProductSizePkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against many `CommonSize` object types. All fields are combined with a logical ‘and.’ */
export type ProductSizeToManyCommonSizeFilter = {
  /** Every related `CommonSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSizeFilter>;
  /** Some related `CommonSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSizeFilter>;
  /** No related `CommonSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSizeFilter>;
};

/** A filter to be used against many `CommonSizeProductSize` object types. All fields are combined with a logical ‘and.’ */
export type ProductSizeToManyCommonSizeProductSizeFilter = {
  /** Every related `CommonSizeProductSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSizeProductSizeFilter>;
  /** Some related `CommonSizeProductSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSizeProductSizeFilter>;
  /** No related `CommonSizeProductSize` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSizeProductSizeFilter>;
};

/** A connection to a list of `ProductSize` values. */
export type ProductSizesConnection = {
  __typename?: 'ProductSizesConnection';
  /** A list of `ProductSize` objects. */
  nodes: Array<Maybe<ProductSize>>;
  /** A list of edges which contains the `ProductSize` and cursor to aid in pagination. */
  edges: Array<ProductSizesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSize` edge in the connection. */
export type ProductSizesEdge = {
  __typename?: 'ProductSizesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSize` at the end of the edge. */
  node?: Maybe<ProductSize>;
};

/** Methods to use when ordering `ProductSize`. */
export enum ProductSizesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SpeciesIdAsc = 'SPECIES_ID_ASC',
  SpeciesIdDesc = 'SPECIES_ID_DESC',
  VarietyIdAsc = 'VARIETY_ID_ASC',
  VarietyIdDesc = 'VARIETY_ID_DESC',
  JvCodeAsc = 'JV_CODE_ASC',
  JvCodeDesc = 'JV_CODE_DESC',
  JvDescriptionAsc = 'JV_DESCRIPTION_ASC',
  JvDescriptionDesc = 'JV_DESCRIPTION_DESC',
  ShipperCodeAsc = 'SHIPPER_CODE_ASC',
  ShipperCodeDesc = 'SHIPPER_CODE_DESC',
  ShipperDescriptionAsc = 'SHIPPER_DESCRIPTION_ASC',
  ShipperDescriptionDesc = 'SHIPPER_DESCRIPTION_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  CombineDescriptionAsc = 'COMBINE_DESCRIPTION_ASC',
  CombineDescriptionDesc = 'COMBINE_DESCRIPTION_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSizesByProductSizeIdCountAsc = 'COMMON_SIZES_BY_PRODUCT_SIZE_ID__COUNT_ASC',
  CommonSizesByProductSizeIdCountDesc = 'COMMON_SIZES_BY_PRODUCT_SIZE_ID__COUNT_DESC',
  CommonSizeProductSizesByProductSizeIdCountAsc = 'COMMON_SIZE_PRODUCT_SIZES_BY_PRODUCT_SIZE_ID__COUNT_ASC',
  CommonSizeProductSizesByProductSizeIdCountDesc = 'COMMON_SIZE_PRODUCT_SIZES_BY_PRODUCT_SIZE_ID__COUNT_DESC'
}

export type ProductSpecies = Node & {
  __typename?: 'ProductSpecies';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpecieses: CommonSpeciesConnection;
  /** Reads and enables pagination through a set of `CommonSpeciesProductSpecies`. */
  commonSpeciesProductSpecieses: CommonSpeciesProductSpeciesConnection;
  /** Reads and enables pagination through a set of `ShipperAdvance`. */
  shipperAdvancesBySpeciesId: ShipperAdvancesConnection;
  commonSpecies?: Maybe<CommonSpecies>;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CommonCategory`. */
  commonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryId: ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesId: ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperAdvanceSpeciesIdAndShipperId: ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdManyToManyConnection;
};


export type ProductSpeciesCommonSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type ProductSpeciesCommonSpeciesProductSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesProductSpeciesCondition>;
  filter?: Maybe<CommonSpeciesProductSpeciesFilter>;
};


export type ProductSpeciesShipperAdvancesBySpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
  condition?: Maybe<ShipperAdvanceCondition>;
  filter?: Maybe<ShipperAdvanceFilter>;
};


export type ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonCategoriesOrderBy>>;
  condition?: Maybe<CommonCategoryCondition>;
  filter?: Maybe<CommonCategoryFilter>;
};


export type ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};

/** A connection to a list of `CommonCategory` values, with data from `CommonSpecies`. */
export type ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdManyToManyConnection = {
  __typename?: 'ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdManyToManyConnection';
  /** A list of `CommonCategory` objects. */
  nodes: Array<Maybe<CommonCategory>>;
  /** A list of edges which contains the `CommonCategory`, info from the `CommonSpecies`, and the cursor to aid in pagination. */
  edges: Array<ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonCategory` edge in the connection, with data from `CommonSpecies`. */
export type ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdManyToManyEdge = {
  __typename?: 'ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonCategory` at the end of the edge. */
  node?: Maybe<CommonCategory>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpecieses: CommonSpeciesConnection;
};


/** A `CommonCategory` edge in the connection, with data from `CommonSpecies`. */
export type ProductSpeciesCommonCategoriesByCommonSpeciesProductSpeciesIdAndCommonCategoryIdManyToManyEdgeCommonSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `CommonSpeciesProductSpecies`. */
export type ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CommonSpeciesProductSpecies`, and the cursor to aid in pagination. */
  edges: Array<ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CommonSpeciesProductSpecies`. */
export type ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CommonSpeciesProductSpecies`. */
  commonSpeciesProductSpecieses: CommonSpeciesProductSpeciesConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CommonSpeciesProductSpecies`. */
export type ProductSpeciesCommonSpeciesByCommonSpeciesProductSpeciesProductSpeciesIdAndCommonSpeciesIdManyToManyEdgeCommonSpeciesProductSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesProductSpeciesCondition>;
  filter?: Maybe<CommonSpeciesProductSpeciesFilter>;
};

/**
 * A condition to be used against `ProductSpecies` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ProductSpeciesCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `speciesDescription` field. */
  speciesDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fdaProductCode` field. */
  fdaProductCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fdaIndustryCode` field. */
  fdaIndustryCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultTemperature` field. */
  defaultTemperature?: Maybe<Scalars['String']>;
};

/** A connection to a list of `ProductSpecies` values. */
export type ProductSpeciesConnection = {
  __typename?: 'ProductSpeciesConnection';
  /** A list of `ProductSpecies` objects. */
  nodes: Array<Maybe<ProductSpecies>>;
  /** A list of edges which contains the `ProductSpecies` and cursor to aid in pagination. */
  edges: Array<ProductSpeciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSpecies` edge in the connection. */
export type ProductSpeciesEdge = {
  __typename?: 'ProductSpeciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSpecies` at the end of the edge. */
  node?: Maybe<ProductSpecies>;
};

/** A filter to be used against `ProductSpecies` object types. All fields are combined with a logical ‘and.’ */
export type ProductSpeciesFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `speciesDescription` field. */
  speciesDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `fdaProductCode` field. */
  fdaProductCode?: Maybe<StringFilter>;
  /** Filter by the object’s `fdaIndustryCode` field. */
  fdaIndustryCode?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultTemperature` field. */
  defaultTemperature?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpecieses` relation. */
  commonSpecieses?: Maybe<ProductSpeciesToManyCommonSpeciesFilter>;
  /** Some related `commonSpecieses` exist. */
  commonSpeciesesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpeciesProductSpecieses` relation. */
  commonSpeciesProductSpecieses?: Maybe<ProductSpeciesToManyCommonSpeciesProductSpeciesFilter>;
  /** Some related `commonSpeciesProductSpecieses` exist. */
  commonSpeciesProductSpeciesesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperAdvancesBySpeciesId` relation. */
  shipperAdvancesBySpeciesId?: Maybe<ProductSpeciesToManyShipperAdvanceFilter>;
  /** Some related `shipperAdvancesBySpeciesId` exist. */
  shipperAdvancesBySpeciesIdExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductSpeciesFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductSpeciesFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductSpeciesFilter>;
};

/** An input for mutations affecting `ProductSpecies` */
export type ProductSpeciesInput = {
  id: Scalars['String'];
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ProductSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `productSpecies` to look up the row to update. */
export type ProductSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyUsingProductSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `productSpecies` being updated. */
  patch: UpdateProductSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpeciesProductSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpeciesProductSpecies` being updated. */
  patch: CommonSpeciesProductSpeciesPatch;
};

/** The fields on `productSpecies` to look up the row to update. */
export type ProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyUsingProductSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `productSpecies` being updated. */
  patch: UpdateProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ProductSpeciesOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperAdvance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperAdvance` being updated. */
  patch: ShipperAdvancePatch;
};

/** The fields on `productSpecies` to look up the row to update. */
export type ProductSpeciesOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyUsingProductSpeciesPkeyUpdate = {
  /** An object where the defined keys will be set on the `productSpecies` being updated. */
  patch: UpdateProductSpeciesOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyPatch;
  id: Scalars['String'];
};

/** Methods to use when ordering `ProductSpecies`. */
export enum ProductSpeciesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SpeciesDescriptionAsc = 'SPECIES_DESCRIPTION_ASC',
  SpeciesDescriptionDesc = 'SPECIES_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  FdaProductCodeAsc = 'FDA_PRODUCT_CODE_ASC',
  FdaProductCodeDesc = 'FDA_PRODUCT_CODE_DESC',
  FdaIndustryCodeAsc = 'FDA_INDUSTRY_CODE_ASC',
  FdaIndustryCodeDesc = 'FDA_INDUSTRY_CODE_DESC',
  DefaultTemperatureAsc = 'DEFAULT_TEMPERATURE_ASC',
  DefaultTemperatureDesc = 'DEFAULT_TEMPERATURE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByProductSpeciesIdCountAsc = 'COMMON_SPECIES_BY_PRODUCT_SPECIES_ID__COUNT_ASC',
  CommonSpeciesByProductSpeciesIdCountDesc = 'COMMON_SPECIES_BY_PRODUCT_SPECIES_ID__COUNT_DESC',
  CommonSpeciesProductSpeciesByProductSpeciesIdCountAsc = 'COMMON_SPECIES_PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__COUNT_ASC',
  CommonSpeciesProductSpeciesByProductSpeciesIdCountDesc = 'COMMON_SPECIES_PRODUCT_SPECIES_BY_PRODUCT_SPECIES_ID__COUNT_DESC',
  ShipperAdvancesBySpeciesIdCountAsc = 'SHIPPER_ADVANCES_BY_SPECIES_ID__COUNT_ASC',
  ShipperAdvancesBySpeciesIdCountDesc = 'SHIPPER_ADVANCES_BY_SPECIES_ID__COUNT_DESC'
}

/** Represents an update to a `ProductSpecies`. Fields that are set will be updated. */
export type ProductSpeciesPatch = {
  id?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** The fields on `productSpecies` to look up the row to connect. */
export type ProductSpeciesProductSpeciesPkeyConnect = {
  id: Scalars['String'];
};

/** The fields on `productSpecies` to look up the row to delete. */
export type ProductSpeciesProductSpeciesPkeyDelete = {
  id: Scalars['String'];
};

/** A connection to a list of `Shipper` values, with data from `ShipperAdvance`. */
export type ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdManyToManyConnection = {
  __typename?: 'ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperAdvance`, and the cursor to aid in pagination. */
  edges: Array<ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperAdvance`. */
export type ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdManyToManyEdge = {
  __typename?: 'ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperAdvance`. */
  shipperAdvances: ShipperAdvancesConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperAdvance`. */
export type ProductSpeciesShippersByShipperAdvanceSpeciesIdAndShipperIdManyToManyEdgeShipperAdvancesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
  condition?: Maybe<ShipperAdvanceCondition>;
  filter?: Maybe<ShipperAdvanceFilter>;
};

/** A filter to be used against many `CommonSpecies` object types. All fields are combined with a logical ‘and.’ */
export type ProductSpeciesToManyCommonSpeciesFilter = {
  /** Every related `CommonSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSpeciesFilter>;
  /** Some related `CommonSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSpeciesFilter>;
  /** No related `CommonSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSpeciesFilter>;
};

/** A filter to be used against many `CommonSpeciesProductSpecies` object types. All fields are combined with a logical ‘and.’ */
export type ProductSpeciesToManyCommonSpeciesProductSpeciesFilter = {
  /** Every related `CommonSpeciesProductSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonSpeciesProductSpeciesFilter>;
  /** Some related `CommonSpeciesProductSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonSpeciesProductSpeciesFilter>;
  /** No related `CommonSpeciesProductSpecies` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonSpeciesProductSpeciesFilter>;
};

/** A filter to be used against many `ShipperAdvance` object types. All fields are combined with a logical ‘and.’ */
export type ProductSpeciesToManyShipperAdvanceFilter = {
  /** Every related `ShipperAdvance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperAdvanceFilter>;
  /** Some related `ShipperAdvance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperAdvanceFilter>;
  /** No related `ShipperAdvance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperAdvanceFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ProductSpecyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `productSpecies` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ProductSpecyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `productSpecies` to be deleted. */
  nodeId: Scalars['ID'];
};

/** A connection to a list of `ProductVariety` values. */
export type ProductVarietiesConnection = {
  __typename?: 'ProductVarietiesConnection';
  /** A list of `ProductVariety` objects. */
  nodes: Array<Maybe<ProductVariety>>;
  /** A list of edges which contains the `ProductVariety` and cursor to aid in pagination. */
  edges: Array<ProductVarietiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductVariety` edge in the connection. */
export type ProductVarietiesEdge = {
  __typename?: 'ProductVarietiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductVariety` at the end of the edge. */
  node?: Maybe<ProductVariety>;
};

/** Methods to use when ordering `ProductVariety`. */
export enum ProductVarietiesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VarietyDescriptionAsc = 'VARIETY_DESCRIPTION_ASC',
  VarietyDescriptionDesc = 'VARIETY_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  CustomerLetterSequenceAsc = 'CUSTOMER_LETTER_SEQUENCE_ASC',
  CustomerLetterSequenceDesc = 'CUSTOMER_LETTER_SEQUENCE_DESC',
  SummaryCodeAsc = 'SUMMARY_CODE_ASC',
  SummaryCodeDesc = 'SUMMARY_CODE_DESC',
  VarietyGroupAsc = 'VARIETY_GROUP_ASC',
  VarietyGroupDesc = 'VARIETY_GROUP_DESC',
  CombineWithAsc = 'COMBINE_WITH_ASC',
  CombineWithDesc = 'COMBINE_WITH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonVarietiesByProductVarietyIdCountAsc = 'COMMON_VARIETIES_BY_PRODUCT_VARIETY_ID__COUNT_ASC',
  CommonVarietiesByProductVarietyIdCountDesc = 'COMMON_VARIETIES_BY_PRODUCT_VARIETY_ID__COUNT_DESC',
  CommonVarietyProductVarietiesByProductVarietyIdCountAsc = 'COMMON_VARIETY_PRODUCT_VARIETIES_BY_PRODUCT_VARIETY_ID__COUNT_ASC',
  CommonVarietyProductVarietiesByProductVarietyIdCountDesc = 'COMMON_VARIETY_PRODUCT_VARIETIES_BY_PRODUCT_VARIETY_ID__COUNT_DESC'
}

export type ProductVariety = Node & {
  __typename?: 'ProductVariety';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarieties: CommonVarietiesConnection;
  /** Reads and enables pagination through a set of `CommonVarietyProductVariety`. */
  commonVarietyProductVarieties: CommonVarietyProductVarietiesConnection;
  commonVariety?: Maybe<CommonVariety>;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesId: ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyId: ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdManyToManyConnection;
};


export type ProductVarietyCommonVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type ProductVarietyCommonVarietyProductVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyProductVarietyCondition>;
  filter?: Maybe<CommonVarietyProductVarietyFilter>;
};


export type ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `CommonVariety`. */
export type ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `CommonVariety`, and the cursor to aid in pagination. */
  edges: Array<ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `CommonVariety`. */
export type ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarieties: CommonVarietiesConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `CommonVariety`. */
export type ProductVarietyCommonSpeciesByCommonVarietyProductVarietyIdAndCommonSpeciesIdManyToManyEdgeCommonVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `CommonVarietyProductVariety`. */
export type ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `CommonVarietyProductVariety`, and the cursor to aid in pagination. */
  edges: Array<ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `CommonVarietyProductVariety`. */
export type ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `CommonVarietyProductVariety`. */
  commonVarietyProductVarieties: CommonVarietyProductVarietiesConnection;
};


/** A `CommonVariety` edge in the connection, with data from `CommonVarietyProductVariety`. */
export type ProductVarietyCommonVarietiesByCommonVarietyProductVarietyProductVarietyIdAndCommonVarietyIdManyToManyEdgeCommonVarietyProductVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyProductVarietyCondition>;
  filter?: Maybe<CommonVarietyProductVarietyFilter>;
};

/**
 * A condition to be used against `ProductVariety` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ProductVarietyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyDescription` field. */
  varietyDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerLetterSequence` field. */
  customerLetterSequence?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summaryCode` field. */
  summaryCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyGroup` field. */
  varietyGroup?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `combineWith` field. */
  combineWith?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ProductVariety` object types. All fields are combined with a logical ‘and.’ */
export type ProductVarietyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyDescription` field. */
  varietyDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `customerLetterSequence` field. */
  customerLetterSequence?: Maybe<StringFilter>;
  /** Filter by the object’s `summaryCode` field. */
  summaryCode?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyGroup` field. */
  varietyGroup?: Maybe<StringFilter>;
  /** Filter by the object’s `combineWith` field. */
  combineWith?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `commonVarieties` relation. */
  commonVarieties?: Maybe<ProductVarietyToManyCommonVarietyFilter>;
  /** Some related `commonVarieties` exist. */
  commonVarietiesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonVarietyProductVarieties` relation. */
  commonVarietyProductVarieties?: Maybe<ProductVarietyToManyCommonVarietyProductVarietyFilter>;
  /** Some related `commonVarietyProductVarieties` exist. */
  commonVarietyProductVarietiesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ProductVarietyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ProductVarietyFilter>>;
  /** Negates the expression. */
  not?: Maybe<ProductVarietyFilter>;
};

/** An input for mutations affecting `ProductVariety` */
export type ProductVarietyInput = {
  id: Scalars['String'];
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  commonVarietiesUsingId?: Maybe<CommonVarietyProductVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ProductVarietyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `productVariety` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ProductVarietyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `productVariety` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ProductVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** The fields on `productVariety` to look up the row to update. */
export type ProductVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyUsingProductVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `productVariety` being updated. */
  patch: UpdateProductVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVarietyProductVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVarietyProductVariety` being updated. */
  patch: CommonVarietyProductVarietyPatch;
};

/** The fields on `productVariety` to look up the row to update. */
export type ProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyUsingProductVarietyPkeyUpdate = {
  /** An object where the defined keys will be set on the `productVariety` being updated. */
  patch: UpdateProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyPatch;
  id: Scalars['String'];
};

/** Represents an update to a `ProductVariety`. Fields that are set will be updated. */
export type ProductVarietyPatch = {
  id?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  commonVarietiesUsingId?: Maybe<CommonVarietyProductVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInverseInput>;
};

/** The fields on `productVariety` to look up the row to connect. */
export type ProductVarietyProductVarietyPkeyConnect = {
  id: Scalars['String'];
};

/** The fields on `productVariety` to look up the row to delete. */
export type ProductVarietyProductVarietyPkeyDelete = {
  id: Scalars['String'];
};

/** A filter to be used against many `CommonVariety` object types. All fields are combined with a logical ‘and.’ */
export type ProductVarietyToManyCommonVarietyFilter = {
  /** Every related `CommonVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonVarietyFilter>;
  /** Some related `CommonVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonVarietyFilter>;
  /** No related `CommonVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonVarietyFilter>;
};

/** A filter to be used against many `CommonVarietyProductVariety` object types. All fields are combined with a logical ‘and.’ */
export type ProductVarietyToManyCommonVarietyProductVarietyFilter = {
  /** Every related `CommonVarietyProductVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CommonVarietyProductVarietyFilter>;
  /** Some related `CommonVarietyProductVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CommonVarietyProductVarietyFilter>;
  /** No related `CommonVarietyProductVariety` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CommonVarietyProductVarietyFilter>;
};

export type PsaApplePallet = Node & {
  __typename?: 'PsaApplePallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  crackingPieces?: Maybe<Scalars['String']>;
  crackingPct?: Maybe<Scalars['String']>;
  bitterPitPieces?: Maybe<Scalars['String']>;
  bitterPitPct?: Maybe<Scalars['String']>;
  bitterPitDeg?: Maybe<Scalars['String']>;
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  watercorePieces?: Maybe<Scalars['String']>;
  watercorePct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaApplePalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaApplePallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaApplePalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `runNumber` field. */
  runNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groundColor` field. */
  groundColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPct` field. */
  cutsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPct` field. */
  scaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `crackingPieces` field. */
  crackingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `crackingPct` field. */
  crackingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bitterPitPieces` field. */
  bitterPitPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bitterPitPct` field. */
  bitterPitPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bitterPitDeg` field. */
  bitterPitDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lenticelBreakdownPieces` field. */
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lenticelBreakdownPct` field. */
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lenticelBreakdownDeg` field. */
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `watercorePieces` field. */
  watercorePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `watercorePct` field. */
  watercorePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaApplePallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaApplePalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `runNumber` field. */
  runNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `groundColor` field. */
  groundColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPct` field. */
  cutsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPct` field. */
  scaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `crackingPieces` field. */
  crackingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `crackingPct` field. */
  crackingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bitterPitPieces` field. */
  bitterPitPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bitterPitPct` field. */
  bitterPitPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bitterPitDeg` field. */
  bitterPitDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `lenticelBreakdownPieces` field. */
  lenticelBreakdownPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `lenticelBreakdownPct` field. */
  lenticelBreakdownPct?: Maybe<StringFilter>;
  /** Filter by the object’s `lenticelBreakdownDeg` field. */
  lenticelBreakdownDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `watercorePieces` field. */
  watercorePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `watercorePct` field. */
  watercorePct?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaApplePalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaApplePalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaApplePalletFilter>;
};

/** An input for mutations affecting `PsaApplePallet` */
export type PsaApplePalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  crackingPieces?: Maybe<Scalars['String']>;
  crackingPct?: Maybe<Scalars['String']>;
  bitterPitPieces?: Maybe<Scalars['String']>;
  bitterPitPct?: Maybe<Scalars['String']>;
  bitterPitDeg?: Maybe<Scalars['String']>;
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  watercorePieces?: Maybe<Scalars['String']>;
  watercorePct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaApplePallet`. Fields that are set will be updated. */
export type PsaApplePalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  crackingPieces?: Maybe<Scalars['String']>;
  crackingPct?: Maybe<Scalars['String']>;
  bitterPitPieces?: Maybe<Scalars['String']>;
  bitterPitPct?: Maybe<Scalars['String']>;
  bitterPitDeg?: Maybe<Scalars['String']>;
  lenticelBreakdownPieces?: Maybe<Scalars['String']>;
  lenticelBreakdownPct?: Maybe<Scalars['String']>;
  lenticelBreakdownDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  watercorePieces?: Maybe<Scalars['String']>;
  watercorePct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaApplePallet` values. */
export type PsaApplePalletsConnection = {
  __typename?: 'PsaApplePalletsConnection';
  /** A list of `PsaApplePallet` objects. */
  nodes: Array<Maybe<PsaApplePallet>>;
  /** A list of edges which contains the `PsaApplePallet` and cursor to aid in pagination. */
  edges: Array<PsaApplePalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaApplePallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaApplePallet` edge in the connection. */
export type PsaApplePalletsEdge = {
  __typename?: 'PsaApplePalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaApplePallet` at the end of the edge. */
  node?: Maybe<PsaApplePallet>;
};

/** Methods to use when ordering `PsaApplePallet`. */
export enum PsaApplePalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  RunNumberAsc = 'RUN_NUMBER_ASC',
  RunNumberDesc = 'RUN_NUMBER_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  GroundColorAsc = 'GROUND_COLOR_ASC',
  GroundColorDesc = 'GROUND_COLOR_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  StemPuncturesPiecesAsc = 'STEM_PUNCTURES_PIECES_ASC',
  StemPuncturesPiecesDesc = 'STEM_PUNCTURES_PIECES_DESC',
  StemPuncturesPctAsc = 'STEM_PUNCTURES_PCT_ASC',
  StemPuncturesPctDesc = 'STEM_PUNCTURES_PCT_DESC',
  CutsPiecesAsc = 'CUTS_PIECES_ASC',
  CutsPiecesDesc = 'CUTS_PIECES_DESC',
  CutsPctAsc = 'CUTS_PCT_ASC',
  CutsPctDesc = 'CUTS_PCT_DESC',
  CutsDegAsc = 'CUTS_DEG_ASC',
  CutsDegDesc = 'CUTS_DEG_DESC',
  SunScaldPiecesAsc = 'SUN_SCALD_PIECES_ASC',
  SunScaldPiecesDesc = 'SUN_SCALD_PIECES_DESC',
  SunScaldPctAsc = 'SUN_SCALD_PCT_ASC',
  SunScaldPctDesc = 'SUN_SCALD_PCT_DESC',
  SunScaldDegAsc = 'SUN_SCALD_DEG_ASC',
  SunScaldDegDesc = 'SUN_SCALD_DEG_DESC',
  ScaldPiecesAsc = 'SCALD_PIECES_ASC',
  ScaldPiecesDesc = 'SCALD_PIECES_DESC',
  ScaldPctAsc = 'SCALD_PCT_ASC',
  ScaldPctDesc = 'SCALD_PCT_DESC',
  ScaldDegAsc = 'SCALD_DEG_ASC',
  ScaldDegDesc = 'SCALD_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  CrackingPiecesAsc = 'CRACKING_PIECES_ASC',
  CrackingPiecesDesc = 'CRACKING_PIECES_DESC',
  CrackingPctAsc = 'CRACKING_PCT_ASC',
  CrackingPctDesc = 'CRACKING_PCT_DESC',
  BitterPitPiecesAsc = 'BITTER_PIT_PIECES_ASC',
  BitterPitPiecesDesc = 'BITTER_PIT_PIECES_DESC',
  BitterPitPctAsc = 'BITTER_PIT_PCT_ASC',
  BitterPitPctDesc = 'BITTER_PIT_PCT_DESC',
  BitterPitDegAsc = 'BITTER_PIT_DEG_ASC',
  BitterPitDegDesc = 'BITTER_PIT_DEG_DESC',
  LenticelBreakdownPiecesAsc = 'LENTICEL_BREAKDOWN_PIECES_ASC',
  LenticelBreakdownPiecesDesc = 'LENTICEL_BREAKDOWN_PIECES_DESC',
  LenticelBreakdownPctAsc = 'LENTICEL_BREAKDOWN_PCT_ASC',
  LenticelBreakdownPctDesc = 'LENTICEL_BREAKDOWN_PCT_DESC',
  LenticelBreakdownDegAsc = 'LENTICEL_BREAKDOWN_DEG_ASC',
  LenticelBreakdownDegDesc = 'LENTICEL_BREAKDOWN_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  WatercorePiecesAsc = 'WATERCORE_PIECES_ASC',
  WatercorePiecesDesc = 'WATERCORE_PIECES_DESC',
  WatercorePctAsc = 'WATERCORE_PCT_ASC',
  WatercorePctDesc = 'WATERCORE_PCT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaArrivalPicture = Node & {
  __typename?: 'PsaArrivalPicture';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  pictureDate?: Maybe<Scalars['Date']>;
  arrivalCode?: Maybe<Scalars['String']>;
  pictureDescription?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  varietyName?: Maybe<Scalars['String']>;
  imageUrl: Scalars['String'];
};

/**
 * A condition to be used against `PsaArrivalPicture` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaArrivalPictureCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pictureDate` field. */
  pictureDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pictureDescription` field. */
  pictureDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterId` field. */
  exporterId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `varietyName` field. */
  varietyName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaArrivalPicture` object types. All fields are combined with a logical ‘and.’ */
export type PsaArrivalPictureFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `pictureDate` field. */
  pictureDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<StringFilter>;
  /** Filter by the object’s `pictureDescription` field. */
  pictureDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterId` field. */
  exporterId?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `varietyName` field. */
  varietyName?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaArrivalPictureFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaArrivalPictureFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaArrivalPictureFilter>;
};

/** An input for mutations affecting `PsaArrivalPicture` */
export type PsaArrivalPictureInput = {
  id: Scalars['BigInt'];
  pictureDate?: Maybe<Scalars['Date']>;
  arrivalCode?: Maybe<Scalars['String']>;
  pictureDescription?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  varietyName?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaArrivalPicture`. Fields that are set will be updated. */
export type PsaArrivalPicturePatch = {
  id?: Maybe<Scalars['BigInt']>;
  pictureDate?: Maybe<Scalars['Date']>;
  arrivalCode?: Maybe<Scalars['String']>;
  pictureDescription?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  varietyName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaArrivalPicture` values. */
export type PsaArrivalPicturesConnection = {
  __typename?: 'PsaArrivalPicturesConnection';
  /** A list of `PsaArrivalPicture` objects. */
  nodes: Array<Maybe<PsaArrivalPicture>>;
  /** A list of edges which contains the `PsaArrivalPicture` and cursor to aid in pagination. */
  edges: Array<PsaArrivalPicturesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaArrivalPicture` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaArrivalPicture` edge in the connection. */
export type PsaArrivalPicturesEdge = {
  __typename?: 'PsaArrivalPicturesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaArrivalPicture` at the end of the edge. */
  node?: Maybe<PsaArrivalPicture>;
};

/** Methods to use when ordering `PsaArrivalPicture`. */
export enum PsaArrivalPicturesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PictureDateAsc = 'PICTURE_DATE_ASC',
  PictureDateDesc = 'PICTURE_DATE_DESC',
  ArrivalCodeAsc = 'ARRIVAL_CODE_ASC',
  ArrivalCodeDesc = 'ARRIVAL_CODE_DESC',
  PictureDescriptionAsc = 'PICTURE_DESCRIPTION_ASC',
  PictureDescriptionDesc = 'PICTURE_DESCRIPTION_DESC',
  ExporterIdAsc = 'EXPORTER_ID_ASC',
  ExporterIdDesc = 'EXPORTER_ID_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyNameAsc = 'VARIETY_NAME_ASC',
  VarietyNameDesc = 'VARIETY_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaArrivalReport = Node & {
  __typename?: 'PsaArrivalReport';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  reportDate?: Maybe<Scalars['Date']>;
  locationName?: Maybe<Scalars['String']>;
  arrivalCode?: Maybe<Scalars['String']>;
  arrivalName?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaApplePallet`. */
  applePallets: PsaApplePalletsConnection;
  /** Reads and enables pagination through a set of `PsaCherryPallet`. */
  cherryPallets: PsaCherryPalletsConnection;
  /** Reads and enables pagination through a set of `PsaCitrusPallet`. */
  citrusPallets: PsaCitrusPalletsConnection;
  commodityList?: Maybe<Array<Maybe<Scalars['String']>>>;
  conditionRange?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaGrapePallet`. */
  grapePallets: PsaGrapePalletsConnection;
  /** Reads and enables pagination through a set of `PsaLemonPallet`. */
  lemonPallets: PsaLemonPalletsConnection;
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Reads and enables pagination through a set of `PsaPearPallet`. */
  pearPallets: PsaPearPalletsConnection;
  /** Reads and enables pagination through a set of `PsaPersimmonPallet`. */
  persimmonPallets: PsaPersimmonPalletsConnection;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
  /** Reads and enables pagination through a set of `PsaPomegranatePallet`. */
  pomegranatePallets: PsaPomegranatePalletsConnection;
  qualityRange?: Maybe<Scalars['String']>;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `PsaStoneFruitPallet`. */
  stoneFruitPallets: PsaStoneFruitPalletsConnection;
  varietyList?: Maybe<Array<Maybe<Scalars['String']>>>;
  vessel?: Maybe<Vessel>;
  reportUrl: Scalars['String'];
};


export type PsaArrivalReportApplePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
  filter?: Maybe<PsaApplePalletFilter>;
};


export type PsaArrivalReportCherryPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
  filter?: Maybe<PsaCherryPalletFilter>;
};


export type PsaArrivalReportCitrusPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
  filter?: Maybe<PsaCitrusPalletFilter>;
};


export type PsaArrivalReportGrapePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
  filter?: Maybe<PsaGrapePalletFilter>;
};


export type PsaArrivalReportLemonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
  filter?: Maybe<PsaLemonPalletFilter>;
};


export type PsaArrivalReportPearPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
  filter?: Maybe<PsaPearPalletFilter>;
};


export type PsaArrivalReportPersimmonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
  filter?: Maybe<PsaPersimmonPalletFilter>;
};


export type PsaArrivalReportPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  condition?: Maybe<PsaArrivalPictureCondition>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};


export type PsaArrivalReportPomegranatePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
  filter?: Maybe<PsaPomegranatePalletFilter>;
};


export type PsaArrivalReportStoneFruitPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
  filter?: Maybe<PsaStoneFruitPalletFilter>;
};


export type PsaArrivalReportVarietyListArgs = {
  com?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `PsaArrivalReport` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaArrivalReportCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `reportDate` field. */
  reportDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `locationName` field. */
  locationName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalName` field. */
  arrivalName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterId` field. */
  exporterId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaArrivalReport` object types. All fields are combined with a logical ‘and.’ */
export type PsaArrivalReportFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `reportDate` field. */
  reportDate?: Maybe<DateFilter>;
  /** Filter by the object’s `locationName` field. */
  locationName?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalCode` field. */
  arrivalCode?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalName` field. */
  arrivalName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterId` field. */
  exporterId?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodityList` field. */
  commodityList?: Maybe<StringListFilter>;
  /** Filter by the object’s `conditionRange` field. */
  conditionRange?: Maybe<StringFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `qualityRange` field. */
  qualityRange?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaArrivalReportFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaArrivalReportFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaArrivalReportFilter>;
};

/** An input for mutations affecting `PsaArrivalReport` */
export type PsaArrivalReportInput = {
  id: Scalars['BigInt'];
  reportDate?: Maybe<Scalars['Date']>;
  locationName?: Maybe<Scalars['String']>;
  arrivalCode?: Maybe<Scalars['String']>;
  arrivalName?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaArrivalReport`. Fields that are set will be updated. */
export type PsaArrivalReportPatch = {
  id?: Maybe<Scalars['BigInt']>;
  reportDate?: Maybe<Scalars['Date']>;
  locationName?: Maybe<Scalars['String']>;
  arrivalCode?: Maybe<Scalars['String']>;
  arrivalName?: Maybe<Scalars['String']>;
  exporterId?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaArrivalReport` values. */
export type PsaArrivalReportsConnection = {
  __typename?: 'PsaArrivalReportsConnection';
  /** A list of `PsaArrivalReport` objects. */
  nodes: Array<Maybe<PsaArrivalReport>>;
  /** A list of edges which contains the `PsaArrivalReport` and cursor to aid in pagination. */
  edges: Array<PsaArrivalReportsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaArrivalReport` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaArrivalReport` edge in the connection. */
export type PsaArrivalReportsEdge = {
  __typename?: 'PsaArrivalReportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaArrivalReport` at the end of the edge. */
  node?: Maybe<PsaArrivalReport>;
};

/** Methods to use when ordering `PsaArrivalReport`. */
export enum PsaArrivalReportsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReportDateAsc = 'REPORT_DATE_ASC',
  ReportDateDesc = 'REPORT_DATE_DESC',
  LocationNameAsc = 'LOCATION_NAME_ASC',
  LocationNameDesc = 'LOCATION_NAME_DESC',
  ArrivalCodeAsc = 'ARRIVAL_CODE_ASC',
  ArrivalCodeDesc = 'ARRIVAL_CODE_DESC',
  ArrivalNameAsc = 'ARRIVAL_NAME_ASC',
  ArrivalNameDesc = 'ARRIVAL_NAME_DESC',
  ExporterIdAsc = 'EXPORTER_ID_ASC',
  ExporterIdDesc = 'EXPORTER_ID_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  ConditionRangeAsc = 'CONDITION_RANGE_ASC',
  ConditionRangeDesc = 'CONDITION_RANGE_DESC',
  QualityRangeAsc = 'QUALITY_RANGE_ASC',
  QualityRangeDesc = 'QUALITY_RANGE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaCherryPallet = Node & {
  __typename?: 'PsaCherryPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  misshapenPieces?: Maybe<Scalars['String']>;
  misshapenPct?: Maybe<Scalars['String']>;
  stemlessPieces?: Maybe<Scalars['String']>;
  stemlessPct?: Maybe<Scalars['String']>;
  splitsPieces?: Maybe<Scalars['String']>;
  splitsPct?: Maybe<Scalars['String']>;
  splitsDeg?: Maybe<Scalars['String']>;
  firmness?: Maybe<Scalars['String']>;
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  pittingBruisingPct?: Maybe<Scalars['String']>;
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaCherryPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaCherryPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaCherryPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMin` field. */
  sizeMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMax` field. */
  sizeMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMost` field. */
  sizeMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `misshapenPieces` field. */
  misshapenPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `misshapenPct` field. */
  misshapenPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemlessPieces` field. */
  stemlessPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemlessPct` field. */
  stemlessPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsPieces` field. */
  splitsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsPct` field. */
  splitsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsDeg` field. */
  splitsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `firmness` field. */
  firmness?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pittingBruisingPieces` field. */
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pittingBruisingPct` field. */
  pittingBruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pittingBruisingDeg` field. */
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationPieces` field. */
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaCherryPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaCherryPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMin` field. */
  sizeMin?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMax` field. */
  sizeMax?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMost` field. */
  sizeMost?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `misshapenPieces` field. */
  misshapenPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `misshapenPct` field. */
  misshapenPct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemlessPieces` field. */
  stemlessPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemlessPct` field. */
  stemlessPct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsPieces` field. */
  splitsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsPct` field. */
  splitsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsDeg` field. */
  splitsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `firmness` field. */
  firmness?: Maybe<StringFilter>;
  /** Filter by the object’s `pittingBruisingPieces` field. */
  pittingBruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `pittingBruisingPct` field. */
  pittingBruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pittingBruisingDeg` field. */
  pittingBruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationPieces` field. */
  stemDehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaCherryPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaCherryPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaCherryPalletFilter>;
};

/** An input for mutations affecting `PsaCherryPallet` */
export type PsaCherryPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  misshapenPieces?: Maybe<Scalars['String']>;
  misshapenPct?: Maybe<Scalars['String']>;
  stemlessPieces?: Maybe<Scalars['String']>;
  stemlessPct?: Maybe<Scalars['String']>;
  splitsPieces?: Maybe<Scalars['String']>;
  splitsPct?: Maybe<Scalars['String']>;
  splitsDeg?: Maybe<Scalars['String']>;
  firmness?: Maybe<Scalars['String']>;
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  pittingBruisingPct?: Maybe<Scalars['String']>;
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaCherryPallet`. Fields that are set will be updated. */
export type PsaCherryPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  misshapenPieces?: Maybe<Scalars['String']>;
  misshapenPct?: Maybe<Scalars['String']>;
  stemlessPieces?: Maybe<Scalars['String']>;
  stemlessPct?: Maybe<Scalars['String']>;
  splitsPieces?: Maybe<Scalars['String']>;
  splitsPct?: Maybe<Scalars['String']>;
  splitsDeg?: Maybe<Scalars['String']>;
  firmness?: Maybe<Scalars['String']>;
  pittingBruisingPieces?: Maybe<Scalars['String']>;
  pittingBruisingPct?: Maybe<Scalars['String']>;
  pittingBruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPieces?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaCherryPallet` values. */
export type PsaCherryPalletsConnection = {
  __typename?: 'PsaCherryPalletsConnection';
  /** A list of `PsaCherryPallet` objects. */
  nodes: Array<Maybe<PsaCherryPallet>>;
  /** A list of edges which contains the `PsaCherryPallet` and cursor to aid in pagination. */
  edges: Array<PsaCherryPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaCherryPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaCherryPallet` edge in the connection. */
export type PsaCherryPalletsEdge = {
  __typename?: 'PsaCherryPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaCherryPallet` at the end of the edge. */
  node?: Maybe<PsaCherryPallet>;
};

/** Methods to use when ordering `PsaCherryPallet`. */
export enum PsaCherryPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  SizeMinAsc = 'SIZE_MIN_ASC',
  SizeMinDesc = 'SIZE_MIN_DESC',
  SizeMaxAsc = 'SIZE_MAX_ASC',
  SizeMaxDesc = 'SIZE_MAX_DESC',
  SizeMostAsc = 'SIZE_MOST_ASC',
  SizeMostDesc = 'SIZE_MOST_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  ScarsMarksPiecesAsc = 'SCARS_MARKS_PIECES_ASC',
  ScarsMarksPiecesDesc = 'SCARS_MARKS_PIECES_DESC',
  ScarsMarksPctAsc = 'SCARS_MARKS_PCT_ASC',
  ScarsMarksPctDesc = 'SCARS_MARKS_PCT_DESC',
  ScarsMarksDegAsc = 'SCARS_MARKS_DEG_ASC',
  ScarsMarksDegDesc = 'SCARS_MARKS_DEG_DESC',
  MisshapenPiecesAsc = 'MISSHAPEN_PIECES_ASC',
  MisshapenPiecesDesc = 'MISSHAPEN_PIECES_DESC',
  MisshapenPctAsc = 'MISSHAPEN_PCT_ASC',
  MisshapenPctDesc = 'MISSHAPEN_PCT_DESC',
  StemlessPiecesAsc = 'STEMLESS_PIECES_ASC',
  StemlessPiecesDesc = 'STEMLESS_PIECES_DESC',
  StemlessPctAsc = 'STEMLESS_PCT_ASC',
  StemlessPctDesc = 'STEMLESS_PCT_DESC',
  SplitsPiecesAsc = 'SPLITS_PIECES_ASC',
  SplitsPiecesDesc = 'SPLITS_PIECES_DESC',
  SplitsPctAsc = 'SPLITS_PCT_ASC',
  SplitsPctDesc = 'SPLITS_PCT_DESC',
  SplitsDegAsc = 'SPLITS_DEG_ASC',
  SplitsDegDesc = 'SPLITS_DEG_DESC',
  FirmnessAsc = 'FIRMNESS_ASC',
  FirmnessDesc = 'FIRMNESS_DESC',
  PittingBruisingPiecesAsc = 'PITTING_BRUISING_PIECES_ASC',
  PittingBruisingPiecesDesc = 'PITTING_BRUISING_PIECES_DESC',
  PittingBruisingPctAsc = 'PITTING_BRUISING_PCT_ASC',
  PittingBruisingPctDesc = 'PITTING_BRUISING_PCT_DESC',
  PittingBruisingDegAsc = 'PITTING_BRUISING_DEG_ASC',
  PittingBruisingDegDesc = 'PITTING_BRUISING_DEG_DESC',
  StemDehydrationPiecesAsc = 'STEM_DEHYDRATION_PIECES_ASC',
  StemDehydrationPiecesDesc = 'STEM_DEHYDRATION_PIECES_DESC',
  StemDehydrationPctAsc = 'STEM_DEHYDRATION_PCT_ASC',
  StemDehydrationPctDesc = 'STEM_DEHYDRATION_PCT_DESC',
  StemDehydrationDegAsc = 'STEM_DEHYDRATION_DEG_ASC',
  StemDehydrationDegDesc = 'STEM_DEHYDRATION_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaCitrusPallet = Node & {
  __typename?: 'PsaCitrusPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  skinBreakdownPct?: Maybe<Scalars['String']>;
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  creasingPieces?: Maybe<Scalars['String']>;
  creasingPct?: Maybe<Scalars['String']>;
  creasingDeg?: Maybe<Scalars['String']>;
  puffinessPieces?: Maybe<Scalars['String']>;
  puffinessPct?: Maybe<Scalars['String']>;
  puffinessDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaCitrusPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaCitrusPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaCitrusPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPct` field. */
  seedsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinBreakdownPieces` field. */
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinBreakdownPct` field. */
  skinBreakdownPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinBreakdownDeg` field. */
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creasingPieces` field. */
  creasingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creasingPct` field. */
  creasingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `creasingDeg` field. */
  creasingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `puffinessPieces` field. */
  puffinessPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `puffinessPct` field. */
  puffinessPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `puffinessDeg` field. */
  puffinessDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPct` field. */
  sporesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaCitrusPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaCitrusPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPct` field. */
  seedsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `skinBreakdownPieces` field. */
  skinBreakdownPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `skinBreakdownPct` field. */
  skinBreakdownPct?: Maybe<StringFilter>;
  /** Filter by the object’s `skinBreakdownDeg` field. */
  skinBreakdownDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `creasingPieces` field. */
  creasingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `creasingPct` field. */
  creasingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `creasingDeg` field. */
  creasingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `puffinessPieces` field. */
  puffinessPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `puffinessPct` field. */
  puffinessPct?: Maybe<StringFilter>;
  /** Filter by the object’s `puffinessDeg` field. */
  puffinessDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPct` field. */
  sporesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaCitrusPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaCitrusPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaCitrusPalletFilter>;
};

/** An input for mutations affecting `PsaCitrusPallet` */
export type PsaCitrusPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  skinBreakdownPct?: Maybe<Scalars['String']>;
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  creasingPieces?: Maybe<Scalars['String']>;
  creasingPct?: Maybe<Scalars['String']>;
  creasingDeg?: Maybe<Scalars['String']>;
  puffinessPieces?: Maybe<Scalars['String']>;
  puffinessPct?: Maybe<Scalars['String']>;
  puffinessDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaCitrusPallet`. Fields that are set will be updated. */
export type PsaCitrusPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  skinBreakdownPieces?: Maybe<Scalars['String']>;
  skinBreakdownPct?: Maybe<Scalars['String']>;
  skinBreakdownDeg?: Maybe<Scalars['String']>;
  creasingPieces?: Maybe<Scalars['String']>;
  creasingPct?: Maybe<Scalars['String']>;
  creasingDeg?: Maybe<Scalars['String']>;
  puffinessPieces?: Maybe<Scalars['String']>;
  puffinessPct?: Maybe<Scalars['String']>;
  puffinessDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaCitrusPallet` values. */
export type PsaCitrusPalletsConnection = {
  __typename?: 'PsaCitrusPalletsConnection';
  /** A list of `PsaCitrusPallet` objects. */
  nodes: Array<Maybe<PsaCitrusPallet>>;
  /** A list of edges which contains the `PsaCitrusPallet` and cursor to aid in pagination. */
  edges: Array<PsaCitrusPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaCitrusPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaCitrusPallet` edge in the connection. */
export type PsaCitrusPalletsEdge = {
  __typename?: 'PsaCitrusPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaCitrusPallet` at the end of the edge. */
  node?: Maybe<PsaCitrusPallet>;
};

/** Methods to use when ordering `PsaCitrusPallet`. */
export enum PsaCitrusPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  DiameterMinMmAsc = 'DIAMETER_MIN_MM_ASC',
  DiameterMinMmDesc = 'DIAMETER_MIN_MM_DESC',
  DiameterMinInchesAsc = 'DIAMETER_MIN_INCHES_ASC',
  DiameterMinInchesDesc = 'DIAMETER_MIN_INCHES_DESC',
  DiameterMaxMmAsc = 'DIAMETER_MAX_MM_ASC',
  DiameterMaxMmDesc = 'DIAMETER_MAX_MM_DESC',
  DiameterMaxInchesAsc = 'DIAMETER_MAX_INCHES_ASC',
  DiameterMaxInchesDesc = 'DIAMETER_MAX_INCHES_DESC',
  DiameterMostMmAsc = 'DIAMETER_MOST_MM_ASC',
  DiameterMostMmDesc = 'DIAMETER_MOST_MM_DESC',
  DiameterMostInchesAsc = 'DIAMETER_MOST_INCHES_ASC',
  DiameterMostInchesDesc = 'DIAMETER_MOST_INCHES_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  GreenHazePiecesAsc = 'GREEN_HAZE_PIECES_ASC',
  GreenHazePiecesDesc = 'GREEN_HAZE_PIECES_DESC',
  GreenHazePctAsc = 'GREEN_HAZE_PCT_ASC',
  GreenHazePctDesc = 'GREEN_HAZE_PCT_DESC',
  GreenHazeDegAsc = 'GREEN_HAZE_DEG_ASC',
  GreenHazeDegDesc = 'GREEN_HAZE_DEG_DESC',
  OilSpotsPiecesAsc = 'OIL_SPOTS_PIECES_ASC',
  OilSpotsPiecesDesc = 'OIL_SPOTS_PIECES_DESC',
  OilSpotsPctAsc = 'OIL_SPOTS_PCT_ASC',
  OilSpotsPctDesc = 'OIL_SPOTS_PCT_DESC',
  OilSpotsDegAsc = 'OIL_SPOTS_DEG_ASC',
  OilSpotsDegDesc = 'OIL_SPOTS_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  DryPulpPiecesAsc = 'DRY_PULP_PIECES_ASC',
  DryPulpPiecesDesc = 'DRY_PULP_PIECES_DESC',
  DryPulpPctAsc = 'DRY_PULP_PCT_ASC',
  DryPulpPctDesc = 'DRY_PULP_PCT_DESC',
  DryPulpDegAsc = 'DRY_PULP_DEG_ASC',
  DryPulpDegDesc = 'DRY_PULP_DEG_DESC',
  SeedsPiecesAsc = 'SEEDS_PIECES_ASC',
  SeedsPiecesDesc = 'SEEDS_PIECES_DESC',
  SeedsPctAsc = 'SEEDS_PCT_ASC',
  SeedsPctDesc = 'SEEDS_PCT_DESC',
  SkinBreakdownPiecesAsc = 'SKIN_BREAKDOWN_PIECES_ASC',
  SkinBreakdownPiecesDesc = 'SKIN_BREAKDOWN_PIECES_DESC',
  SkinBreakdownPctAsc = 'SKIN_BREAKDOWN_PCT_ASC',
  SkinBreakdownPctDesc = 'SKIN_BREAKDOWN_PCT_DESC',
  SkinBreakdownDegAsc = 'SKIN_BREAKDOWN_DEG_ASC',
  SkinBreakdownDegDesc = 'SKIN_BREAKDOWN_DEG_DESC',
  CreasingPiecesAsc = 'CREASING_PIECES_ASC',
  CreasingPiecesDesc = 'CREASING_PIECES_DESC',
  CreasingPctAsc = 'CREASING_PCT_ASC',
  CreasingPctDesc = 'CREASING_PCT_DESC',
  CreasingDegAsc = 'CREASING_DEG_ASC',
  CreasingDegDesc = 'CREASING_DEG_DESC',
  PuffinessPiecesAsc = 'PUFFINESS_PIECES_ASC',
  PuffinessPiecesDesc = 'PUFFINESS_PIECES_DESC',
  PuffinessPctAsc = 'PUFFINESS_PCT_ASC',
  PuffinessPctDesc = 'PUFFINESS_PCT_DESC',
  PuffinessDegAsc = 'PUFFINESS_DEG_ASC',
  PuffinessDegDesc = 'PUFFINESS_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  SporesPiecesAsc = 'SPORES_PIECES_ASC',
  SporesPiecesDesc = 'SPORES_PIECES_DESC',
  SporesPctAsc = 'SPORES_PCT_ASC',
  SporesPctDesc = 'SPORES_PCT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaGrapePallet = Node & {
  __typename?: 'PsaGrapePallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['Date']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  autoOpening?: Maybe<Scalars['String']>;
  bunches?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  colorMin?: Maybe<Scalars['String']>;
  colorMax?: Maybe<Scalars['String']>;
  colorMost?: Maybe<Scalars['String']>;
  colorConsistency?: Maybe<Scalars['String']>;
  autoColorConsistency?: Maybe<Scalars['String']>;
  sunburnBunches?: Maybe<Scalars['String']>;
  autoSunburnBunches?: Maybe<Scalars['String']>;
  sunburnPct?: Maybe<Scalars['String']>;
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  bunchConformation?: Maybe<Scalars['String']>;
  autoBunchConformation?: Maybe<Scalars['String']>;
  stragglyBunches?: Maybe<Scalars['String']>;
  stragglyPct?: Maybe<Scalars['String']>;
  smallBunches?: Maybe<Scalars['String']>;
  russetMarksBunches?: Maybe<Scalars['String']>;
  russetMarksPct?: Maybe<Scalars['String']>;
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  dustPct?: Maybe<Scalars['String']>;
  autoDustPct?: Maybe<Scalars['String']>;
  residuesPct?: Maybe<Scalars['String']>;
  autoResiduesPct?: Maybe<Scalars['String']>;
  tightBunches?: Maybe<Scalars['String']>;
  autoTightBunches?: Maybe<Scalars['String']>;
  bruisingBunches?: Maybe<Scalars['String']>;
  autoBruisingBunches?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  berryCondition?: Maybe<Scalars['String']>;
  autoBerryCondition?: Maybe<Scalars['String']>;
  h2OBerries?: Maybe<Scalars['String']>;
  autoH2OBerries?: Maybe<Scalars['String']>;
  so2DamagePct?: Maybe<Scalars['String']>;
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  so2DamageDeg?: Maybe<Scalars['String']>;
  weakBunches?: Maybe<Scalars['String']>;
  autoWeakBunches?: Maybe<Scalars['String']>;
  splitsHairlinePct?: Maybe<Scalars['String']>;
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  splitsDryPct?: Maybe<Scalars['String']>;
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  intDisc?: Maybe<Scalars['String']>;
  autoIntDisc?: Maybe<Scalars['String']>;
  intDiscDeg?: Maybe<Scalars['String']>;
  decayMoldBerries?: Maybe<Scalars['String']>;
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  decayNestBerries?: Maybe<Scalars['String']>;
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  decayNestDeg?: Maybe<Scalars['String']>;
  shatterPct?: Maybe<Scalars['String']>;
  autoShatterPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  autoOverallQuality?: Maybe<Scalars['String']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  autoOverallCondition?: Maybe<Scalars['String']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaGrapePalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaGrapePallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaGrapePalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoOpening` field. */
  autoOpening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bunches` field. */
  bunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMin` field. */
  sizeMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMax` field. */
  sizeMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sizeMost` field. */
  sizeMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `undersizeBunchesCount` field. */
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoUndersizeBerriesBunches` field. */
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `undersizeBerriesPct` field. */
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorMin` field. */
  colorMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorMax` field. */
  colorMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorMost` field. */
  colorMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `colorConsistency` field. */
  colorConsistency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoColorConsistency` field. */
  autoColorConsistency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunburnBunches` field. */
  sunburnBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSunburnBunches` field. */
  autoSunburnBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunburnBunchesDeg` field. */
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bunchConformation` field. */
  bunchConformation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoBunchConformation` field. */
  autoBunchConformation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stragglyBunches` field. */
  stragglyBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stragglyPct` field. */
  stragglyPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `smallBunches` field. */
  smallBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `russetMarksBunches` field. */
  russetMarksBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `russetMarksPct` field. */
  russetMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoRussetMarksPct` field. */
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dustPct` field. */
  dustPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDustPct` field. */
  autoDustPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `residuesPct` field. */
  residuesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoResiduesPct` field. */
  autoResiduesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `tightBunches` field. */
  tightBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoTightBunches` field. */
  autoTightBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingBunches` field. */
  bruisingBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoBruisingBunches` field. */
  autoBruisingBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoStemDehydrationPct` field. */
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `berryCondition` field. */
  berryCondition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoBerryCondition` field. */
  autoBerryCondition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `h2OBerries` field. */
  h2OBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoH2OBerries` field. */
  autoH2OBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `so2DamagePct` field. */
  so2DamagePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSo2DamagePct` field. */
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `so2DamageDeg` field. */
  so2DamageDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weakBunches` field. */
  weakBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoWeakBunches` field. */
  autoWeakBunches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsHairlinePct` field. */
  splitsHairlinePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSplitsHairlinePct` field. */
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsWetCrushPct` field. */
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSplitsWetCrushPct` field. */
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitsDryPct` field. */
  splitsDryPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoSplitsDryPct` field. */
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `intDisc` field. */
  intDisc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoIntDisc` field. */
  autoIntDisc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `intDiscDeg` field. */
  intDiscDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayMoldBerries` field. */
  decayMoldBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDecayMoldBerries` field. */
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decaySlipskinBerries` field. */
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDecaySlipskinBerries` field. */
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayNestBerries` field. */
  decayNestBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoDecayNestBerries` field. */
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayNestDeg` field. */
  decayNestDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shatterPct` field. */
  shatterPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `autoShatterPct` field. */
  autoShatterPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMin` field. */
  brixMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMax` field. */
  brixMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMost` field. */
  brixMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `autoOverallQuality` field. */
  autoOverallQuality?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `autoOverallCondition` field. */
  autoOverallCondition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaGrapePallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaGrapePalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<DateFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `autoOpening` field. */
  autoOpening?: Maybe<StringFilter>;
  /** Filter by the object’s `bunches` field. */
  bunches?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMin` field. */
  sizeMin?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMax` field. */
  sizeMax?: Maybe<StringFilter>;
  /** Filter by the object’s `sizeMost` field. */
  sizeMost?: Maybe<StringFilter>;
  /** Filter by the object’s `undersizeBunchesCount` field. */
  undersizeBunchesCount?: Maybe<StringFilter>;
  /** Filter by the object’s `autoUndersizeBerriesBunches` field. */
  autoUndersizeBerriesBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `undersizeBerriesPct` field. */
  undersizeBerriesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `colorMin` field. */
  colorMin?: Maybe<StringFilter>;
  /** Filter by the object’s `colorMax` field. */
  colorMax?: Maybe<StringFilter>;
  /** Filter by the object’s `colorMost` field. */
  colorMost?: Maybe<StringFilter>;
  /** Filter by the object’s `colorConsistency` field. */
  colorConsistency?: Maybe<StringFilter>;
  /** Filter by the object’s `autoColorConsistency` field. */
  autoColorConsistency?: Maybe<StringFilter>;
  /** Filter by the object’s `sunburnBunches` field. */
  sunburnBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSunburnBunches` field. */
  autoSunburnBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `sunburnPct` field. */
  sunburnPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sunburnBunchesDeg` field. */
  sunburnBunchesDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bunchConformation` field. */
  bunchConformation?: Maybe<StringFilter>;
  /** Filter by the object’s `autoBunchConformation` field. */
  autoBunchConformation?: Maybe<StringFilter>;
  /** Filter by the object’s `stragglyBunches` field. */
  stragglyBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `stragglyPct` field. */
  stragglyPct?: Maybe<StringFilter>;
  /** Filter by the object’s `smallBunches` field. */
  smallBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `russetMarksBunches` field. */
  russetMarksBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `russetMarksPct` field. */
  russetMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoRussetMarksPct` field. */
  autoRussetMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dustPct` field. */
  dustPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDustPct` field. */
  autoDustPct?: Maybe<StringFilter>;
  /** Filter by the object’s `residuesPct` field. */
  residuesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoResiduesPct` field. */
  autoResiduesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `tightBunches` field. */
  tightBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoTightBunches` field. */
  autoTightBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingBunches` field. */
  bruisingBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoBruisingBunches` field. */
  autoBruisingBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationPct` field. */
  stemDehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoStemDehydrationPct` field. */
  autoStemDehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemDehydrationDeg` field. */
  stemDehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `berryCondition` field. */
  berryCondition?: Maybe<StringFilter>;
  /** Filter by the object’s `autoBerryCondition` field. */
  autoBerryCondition?: Maybe<StringFilter>;
  /** Filter by the object’s `h2OBerries` field. */
  h2OBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoH2OBerries` field. */
  autoH2OBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `so2DamagePct` field. */
  so2DamagePct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSo2DamagePct` field. */
  autoSo2DamagePct?: Maybe<StringFilter>;
  /** Filter by the object’s `so2DamageDeg` field. */
  so2DamageDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `weakBunches` field. */
  weakBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `autoWeakBunches` field. */
  autoWeakBunches?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsHairlinePct` field. */
  splitsHairlinePct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSplitsHairlinePct` field. */
  autoSplitsHairlinePct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsWetCrushPct` field. */
  splitsWetCrushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSplitsWetCrushPct` field. */
  autoSplitsWetCrushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `splitsDryPct` field. */
  splitsDryPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoSplitsDryPct` field. */
  autoSplitsDryPct?: Maybe<StringFilter>;
  /** Filter by the object’s `intDisc` field. */
  intDisc?: Maybe<StringFilter>;
  /** Filter by the object’s `autoIntDisc` field. */
  autoIntDisc?: Maybe<StringFilter>;
  /** Filter by the object’s `intDiscDeg` field. */
  intDiscDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayMoldBerries` field. */
  decayMoldBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDecayMoldBerries` field. */
  autoDecayMoldBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `decaySlipskinBerries` field. */
  decaySlipskinBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDecaySlipskinBerries` field. */
  autoDecaySlipskinBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `decayNestBerries` field. */
  decayNestBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `autoDecayNestBerries` field. */
  autoDecayNestBerries?: Maybe<StringFilter>;
  /** Filter by the object’s `decayNestDeg` field. */
  decayNestDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `shatterPct` field. */
  shatterPct?: Maybe<StringFilter>;
  /** Filter by the object’s `autoShatterPct` field. */
  autoShatterPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMost` field. */
  brixMost?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `autoOverallQuality` field. */
  autoOverallQuality?: Maybe<StringFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `autoOverallCondition` field. */
  autoOverallCondition?: Maybe<StringFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaGrapePalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaGrapePalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaGrapePalletFilter>;
};

/** An input for mutations affecting `PsaGrapePallet` */
export type PsaGrapePalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['Date']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  autoOpening?: Maybe<Scalars['String']>;
  bunches?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  colorMin?: Maybe<Scalars['String']>;
  colorMax?: Maybe<Scalars['String']>;
  colorMost?: Maybe<Scalars['String']>;
  colorConsistency?: Maybe<Scalars['String']>;
  autoColorConsistency?: Maybe<Scalars['String']>;
  sunburnBunches?: Maybe<Scalars['String']>;
  autoSunburnBunches?: Maybe<Scalars['String']>;
  sunburnPct?: Maybe<Scalars['String']>;
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  bunchConformation?: Maybe<Scalars['String']>;
  autoBunchConformation?: Maybe<Scalars['String']>;
  stragglyBunches?: Maybe<Scalars['String']>;
  stragglyPct?: Maybe<Scalars['String']>;
  smallBunches?: Maybe<Scalars['String']>;
  russetMarksBunches?: Maybe<Scalars['String']>;
  russetMarksPct?: Maybe<Scalars['String']>;
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  dustPct?: Maybe<Scalars['String']>;
  autoDustPct?: Maybe<Scalars['String']>;
  residuesPct?: Maybe<Scalars['String']>;
  autoResiduesPct?: Maybe<Scalars['String']>;
  tightBunches?: Maybe<Scalars['String']>;
  autoTightBunches?: Maybe<Scalars['String']>;
  bruisingBunches?: Maybe<Scalars['String']>;
  autoBruisingBunches?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  berryCondition?: Maybe<Scalars['String']>;
  autoBerryCondition?: Maybe<Scalars['String']>;
  h2OBerries?: Maybe<Scalars['String']>;
  autoH2OBerries?: Maybe<Scalars['String']>;
  so2DamagePct?: Maybe<Scalars['String']>;
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  so2DamageDeg?: Maybe<Scalars['String']>;
  weakBunches?: Maybe<Scalars['String']>;
  autoWeakBunches?: Maybe<Scalars['String']>;
  splitsHairlinePct?: Maybe<Scalars['String']>;
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  splitsDryPct?: Maybe<Scalars['String']>;
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  intDisc?: Maybe<Scalars['String']>;
  autoIntDisc?: Maybe<Scalars['String']>;
  intDiscDeg?: Maybe<Scalars['String']>;
  decayMoldBerries?: Maybe<Scalars['String']>;
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  decayNestBerries?: Maybe<Scalars['String']>;
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  decayNestDeg?: Maybe<Scalars['String']>;
  shatterPct?: Maybe<Scalars['String']>;
  autoShatterPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  autoOverallQuality?: Maybe<Scalars['String']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  autoOverallCondition?: Maybe<Scalars['String']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaGrapePallet`. Fields that are set will be updated. */
export type PsaGrapePalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['Date']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  autoOpening?: Maybe<Scalars['String']>;
  bunches?: Maybe<Scalars['String']>;
  sizeMin?: Maybe<Scalars['String']>;
  sizeMax?: Maybe<Scalars['String']>;
  sizeMost?: Maybe<Scalars['String']>;
  undersizeBunchesCount?: Maybe<Scalars['String']>;
  autoUndersizeBerriesBunches?: Maybe<Scalars['String']>;
  undersizeBerriesPct?: Maybe<Scalars['String']>;
  colorMin?: Maybe<Scalars['String']>;
  colorMax?: Maybe<Scalars['String']>;
  colorMost?: Maybe<Scalars['String']>;
  colorConsistency?: Maybe<Scalars['String']>;
  autoColorConsistency?: Maybe<Scalars['String']>;
  sunburnBunches?: Maybe<Scalars['String']>;
  autoSunburnBunches?: Maybe<Scalars['String']>;
  sunburnPct?: Maybe<Scalars['String']>;
  sunburnBunchesDeg?: Maybe<Scalars['String']>;
  bunchConformation?: Maybe<Scalars['String']>;
  autoBunchConformation?: Maybe<Scalars['String']>;
  stragglyBunches?: Maybe<Scalars['String']>;
  stragglyPct?: Maybe<Scalars['String']>;
  smallBunches?: Maybe<Scalars['String']>;
  russetMarksBunches?: Maybe<Scalars['String']>;
  russetMarksPct?: Maybe<Scalars['String']>;
  autoRussetMarksPct?: Maybe<Scalars['String']>;
  dustPct?: Maybe<Scalars['String']>;
  autoDustPct?: Maybe<Scalars['String']>;
  residuesPct?: Maybe<Scalars['String']>;
  autoResiduesPct?: Maybe<Scalars['String']>;
  tightBunches?: Maybe<Scalars['String']>;
  autoTightBunches?: Maybe<Scalars['String']>;
  bruisingBunches?: Maybe<Scalars['String']>;
  autoBruisingBunches?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  stemDehydrationPct?: Maybe<Scalars['String']>;
  autoStemDehydrationPct?: Maybe<Scalars['String']>;
  stemDehydrationDeg?: Maybe<Scalars['String']>;
  berryCondition?: Maybe<Scalars['String']>;
  autoBerryCondition?: Maybe<Scalars['String']>;
  h2OBerries?: Maybe<Scalars['String']>;
  autoH2OBerries?: Maybe<Scalars['String']>;
  so2DamagePct?: Maybe<Scalars['String']>;
  autoSo2DamagePct?: Maybe<Scalars['String']>;
  so2DamageDeg?: Maybe<Scalars['String']>;
  weakBunches?: Maybe<Scalars['String']>;
  autoWeakBunches?: Maybe<Scalars['String']>;
  splitsHairlinePct?: Maybe<Scalars['String']>;
  autoSplitsHairlinePct?: Maybe<Scalars['String']>;
  splitsWetCrushPct?: Maybe<Scalars['String']>;
  autoSplitsWetCrushPct?: Maybe<Scalars['String']>;
  splitsDryPct?: Maybe<Scalars['String']>;
  autoSplitsDryPct?: Maybe<Scalars['String']>;
  intDisc?: Maybe<Scalars['String']>;
  autoIntDisc?: Maybe<Scalars['String']>;
  intDiscDeg?: Maybe<Scalars['String']>;
  decayMoldBerries?: Maybe<Scalars['String']>;
  autoDecayMoldBerries?: Maybe<Scalars['String']>;
  decaySlipskinBerries?: Maybe<Scalars['String']>;
  autoDecaySlipskinBerries?: Maybe<Scalars['String']>;
  decayNestBerries?: Maybe<Scalars['String']>;
  autoDecayNestBerries?: Maybe<Scalars['String']>;
  decayNestDeg?: Maybe<Scalars['String']>;
  shatterPct?: Maybe<Scalars['String']>;
  autoShatterPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  autoOverallQuality?: Maybe<Scalars['String']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  autoOverallCondition?: Maybe<Scalars['String']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaGrapePallet` values. */
export type PsaGrapePalletsConnection = {
  __typename?: 'PsaGrapePalletsConnection';
  /** A list of `PsaGrapePallet` objects. */
  nodes: Array<Maybe<PsaGrapePallet>>;
  /** A list of edges which contains the `PsaGrapePallet` and cursor to aid in pagination. */
  edges: Array<PsaGrapePalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaGrapePallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaGrapePallet` edge in the connection. */
export type PsaGrapePalletsEdge = {
  __typename?: 'PsaGrapePalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaGrapePallet` at the end of the edge. */
  node?: Maybe<PsaGrapePallet>;
};

/** Methods to use when ordering `PsaGrapePallet`. */
export enum PsaGrapePalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  AutoOpeningAsc = 'AUTO_OPENING_ASC',
  AutoOpeningDesc = 'AUTO_OPENING_DESC',
  BunchesAsc = 'BUNCHES_ASC',
  BunchesDesc = 'BUNCHES_DESC',
  SizeMinAsc = 'SIZE_MIN_ASC',
  SizeMinDesc = 'SIZE_MIN_DESC',
  SizeMaxAsc = 'SIZE_MAX_ASC',
  SizeMaxDesc = 'SIZE_MAX_DESC',
  SizeMostAsc = 'SIZE_MOST_ASC',
  SizeMostDesc = 'SIZE_MOST_DESC',
  UndersizeBunchesCountAsc = 'UNDERSIZE_BUNCHES_COUNT_ASC',
  UndersizeBunchesCountDesc = 'UNDERSIZE_BUNCHES_COUNT_DESC',
  AutoUndersizeBerriesBunchesAsc = 'AUTO_UNDERSIZE_BERRIES_BUNCHES_ASC',
  AutoUndersizeBerriesBunchesDesc = 'AUTO_UNDERSIZE_BERRIES_BUNCHES_DESC',
  UndersizeBerriesPctAsc = 'UNDERSIZE_BERRIES_PCT_ASC',
  UndersizeBerriesPctDesc = 'UNDERSIZE_BERRIES_PCT_DESC',
  ColorMinAsc = 'COLOR_MIN_ASC',
  ColorMinDesc = 'COLOR_MIN_DESC',
  ColorMaxAsc = 'COLOR_MAX_ASC',
  ColorMaxDesc = 'COLOR_MAX_DESC',
  ColorMostAsc = 'COLOR_MOST_ASC',
  ColorMostDesc = 'COLOR_MOST_DESC',
  ColorConsistencyAsc = 'COLOR_CONSISTENCY_ASC',
  ColorConsistencyDesc = 'COLOR_CONSISTENCY_DESC',
  AutoColorConsistencyAsc = 'AUTO_COLOR_CONSISTENCY_ASC',
  AutoColorConsistencyDesc = 'AUTO_COLOR_CONSISTENCY_DESC',
  SunburnBunchesAsc = 'SUNBURN_BUNCHES_ASC',
  SunburnBunchesDesc = 'SUNBURN_BUNCHES_DESC',
  AutoSunburnBunchesAsc = 'AUTO_SUNBURN_BUNCHES_ASC',
  AutoSunburnBunchesDesc = 'AUTO_SUNBURN_BUNCHES_DESC',
  SunburnPctAsc = 'SUNBURN_PCT_ASC',
  SunburnPctDesc = 'SUNBURN_PCT_DESC',
  SunburnBunchesDegAsc = 'SUNBURN_BUNCHES_DEG_ASC',
  SunburnBunchesDegDesc = 'SUNBURN_BUNCHES_DEG_DESC',
  BunchConformationAsc = 'BUNCH_CONFORMATION_ASC',
  BunchConformationDesc = 'BUNCH_CONFORMATION_DESC',
  AutoBunchConformationAsc = 'AUTO_BUNCH_CONFORMATION_ASC',
  AutoBunchConformationDesc = 'AUTO_BUNCH_CONFORMATION_DESC',
  StragglyBunchesAsc = 'STRAGGLY_BUNCHES_ASC',
  StragglyBunchesDesc = 'STRAGGLY_BUNCHES_DESC',
  StragglyPctAsc = 'STRAGGLY_PCT_ASC',
  StragglyPctDesc = 'STRAGGLY_PCT_DESC',
  SmallBunchesAsc = 'SMALL_BUNCHES_ASC',
  SmallBunchesDesc = 'SMALL_BUNCHES_DESC',
  RussetMarksBunchesAsc = 'RUSSET_MARKS_BUNCHES_ASC',
  RussetMarksBunchesDesc = 'RUSSET_MARKS_BUNCHES_DESC',
  RussetMarksPctAsc = 'RUSSET_MARKS_PCT_ASC',
  RussetMarksPctDesc = 'RUSSET_MARKS_PCT_DESC',
  AutoRussetMarksPctAsc = 'AUTO_RUSSET_MARKS_PCT_ASC',
  AutoRussetMarksPctDesc = 'AUTO_RUSSET_MARKS_PCT_DESC',
  DustPctAsc = 'DUST_PCT_ASC',
  DustPctDesc = 'DUST_PCT_DESC',
  AutoDustPctAsc = 'AUTO_DUST_PCT_ASC',
  AutoDustPctDesc = 'AUTO_DUST_PCT_DESC',
  ResiduesPctAsc = 'RESIDUES_PCT_ASC',
  ResiduesPctDesc = 'RESIDUES_PCT_DESC',
  AutoResiduesPctAsc = 'AUTO_RESIDUES_PCT_ASC',
  AutoResiduesPctDesc = 'AUTO_RESIDUES_PCT_DESC',
  TightBunchesAsc = 'TIGHT_BUNCHES_ASC',
  TightBunchesDesc = 'TIGHT_BUNCHES_DESC',
  AutoTightBunchesAsc = 'AUTO_TIGHT_BUNCHES_ASC',
  AutoTightBunchesDesc = 'AUTO_TIGHT_BUNCHES_DESC',
  BruisingBunchesAsc = 'BRUISING_BUNCHES_ASC',
  BruisingBunchesDesc = 'BRUISING_BUNCHES_DESC',
  AutoBruisingBunchesAsc = 'AUTO_BRUISING_BUNCHES_ASC',
  AutoBruisingBunchesDesc = 'AUTO_BRUISING_BUNCHES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  StemDehydrationPctAsc = 'STEM_DEHYDRATION_PCT_ASC',
  StemDehydrationPctDesc = 'STEM_DEHYDRATION_PCT_DESC',
  AutoStemDehydrationPctAsc = 'AUTO_STEM_DEHYDRATION_PCT_ASC',
  AutoStemDehydrationPctDesc = 'AUTO_STEM_DEHYDRATION_PCT_DESC',
  StemDehydrationDegAsc = 'STEM_DEHYDRATION_DEG_ASC',
  StemDehydrationDegDesc = 'STEM_DEHYDRATION_DEG_DESC',
  BerryConditionAsc = 'BERRY_CONDITION_ASC',
  BerryConditionDesc = 'BERRY_CONDITION_DESC',
  AutoBerryConditionAsc = 'AUTO_BERRY_CONDITION_ASC',
  AutoBerryConditionDesc = 'AUTO_BERRY_CONDITION_DESC',
  H2OBerriesAsc = 'H2O_BERRIES_ASC',
  H2OBerriesDesc = 'H2O_BERRIES_DESC',
  AutoH2OBerriesAsc = 'AUTO_H2O_BERRIES_ASC',
  AutoH2OBerriesDesc = 'AUTO_H2O_BERRIES_DESC',
  So2DamagePctAsc = 'SO2_DAMAGE_PCT_ASC',
  So2DamagePctDesc = 'SO2_DAMAGE_PCT_DESC',
  AutoSo2DamagePctAsc = 'AUTO_SO2_DAMAGE_PCT_ASC',
  AutoSo2DamagePctDesc = 'AUTO_SO2_DAMAGE_PCT_DESC',
  So2DamageDegAsc = 'SO2_DAMAGE_DEG_ASC',
  So2DamageDegDesc = 'SO2_DAMAGE_DEG_DESC',
  WeakBunchesAsc = 'WEAK_BUNCHES_ASC',
  WeakBunchesDesc = 'WEAK_BUNCHES_DESC',
  AutoWeakBunchesAsc = 'AUTO_WEAK_BUNCHES_ASC',
  AutoWeakBunchesDesc = 'AUTO_WEAK_BUNCHES_DESC',
  SplitsHairlinePctAsc = 'SPLITS_HAIRLINE_PCT_ASC',
  SplitsHairlinePctDesc = 'SPLITS_HAIRLINE_PCT_DESC',
  AutoSplitsHairlinePctAsc = 'AUTO_SPLITS_HAIRLINE_PCT_ASC',
  AutoSplitsHairlinePctDesc = 'AUTO_SPLITS_HAIRLINE_PCT_DESC',
  SplitsWetCrushPctAsc = 'SPLITS_WET_CRUSH_PCT_ASC',
  SplitsWetCrushPctDesc = 'SPLITS_WET_CRUSH_PCT_DESC',
  AutoSplitsWetCrushPctAsc = 'AUTO_SPLITS_WET_CRUSH_PCT_ASC',
  AutoSplitsWetCrushPctDesc = 'AUTO_SPLITS_WET_CRUSH_PCT_DESC',
  SplitsDryPctAsc = 'SPLITS_DRY_PCT_ASC',
  SplitsDryPctDesc = 'SPLITS_DRY_PCT_DESC',
  AutoSplitsDryPctAsc = 'AUTO_SPLITS_DRY_PCT_ASC',
  AutoSplitsDryPctDesc = 'AUTO_SPLITS_DRY_PCT_DESC',
  IntDiscAsc = 'INT_DISC_ASC',
  IntDiscDesc = 'INT_DISC_DESC',
  AutoIntDiscAsc = 'AUTO_INT_DISC_ASC',
  AutoIntDiscDesc = 'AUTO_INT_DISC_DESC',
  IntDiscDegAsc = 'INT_DISC_DEG_ASC',
  IntDiscDegDesc = 'INT_DISC_DEG_DESC',
  DecayMoldBerriesAsc = 'DECAY_MOLD_BERRIES_ASC',
  DecayMoldBerriesDesc = 'DECAY_MOLD_BERRIES_DESC',
  AutoDecayMoldBerriesAsc = 'AUTO_DECAY_MOLD_BERRIES_ASC',
  AutoDecayMoldBerriesDesc = 'AUTO_DECAY_MOLD_BERRIES_DESC',
  DecaySlipskinBerriesAsc = 'DECAY_SLIPSKIN_BERRIES_ASC',
  DecaySlipskinBerriesDesc = 'DECAY_SLIPSKIN_BERRIES_DESC',
  AutoDecaySlipskinBerriesAsc = 'AUTO_DECAY_SLIPSKIN_BERRIES_ASC',
  AutoDecaySlipskinBerriesDesc = 'AUTO_DECAY_SLIPSKIN_BERRIES_DESC',
  DecayNestBerriesAsc = 'DECAY_NEST_BERRIES_ASC',
  DecayNestBerriesDesc = 'DECAY_NEST_BERRIES_DESC',
  AutoDecayNestBerriesAsc = 'AUTO_DECAY_NEST_BERRIES_ASC',
  AutoDecayNestBerriesDesc = 'AUTO_DECAY_NEST_BERRIES_DESC',
  DecayNestDegAsc = 'DECAY_NEST_DEG_ASC',
  DecayNestDegDesc = 'DECAY_NEST_DEG_DESC',
  ShatterPctAsc = 'SHATTER_PCT_ASC',
  ShatterPctDesc = 'SHATTER_PCT_DESC',
  AutoShatterPctAsc = 'AUTO_SHATTER_PCT_ASC',
  AutoShatterPctDesc = 'AUTO_SHATTER_PCT_DESC',
  BrixMinAsc = 'BRIX_MIN_ASC',
  BrixMinDesc = 'BRIX_MIN_DESC',
  BrixMaxAsc = 'BRIX_MAX_ASC',
  BrixMaxDesc = 'BRIX_MAX_DESC',
  BrixMostAsc = 'BRIX_MOST_ASC',
  BrixMostDesc = 'BRIX_MOST_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  AutoOverallQualityAsc = 'AUTO_OVERALL_QUALITY_ASC',
  AutoOverallQualityDesc = 'AUTO_OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  AutoOverallConditionAsc = 'AUTO_OVERALL_CONDITION_ASC',
  AutoOverallConditionDesc = 'AUTO_OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaLemonPallet = Node & {
  __typename?: 'PsaLemonPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  skinDamagePieces?: Maybe<Scalars['String']>;
  skinDamagePct?: Maybe<Scalars['String']>;
  skinDamageDeg?: Maybe<Scalars['String']>;
  petecaPieces?: Maybe<Scalars['String']>;
  petecaPct?: Maybe<Scalars['String']>;
  petecaDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaLemonPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaLemonPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaLemonPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinDamagePieces` field. */
  skinDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinDamagePct` field. */
  skinDamagePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skinDamageDeg` field. */
  skinDamageDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `petecaPieces` field. */
  petecaPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `petecaPct` field. */
  petecaPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `petecaDeg` field. */
  petecaDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sporesPct` field. */
  sporesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaLemonPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaLemonPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinMm` field. */
  diameterMinMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMinInches` field. */
  diameterMinInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxMm` field. */
  diameterMaxMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMaxInches` field. */
  diameterMaxInches?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostMm` field. */
  diameterMostMm?: Maybe<StringFilter>;
  /** Filter by the object’s `diameterMostInches` field. */
  diameterMostInches?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePieces` field. */
  greenHazePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazePct` field. */
  greenHazePct?: Maybe<StringFilter>;
  /** Filter by the object’s `greenHazeDeg` field. */
  greenHazeDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPieces` field. */
  oilSpotsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsPct` field. */
  oilSpotsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `oilSpotsDeg` field. */
  oilSpotsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPieces` field. */
  dryPulpPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpPct` field. */
  dryPulpPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dryPulpDeg` field. */
  dryPulpDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `skinDamagePieces` field. */
  skinDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `skinDamagePct` field. */
  skinDamagePct?: Maybe<StringFilter>;
  /** Filter by the object’s `skinDamageDeg` field. */
  skinDamageDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `petecaPieces` field. */
  petecaPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `petecaPct` field. */
  petecaPct?: Maybe<StringFilter>;
  /** Filter by the object’s `petecaDeg` field. */
  petecaDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPieces` field. */
  sporesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sporesPct` field. */
  sporesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaLemonPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaLemonPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaLemonPalletFilter>;
};

/** An input for mutations affecting `PsaLemonPallet` */
export type PsaLemonPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  skinDamagePieces?: Maybe<Scalars['String']>;
  skinDamagePct?: Maybe<Scalars['String']>;
  skinDamageDeg?: Maybe<Scalars['String']>;
  petecaPieces?: Maybe<Scalars['String']>;
  petecaPct?: Maybe<Scalars['String']>;
  petecaDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaLemonPallet`. Fields that are set will be updated. */
export type PsaLemonPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  diameterMinMm?: Maybe<Scalars['String']>;
  diameterMinInches?: Maybe<Scalars['String']>;
  diameterMaxMm?: Maybe<Scalars['String']>;
  diameterMaxInches?: Maybe<Scalars['String']>;
  diameterMostMm?: Maybe<Scalars['String']>;
  diameterMostInches?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  greenHazePieces?: Maybe<Scalars['String']>;
  greenHazePct?: Maybe<Scalars['String']>;
  greenHazeDeg?: Maybe<Scalars['String']>;
  oilSpotsPieces?: Maybe<Scalars['String']>;
  oilSpotsPct?: Maybe<Scalars['String']>;
  oilSpotsDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  dryPulpPieces?: Maybe<Scalars['String']>;
  dryPulpPct?: Maybe<Scalars['String']>;
  dryPulpDeg?: Maybe<Scalars['String']>;
  skinDamagePieces?: Maybe<Scalars['String']>;
  skinDamagePct?: Maybe<Scalars['String']>;
  skinDamageDeg?: Maybe<Scalars['String']>;
  petecaPieces?: Maybe<Scalars['String']>;
  petecaPct?: Maybe<Scalars['String']>;
  petecaDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  sporesPieces?: Maybe<Scalars['String']>;
  sporesPct?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaLemonPallet` values. */
export type PsaLemonPalletsConnection = {
  __typename?: 'PsaLemonPalletsConnection';
  /** A list of `PsaLemonPallet` objects. */
  nodes: Array<Maybe<PsaLemonPallet>>;
  /** A list of edges which contains the `PsaLemonPallet` and cursor to aid in pagination. */
  edges: Array<PsaLemonPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaLemonPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaLemonPallet` edge in the connection. */
export type PsaLemonPalletsEdge = {
  __typename?: 'PsaLemonPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaLemonPallet` at the end of the edge. */
  node?: Maybe<PsaLemonPallet>;
};

/** Methods to use when ordering `PsaLemonPallet`. */
export enum PsaLemonPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  DiameterMinMmAsc = 'DIAMETER_MIN_MM_ASC',
  DiameterMinMmDesc = 'DIAMETER_MIN_MM_DESC',
  DiameterMinInchesAsc = 'DIAMETER_MIN_INCHES_ASC',
  DiameterMinInchesDesc = 'DIAMETER_MIN_INCHES_DESC',
  DiameterMaxMmAsc = 'DIAMETER_MAX_MM_ASC',
  DiameterMaxMmDesc = 'DIAMETER_MAX_MM_DESC',
  DiameterMaxInchesAsc = 'DIAMETER_MAX_INCHES_ASC',
  DiameterMaxInchesDesc = 'DIAMETER_MAX_INCHES_DESC',
  DiameterMostMmAsc = 'DIAMETER_MOST_MM_ASC',
  DiameterMostMmDesc = 'DIAMETER_MOST_MM_DESC',
  DiameterMostInchesAsc = 'DIAMETER_MOST_INCHES_ASC',
  DiameterMostInchesDesc = 'DIAMETER_MOST_INCHES_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  GreenHazePiecesAsc = 'GREEN_HAZE_PIECES_ASC',
  GreenHazePiecesDesc = 'GREEN_HAZE_PIECES_DESC',
  GreenHazePctAsc = 'GREEN_HAZE_PCT_ASC',
  GreenHazePctDesc = 'GREEN_HAZE_PCT_DESC',
  GreenHazeDegAsc = 'GREEN_HAZE_DEG_ASC',
  GreenHazeDegDesc = 'GREEN_HAZE_DEG_DESC',
  OilSpotsPiecesAsc = 'OIL_SPOTS_PIECES_ASC',
  OilSpotsPiecesDesc = 'OIL_SPOTS_PIECES_DESC',
  OilSpotsPctAsc = 'OIL_SPOTS_PCT_ASC',
  OilSpotsPctDesc = 'OIL_SPOTS_PCT_DESC',
  OilSpotsDegAsc = 'OIL_SPOTS_DEG_ASC',
  OilSpotsDegDesc = 'OIL_SPOTS_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  DryPulpPiecesAsc = 'DRY_PULP_PIECES_ASC',
  DryPulpPiecesDesc = 'DRY_PULP_PIECES_DESC',
  DryPulpPctAsc = 'DRY_PULP_PCT_ASC',
  DryPulpPctDesc = 'DRY_PULP_PCT_DESC',
  DryPulpDegAsc = 'DRY_PULP_DEG_ASC',
  DryPulpDegDesc = 'DRY_PULP_DEG_DESC',
  SkinDamagePiecesAsc = 'SKIN_DAMAGE_PIECES_ASC',
  SkinDamagePiecesDesc = 'SKIN_DAMAGE_PIECES_DESC',
  SkinDamagePctAsc = 'SKIN_DAMAGE_PCT_ASC',
  SkinDamagePctDesc = 'SKIN_DAMAGE_PCT_DESC',
  SkinDamageDegAsc = 'SKIN_DAMAGE_DEG_ASC',
  SkinDamageDegDesc = 'SKIN_DAMAGE_DEG_DESC',
  PetecaPiecesAsc = 'PETECA_PIECES_ASC',
  PetecaPiecesDesc = 'PETECA_PIECES_DESC',
  PetecaPctAsc = 'PETECA_PCT_ASC',
  PetecaPctDesc = 'PETECA_PCT_DESC',
  PetecaDegAsc = 'PETECA_DEG_ASC',
  PetecaDegDesc = 'PETECA_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  SporesPiecesAsc = 'SPORES_PIECES_ASC',
  SporesPiecesDesc = 'SPORES_PIECES_DESC',
  SporesPctAsc = 'SPORES_PCT_ASC',
  SporesPctDesc = 'SPORES_PCT_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaPearPallet = Node & {
  __typename?: 'PsaPearPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  russetPerPiecePct?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  turningColorPieces?: Maybe<Scalars['String']>;
  turningColorPct?: Maybe<Scalars['String']>;
  turningColorDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaPearPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaPearPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaPearPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `runNumber` field. */
  runNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groundColor` field. */
  groundColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `russetPerPiecePct` field. */
  russetPerPiecePct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPct` field. */
  cutsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `turningColorPieces` field. */
  turningColorPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `turningColorPct` field. */
  turningColorPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `turningColorDeg` field. */
  turningColorDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaPearPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaPearPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `runNumber` field. */
  runNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `groundColor` field. */
  groundColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `russetPerPiecePct` field. */
  russetPerPiecePct?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPieces` field. */
  stemPuncturesPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `stemPuncturesPct` field. */
  stemPuncturesPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPct` field. */
  cutsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `turningColorPieces` field. */
  turningColorPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `turningColorPct` field. */
  turningColorPct?: Maybe<StringFilter>;
  /** Filter by the object’s `turningColorDeg` field. */
  turningColorDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaPearPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaPearPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaPearPalletFilter>;
};

/** An input for mutations affecting `PsaPearPallet` */
export type PsaPearPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  russetPerPiecePct?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  turningColorPieces?: Maybe<Scalars['String']>;
  turningColorPct?: Maybe<Scalars['String']>;
  turningColorDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaPearPallet`. Fields that are set will be updated. */
export type PsaPearPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  russetPerPiecePct?: Maybe<Scalars['String']>;
  stemPuncturesPieces?: Maybe<Scalars['String']>;
  stemPuncturesPct?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  turningColorPieces?: Maybe<Scalars['String']>;
  turningColorPct?: Maybe<Scalars['String']>;
  turningColorDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaPearPallet` values. */
export type PsaPearPalletsConnection = {
  __typename?: 'PsaPearPalletsConnection';
  /** A list of `PsaPearPallet` objects. */
  nodes: Array<Maybe<PsaPearPallet>>;
  /** A list of edges which contains the `PsaPearPallet` and cursor to aid in pagination. */
  edges: Array<PsaPearPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaPearPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaPearPallet` edge in the connection. */
export type PsaPearPalletsEdge = {
  __typename?: 'PsaPearPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaPearPallet` at the end of the edge. */
  node?: Maybe<PsaPearPallet>;
};

/** Methods to use when ordering `PsaPearPallet`. */
export enum PsaPearPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  RunNumberAsc = 'RUN_NUMBER_ASC',
  RunNumberDesc = 'RUN_NUMBER_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  GroundColorAsc = 'GROUND_COLOR_ASC',
  GroundColorDesc = 'GROUND_COLOR_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ScarsRussetPiecesAsc = 'SCARS_RUSSET_PIECES_ASC',
  ScarsRussetPiecesDesc = 'SCARS_RUSSET_PIECES_DESC',
  ScarsRussetPctAsc = 'SCARS_RUSSET_PCT_ASC',
  ScarsRussetPctDesc = 'SCARS_RUSSET_PCT_DESC',
  ScarsRussetDegAsc = 'SCARS_RUSSET_DEG_ASC',
  ScarsRussetDegDesc = 'SCARS_RUSSET_DEG_DESC',
  RussetPerPiecePctAsc = 'RUSSET_PER_PIECE_PCT_ASC',
  RussetPerPiecePctDesc = 'RUSSET_PER_PIECE_PCT_DESC',
  StemPuncturesPiecesAsc = 'STEM_PUNCTURES_PIECES_ASC',
  StemPuncturesPiecesDesc = 'STEM_PUNCTURES_PIECES_DESC',
  StemPuncturesPctAsc = 'STEM_PUNCTURES_PCT_ASC',
  StemPuncturesPctDesc = 'STEM_PUNCTURES_PCT_DESC',
  CutsPiecesAsc = 'CUTS_PIECES_ASC',
  CutsPiecesDesc = 'CUTS_PIECES_DESC',
  CutsPctAsc = 'CUTS_PCT_ASC',
  CutsPctDesc = 'CUTS_PCT_DESC',
  CutsDegAsc = 'CUTS_DEG_ASC',
  CutsDegDesc = 'CUTS_DEG_DESC',
  TurningColorPiecesAsc = 'TURNING_COLOR_PIECES_ASC',
  TurningColorPiecesDesc = 'TURNING_COLOR_PIECES_DESC',
  TurningColorPctAsc = 'TURNING_COLOR_PCT_ASC',
  TurningColorPctDesc = 'TURNING_COLOR_PCT_DESC',
  TurningColorDegAsc = 'TURNING_COLOR_DEG_ASC',
  TurningColorDegDesc = 'TURNING_COLOR_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaPersimmonPallet = Node & {
  __typename?: 'PsaPersimmonPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  greenColorPieces?: Maybe<Scalars['String']>;
  greenColor?: Maybe<Scalars['String']>;
  greenColorDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  internalDamageDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaPersimmonPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaPersimmonPallet` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PsaPersimmonPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `color` field. */
  color?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenColorPieces` field. */
  greenColorPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenColor` field. */
  greenColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `greenColorDeg` field. */
  greenColorDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `seedsPct` field. */
  seedsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamageDeg` field. */
  internalDamageDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaPersimmonPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaPersimmonPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `color` field. */
  color?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPieces` field. */
  scarsMarksPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksPct` field. */
  scarsMarksPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsMarksDeg` field. */
  scarsMarksDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `greenColorPieces` field. */
  greenColorPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `greenColor` field. */
  greenColor?: Maybe<StringFilter>;
  /** Filter by the object’s `greenColorDeg` field. */
  greenColorDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPieces` field. */
  seedsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `seedsPct` field. */
  seedsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamageDeg` field. */
  internalDamageDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaPersimmonPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaPersimmonPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaPersimmonPalletFilter>;
};

/** An input for mutations affecting `PsaPersimmonPallet` */
export type PsaPersimmonPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  greenColorPieces?: Maybe<Scalars['String']>;
  greenColor?: Maybe<Scalars['String']>;
  greenColorDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  internalDamageDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaPersimmonPallet`. Fields that are set will be updated. */
export type PsaPersimmonPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  color?: Maybe<Scalars['String']>;
  scarsMarksPieces?: Maybe<Scalars['String']>;
  scarsMarksPct?: Maybe<Scalars['String']>;
  scarsMarksDeg?: Maybe<Scalars['String']>;
  greenColorPieces?: Maybe<Scalars['String']>;
  greenColor?: Maybe<Scalars['String']>;
  greenColorDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  seedsPieces?: Maybe<Scalars['String']>;
  seedsPct?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  internalDamageDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaPersimmonPallet` values. */
export type PsaPersimmonPalletsConnection = {
  __typename?: 'PsaPersimmonPalletsConnection';
  /** A list of `PsaPersimmonPallet` objects. */
  nodes: Array<Maybe<PsaPersimmonPallet>>;
  /** A list of edges which contains the `PsaPersimmonPallet` and cursor to aid in pagination. */
  edges: Array<PsaPersimmonPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaPersimmonPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaPersimmonPallet` edge in the connection. */
export type PsaPersimmonPalletsEdge = {
  __typename?: 'PsaPersimmonPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaPersimmonPallet` at the end of the edge. */
  node?: Maybe<PsaPersimmonPallet>;
};

/** Methods to use when ordering `PsaPersimmonPallet`. */
export enum PsaPersimmonPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  ColorAsc = 'COLOR_ASC',
  ColorDesc = 'COLOR_DESC',
  ScarsMarksPiecesAsc = 'SCARS_MARKS_PIECES_ASC',
  ScarsMarksPiecesDesc = 'SCARS_MARKS_PIECES_DESC',
  ScarsMarksPctAsc = 'SCARS_MARKS_PCT_ASC',
  ScarsMarksPctDesc = 'SCARS_MARKS_PCT_DESC',
  ScarsMarksDegAsc = 'SCARS_MARKS_DEG_ASC',
  ScarsMarksDegDesc = 'SCARS_MARKS_DEG_DESC',
  GreenColorPiecesAsc = 'GREEN_COLOR_PIECES_ASC',
  GreenColorPiecesDesc = 'GREEN_COLOR_PIECES_DESC',
  GreenColorAsc = 'GREEN_COLOR_ASC',
  GreenColorDesc = 'GREEN_COLOR_DESC',
  GreenColorDegAsc = 'GREEN_COLOR_DEG_ASC',
  GreenColorDegDesc = 'GREEN_COLOR_DEG_DESC',
  CutsSplitsPiecesAsc = 'CUTS_SPLITS_PIECES_ASC',
  CutsSplitsPiecesDesc = 'CUTS_SPLITS_PIECES_DESC',
  CutsSplitsPctAsc = 'CUTS_SPLITS_PCT_ASC',
  CutsSplitsPctDesc = 'CUTS_SPLITS_PCT_DESC',
  CutsSplitsDegAsc = 'CUTS_SPLITS_DEG_ASC',
  CutsSplitsDegDesc = 'CUTS_SPLITS_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  SeedsPiecesAsc = 'SEEDS_PIECES_ASC',
  SeedsPiecesDesc = 'SEEDS_PIECES_DESC',
  SeedsPctAsc = 'SEEDS_PCT_ASC',
  SeedsPctDesc = 'SEEDS_PCT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  InternalDamageDegAsc = 'INTERNAL_DAMAGE_DEG_ASC',
  InternalDamageDegDesc = 'INTERNAL_DAMAGE_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaPomegranatePallet = Node & {
  __typename?: 'PsaPomegranatePallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  arilsColor?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaPomegranatePalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaPomegranatePallet` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PsaPomegranatePalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `grade` field. */
  grade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrade` field. */
  inspGrade?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arilsColor` field. */
  arilsColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsPct` field. */
  cutsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldPct` field. */
  scaldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMin` field. */
  brixMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMax` field. */
  brixMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brixMost` field. */
  brixMost?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaPomegranatePallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaPomegranatePalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `grade` field. */
  grade?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrade` field. */
  inspGrade?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `arilsColor` field. */
  arilsColor?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPieces` field. */
  scarsRussetPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetPct` field. */
  scarsRussetPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsRussetDeg` field. */
  scarsRussetDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPieces` field. */
  cutsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsPct` field. */
  cutsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsDeg` field. */
  cutsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPieces` field. */
  sunScaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldPct` field. */
  sunScaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `sunScaldDeg` field. */
  sunScaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPieces` field. */
  scaldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldPct` field. */
  scaldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scaldDeg` field. */
  scaldDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMin` field. */
  brixMin?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMax` field. */
  brixMax?: Maybe<StringFilter>;
  /** Filter by the object’s `brixMost` field. */
  brixMost?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaPomegranatePalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaPomegranatePalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaPomegranatePalletFilter>;
};

/** An input for mutations affecting `PsaPomegranatePallet` */
export type PsaPomegranatePalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  arilsColor?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaPomegranatePallet`. Fields that are set will be updated. */
export type PsaPomegranatePalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  inspGrade?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  arilsColor?: Maybe<Scalars['String']>;
  scarsRussetPieces?: Maybe<Scalars['String']>;
  scarsRussetPct?: Maybe<Scalars['String']>;
  scarsRussetDeg?: Maybe<Scalars['String']>;
  cutsPieces?: Maybe<Scalars['String']>;
  cutsPct?: Maybe<Scalars['String']>;
  cutsDeg?: Maybe<Scalars['String']>;
  sunScaldPieces?: Maybe<Scalars['String']>;
  sunScaldPct?: Maybe<Scalars['String']>;
  sunScaldDeg?: Maybe<Scalars['String']>;
  scaldPieces?: Maybe<Scalars['String']>;
  scaldPct?: Maybe<Scalars['String']>;
  scaldDeg?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brixMin?: Maybe<Scalars['String']>;
  brixMax?: Maybe<Scalars['String']>;
  brixMost?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaPomegranatePallet` values. */
export type PsaPomegranatePalletsConnection = {
  __typename?: 'PsaPomegranatePalletsConnection';
  /** A list of `PsaPomegranatePallet` objects. */
  nodes: Array<Maybe<PsaPomegranatePallet>>;
  /** A list of edges which contains the `PsaPomegranatePallet` and cursor to aid in pagination. */
  edges: Array<PsaPomegranatePalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaPomegranatePallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaPomegranatePallet` edge in the connection. */
export type PsaPomegranatePalletsEdge = {
  __typename?: 'PsaPomegranatePalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaPomegranatePallet` at the end of the edge. */
  node?: Maybe<PsaPomegranatePallet>;
};

/** Methods to use when ordering `PsaPomegranatePallet`. */
export enum PsaPomegranatePalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  GradeAsc = 'GRADE_ASC',
  GradeDesc = 'GRADE_DESC',
  InspGradeAsc = 'INSP_GRADE_ASC',
  InspGradeDesc = 'INSP_GRADE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ArilsColorAsc = 'ARILS_COLOR_ASC',
  ArilsColorDesc = 'ARILS_COLOR_DESC',
  ScarsRussetPiecesAsc = 'SCARS_RUSSET_PIECES_ASC',
  ScarsRussetPiecesDesc = 'SCARS_RUSSET_PIECES_DESC',
  ScarsRussetPctAsc = 'SCARS_RUSSET_PCT_ASC',
  ScarsRussetPctDesc = 'SCARS_RUSSET_PCT_DESC',
  ScarsRussetDegAsc = 'SCARS_RUSSET_DEG_ASC',
  ScarsRussetDegDesc = 'SCARS_RUSSET_DEG_DESC',
  CutsPiecesAsc = 'CUTS_PIECES_ASC',
  CutsPiecesDesc = 'CUTS_PIECES_DESC',
  CutsPctAsc = 'CUTS_PCT_ASC',
  CutsPctDesc = 'CUTS_PCT_DESC',
  CutsDegAsc = 'CUTS_DEG_ASC',
  CutsDegDesc = 'CUTS_DEG_DESC',
  SunScaldPiecesAsc = 'SUN_SCALD_PIECES_ASC',
  SunScaldPiecesDesc = 'SUN_SCALD_PIECES_DESC',
  SunScaldPctAsc = 'SUN_SCALD_PCT_ASC',
  SunScaldPctDesc = 'SUN_SCALD_PCT_DESC',
  SunScaldDegAsc = 'SUN_SCALD_DEG_ASC',
  SunScaldDegDesc = 'SUN_SCALD_DEG_DESC',
  ScaldPiecesAsc = 'SCALD_PIECES_ASC',
  ScaldPiecesDesc = 'SCALD_PIECES_DESC',
  ScaldPctAsc = 'SCALD_PCT_ASC',
  ScaldPctDesc = 'SCALD_PCT_DESC',
  ScaldDegAsc = 'SCALD_DEG_ASC',
  ScaldDegDesc = 'SCALD_DEG_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  BrixMinAsc = 'BRIX_MIN_ASC',
  BrixMinDesc = 'BRIX_MIN_DESC',
  BrixMaxAsc = 'BRIX_MAX_ASC',
  BrixMaxDesc = 'BRIX_MAX_DESC',
  BrixMostAsc = 'BRIX_MOST_ASC',
  BrixMostDesc = 'BRIX_MOST_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PsaStoneFruitPallet = Node & {
  __typename?: 'PsaStoneFruitPallet';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  ripening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  splitPitPieces?: Maybe<Scalars['String']>;
  splitPitPct?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  softTipsPieces?: Maybe<Scalars['String']>;
  softTipsPct?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  mealinessPieces?: Maybe<Scalars['String']>;
  mealinessPct?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  pictures: PsaArrivalPicturesConnection;
};


export type PsaStoneFruitPalletPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};

/**
 * A condition to be used against `PsaStoneFruitPallet` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PsaStoneFruitPalletCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `location` field. */
  location?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerName` field. */
  importerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exporterName` field. */
  exporterName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commodity` field. */
  commodity?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `productCode` field. */
  productCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspDate` field. */
  inspDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `hatch` field. */
  hatch?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `deck` field. */
  deck?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `containerId` field. */
  containerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fumigation` field. */
  fumigation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `labelCode` field. */
  labelCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLocation` field. */
  inspLocation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `importerCode` field. */
  importerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lotCode` field. */
  lotCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspLot` field. */
  inspLot?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `growerCode` field. */
  growerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDate` field. */
  packDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspSize` field. */
  inspSize?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packCode` field. */
  packCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packDescription` field. */
  packDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pluPct` field. */
  pluPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `upc` field. */
  upc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMin` field. */
  underweightMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightMax` field. */
  underweightMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `underweightPct` field. */
  underweightPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `opening` field. */
  opening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `ripening` field. */
  ripening?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groundColor` field. */
  groundColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushColor` field. */
  blushColor?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `blushPct` field. */
  blushPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsPct` field. */
  scarsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitPitPieces` field. */
  splitPitPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `splitPitPct` field. */
  splitPitPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `softTipsPieces` field. */
  softTipsPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `softTipsPct` field. */
  softTipsPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cutCount` field. */
  cutCount?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `mealinessPieces` field. */
  mealinessPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `mealinessPct` field. */
  mealinessPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPieces` field. */
  decayPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayPct` field. */
  decayPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decayDeg` field. */
  decayDeg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPieces` field. */
  moldPieces?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `moldPct` field. */
  moldPct?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `brix` field. */
  brix?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure1` field. */
  pressure1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure2` field. */
  pressure2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure3` field. */
  pressure3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure4` field. */
  pressure4?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure5` field. */
  pressure5?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressure6` field. */
  pressure6?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `overallQuality` field. */
  overallQuality?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `overallCondition` field. */
  overallCondition?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `comment1` field. */
  comment1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `comment2` field. */
  comment2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inspectionType` field. */
  inspectionType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortInsp` field. */
  shortInsp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A filter to be used against `PsaStoneFruitPallet` object types. All fields are combined with a logical ‘and.’ */
export type PsaStoneFruitPalletFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: Maybe<StringFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<StringFilter>;
  /** Filter by the object’s `importerName` field. */
  importerName?: Maybe<StringFilter>;
  /** Filter by the object’s `exporterName` field. */
  exporterName?: Maybe<StringFilter>;
  /** Filter by the object’s `commodity` field. */
  commodity?: Maybe<StringFilter>;
  /** Filter by the object’s `productCode` field. */
  productCode?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `inspDate` field. */
  inspDate?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `hatch` field. */
  hatch?: Maybe<StringFilter>;
  /** Filter by the object’s `deck` field. */
  deck?: Maybe<StringFilter>;
  /** Filter by the object’s `containerId` field. */
  containerId?: Maybe<StringFilter>;
  /** Filter by the object’s `fumigation` field. */
  fumigation?: Maybe<StringFilter>;
  /** Filter by the object’s `labelCode` field. */
  labelCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLocation` field. */
  inspLocation?: Maybe<StringFilter>;
  /** Filter by the object’s `importerCode` field. */
  importerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `lotCode` field. */
  lotCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspLot` field. */
  inspLot?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `growerCode` field. */
  growerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `inspGrowerCode` field. */
  inspGrowerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDate` field. */
  packDate?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackDate` field. */
  inspPackDate?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `inspSize` field. */
  inspSize?: Maybe<StringFilter>;
  /** Filter by the object’s `packCode` field. */
  packCode?: Maybe<StringFilter>;
  /** Filter by the object’s `packDescription` field. */
  packDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `secondaryDescription` field. */
  secondaryDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `inspPackCode` field. */
  inspPackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `pluPct` field. */
  pluPct?: Maybe<StringFilter>;
  /** Filter by the object’s `countryOfOrigin` field. */
  countryOfOrigin?: Maybe<StringFilter>;
  /** Filter by the object’s `upc` field. */
  upc?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMin` field. */
  underweightMin?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightMax` field. */
  underweightMax?: Maybe<StringFilter>;
  /** Filter by the object’s `weighedUnits` field. */
  weighedUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightUnits` field. */
  underweightUnits?: Maybe<StringFilter>;
  /** Filter by the object’s `underweightPct` field. */
  underweightPct?: Maybe<StringFilter>;
  /** Filter by the object’s `pulpTemp` field. */
  pulpTemp?: Maybe<StringFilter>;
  /** Filter by the object’s `opening` field. */
  opening?: Maybe<StringFilter>;
  /** Filter by the object’s `ripening` field. */
  ripening?: Maybe<StringFilter>;
  /** Filter by the object’s `groundColor` field. */
  groundColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushColor` field. */
  blushColor?: Maybe<StringFilter>;
  /** Filter by the object’s `blushPct` field. */
  blushPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPieces` field. */
  scarsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsPct` field. */
  scarsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `scarsDeg` field. */
  scarsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPieces` field. */
  cutsSplitsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsPct` field. */
  cutsSplitsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `cutsSplitsDeg` field. */
  cutsSplitsDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `splitPitPieces` field. */
  splitPitPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `splitPitPct` field. */
  splitPitPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPieces` field. */
  bruisingPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingPct` field. */
  bruisingPct?: Maybe<StringFilter>;
  /** Filter by the object’s `bruisingDeg` field. */
  bruisingDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `softTipsPieces` field. */
  softTipsPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `softTipsPct` field. */
  softTipsPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPieces` field. */
  dehydrationPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationPct` field. */
  dehydrationPct?: Maybe<StringFilter>;
  /** Filter by the object’s `dehydrationDeg` field. */
  dehydrationDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `cutCount` field. */
  cutCount?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePieces` field. */
  internalDamagePieces?: Maybe<StringFilter>;
  /** Filter by the object’s `internalDamagePer` field. */
  internalDamagePer?: Maybe<StringFilter>;
  /** Filter by the object’s `mealinessPieces` field. */
  mealinessPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `mealinessPct` field. */
  mealinessPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPieces` field. */
  decayPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `decayPct` field. */
  decayPct?: Maybe<StringFilter>;
  /** Filter by the object’s `decayDeg` field. */
  decayDeg?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPieces` field. */
  moldPieces?: Maybe<StringFilter>;
  /** Filter by the object’s `moldPct` field. */
  moldPct?: Maybe<StringFilter>;
  /** Filter by the object’s `brix` field. */
  brix?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure1` field. */
  pressure1?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure2` field. */
  pressure2?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure3` field. */
  pressure3?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure4` field. */
  pressure4?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure5` field. */
  pressure5?: Maybe<StringFilter>;
  /** Filter by the object’s `pressure6` field. */
  pressure6?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMin` field. */
  pressuresMin?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresMax` field. */
  pressuresMax?: Maybe<StringFilter>;
  /** Filter by the object’s `pressuresAvg` field. */
  pressuresAvg?: Maybe<StringFilter>;
  /** Filter by the object’s `overallQuality` field. */
  overallQuality?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `overallCondition` field. */
  overallCondition?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `comment1` field. */
  comment1?: Maybe<StringFilter>;
  /** Filter by the object’s `comment2` field. */
  comment2?: Maybe<StringFilter>;
  /** Filter by the object’s `inspectionType` field. */
  inspectionType?: Maybe<StringFilter>;
  /** Filter by the object’s `shortInsp` field. */
  shortInsp?: Maybe<StringFilter>;
  /** Filter by the object’s `fixedWeight` field. */
  fixedWeight?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PsaStoneFruitPalletFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PsaStoneFruitPalletFilter>>;
  /** Negates the expression. */
  not?: Maybe<PsaStoneFruitPalletFilter>;
};

/** An input for mutations affecting `PsaStoneFruitPallet` */
export type PsaStoneFruitPalletInput = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  ripening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  splitPitPieces?: Maybe<Scalars['String']>;
  splitPitPct?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  softTipsPieces?: Maybe<Scalars['String']>;
  softTipsPct?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  mealinessPieces?: Maybe<Scalars['String']>;
  mealinessPct?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** Represents an update to a `PsaStoneFruitPallet`. Fields that are set will be updated. */
export type PsaStoneFruitPalletPatch = {
  id?: Maybe<Scalars['BigInt']>;
  location?: Maybe<Scalars['String']>;
  arrival?: Maybe<Scalars['String']>;
  importerName?: Maybe<Scalars['String']>;
  exporterName?: Maybe<Scalars['String']>;
  commodity?: Maybe<Scalars['String']>;
  productCode?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  inspDate?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  hatch?: Maybe<Scalars['String']>;
  deck?: Maybe<Scalars['String']>;
  containerId?: Maybe<Scalars['String']>;
  fumigation?: Maybe<Scalars['String']>;
  labelCode?: Maybe<Scalars['String']>;
  inspLocation?: Maybe<Scalars['String']>;
  importerCode?: Maybe<Scalars['String']>;
  lotCode?: Maybe<Scalars['String']>;
  inspLot?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  growerCode?: Maybe<Scalars['String']>;
  inspGrowerCode?: Maybe<Scalars['String']>;
  packDate?: Maybe<Scalars['String']>;
  inspPackDate?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  inspSize?: Maybe<Scalars['String']>;
  packCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  inspPackCode?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  pluPct?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  upc?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  underweightMin?: Maybe<Scalars['String']>;
  underweightMax?: Maybe<Scalars['String']>;
  weighedUnits?: Maybe<Scalars['String']>;
  underweightUnits?: Maybe<Scalars['String']>;
  underweightPct?: Maybe<Scalars['String']>;
  pulpTemp?: Maybe<Scalars['String']>;
  opening?: Maybe<Scalars['String']>;
  ripening?: Maybe<Scalars['String']>;
  groundColor?: Maybe<Scalars['String']>;
  blushColor?: Maybe<Scalars['String']>;
  blushPct?: Maybe<Scalars['String']>;
  scarsPieces?: Maybe<Scalars['String']>;
  scarsPct?: Maybe<Scalars['String']>;
  scarsDeg?: Maybe<Scalars['String']>;
  cutsSplitsPieces?: Maybe<Scalars['String']>;
  cutsSplitsPct?: Maybe<Scalars['String']>;
  cutsSplitsDeg?: Maybe<Scalars['String']>;
  splitPitPieces?: Maybe<Scalars['String']>;
  splitPitPct?: Maybe<Scalars['String']>;
  bruisingPieces?: Maybe<Scalars['String']>;
  bruisingPct?: Maybe<Scalars['String']>;
  bruisingDeg?: Maybe<Scalars['String']>;
  softTipsPieces?: Maybe<Scalars['String']>;
  softTipsPct?: Maybe<Scalars['String']>;
  dehydrationPieces?: Maybe<Scalars['String']>;
  dehydrationPct?: Maybe<Scalars['String']>;
  dehydrationDeg?: Maybe<Scalars['String']>;
  cutCount?: Maybe<Scalars['String']>;
  internalDamagePieces?: Maybe<Scalars['String']>;
  internalDamagePer?: Maybe<Scalars['String']>;
  mealinessPieces?: Maybe<Scalars['String']>;
  mealinessPct?: Maybe<Scalars['String']>;
  decayPieces?: Maybe<Scalars['String']>;
  decayPct?: Maybe<Scalars['String']>;
  decayDeg?: Maybe<Scalars['String']>;
  moldPieces?: Maybe<Scalars['String']>;
  moldPct?: Maybe<Scalars['String']>;
  brix?: Maybe<Scalars['String']>;
  pressure1?: Maybe<Scalars['String']>;
  pressure2?: Maybe<Scalars['String']>;
  pressure3?: Maybe<Scalars['String']>;
  pressure4?: Maybe<Scalars['String']>;
  pressure5?: Maybe<Scalars['String']>;
  pressure6?: Maybe<Scalars['String']>;
  pressuresMin?: Maybe<Scalars['String']>;
  pressuresMax?: Maybe<Scalars['String']>;
  pressuresAvg?: Maybe<Scalars['String']>;
  overallQuality?: Maybe<Scalars['BigFloat']>;
  overallCondition?: Maybe<Scalars['BigFloat']>;
  comment1?: Maybe<Scalars['String']>;
  comment2?: Maybe<Scalars['String']>;
  inspectionType?: Maybe<Scalars['String']>;
  shortInsp?: Maybe<Scalars['String']>;
  fixedWeight?: Maybe<Scalars['String']>;
};

/** A connection to a list of `PsaStoneFruitPallet` values. */
export type PsaStoneFruitPalletsConnection = {
  __typename?: 'PsaStoneFruitPalletsConnection';
  /** A list of `PsaStoneFruitPallet` objects. */
  nodes: Array<Maybe<PsaStoneFruitPallet>>;
  /** A list of edges which contains the `PsaStoneFruitPallet` and cursor to aid in pagination. */
  edges: Array<PsaStoneFruitPalletsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PsaStoneFruitPallet` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PsaStoneFruitPallet` edge in the connection. */
export type PsaStoneFruitPalletsEdge = {
  __typename?: 'PsaStoneFruitPalletsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PsaStoneFruitPallet` at the end of the edge. */
  node?: Maybe<PsaStoneFruitPallet>;
};

/** Methods to use when ordering `PsaStoneFruitPallet`. */
export enum PsaStoneFruitPalletsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  ImporterNameAsc = 'IMPORTER_NAME_ASC',
  ImporterNameDesc = 'IMPORTER_NAME_DESC',
  ExporterNameAsc = 'EXPORTER_NAME_ASC',
  ExporterNameDesc = 'EXPORTER_NAME_DESC',
  CommodityAsc = 'COMMODITY_ASC',
  CommodityDesc = 'COMMODITY_DESC',
  ProductCodeAsc = 'PRODUCT_CODE_ASC',
  ProductCodeDesc = 'PRODUCT_CODE_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  InspDateAsc = 'INSP_DATE_ASC',
  InspDateDesc = 'INSP_DATE_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  HatchAsc = 'HATCH_ASC',
  HatchDesc = 'HATCH_DESC',
  DeckAsc = 'DECK_ASC',
  DeckDesc = 'DECK_DESC',
  ContainerIdAsc = 'CONTAINER_ID_ASC',
  ContainerIdDesc = 'CONTAINER_ID_DESC',
  FumigationAsc = 'FUMIGATION_ASC',
  FumigationDesc = 'FUMIGATION_DESC',
  LabelCodeAsc = 'LABEL_CODE_ASC',
  LabelCodeDesc = 'LABEL_CODE_DESC',
  InspLocationAsc = 'INSP_LOCATION_ASC',
  InspLocationDesc = 'INSP_LOCATION_DESC',
  ImporterCodeAsc = 'IMPORTER_CODE_ASC',
  ImporterCodeDesc = 'IMPORTER_CODE_DESC',
  LotCodeAsc = 'LOT_CODE_ASC',
  LotCodeDesc = 'LOT_CODE_DESC',
  InspLotAsc = 'INSP_LOT_ASC',
  InspLotDesc = 'INSP_LOT_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  GrowerCodeAsc = 'GROWER_CODE_ASC',
  GrowerCodeDesc = 'GROWER_CODE_DESC',
  InspGrowerCodeAsc = 'INSP_GROWER_CODE_ASC',
  InspGrowerCodeDesc = 'INSP_GROWER_CODE_DESC',
  PackDateAsc = 'PACK_DATE_ASC',
  PackDateDesc = 'PACK_DATE_DESC',
  InspPackDateAsc = 'INSP_PACK_DATE_ASC',
  InspPackDateDesc = 'INSP_PACK_DATE_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  InspSizeAsc = 'INSP_SIZE_ASC',
  InspSizeDesc = 'INSP_SIZE_DESC',
  PackCodeAsc = 'PACK_CODE_ASC',
  PackCodeDesc = 'PACK_CODE_DESC',
  PackDescriptionAsc = 'PACK_DESCRIPTION_ASC',
  PackDescriptionDesc = 'PACK_DESCRIPTION_DESC',
  SecondaryDescriptionAsc = 'SECONDARY_DESCRIPTION_ASC',
  SecondaryDescriptionDesc = 'SECONDARY_DESCRIPTION_DESC',
  InspPackCodeAsc = 'INSP_PACK_CODE_ASC',
  InspPackCodeDesc = 'INSP_PACK_CODE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  PluPctAsc = 'PLU_PCT_ASC',
  PluPctDesc = 'PLU_PCT_DESC',
  CountryOfOriginAsc = 'COUNTRY_OF_ORIGIN_ASC',
  CountryOfOriginDesc = 'COUNTRY_OF_ORIGIN_DESC',
  UpcAsc = 'UPC_ASC',
  UpcDesc = 'UPC_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  UnderweightMinAsc = 'UNDERWEIGHT_MIN_ASC',
  UnderweightMinDesc = 'UNDERWEIGHT_MIN_DESC',
  UnderweightMaxAsc = 'UNDERWEIGHT_MAX_ASC',
  UnderweightMaxDesc = 'UNDERWEIGHT_MAX_DESC',
  WeighedUnitsAsc = 'WEIGHED_UNITS_ASC',
  WeighedUnitsDesc = 'WEIGHED_UNITS_DESC',
  UnderweightUnitsAsc = 'UNDERWEIGHT_UNITS_ASC',
  UnderweightUnitsDesc = 'UNDERWEIGHT_UNITS_DESC',
  UnderweightPctAsc = 'UNDERWEIGHT_PCT_ASC',
  UnderweightPctDesc = 'UNDERWEIGHT_PCT_DESC',
  PulpTempAsc = 'PULP_TEMP_ASC',
  PulpTempDesc = 'PULP_TEMP_DESC',
  OpeningAsc = 'OPENING_ASC',
  OpeningDesc = 'OPENING_DESC',
  RipeningAsc = 'RIPENING_ASC',
  RipeningDesc = 'RIPENING_DESC',
  GroundColorAsc = 'GROUND_COLOR_ASC',
  GroundColorDesc = 'GROUND_COLOR_DESC',
  BlushColorAsc = 'BLUSH_COLOR_ASC',
  BlushColorDesc = 'BLUSH_COLOR_DESC',
  BlushPctAsc = 'BLUSH_PCT_ASC',
  BlushPctDesc = 'BLUSH_PCT_DESC',
  ScarsPiecesAsc = 'SCARS_PIECES_ASC',
  ScarsPiecesDesc = 'SCARS_PIECES_DESC',
  ScarsPctAsc = 'SCARS_PCT_ASC',
  ScarsPctDesc = 'SCARS_PCT_DESC',
  ScarsDegAsc = 'SCARS_DEG_ASC',
  ScarsDegDesc = 'SCARS_DEG_DESC',
  CutsSplitsPiecesAsc = 'CUTS_SPLITS_PIECES_ASC',
  CutsSplitsPiecesDesc = 'CUTS_SPLITS_PIECES_DESC',
  CutsSplitsPctAsc = 'CUTS_SPLITS_PCT_ASC',
  CutsSplitsPctDesc = 'CUTS_SPLITS_PCT_DESC',
  CutsSplitsDegAsc = 'CUTS_SPLITS_DEG_ASC',
  CutsSplitsDegDesc = 'CUTS_SPLITS_DEG_DESC',
  SplitPitPiecesAsc = 'SPLIT_PIT_PIECES_ASC',
  SplitPitPiecesDesc = 'SPLIT_PIT_PIECES_DESC',
  SplitPitPctAsc = 'SPLIT_PIT_PCT_ASC',
  SplitPitPctDesc = 'SPLIT_PIT_PCT_DESC',
  BruisingPiecesAsc = 'BRUISING_PIECES_ASC',
  BruisingPiecesDesc = 'BRUISING_PIECES_DESC',
  BruisingPctAsc = 'BRUISING_PCT_ASC',
  BruisingPctDesc = 'BRUISING_PCT_DESC',
  BruisingDegAsc = 'BRUISING_DEG_ASC',
  BruisingDegDesc = 'BRUISING_DEG_DESC',
  SoftTipsPiecesAsc = 'SOFT_TIPS_PIECES_ASC',
  SoftTipsPiecesDesc = 'SOFT_TIPS_PIECES_DESC',
  SoftTipsPctAsc = 'SOFT_TIPS_PCT_ASC',
  SoftTipsPctDesc = 'SOFT_TIPS_PCT_DESC',
  DehydrationPiecesAsc = 'DEHYDRATION_PIECES_ASC',
  DehydrationPiecesDesc = 'DEHYDRATION_PIECES_DESC',
  DehydrationPctAsc = 'DEHYDRATION_PCT_ASC',
  DehydrationPctDesc = 'DEHYDRATION_PCT_DESC',
  DehydrationDegAsc = 'DEHYDRATION_DEG_ASC',
  DehydrationDegDesc = 'DEHYDRATION_DEG_DESC',
  CutCountAsc = 'CUT_COUNT_ASC',
  CutCountDesc = 'CUT_COUNT_DESC',
  InternalDamagePiecesAsc = 'INTERNAL_DAMAGE_PIECES_ASC',
  InternalDamagePiecesDesc = 'INTERNAL_DAMAGE_PIECES_DESC',
  InternalDamagePerAsc = 'INTERNAL_DAMAGE_PER_ASC',
  InternalDamagePerDesc = 'INTERNAL_DAMAGE_PER_DESC',
  MealinessPiecesAsc = 'MEALINESS_PIECES_ASC',
  MealinessPiecesDesc = 'MEALINESS_PIECES_DESC',
  MealinessPctAsc = 'MEALINESS_PCT_ASC',
  MealinessPctDesc = 'MEALINESS_PCT_DESC',
  DecayPiecesAsc = 'DECAY_PIECES_ASC',
  DecayPiecesDesc = 'DECAY_PIECES_DESC',
  DecayPctAsc = 'DECAY_PCT_ASC',
  DecayPctDesc = 'DECAY_PCT_DESC',
  DecayDegAsc = 'DECAY_DEG_ASC',
  DecayDegDesc = 'DECAY_DEG_DESC',
  MoldPiecesAsc = 'MOLD_PIECES_ASC',
  MoldPiecesDesc = 'MOLD_PIECES_DESC',
  MoldPctAsc = 'MOLD_PCT_ASC',
  MoldPctDesc = 'MOLD_PCT_DESC',
  BrixAsc = 'BRIX_ASC',
  BrixDesc = 'BRIX_DESC',
  Pressure1Asc = 'PRESSURE1_ASC',
  Pressure1Desc = 'PRESSURE1_DESC',
  Pressure2Asc = 'PRESSURE2_ASC',
  Pressure2Desc = 'PRESSURE2_DESC',
  Pressure3Asc = 'PRESSURE3_ASC',
  Pressure3Desc = 'PRESSURE3_DESC',
  Pressure4Asc = 'PRESSURE4_ASC',
  Pressure4Desc = 'PRESSURE4_DESC',
  Pressure5Asc = 'PRESSURE5_ASC',
  Pressure5Desc = 'PRESSURE5_DESC',
  Pressure6Asc = 'PRESSURE6_ASC',
  Pressure6Desc = 'PRESSURE6_DESC',
  PressuresMinAsc = 'PRESSURES_MIN_ASC',
  PressuresMinDesc = 'PRESSURES_MIN_DESC',
  PressuresMaxAsc = 'PRESSURES_MAX_ASC',
  PressuresMaxDesc = 'PRESSURES_MAX_DESC',
  PressuresAvgAsc = 'PRESSURES_AVG_ASC',
  PressuresAvgDesc = 'PRESSURES_AVG_DESC',
  OverallQualityAsc = 'OVERALL_QUALITY_ASC',
  OverallQualityDesc = 'OVERALL_QUALITY_DESC',
  OverallConditionAsc = 'OVERALL_CONDITION_ASC',
  OverallConditionDesc = 'OVERALL_CONDITION_DESC',
  Comment1Asc = 'COMMENT1_ASC',
  Comment1Desc = 'COMMENT1_DESC',
  Comment2Asc = 'COMMENT2_ASC',
  Comment2Desc = 'COMMENT2_DESC',
  InspectionTypeAsc = 'INSPECTION_TYPE_ASC',
  InspectionTypeDesc = 'INSPECTION_TYPE_DESC',
  ShortInspAsc = 'SHORT_INSP_ASC',
  ShortInspDesc = 'SHORT_INSP_DESC',
  FixedWeightAsc = 'FIXED_WEIGHT_ASC',
  FixedWeightDesc = 'FIXED_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `OrderNumber`. */
  orderNumbers?: Maybe<OrderNumbersConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `UserBookmark`. */
  userBookmarks?: Maybe<UserBookmarksConnection>;
  /** Reads and enables pagination through a set of `UserMessage`. */
  userMessages?: Maybe<UserMessagesConnection>;
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles?: Maybe<UserRolesConnection>;
  /** Reads and enables pagination through a set of `ContactGroup`. */
  contactGroups?: Maybe<ContactGroupsConnection>;
  /** Reads and enables pagination through a set of `ContactGroupPersonContact`. */
  contactGroupPersonContacts?: Maybe<ContactGroupPersonContactsConnection>;
  /** Reads and enables pagination through a set of `Country`. */
  countries?: Maybe<CountriesConnection>;
  /** Reads and enables pagination through a set of `Customer`. */
  customers?: Maybe<CustomersConnection>;
  /** Reads and enables pagination through a set of `CustomerPersonContact`. */
  customerPersonContacts?: Maybe<CustomerPersonContactsConnection>;
  /** Reads and enables pagination through a set of `CustomerVolumeDiscount`. */
  customerVolumeDiscounts?: Maybe<CustomerVolumeDiscountsConnection>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContacts?: Maybe<PersonContactsConnection>;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippers?: Maybe<ShippersConnection>;
  /** Reads and enables pagination through a set of `ShipperAdvance`. */
  shipperAdvances?: Maybe<ShipperAdvancesConnection>;
  /** Reads and enables pagination through a set of `ShipperPersonContact`. */
  shipperPersonContacts?: Maybe<ShipperPersonContactsConnection>;
  /** Reads and enables pagination through a set of `Vendor`. */
  vendors?: Maybe<VendorsConnection>;
  /** Reads and enables pagination through a set of `VendorPersonContact`. */
  vendorPersonContacts?: Maybe<VendorPersonContactsConnection>;
  /** Reads and enables pagination through a set of `Warehouse`. */
  warehouses?: Maybe<WarehousesConnection>;
  /** Reads and enables pagination through a set of `WarehousePersonContact`. */
  warehousePersonContacts?: Maybe<WarehousePersonContactsConnection>;
  /** Reads and enables pagination through a set of `ChileDepartureInspectionPallet`. */
  chileDepartureInspectionPallets?: Maybe<ChileDepartureInspectionPalletsConnection>;
  /** Reads and enables pagination through a set of `PeruDepartureInspection`. */
  peruDepartureInspections?: Maybe<PeruDepartureInspectionsConnection>;
  /** Reads and enables pagination through a set of `PeruDepartureInspectionPallet`. */
  peruDepartureInspectionPallets?: Maybe<PeruDepartureInspectionPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaApplePallet`. */
  psaApplePallets?: Maybe<PsaApplePalletsConnection>;
  /** Reads and enables pagination through a set of `PsaArrivalPicture`. */
  psaArrivalPictures?: Maybe<PsaArrivalPicturesConnection>;
  /** Reads and enables pagination through a set of `PsaArrivalReport`. */
  psaArrivalReports?: Maybe<PsaArrivalReportsConnection>;
  /** Reads and enables pagination through a set of `PsaCherryPallet`. */
  psaCherryPallets?: Maybe<PsaCherryPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaCitrusPallet`. */
  psaCitrusPallets?: Maybe<PsaCitrusPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaGrapePallet`. */
  psaGrapePallets?: Maybe<PsaGrapePalletsConnection>;
  /** Reads and enables pagination through a set of `PsaLemonPallet`. */
  psaLemonPallets?: Maybe<PsaLemonPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaPearPallet`. */
  psaPearPallets?: Maybe<PsaPearPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaPersimmonPallet`. */
  psaPersimmonPallets?: Maybe<PsaPersimmonPalletsConnection>;
  /** Reads and enables pagination through a set of `PsaPomegranatePallet`. */
  psaPomegranatePallets?: Maybe<PsaPomegranatePalletsConnection>;
  /** Reads and enables pagination through a set of `PsaStoneFruitPallet`. */
  psaStoneFruitPallets?: Maybe<PsaStoneFruitPalletsConnection>;
  /** Reads and enables pagination through a set of `CommonCategory`. */
  commonCategories?: Maybe<CommonCategoriesConnection>;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypes?: Maybe<CommonPackTypesConnection>;
  /** Reads and enables pagination through a set of `CommonPackTypePackMaster`. */
  commonPackTypePackMasters?: Maybe<CommonPackTypePackMastersConnection>;
  /** Reads and enables pagination through a set of `CommonPackTypeTag`. */
  commonPackTypeTags?: Maybe<CommonPackTypeTagsConnection>;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizes?: Maybe<CommonSizesConnection>;
  /** Reads and enables pagination through a set of `CommonSizeProductSize`. */
  commonSizeProductSizes?: Maybe<CommonSizeProductSizesConnection>;
  /** Reads and enables pagination through a set of `CommonSizeTag`. */
  commonSizeTags?: Maybe<CommonSizeTagsConnection>;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpecieses?: Maybe<CommonSpeciesConnection>;
  /** Reads and enables pagination through a set of `CommonSpeciesProductSpecies`. */
  commonSpeciesProductSpecieses?: Maybe<CommonSpeciesProductSpeciesConnection>;
  /** Reads and enables pagination through a set of `CommonSpeciesTag`. */
  commonSpeciesTags?: Maybe<CommonSpeciesTagsConnection>;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarieties?: Maybe<CommonVarietiesConnection>;
  /** Reads and enables pagination through a set of `CommonVarietyProductVariety`. */
  commonVarietyProductVarieties?: Maybe<CommonVarietyProductVarietiesConnection>;
  /** Reads and enables pagination through a set of `CommonVarietyTag`. */
  commonVarietyTags?: Maybe<CommonVarietyTagsConnection>;
  /** Reads and enables pagination through a set of `Container`. */
  containers?: Maybe<ContainersConnection>;
  /** Reads and enables pagination through a set of `ContainerTreatment`. */
  containerTreatments?: Maybe<ContainerTreatmentsConnection>;
  /** Reads and enables pagination through a set of `CustomerProgram`. */
  customerPrograms?: Maybe<CustomerProgramsConnection>;
  /** Reads and enables pagination through a set of `CustomerProgramEntry`. */
  customerProgramEntries?: Maybe<CustomerProgramEntriesConnection>;
  /** Reads and enables pagination through a set of `InventoryItem`. */
  inventoryItems?: Maybe<InventoryItemsConnection>;
  /** Reads and enables pagination through a set of `PackAtmosphere`. */
  packAtmospheres?: Maybe<PackAtmospheresConnection>;
  /** Reads and enables pagination through a set of `PackBoxStyle`. */
  packBoxStyles?: Maybe<PackBoxStylesConnection>;
  /** Reads and enables pagination through a set of `PackBoxType`. */
  packBoxTypes?: Maybe<PackBoxTypesConnection>;
  /** Reads and enables pagination through a set of `PackDestination`. */
  packDestinations?: Maybe<PackDestinationsConnection>;
  /** Reads and enables pagination through a set of `PackGrade`. */
  packGrades?: Maybe<PackGradesConnection>;
  /** Reads and enables pagination through a set of `PackHold`. */
  packHolds?: Maybe<PackHoldsConnection>;
  /** Reads and enables pagination through a set of `PackLabel`. */
  packLabels?: Maybe<PackLabelsConnection>;
  /** Reads and enables pagination through a set of `PackLiner`. */
  packLiners?: Maybe<PackLinersConnection>;
  /** Reads and enables pagination through a set of `PackMaster`. */
  packMasters?: Maybe<PackMastersConnection>;
  /** Reads and enables pagination through a set of `PackOut`. */
  packOuts?: Maybe<PackOutsConnection>;
  /** Reads and enables pagination through a set of `PackPalletType`. */
  packPalletTypes?: Maybe<PackPalletTypesConnection>;
  /** Reads and enables pagination through a set of `PackProduction`. */
  packProductions?: Maybe<PackProductionsConnection>;
  /** Reads and enables pagination through a set of `PackSpecial`. */
  packSpecials?: Maybe<PackSpecialsConnection>;
  /** Reads and enables pagination through a set of `PackStyle`. */
  packStyles?: Maybe<PackStylesConnection>;
  /** Reads and enables pagination through a set of `PackTreeRipe`. */
  packTreeRipes?: Maybe<PackTreeRipesConnection>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets?: Maybe<PalletsConnection>;
  /** Reads and enables pagination through a set of `PalletSection`. */
  palletSections?: Maybe<PalletSectionsConnection>;
  /** Reads and enables pagination through a set of `ProductMaster`. */
  productMasters?: Maybe<ProductMastersConnection>;
  /** Reads and enables pagination through a set of `ProductSize`. */
  productSizes?: Maybe<ProductSizesConnection>;
  /** Reads and enables pagination through a set of `ProductSpecies`. */
  productSpecieses?: Maybe<ProductSpeciesConnection>;
  /** Reads and enables pagination through a set of `ProductVariety`. */
  productVarieties?: Maybe<ProductVarietiesConnection>;
  /** Reads and enables pagination through a set of `RepackStyle`. */
  repackStyles?: Maybe<RepackStylesConnection>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms?: Maybe<ShipperProgramsConnection>;
  /** Reads and enables pagination through a set of `ShipperProgramEntry`. */
  shipperProgramEntries?: Maybe<ShipperProgramEntriesConnection>;
  /** Reads and enables pagination through a set of `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntryCustomerProgramEntries?: Maybe<ShipperProgramEntryCustomerProgramEntriesConnection>;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjections?: Maybe<ShipperProjectionsConnection>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntries?: Maybe<ShipperProjectionEntriesConnection>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts?: Maybe<ShipperProjectionProductsConnection>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVessels?: Maybe<ShipperProjectionVesselsConnection>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfos?: Maybe<ShipperProjectionVesselInfosConnection>;
  /** Reads and enables pagination through a set of `Vessel`. */
  vessels?: Maybe<VesselsConnection>;
  /** Reads and enables pagination through a set of `AgendaItem`. */
  agendaItems?: Maybe<AgendaItemsConnection>;
  /** Reads and enables pagination through a set of `CalendarEvent`. */
  calendarEvents?: Maybe<CalendarEventsConnection>;
  /** Reads and enables pagination through a set of `PriceCategory`. */
  priceCategories?: Maybe<PriceCategoriesConnection>;
  /** Reads and enables pagination through a set of `PriceEntry`. */
  priceEntries?: Maybe<PriceEntriesConnection>;
  /** Reads and enables pagination through a set of `PriceProduct`. */
  priceProducts?: Maybe<PriceProductsConnection>;
  /** Reads and enables pagination through a set of `PriceSize`. */
  priceSizes?: Maybe<PriceSizesConnection>;
  /** Reads and enables pagination through a set of `LoadNumber`. */
  loadNumbers?: Maybe<LoadNumbersConnection>;
  /** Reads and enables pagination through a set of `OrderComment`. */
  orderComments?: Maybe<OrderCommentsConnection>;
  /** Reads and enables pagination through a set of `OrderEntry`. */
  orderEntries?: Maybe<OrderEntriesConnection>;
  /** Reads and enables pagination through a set of `OrderEntryItem`. */
  orderEntryItems?: Maybe<OrderEntryItemsConnection>;
  /** Reads and enables pagination through a set of `OrderEntryReviewItem`. */
  orderEntryReviewItems?: Maybe<OrderEntryReviewItemsConnection>;
  /** Reads and enables pagination through a set of `OrderItem`. */
  orderItems?: Maybe<OrderItemsConnection>;
  /** Reads and enables pagination through a set of `OrderMaster`. */
  orderMasters?: Maybe<OrderMastersConnection>;
  /** Reads and enables pagination through a set of `OrderPallet`. */
  orderPallets?: Maybe<OrderPalletsConnection>;
  /** Reads and enables pagination through a set of `RepackHeader`. */
  repackHeaders?: Maybe<RepackHeadersConnection>;
  /** Reads and enables pagination through a set of `RepackItem`. */
  repackItems?: Maybe<RepackItemsConnection>;
  /** Reads and enables pagination through a set of `RepackQueue`. */
  repackQueues?: Maybe<RepackQueuesConnection>;
  /** Reads and enables pagination through a set of `TruckLoad`. */
  truckLoads?: Maybe<TruckLoadsConnection>;
  /** Reads and enables pagination through a set of `TruckRate`. */
  truckRates?: Maybe<TruckRatesConnection>;
  /** Reads and enables pagination through a set of `TruckRateCustomer`. */
  truckRateCustomers?: Maybe<TruckRateCustomersConnection>;
  /** Reads and enables pagination through a set of `CheckHeader`. */
  checkHeaders?: Maybe<CheckHeadersConnection>;
  /** Reads and enables pagination through a set of `CustomerPayment`. */
  customerPayments?: Maybe<CustomerPaymentsConnection>;
  /** Reads and enables pagination through a set of `ExpenseHeader`. */
  expenseHeaders?: Maybe<ExpenseHeadersConnection>;
  /** Reads and enables pagination through a set of `ExpenseHeaderReview`. */
  expenseHeaderReviews?: Maybe<ExpenseHeaderReviewsConnection>;
  /** Reads and enables pagination through a set of `ExpenseItem`. */
  expenseItems?: Maybe<ExpenseItemsConnection>;
  /** Reads and enables pagination through a set of `InvoiceHeader`. */
  invoiceHeaders?: Maybe<InvoiceHeadersConnection>;
  /** Reads and enables pagination through a set of `InvoiceItem`. */
  invoiceItems?: Maybe<InvoiceItemsConnection>;
  /** Reads and enables pagination through a set of `InvoiceItemHistory`. */
  invoiceItemHistories?: Maybe<InvoiceItemHistoriesConnection>;
  /** Reads and enables pagination through a set of `Unpaid`. */
  unpaids?: Maybe<UnpaidsConnection>;
  /** Reads and enables pagination through a set of `VesselControl`. */
  vesselControls?: Maybe<VesselControlsConnection>;
  /** Reads and enables pagination through a set of `WireRequest`. */
  wireRequests?: Maybe<WireRequestsConnection>;
  /** Reads and enables pagination through a set of `WireRequestAccountOfSaleItem`. */
  wireRequestAccountOfSaleItems?: Maybe<WireRequestAccountOfSaleItemsConnection>;
  /** Reads and enables pagination through a set of `WireRequestMiscItem`. */
  wireRequestMiscItems?: Maybe<WireRequestMiscItemsConnection>;
  /** Reads and enables pagination through a set of `WireRequestOceanFreightItem`. */
  wireRequestOceanFreightItems?: Maybe<WireRequestOceanFreightItemsConnection>;
  /** Reads and enables pagination through a set of `WireRequestShipperAdvanceItem`. */
  wireRequestShipperAdvanceItems?: Maybe<WireRequestShipperAdvanceItemsConnection>;
  orderNumber?: Maybe<OrderNumber>;
  user?: Maybe<User>;
  userByPin?: Maybe<User>;
  userBookmark?: Maybe<UserBookmark>;
  userMessage?: Maybe<UserMessage>;
  userRoleByUserIdAndRoleName?: Maybe<UserRole>;
  contactGroup?: Maybe<ContactGroup>;
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  country?: Maybe<Country>;
  customer?: Maybe<Customer>;
  customerPersonContact?: Maybe<CustomerPersonContact>;
  customerVolumeDiscount?: Maybe<CustomerVolumeDiscount>;
  personContact?: Maybe<PersonContact>;
  shipper?: Maybe<Shipper>;
  shipperAdvance?: Maybe<ShipperAdvance>;
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  vendor?: Maybe<Vendor>;
  vendorPersonContact?: Maybe<VendorPersonContact>;
  warehouse?: Maybe<Warehouse>;
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  psaApplePallet?: Maybe<PsaApplePallet>;
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  psaPearPallet?: Maybe<PsaPearPallet>;
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  commonCategory?: Maybe<CommonCategory>;
  commonPackType?: Maybe<CommonPackType>;
  commonPackTypePackMaster?: Maybe<CommonPackTypePackMaster>;
  commonPackTypeTag?: Maybe<CommonPackTypeTag>;
  commonSize?: Maybe<CommonSize>;
  commonSizeProductSize?: Maybe<CommonSizeProductSize>;
  commonSizeTag?: Maybe<CommonSizeTag>;
  commonSpecies?: Maybe<CommonSpecies>;
  commonSpeciesProductSpecies?: Maybe<CommonSpeciesProductSpecies>;
  commonSpeciesTag?: Maybe<CommonSpeciesTag>;
  commonVariety?: Maybe<CommonVariety>;
  commonVarietyProductVariety?: Maybe<CommonVarietyProductVariety>;
  commonVarietyTag?: Maybe<CommonVarietyTag>;
  container?: Maybe<Container>;
  containerTreatment?: Maybe<ContainerTreatment>;
  customerProgram?: Maybe<CustomerProgram>;
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  inventoryItem?: Maybe<InventoryItem>;
  packAtmosphere?: Maybe<PackAtmosphere>;
  packAtmosphereByShipperIdAndMaCode?: Maybe<PackAtmosphere>;
  packBoxStyle?: Maybe<PackBoxStyle>;
  packBoxStyleByShipperIdAndBoxStyle?: Maybe<PackBoxStyle>;
  packBoxType?: Maybe<PackBoxType>;
  packBoxTypeByShipperIdAndBoxType?: Maybe<PackBoxType>;
  packDestination?: Maybe<PackDestination>;
  packDestinationByShipperIdAndDestinationCode?: Maybe<PackDestination>;
  packGrade?: Maybe<PackGrade>;
  packGradeByShipperIdAndGradeCode?: Maybe<PackGrade>;
  packHold?: Maybe<PackHold>;
  packHoldByShipperIdAndHoldCode?: Maybe<PackHold>;
  packLabel?: Maybe<PackLabel>;
  packLabelByShipperIdAndLabelCode?: Maybe<PackLabel>;
  packLiner?: Maybe<PackLiner>;
  packLinerByShipperIdAndLinerCode?: Maybe<PackLiner>;
  packMaster?: Maybe<PackMaster>;
  packOut?: Maybe<PackOut>;
  packOutByShipperIdAndOutCode?: Maybe<PackOut>;
  packPalletType?: Maybe<PackPalletType>;
  packPalletTypeByShipperIdAndPalletType?: Maybe<PackPalletType>;
  packProduction?: Maybe<PackProduction>;
  packProductionByShipperIdAndProductionCode?: Maybe<PackProduction>;
  packSpecial?: Maybe<PackSpecial>;
  packSpecialByShipperIdAndCustomerCode?: Maybe<PackSpecial>;
  packStyle?: Maybe<PackStyle>;
  packStyleByShipperIdAndPackStyle?: Maybe<PackStyle>;
  packTreeRipe?: Maybe<PackTreeRipe>;
  packTreeRipeByShipperIdAndTreeRipe?: Maybe<PackTreeRipe>;
  pallet?: Maybe<Pallet>;
  palletSection?: Maybe<PalletSection>;
  productMaster?: Maybe<ProductMaster>;
  productSize?: Maybe<ProductSize>;
  productSpecies?: Maybe<ProductSpecies>;
  productVariety?: Maybe<ProductVariety>;
  repackStyle?: Maybe<RepackStyle>;
  shipperProgram?: Maybe<ShipperProgram>;
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  shipperProgramEntryCustomerProgramEntry?: Maybe<ShipperProgramEntryCustomerProgramEntry>;
  shipperProjection?: Maybe<ShipperProjection>;
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  shipperProjectionVesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  vessel?: Maybe<Vessel>;
  agendaItem?: Maybe<AgendaItem>;
  calendarEvent?: Maybe<CalendarEvent>;
  priceCategory?: Maybe<PriceCategory>;
  priceEntry?: Maybe<PriceEntry>;
  priceProduct?: Maybe<PriceProduct>;
  priceSize?: Maybe<PriceSize>;
  loadNumber?: Maybe<LoadNumber>;
  orderComment?: Maybe<OrderComment>;
  orderEntry?: Maybe<OrderEntry>;
  orderEntryItem?: Maybe<OrderEntryItem>;
  orderEntryReviewItem?: Maybe<OrderEntryReviewItem>;
  orderItem?: Maybe<OrderItem>;
  orderMaster?: Maybe<OrderMaster>;
  orderPallet?: Maybe<OrderPallet>;
  repackHeader?: Maybe<RepackHeader>;
  repackItem?: Maybe<RepackItem>;
  repackQueue?: Maybe<RepackQueue>;
  truckLoad?: Maybe<TruckLoad>;
  truckRate?: Maybe<TruckRate>;
  truckRateCustomer?: Maybe<TruckRateCustomer>;
  checkHeader?: Maybe<CheckHeader>;
  customerPayment?: Maybe<CustomerPayment>;
  expenseHeader?: Maybe<ExpenseHeader>;
  expenseHeaderReview?: Maybe<ExpenseHeaderReview>;
  expenseItem?: Maybe<ExpenseItem>;
  invoiceHeader?: Maybe<InvoiceHeader>;
  invoiceItem?: Maybe<InvoiceItem>;
  invoiceItemHistory?: Maybe<InvoiceItemHistory>;
  unpaid?: Maybe<Unpaid>;
  vesselControl?: Maybe<VesselControl>;
  wireRequest?: Maybe<WireRequest>;
  wireRequestAccountOfSaleItem?: Maybe<WireRequestAccountOfSaleItem>;
  wireRequestMiscItem?: Maybe<WireRequestMiscItem>;
  wireRequestOceanFreightItem?: Maybe<WireRequestOceanFreightItem>;
  wireRequestShipperAdvanceItem?: Maybe<WireRequestShipperAdvanceItem>;
  baseData?: Maybe<Scalars['String']>;
  distinctValues?: Maybe<DistinctValuesConnection>;
  customerDistinctColumnValues?: Maybe<CustomerDistinctColumnValuesConnection>;
  customerDistinctValues?: Maybe<CustomerDistinctValuesConnection>;
  shipperDistinctValues?: Maybe<ShipperDistinctValuesConnection>;
  vendorDistinctValues?: Maybe<VendorDistinctValuesConnection>;
  warehouseDistinctValues?: Maybe<WarehouseDistinctValuesConnection>;
  /** Reads and enables pagination through a set of `ChileDepartureInspection`. */
  chileDepartureInspections?: Maybe<ChileDepartureInspectionsConnection>;
  orderMasterCustomerDistinctValues?: Maybe<OrderMasterCustomerDistinctValuesConnection>;
  newRepackQueues?: Maybe<NewRepackQueuesConnection>;
  nextOrderNumber?: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `VesselControl`. */
  allVesselControls?: Maybe<VesselControlsConnection>;
  /** Reads and enables pagination through a set of `ExpenseHeaderReview`. */
  expenseHeaderReviewsList?: Maybe<ExpenseHeaderReviewsConnection>;
  /** Reads and enables pagination through a set of `ExpenseHeader`. */
  expenseHeaderSummary?: Maybe<ExpenseHeadersConnection>;
  expenseSummaryTruckLoadIds?: Maybe<ExpenseSummaryTruckLoadIdsConnection>;
  /** Reads a single `OrderNumber` using its globally unique `ID`. */
  orderNumberByNodeId?: Maybe<OrderNumber>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  /** Reads a single `UserBookmark` using its globally unique `ID`. */
  userBookmarkByNodeId?: Maybe<UserBookmark>;
  /** Reads a single `UserMessage` using its globally unique `ID`. */
  userMessageByNodeId?: Maybe<UserMessage>;
  /** Reads a single `ContactGroup` using its globally unique `ID`. */
  contactGroupByNodeId?: Maybe<ContactGroup>;
  /** Reads a single `ContactGroupPersonContact` using its globally unique `ID`. */
  contactGroupPersonContactByNodeId?: Maybe<ContactGroupPersonContact>;
  /** Reads a single `Country` using its globally unique `ID`. */
  countryByNodeId?: Maybe<Country>;
  /** Reads a single `Customer` using its globally unique `ID`. */
  customerByNodeId?: Maybe<Customer>;
  /** Reads a single `CustomerPersonContact` using its globally unique `ID`. */
  customerPersonContactByNodeId?: Maybe<CustomerPersonContact>;
  /** Reads a single `CustomerVolumeDiscount` using its globally unique `ID`. */
  customerVolumeDiscountByNodeId?: Maybe<CustomerVolumeDiscount>;
  /** Reads a single `PersonContact` using its globally unique `ID`. */
  personContactByNodeId?: Maybe<PersonContact>;
  /** Reads a single `Shipper` using its globally unique `ID`. */
  shipperByNodeId?: Maybe<Shipper>;
  /** Reads a single `ShipperAdvance` using its globally unique `ID`. */
  shipperAdvanceByNodeId?: Maybe<ShipperAdvance>;
  /** Reads a single `ShipperPersonContact` using its globally unique `ID`. */
  shipperPersonContactByNodeId?: Maybe<ShipperPersonContact>;
  /** Reads a single `Vendor` using its globally unique `ID`. */
  vendorByNodeId?: Maybe<Vendor>;
  /** Reads a single `VendorPersonContact` using its globally unique `ID`. */
  vendorPersonContactByNodeId?: Maybe<VendorPersonContact>;
  /** Reads a single `Warehouse` using its globally unique `ID`. */
  warehouseByNodeId?: Maybe<Warehouse>;
  /** Reads a single `WarehousePersonContact` using its globally unique `ID`. */
  warehousePersonContactByNodeId?: Maybe<WarehousePersonContact>;
  /** Reads a single `ChileDepartureInspectionPallet` using its globally unique `ID`. */
  chileDepartureInspectionPalletByNodeId?: Maybe<ChileDepartureInspectionPallet>;
  /** Reads a single `PeruDepartureInspection` using its globally unique `ID`. */
  peruDepartureInspectionByNodeId?: Maybe<PeruDepartureInspection>;
  /** Reads a single `PeruDepartureInspectionPallet` using its globally unique `ID`. */
  peruDepartureInspectionPalletByNodeId?: Maybe<PeruDepartureInspectionPallet>;
  /** Reads a single `PsaApplePallet` using its globally unique `ID`. */
  psaApplePalletByNodeId?: Maybe<PsaApplePallet>;
  /** Reads a single `PsaArrivalPicture` using its globally unique `ID`. */
  psaArrivalPictureByNodeId?: Maybe<PsaArrivalPicture>;
  /** Reads a single `PsaArrivalReport` using its globally unique `ID`. */
  psaArrivalReportByNodeId?: Maybe<PsaArrivalReport>;
  /** Reads a single `PsaCherryPallet` using its globally unique `ID`. */
  psaCherryPalletByNodeId?: Maybe<PsaCherryPallet>;
  /** Reads a single `PsaCitrusPallet` using its globally unique `ID`. */
  psaCitrusPalletByNodeId?: Maybe<PsaCitrusPallet>;
  /** Reads a single `PsaGrapePallet` using its globally unique `ID`. */
  psaGrapePalletByNodeId?: Maybe<PsaGrapePallet>;
  /** Reads a single `PsaLemonPallet` using its globally unique `ID`. */
  psaLemonPalletByNodeId?: Maybe<PsaLemonPallet>;
  /** Reads a single `PsaPearPallet` using its globally unique `ID`. */
  psaPearPalletByNodeId?: Maybe<PsaPearPallet>;
  /** Reads a single `PsaPersimmonPallet` using its globally unique `ID`. */
  psaPersimmonPalletByNodeId?: Maybe<PsaPersimmonPallet>;
  /** Reads a single `PsaPomegranatePallet` using its globally unique `ID`. */
  psaPomegranatePalletByNodeId?: Maybe<PsaPomegranatePallet>;
  /** Reads a single `PsaStoneFruitPallet` using its globally unique `ID`. */
  psaStoneFruitPalletByNodeId?: Maybe<PsaStoneFruitPallet>;
  /** Reads a single `CommonCategory` using its globally unique `ID`. */
  commonCategoryByNodeId?: Maybe<CommonCategory>;
  /** Reads a single `CommonPackType` using its globally unique `ID`. */
  commonPackTypeByNodeId?: Maybe<CommonPackType>;
  /** Reads a single `CommonPackTypePackMaster` using its globally unique `ID`. */
  commonPackTypePackMasterByNodeId?: Maybe<CommonPackTypePackMaster>;
  /** Reads a single `CommonPackTypeTag` using its globally unique `ID`. */
  commonPackTypeTagByNodeId?: Maybe<CommonPackTypeTag>;
  /** Reads a single `CommonSize` using its globally unique `ID`. */
  commonSizeByNodeId?: Maybe<CommonSize>;
  /** Reads a single `CommonSizeProductSize` using its globally unique `ID`. */
  commonSizeProductSizeByNodeId?: Maybe<CommonSizeProductSize>;
  /** Reads a single `CommonSizeTag` using its globally unique `ID`. */
  commonSizeTagByNodeId?: Maybe<CommonSizeTag>;
  /** Reads a single `CommonSpecies` using its globally unique `ID`. */
  commonSpeciesByNodeId?: Maybe<CommonSpecies>;
  /** Reads a single `CommonSpeciesProductSpecies` using its globally unique `ID`. */
  commonSpeciesProductSpeciesByNodeId?: Maybe<CommonSpeciesProductSpecies>;
  /** Reads a single `CommonSpeciesTag` using its globally unique `ID`. */
  commonSpeciesTagByNodeId?: Maybe<CommonSpeciesTag>;
  /** Reads a single `CommonVariety` using its globally unique `ID`. */
  commonVarietyByNodeId?: Maybe<CommonVariety>;
  /** Reads a single `CommonVarietyProductVariety` using its globally unique `ID`. */
  commonVarietyProductVarietyByNodeId?: Maybe<CommonVarietyProductVariety>;
  /** Reads a single `CommonVarietyTag` using its globally unique `ID`. */
  commonVarietyTagByNodeId?: Maybe<CommonVarietyTag>;
  /** Reads a single `Container` using its globally unique `ID`. */
  containerByNodeId?: Maybe<Container>;
  /** Reads a single `ContainerTreatment` using its globally unique `ID`. */
  containerTreatmentByNodeId?: Maybe<ContainerTreatment>;
  /** Reads a single `CustomerProgram` using its globally unique `ID`. */
  customerProgramByNodeId?: Maybe<CustomerProgram>;
  /** Reads a single `CustomerProgramEntry` using its globally unique `ID`. */
  customerProgramEntryByNodeId?: Maybe<CustomerProgramEntry>;
  /** Reads a single `InventoryItem` using its globally unique `ID`. */
  inventoryItemByNodeId?: Maybe<InventoryItem>;
  /** Reads a single `PackAtmosphere` using its globally unique `ID`. */
  packAtmosphereByNodeId?: Maybe<PackAtmosphere>;
  /** Reads a single `PackBoxStyle` using its globally unique `ID`. */
  packBoxStyleByNodeId?: Maybe<PackBoxStyle>;
  /** Reads a single `PackBoxType` using its globally unique `ID`. */
  packBoxTypeByNodeId?: Maybe<PackBoxType>;
  /** Reads a single `PackDestination` using its globally unique `ID`. */
  packDestinationByNodeId?: Maybe<PackDestination>;
  /** Reads a single `PackGrade` using its globally unique `ID`. */
  packGradeByNodeId?: Maybe<PackGrade>;
  /** Reads a single `PackHold` using its globally unique `ID`. */
  packHoldByNodeId?: Maybe<PackHold>;
  /** Reads a single `PackLabel` using its globally unique `ID`. */
  packLabelByNodeId?: Maybe<PackLabel>;
  /** Reads a single `PackLiner` using its globally unique `ID`. */
  packLinerByNodeId?: Maybe<PackLiner>;
  /** Reads a single `PackMaster` using its globally unique `ID`. */
  packMasterByNodeId?: Maybe<PackMaster>;
  /** Reads a single `PackOut` using its globally unique `ID`. */
  packOutByNodeId?: Maybe<PackOut>;
  /** Reads a single `PackPalletType` using its globally unique `ID`. */
  packPalletTypeByNodeId?: Maybe<PackPalletType>;
  /** Reads a single `PackProduction` using its globally unique `ID`. */
  packProductionByNodeId?: Maybe<PackProduction>;
  /** Reads a single `PackSpecial` using its globally unique `ID`. */
  packSpecialByNodeId?: Maybe<PackSpecial>;
  /** Reads a single `PackStyle` using its globally unique `ID`. */
  packStyleByNodeId?: Maybe<PackStyle>;
  /** Reads a single `PackTreeRipe` using its globally unique `ID`. */
  packTreeRipeByNodeId?: Maybe<PackTreeRipe>;
  /** Reads a single `Pallet` using its globally unique `ID`. */
  palletByNodeId?: Maybe<Pallet>;
  /** Reads a single `PalletSection` using its globally unique `ID`. */
  palletSectionByNodeId?: Maybe<PalletSection>;
  /** Reads a single `ProductMaster` using its globally unique `ID`. */
  productMasterByNodeId?: Maybe<ProductMaster>;
  /** Reads a single `ProductSize` using its globally unique `ID`. */
  productSizeByNodeId?: Maybe<ProductSize>;
  /** Reads a single `ProductSpecies` using its globally unique `ID`. */
  productSpeciesByNodeId?: Maybe<ProductSpecies>;
  /** Reads a single `ProductVariety` using its globally unique `ID`. */
  productVarietyByNodeId?: Maybe<ProductVariety>;
  /** Reads a single `RepackStyle` using its globally unique `ID`. */
  repackStyleByNodeId?: Maybe<RepackStyle>;
  /** Reads a single `ShipperProgram` using its globally unique `ID`. */
  shipperProgramByNodeId?: Maybe<ShipperProgram>;
  /** Reads a single `ShipperProgramEntry` using its globally unique `ID`. */
  shipperProgramEntryByNodeId?: Maybe<ShipperProgramEntry>;
  /** Reads a single `ShipperProgramEntryCustomerProgramEntry` using its globally unique `ID`. */
  shipperProgramEntryCustomerProgramEntryByNodeId?: Maybe<ShipperProgramEntryCustomerProgramEntry>;
  /** Reads a single `ShipperProjection` using its globally unique `ID`. */
  shipperProjectionByNodeId?: Maybe<ShipperProjection>;
  /** Reads a single `ShipperProjectionEntry` using its globally unique `ID`. */
  shipperProjectionEntryByNodeId?: Maybe<ShipperProjectionEntry>;
  /** Reads a single `ShipperProjectionProduct` using its globally unique `ID`. */
  shipperProjectionProductByNodeId?: Maybe<ShipperProjectionProduct>;
  /** Reads a single `ShipperProjectionVessel` using its globally unique `ID`. */
  shipperProjectionVesselByNodeId?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `ShipperProjectionVesselInfo` using its globally unique `ID`. */
  shipperProjectionVesselInfoByNodeId?: Maybe<ShipperProjectionVesselInfo>;
  /** Reads a single `Vessel` using its globally unique `ID`. */
  vesselByNodeId?: Maybe<Vessel>;
  /** Reads a single `AgendaItem` using its globally unique `ID`. */
  agendaItemByNodeId?: Maybe<AgendaItem>;
  /** Reads a single `CalendarEvent` using its globally unique `ID`. */
  calendarEventByNodeId?: Maybe<CalendarEvent>;
  /** Reads a single `PriceCategory` using its globally unique `ID`. */
  priceCategoryByNodeId?: Maybe<PriceCategory>;
  /** Reads a single `PriceEntry` using its globally unique `ID`. */
  priceEntryByNodeId?: Maybe<PriceEntry>;
  /** Reads a single `PriceProduct` using its globally unique `ID`. */
  priceProductByNodeId?: Maybe<PriceProduct>;
  /** Reads a single `PriceSize` using its globally unique `ID`. */
  priceSizeByNodeId?: Maybe<PriceSize>;
  /** Reads a single `LoadNumber` using its globally unique `ID`. */
  loadNumberByNodeId?: Maybe<LoadNumber>;
  /** Reads a single `OrderComment` using its globally unique `ID`. */
  orderCommentByNodeId?: Maybe<OrderComment>;
  /** Reads a single `OrderEntry` using its globally unique `ID`. */
  orderEntryByNodeId?: Maybe<OrderEntry>;
  /** Reads a single `OrderEntryItem` using its globally unique `ID`. */
  orderEntryItemByNodeId?: Maybe<OrderEntryItem>;
  /** Reads a single `OrderEntryReviewItem` using its globally unique `ID`. */
  orderEntryReviewItemByNodeId?: Maybe<OrderEntryReviewItem>;
  /** Reads a single `OrderItem` using its globally unique `ID`. */
  orderItemByNodeId?: Maybe<OrderItem>;
  /** Reads a single `OrderMaster` using its globally unique `ID`. */
  orderMasterByNodeId?: Maybe<OrderMaster>;
  /** Reads a single `OrderPallet` using its globally unique `ID`. */
  orderPalletByNodeId?: Maybe<OrderPallet>;
  /** Reads a single `RepackHeader` using its globally unique `ID`. */
  repackHeaderByNodeId?: Maybe<RepackHeader>;
  /** Reads a single `RepackItem` using its globally unique `ID`. */
  repackItemByNodeId?: Maybe<RepackItem>;
  /** Reads a single `RepackQueue` using its globally unique `ID`. */
  repackQueueByNodeId?: Maybe<RepackQueue>;
  /** Reads a single `TruckLoad` using its globally unique `ID`. */
  truckLoadByNodeId?: Maybe<TruckLoad>;
  /** Reads a single `TruckRate` using its globally unique `ID`. */
  truckRateByNodeId?: Maybe<TruckRate>;
  /** Reads a single `TruckRateCustomer` using its globally unique `ID`. */
  truckRateCustomerByNodeId?: Maybe<TruckRateCustomer>;
  /** Reads a single `CheckHeader` using its globally unique `ID`. */
  checkHeaderByNodeId?: Maybe<CheckHeader>;
  /** Reads a single `CustomerPayment` using its globally unique `ID`. */
  customerPaymentByNodeId?: Maybe<CustomerPayment>;
  /** Reads a single `ExpenseHeader` using its globally unique `ID`. */
  expenseHeaderByNodeId?: Maybe<ExpenseHeader>;
  /** Reads a single `ExpenseHeaderReview` using its globally unique `ID`. */
  expenseHeaderReviewByNodeId?: Maybe<ExpenseHeaderReview>;
  /** Reads a single `ExpenseItem` using its globally unique `ID`. */
  expenseItemByNodeId?: Maybe<ExpenseItem>;
  /** Reads a single `InvoiceHeader` using its globally unique `ID`. */
  invoiceHeaderByNodeId?: Maybe<InvoiceHeader>;
  /** Reads a single `InvoiceItem` using its globally unique `ID`. */
  invoiceItemByNodeId?: Maybe<InvoiceItem>;
  /** Reads a single `InvoiceItemHistory` using its globally unique `ID`. */
  invoiceItemHistoryByNodeId?: Maybe<InvoiceItemHistory>;
  /** Reads a single `Unpaid` using its globally unique `ID`. */
  unpaidByNodeId?: Maybe<Unpaid>;
  /** Reads a single `VesselControl` using its globally unique `ID`. */
  vesselControlByNodeId?: Maybe<VesselControl>;
  /** Reads a single `WireRequest` using its globally unique `ID`. */
  wireRequestByNodeId?: Maybe<WireRequest>;
  /** Reads a single `WireRequestAccountOfSaleItem` using its globally unique `ID`. */
  wireRequestAccountOfSaleItemByNodeId?: Maybe<WireRequestAccountOfSaleItem>;
  /** Reads a single `WireRequestMiscItem` using its globally unique `ID`. */
  wireRequestMiscItemByNodeId?: Maybe<WireRequestMiscItem>;
  /** Reads a single `WireRequestOceanFreightItem` using its globally unique `ID`. */
  wireRequestOceanFreightItemByNodeId?: Maybe<WireRequestOceanFreightItem>;
  /** Reads a single `WireRequestShipperAdvanceItem` using its globally unique `ID`. */
  wireRequestShipperAdvanceItemByNodeId?: Maybe<WireRequestShipperAdvanceItem>;
  db2Query: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderNumbersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderNumbersOrderBy>>;
  condition?: Maybe<OrderNumberCondition>;
  filter?: Maybe<OrderNumberFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserBookmarksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserBookmarksOrderBy>>;
  condition?: Maybe<UserBookmarkCondition>;
  filter?: Maybe<UserBookmarkFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
  condition?: Maybe<UserMessageCondition>;
  filter?: Maybe<UserMessageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserRolesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserRolesOrderBy>>;
  condition?: Maybe<UserRoleCondition>;
  filter?: Maybe<UserRoleFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
  condition?: Maybe<ContactGroupCondition>;
  filter?: Maybe<ContactGroupFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
  condition?: Maybe<ContactGroupPersonContactCondition>;
  filter?: Maybe<ContactGroupPersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCountriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CountriesOrderBy>>;
  condition?: Maybe<CountryCondition>;
  filter?: Maybe<CountryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
  condition?: Maybe<CustomerPersonContactCondition>;
  filter?: Maybe<CustomerPersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerVolumeDiscountsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerVolumeDiscountsOrderBy>>;
  condition?: Maybe<CustomerVolumeDiscountCondition>;
  filter?: Maybe<CustomerVolumeDiscountFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShippersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperAdvancesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
  condition?: Maybe<ShipperAdvanceCondition>;
  filter?: Maybe<ShipperAdvanceFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
  condition?: Maybe<ShipperPersonContactCondition>;
  filter?: Maybe<ShipperPersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVendorsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VendorsOrderBy>>;
  condition?: Maybe<VendorCondition>;
  filter?: Maybe<VendorFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVendorPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VendorPersonContactsOrderBy>>;
  condition?: Maybe<VendorPersonContactCondition>;
  filter?: Maybe<VendorPersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
  condition?: Maybe<WarehouseCondition>;
  filter?: Maybe<WarehouseFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousePersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
  condition?: Maybe<WarehousePersonContactCondition>;
  filter?: Maybe<WarehousePersonContactFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
  condition?: Maybe<ChileDepartureInspectionPalletCondition>;
  filter?: Maybe<ChileDepartureInspectionPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
  condition?: Maybe<PeruDepartureInspectionCondition>;
  filter?: Maybe<PeruDepartureInspectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
  condition?: Maybe<PeruDepartureInspectionPalletCondition>;
  filter?: Maybe<PeruDepartureInspectionPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaApplePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
  condition?: Maybe<PsaApplePalletCondition>;
  filter?: Maybe<PsaApplePalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalPicturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
  condition?: Maybe<PsaArrivalPictureCondition>;
  filter?: Maybe<PsaArrivalPictureFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalReportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
  condition?: Maybe<PsaArrivalReportCondition>;
  filter?: Maybe<PsaArrivalReportFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCherryPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
  condition?: Maybe<PsaCherryPalletCondition>;
  filter?: Maybe<PsaCherryPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCitrusPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
  condition?: Maybe<PsaCitrusPalletCondition>;
  filter?: Maybe<PsaCitrusPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaGrapePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
  condition?: Maybe<PsaGrapePalletCondition>;
  filter?: Maybe<PsaGrapePalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaLemonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
  condition?: Maybe<PsaLemonPalletCondition>;
  filter?: Maybe<PsaLemonPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPearPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
  condition?: Maybe<PsaPearPalletCondition>;
  filter?: Maybe<PsaPearPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPersimmonPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
  condition?: Maybe<PsaPersimmonPalletCondition>;
  filter?: Maybe<PsaPersimmonPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPomegranatePalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
  condition?: Maybe<PsaPomegranatePalletCondition>;
  filter?: Maybe<PsaPomegranatePalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaStoneFruitPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
  condition?: Maybe<PsaStoneFruitPalletCondition>;
  filter?: Maybe<PsaStoneFruitPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonCategoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonCategoriesOrderBy>>;
  condition?: Maybe<CommonCategoryCondition>;
  filter?: Maybe<CommonCategoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypePackMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
  condition?: Maybe<CommonPackTypePackMasterCondition>;
  filter?: Maybe<CommonPackTypePackMasterFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypeTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypeTagsOrderBy>>;
  condition?: Maybe<CommonPackTypeTagCondition>;
  filter?: Maybe<CommonPackTypeTagFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeProductSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
  condition?: Maybe<CommonSizeProductSizeCondition>;
  filter?: Maybe<CommonSizeProductSizeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizeTagsOrderBy>>;
  condition?: Maybe<CommonSizeTagCondition>;
  filter?: Maybe<CommonSizeTagFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesProductSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesProductSpeciesCondition>;
  filter?: Maybe<CommonSpeciesProductSpeciesFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesTagsOrderBy>>;
  condition?: Maybe<CommonSpeciesTagCondition>;
  filter?: Maybe<CommonSpeciesTagFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyProductVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyProductVarietyCondition>;
  filter?: Maybe<CommonVarietyProductVarietyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietyTagsOrderBy>>;
  condition?: Maybe<CommonVarietyTagCondition>;
  filter?: Maybe<CommonVarietyTagFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryContainersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContainersOrderBy>>;
  condition?: Maybe<ContainerCondition>;
  filter?: Maybe<ContainerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryContainerTreatmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContainerTreatmentsOrderBy>>;
  condition?: Maybe<ContainerTreatmentCondition>;
  filter?: Maybe<ContainerTreatmentFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
  condition?: Maybe<CustomerProgramCondition>;
  filter?: Maybe<CustomerProgramFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramEntriesOrderBy>>;
  condition?: Maybe<CustomerProgramEntryCondition>;
  filter?: Maybe<CustomerProgramEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInventoryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
  condition?: Maybe<InventoryItemCondition>;
  filter?: Maybe<InventoryItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmospheresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
  condition?: Maybe<PackAtmosphereCondition>;
  filter?: Maybe<PackAtmosphereFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStylesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
  condition?: Maybe<PackBoxStyleCondition>;
  filter?: Maybe<PackBoxStyleFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
  condition?: Maybe<PackBoxTypeCondition>;
  filter?: Maybe<PackBoxTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
  condition?: Maybe<PackDestinationCondition>;
  filter?: Maybe<PackDestinationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
  condition?: Maybe<PackGradeCondition>;
  filter?: Maybe<PackGradeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
  condition?: Maybe<PackHoldCondition>;
  filter?: Maybe<PackHoldFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
  condition?: Maybe<PackLabelCondition>;
  filter?: Maybe<PackLabelFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
  condition?: Maybe<PackLinerCondition>;
  filter?: Maybe<PackLinerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
  condition?: Maybe<PackMasterCondition>;
  filter?: Maybe<PackMasterFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
  condition?: Maybe<PackOutCondition>;
  filter?: Maybe<PackOutFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
  condition?: Maybe<PackPalletTypeCondition>;
  filter?: Maybe<PackPalletTypeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
  condition?: Maybe<PackProductionCondition>;
  filter?: Maybe<PackProductionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
  condition?: Maybe<PackSpecialCondition>;
  filter?: Maybe<PackSpecialFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStylesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
  condition?: Maybe<PackStyleCondition>;
  filter?: Maybe<PackStyleFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
  condition?: Maybe<PackTreeRipeCondition>;
  filter?: Maybe<PackTreeRipeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PalletsOrderBy>>;
  condition?: Maybe<PalletCondition>;
  filter?: Maybe<PalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
  condition?: Maybe<PalletSectionCondition>;
  filter?: Maybe<PalletSectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
  condition?: Maybe<ProductMasterCondition>;
  filter?: Maybe<ProductMasterFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
  condition?: Maybe<ProductSizeCondition>;
  filter?: Maybe<ProductSizeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSpeciesesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
  condition?: Maybe<ProductSpeciesCondition>;
  filter?: Maybe<ProductSpeciesFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductVarietiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
  condition?: Maybe<ProductVarietyCondition>;
  filter?: Maybe<ProductVarietyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackStylesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<RepackStylesOrderBy>>;
  condition?: Maybe<RepackStyleCondition>;
  filter?: Maybe<RepackStyleFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramEntryCustomerProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCustomerProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselInfosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VesselsOrderBy>>;
  condition?: Maybe<VesselCondition>;
  filter?: Maybe<VesselFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAgendaItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
  condition?: Maybe<AgendaItemCondition>;
  filter?: Maybe<AgendaItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCalendarEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
  condition?: Maybe<CalendarEventCondition>;
  filter?: Maybe<CalendarEventFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceCategoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
  condition?: Maybe<PriceCategoryCondition>;
  filter?: Maybe<PriceCategoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
  condition?: Maybe<PriceEntryCondition>;
  filter?: Maybe<PriceEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
  condition?: Maybe<PriceProductCondition>;
  filter?: Maybe<PriceProductFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceSizesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
  condition?: Maybe<PriceSizeCondition>;
  filter?: Maybe<PriceSizeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLoadNumbersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LoadNumbersOrderBy>>;
  condition?: Maybe<LoadNumberCondition>;
  filter?: Maybe<LoadNumberFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderCommentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderCommentsOrderBy>>;
  condition?: Maybe<OrderCommentCondition>;
  filter?: Maybe<OrderCommentFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderEntriesOrderBy>>;
  condition?: Maybe<OrderEntryCondition>;
  filter?: Maybe<OrderEntryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderEntryItemsOrderBy>>;
  condition?: Maybe<OrderEntryItemCondition>;
  filter?: Maybe<OrderEntryItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryReviewItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderEntryReviewItemsOrderBy>>;
  condition?: Maybe<OrderEntryReviewItemCondition>;
  filter?: Maybe<OrderEntryReviewItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderItemsOrderBy>>;
  condition?: Maybe<OrderItemCondition>;
  filter?: Maybe<OrderItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderMastersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderMastersOrderBy>>;
  condition?: Maybe<OrderMasterCondition>;
  filter?: Maybe<OrderMasterFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrderPalletsOrderBy>>;
  condition?: Maybe<OrderPalletCondition>;
  filter?: Maybe<OrderPalletFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<RepackHeadersOrderBy>>;
  condition?: Maybe<RepackHeaderCondition>;
  filter?: Maybe<RepackHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<RepackItemsOrderBy>>;
  condition?: Maybe<RepackItemCondition>;
  filter?: Maybe<RepackItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackQueuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<RepackQueuesOrderBy>>;
  condition?: Maybe<RepackQueueCondition>;
  filter?: Maybe<RepackQueueFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckLoadsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TruckLoadsOrderBy>>;
  condition?: Maybe<TruckLoadCondition>;
  filter?: Maybe<TruckLoadFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckRatesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TruckRatesOrderBy>>;
  condition?: Maybe<TruckRateCondition>;
  filter?: Maybe<TruckRateFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckRateCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TruckRateCustomersOrderBy>>;
  condition?: Maybe<TruckRateCustomerCondition>;
  filter?: Maybe<TruckRateCustomerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCheckHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CheckHeadersOrderBy>>;
  condition?: Maybe<CheckHeaderCondition>;
  filter?: Maybe<CheckHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerPaymentsOrderBy>>;
  condition?: Maybe<CustomerPaymentCondition>;
  filter?: Maybe<CustomerPaymentFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpenseHeadersOrderBy>>;
  condition?: Maybe<ExpenseHeaderCondition>;
  filter?: Maybe<ExpenseHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeaderReviewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpenseHeaderReviewsOrderBy>>;
  condition?: Maybe<ExpenseHeaderReviewCondition>;
  filter?: Maybe<ExpenseHeaderReviewFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpenseItemsOrderBy>>;
  condition?: Maybe<ExpenseItemCondition>;
  filter?: Maybe<ExpenseItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoiceHeadersOrderBy>>;
  condition?: Maybe<InvoiceHeaderCondition>;
  filter?: Maybe<InvoiceHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoiceItemsOrderBy>>;
  condition?: Maybe<InvoiceItemCondition>;
  filter?: Maybe<InvoiceItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceItemHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoiceItemHistoriesOrderBy>>;
  condition?: Maybe<InvoiceItemHistoryCondition>;
  filter?: Maybe<InvoiceItemHistoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUnpaidsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UnpaidsOrderBy>>;
  condition?: Maybe<UnpaidCondition>;
  filter?: Maybe<UnpaidFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselControlsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VesselControlsOrderBy>>;
  condition?: Maybe<VesselControlCondition>;
  filter?: Maybe<VesselControlFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestsOrderBy>>;
  condition?: Maybe<WireRequestCondition>;
  filter?: Maybe<WireRequestFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestAccountOfSaleItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestAccountOfSaleItemsOrderBy>>;
  condition?: Maybe<WireRequestAccountOfSaleItemCondition>;
  filter?: Maybe<WireRequestAccountOfSaleItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestMiscItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestMiscItemsOrderBy>>;
  condition?: Maybe<WireRequestMiscItemCondition>;
  filter?: Maybe<WireRequestMiscItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestOceanFreightItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestOceanFreightItemsOrderBy>>;
  condition?: Maybe<WireRequestOceanFreightItemCondition>;
  filter?: Maybe<WireRequestOceanFreightItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestShipperAdvanceItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestShipperAdvanceItemsOrderBy>>;
  condition?: Maybe<WireRequestShipperAdvanceItemCondition>;
  filter?: Maybe<WireRequestShipperAdvanceItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderNumberArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByPinArgs = {
  pin: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserBookmarkArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserMessageArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserRoleByUserIdAndRoleNameArgs = {
  userId: Scalars['BigInt'];
  roleName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupPersonContactArgs = {
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountryArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPersonContactArgs = {
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerVolumeDiscountArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonContactArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperAdvanceArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperPersonContactArgs = {
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVendorArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVendorPersonContactArgs = {
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehouseArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousePersonContactArgs = {
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionPalletArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionArgs = {
  containerId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaApplePalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalPictureArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalReportArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCherryPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCitrusPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaGrapePalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaLemonPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPearPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPersimmonPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPomegranatePalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaStoneFruitPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonCategoryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypePackMasterArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypeTagArgs = {
  tagText: Scalars['String'];
  commonPackTypeId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeProductSizeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeTagArgs = {
  tagText: Scalars['String'];
  commonSizeId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesProductSpeciesArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesTagArgs = {
  tagText: Scalars['String'];
  commonSpeciesId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyProductVarietyArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyTagArgs = {
  tagText: Scalars['String'];
  commonVarietyId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContainerArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContainerTreatmentArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerProgramArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerProgramEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInventoryItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmosphereArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmosphereByShipperIdAndMaCodeArgs = {
  shipperId: Scalars['String'];
  maCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStyleArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStyleByShipperIdAndBoxStyleArgs = {
  shipperId: Scalars['String'];
  boxStyle: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypeByShipperIdAndBoxTypeArgs = {
  shipperId: Scalars['String'];
  boxType: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationByShipperIdAndDestinationCodeArgs = {
  shipperId: Scalars['String'];
  destinationCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradeByShipperIdAndGradeCodeArgs = {
  shipperId: Scalars['String'];
  gradeCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldByShipperIdAndHoldCodeArgs = {
  shipperId: Scalars['String'];
  holdCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelByShipperIdAndLabelCodeArgs = {
  shipperId: Scalars['String'];
  labelCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinerArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinerByShipperIdAndLinerCodeArgs = {
  shipperId: Scalars['String'];
  linerCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackMasterArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutByShipperIdAndOutCodeArgs = {
  shipperId: Scalars['String'];
  outCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypeByShipperIdAndPalletTypeArgs = {
  shipperId: Scalars['String'];
  palletType: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionByShipperIdAndProductionCodeArgs = {
  shipperId: Scalars['String'];
  productionCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialByShipperIdAndCustomerCodeArgs = {
  shipperId: Scalars['String'];
  customerCode: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStyleArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStyleByShipperIdAndPackStyleArgs = {
  shipperId: Scalars['String'];
  packStyle: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipeByShipperIdAndTreeRipeArgs = {
  shipperId: Scalars['String'];
  treeRipe: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletSectionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductMasterArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSizeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSpeciesArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductVarietyArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackStyleArgs = {
  id: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramEntryCustomerProgramEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionProductArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselInfoArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgendaItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCalendarEventArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceCategoryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceProductArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceSizeArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLoadNumberArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderCommentArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryReviewItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderMasterArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderPalletArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackQueueArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckLoadArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckRateArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckRateCustomerArgs = {
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCheckHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPaymentArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeaderReviewArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceHeaderArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceItemHistoryArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUnpaidArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselControlArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestAccountOfSaleItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestMiscItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestOceanFreightItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestShipperAdvanceItemArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDistinctValuesArgs = {
  schemaName?: Maybe<Scalars['String']>;
  tableName?: Maybe<Scalars['String']>;
  columnName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerDistinctColumnValuesArgs = {
  columnName?: Maybe<Scalars['String']>;
  conditionName?: Maybe<Scalars['String']>;
  conditionValue?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerDistinctValuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperDistinctValuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVendorDistinctValuesArgs = {
  vendorTypeParam?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehouseDistinctValuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionsArgs = {
  orderBy?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ChileDepartureInspectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderMasterCustomerDistinctValuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNewRepackQueuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVesselControlsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<VesselControlFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeaderReviewsListArgs = {
  vesselCodeParam?: Maybe<Scalars['String']>;
  shipperIdParam?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ExpenseHeaderReviewFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeaderSummaryArgs = {
  vesselCodeParam?: Maybe<Scalars['String']>;
  shipperIdParam?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ExpenseHeaderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseSummaryTruckLoadIdsArgs = {
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<StringFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderNumberByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserBookmarkByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserMessageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContactGroupPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerVolumeDiscountByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperAdvanceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVendorByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVendorPersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehouseByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWarehousePersonContactByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChileDepartureInspectionPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPeruDepartureInspectionPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaApplePalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalPictureByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaArrivalReportByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCherryPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaCitrusPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaGrapePalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaLemonPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPearPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPersimmonPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaPomegranatePalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPsaStoneFruitPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypePackMasterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonPackTypeTagByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeProductSizeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSizeTagByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesProductSpeciesByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonSpeciesTagByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyProductVarietyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCommonVarietyTagByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContainerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContainerTreatmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerProgramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerProgramEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInventoryItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackAtmosphereByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxStyleByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackBoxTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackDestinationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackGradeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackHoldByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLabelByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackLinerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackMasterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackOutByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackPalletTypeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackProductionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackSpecialByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackStyleByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPackTreeRipeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPalletSectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductMasterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSizeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductSpeciesByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductVarietyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackStyleByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProgramEntryCustomerProgramEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionProductByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryShipperProjectionVesselInfoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgendaItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCalendarEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceProductByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPriceSizeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLoadNumberByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderCommentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderEntryReviewItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderMasterByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrderPalletByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRepackQueueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckLoadByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckRateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTruckRateCustomerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCheckHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerPaymentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseHeaderReviewByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceHeaderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceItemHistoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUnpaidByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVesselControlByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestAccountOfSaleItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestMiscItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestOceanFreightItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWireRequestShipperAdvanceItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDb2QueryArgs = {
  input?: Maybe<Db2QueryInput>;
};

export type RepackHeader = Node & {
  __typename?: 'RepackHeader';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  repackCode?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  whBagsOut?: Maybe<Scalars['BigFloat']>;
  whWeightIn?: Maybe<Scalars['BigFloat']>;
  whWeightOut?: Maybe<Scalars['BigFloat']>;
  whBoxesIn?: Maybe<Scalars['BigFloat']>;
  whBoxesOut?: Maybe<Scalars['BigFloat']>;
  repackDate?: Maybe<Scalars['Date']>;
  repackStyleId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  entryUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  boxesIn?: Maybe<Scalars['BigFloat']>;
  boxesOut?: Maybe<Scalars['BigFloat']>;
  count?: Maybe<Scalars['Int']>;
  entryUser?: Maybe<User>;
  /** Reads and enables pagination through a set of `RepackItem`. */
  items: RepackItemsConnection;
  repackQueue?: Maybe<RepackQueue>;
  repackStyle?: Maybe<RepackStyle>;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
  warehouse?: Maybe<Warehouse>;
  weightIn?: Maybe<Scalars['BigFloat']>;
  weightOut?: Maybe<Scalars['BigFloat']>;
};


export type RepackHeaderItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<RepackItemFilter>;
};

/**
 * A condition to be used against `RepackHeader` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RepackHeaderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `repackCode` field. */
  repackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `runNumber` field. */
  runNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `whBagsOut` field. */
  whBagsOut?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `whWeightIn` field. */
  whWeightIn?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `whWeightOut` field. */
  whWeightOut?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `whBoxesIn` field. */
  whBoxesIn?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `whBoxesOut` field. */
  whBoxesOut?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `repackDate` field. */
  repackDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `repackStyleId` field. */
  repackStyleId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `entryUserCode` field. */
  entryUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `RepackHeader` object types. All fields are combined with a logical ‘and.’ */
export type RepackHeaderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `repackCode` field. */
  repackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `runNumber` field. */
  runNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `whBagsOut` field. */
  whBagsOut?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `whWeightIn` field. */
  whWeightIn?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `whWeightOut` field. */
  whWeightOut?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `whBoxesIn` field. */
  whBoxesIn?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `whBoxesOut` field. */
  whBoxesOut?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `repackDate` field. */
  repackDate?: Maybe<DateFilter>;
  /** Filter by the object’s `repackStyleId` field. */
  repackStyleId?: Maybe<StringFilter>;
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `entryUserCode` field. */
  entryUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `boxesIn` field. */
  boxesIn?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxesOut` field. */
  boxesOut?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<IntFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `weightIn` field. */
  weightIn?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `weightOut` field. */
  weightOut?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RepackHeaderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RepackHeaderFilter>>;
  /** Negates the expression. */
  not?: Maybe<RepackHeaderFilter>;
};

/** An input for mutations affecting `RepackHeader` */
export type RepackHeaderInput = {
  id?: Maybe<Scalars['BigInt']>;
  repackCode?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  whBagsOut?: Maybe<Scalars['BigFloat']>;
  whWeightIn?: Maybe<Scalars['BigFloat']>;
  whWeightOut?: Maybe<Scalars['BigFloat']>;
  whBoxesIn?: Maybe<Scalars['BigFloat']>;
  whBoxesOut?: Maybe<Scalars['BigFloat']>;
  repackDate?: Maybe<Scalars['Date']>;
  repackStyleId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  entryUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
};

/** Represents an update to a `RepackHeader`. Fields that are set will be updated. */
export type RepackHeaderPatch = {
  id?: Maybe<Scalars['BigInt']>;
  repackCode?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  whBagsOut?: Maybe<Scalars['BigFloat']>;
  whWeightIn?: Maybe<Scalars['BigFloat']>;
  whWeightOut?: Maybe<Scalars['BigFloat']>;
  whBoxesIn?: Maybe<Scalars['BigFloat']>;
  whBoxesOut?: Maybe<Scalars['BigFloat']>;
  repackDate?: Maybe<Scalars['Date']>;
  repackStyleId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  entryUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
};

/** A connection to a list of `RepackHeader` values. */
export type RepackHeadersConnection = {
  __typename?: 'RepackHeadersConnection';
  /** A list of `RepackHeader` objects. */
  nodes: Array<Maybe<RepackHeader>>;
  /** A list of edges which contains the `RepackHeader` and cursor to aid in pagination. */
  edges: Array<RepackHeadersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RepackHeader` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RepackHeader` edge in the connection. */
export type RepackHeadersEdge = {
  __typename?: 'RepackHeadersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RepackHeader` at the end of the edge. */
  node?: Maybe<RepackHeader>;
};

/** Methods to use when ordering `RepackHeader`. */
export enum RepackHeadersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  RepackCodeAsc = 'REPACK_CODE_ASC',
  RepackCodeDesc = 'REPACK_CODE_DESC',
  RunNumberAsc = 'RUN_NUMBER_ASC',
  RunNumberDesc = 'RUN_NUMBER_DESC',
  WhBagsOutAsc = 'WH_BAGS_OUT_ASC',
  WhBagsOutDesc = 'WH_BAGS_OUT_DESC',
  WhWeightInAsc = 'WH_WEIGHT_IN_ASC',
  WhWeightInDesc = 'WH_WEIGHT_IN_DESC',
  WhWeightOutAsc = 'WH_WEIGHT_OUT_ASC',
  WhWeightOutDesc = 'WH_WEIGHT_OUT_DESC',
  WhBoxesInAsc = 'WH_BOXES_IN_ASC',
  WhBoxesInDesc = 'WH_BOXES_IN_DESC',
  WhBoxesOutAsc = 'WH_BOXES_OUT_ASC',
  WhBoxesOutDesc = 'WH_BOXES_OUT_DESC',
  RepackDateAsc = 'REPACK_DATE_ASC',
  RepackDateDesc = 'REPACK_DATE_DESC',
  RepackStyleIdAsc = 'REPACK_STYLE_ID_ASC',
  RepackStyleIdDesc = 'REPACK_STYLE_ID_DESC',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  EntryUserCodeAsc = 'ENTRY_USER_CODE_ASC',
  EntryUserCodeDesc = 'ENTRY_USER_CODE_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type RepackItem = Node & {
  __typename?: 'RepackItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  repackCode?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  newPalletId?: Maybe<Scalars['String']>;
  boxesIn?: Maybe<Scalars['BigFloat']>;
  boxesOut?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  pallet?: Maybe<Pallet>;
};

/**
 * A condition to be used against `RepackItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RepackItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `repackCode` field. */
  repackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `runNumber` field. */
  runNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletId` field. */
  palletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `newPalletId` field. */
  newPalletId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxesIn` field. */
  boxesIn?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `boxesOut` field. */
  boxesOut?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `RepackItem` object types. All fields are combined with a logical ‘and.’ */
export type RepackItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `repackCode` field. */
  repackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `runNumber` field. */
  runNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `palletId` field. */
  palletId?: Maybe<StringFilter>;
  /** Filter by the object’s `newPalletId` field. */
  newPalletId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxesIn` field. */
  boxesIn?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `boxesOut` field. */
  boxesOut?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RepackItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RepackItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<RepackItemFilter>;
};

/** An input for mutations affecting `RepackItem` */
export type RepackItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  repackCode?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  newPalletId?: Maybe<Scalars['String']>;
  boxesIn?: Maybe<Scalars['BigFloat']>;
  boxesOut?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
};

/** Represents an update to a `RepackItem`. Fields that are set will be updated. */
export type RepackItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  repackCode?: Maybe<Scalars['String']>;
  runNumber?: Maybe<Scalars['String']>;
  palletId?: Maybe<Scalars['String']>;
  newPalletId?: Maybe<Scalars['String']>;
  boxesIn?: Maybe<Scalars['BigFloat']>;
  boxesOut?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
};

/** A connection to a list of `RepackItem` values. */
export type RepackItemsConnection = {
  __typename?: 'RepackItemsConnection';
  /** A list of `RepackItem` objects. */
  nodes: Array<Maybe<RepackItem>>;
  /** A list of edges which contains the `RepackItem` and cursor to aid in pagination. */
  edges: Array<RepackItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RepackItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RepackItem` edge in the connection. */
export type RepackItemsEdge = {
  __typename?: 'RepackItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RepackItem` at the end of the edge. */
  node?: Maybe<RepackItem>;
};

/** Methods to use when ordering `RepackItem`. */
export enum RepackItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  RepackCodeAsc = 'REPACK_CODE_ASC',
  RepackCodeDesc = 'REPACK_CODE_DESC',
  RunNumberAsc = 'RUN_NUMBER_ASC',
  RunNumberDesc = 'RUN_NUMBER_DESC',
  PalletIdAsc = 'PALLET_ID_ASC',
  PalletIdDesc = 'PALLET_ID_DESC',
  NewPalletIdAsc = 'NEW_PALLET_ID_ASC',
  NewPalletIdDesc = 'NEW_PALLET_ID_DESC',
  BoxesInAsc = 'BOXES_IN_ASC',
  BoxesInDesc = 'BOXES_IN_DESC',
  BoxesOutAsc = 'BOXES_OUT_ASC',
  BoxesOutDesc = 'BOXES_OUT_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type RepackQueue = Node & {
  __typename?: 'RepackQueue';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  orderId?: Maybe<Scalars['BigFloat']>;
  repackCode?: Maybe<Scalars['String']>;
  repackDate?: Maybe<Scalars['Date']>;
  repackStyleId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipDate?: Maybe<Scalars['Date']>;
  orderNotes?: Maybe<Scalars['String']>;
  delDate?: Maybe<Scalars['Date']>;
  /** Reads and enables pagination through a set of `InvoiceHeader`. */
  invoices: InvoiceHeadersConnection;
  /** Reads and enables pagination through a set of `OrderMaster`. */
  orders: OrderMastersConnection;
  /** Reads and enables pagination through a set of `RepackHeader`. */
  repackHeaders: RepackHeadersConnection;
  repackStyle?: Maybe<RepackStyle>;
  searchText?: Maybe<Scalars['String']>;
  warehouse?: Maybe<Warehouse>;
};


export type RepackQueueInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceHeaderFilter>;
};


export type RepackQueueOrdersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<OrderMasterFilter>;
};


export type RepackQueueRepackHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<RepackHeaderFilter>;
};

/**
 * A condition to be used against `RepackQueue` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RepackQueueCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `orderId` field. */
  orderId?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `repackCode` field. */
  repackCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `repackDate` field. */
  repackDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `repackStyleId` field. */
  repackStyleId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `shipDate` field. */
  shipDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `orderNotes` field. */
  orderNotes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `delDate` field. */
  delDate?: Maybe<Scalars['Date']>;
};

/** A filter to be used against `RepackQueue` object types. All fields are combined with a logical ‘and.’ */
export type RepackQueueFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `orderId` field. */
  orderId?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `repackCode` field. */
  repackCode?: Maybe<StringFilter>;
  /** Filter by the object’s `repackDate` field. */
  repackDate?: Maybe<DateFilter>;
  /** Filter by the object’s `repackStyleId` field. */
  repackStyleId?: Maybe<StringFilter>;
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `shipDate` field. */
  shipDate?: Maybe<DateFilter>;
  /** Filter by the object’s `orderNotes` field. */
  orderNotes?: Maybe<StringFilter>;
  /** Filter by the object’s `delDate` field. */
  delDate?: Maybe<DateFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RepackQueueFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RepackQueueFilter>>;
  /** Negates the expression. */
  not?: Maybe<RepackQueueFilter>;
};

/** An input for mutations affecting `RepackQueue` */
export type RepackQueueInput = {
  id?: Maybe<Scalars['BigInt']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  repackCode?: Maybe<Scalars['String']>;
  repackDate?: Maybe<Scalars['Date']>;
  repackStyleId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipDate?: Maybe<Scalars['Date']>;
  orderNotes?: Maybe<Scalars['String']>;
  delDate?: Maybe<Scalars['Date']>;
};

/** Represents an update to a `RepackQueue`. Fields that are set will be updated. */
export type RepackQueuePatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  repackCode?: Maybe<Scalars['String']>;
  repackDate?: Maybe<Scalars['Date']>;
  repackStyleId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipDate?: Maybe<Scalars['Date']>;
  orderNotes?: Maybe<Scalars['String']>;
  delDate?: Maybe<Scalars['Date']>;
};

/** A connection to a list of `RepackQueue` values. */
export type RepackQueuesConnection = {
  __typename?: 'RepackQueuesConnection';
  /** A list of `RepackQueue` objects. */
  nodes: Array<Maybe<RepackQueue>>;
  /** A list of edges which contains the `RepackQueue` and cursor to aid in pagination. */
  edges: Array<RepackQueuesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RepackQueue` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RepackQueue` edge in the connection. */
export type RepackQueuesEdge = {
  __typename?: 'RepackQueuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RepackQueue` at the end of the edge. */
  node?: Maybe<RepackQueue>;
};

/** Methods to use when ordering `RepackQueue`. */
export enum RepackQueuesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderIdAsc = 'ORDER_ID_ASC',
  OrderIdDesc = 'ORDER_ID_DESC',
  RepackCodeAsc = 'REPACK_CODE_ASC',
  RepackCodeDesc = 'REPACK_CODE_DESC',
  RepackDateAsc = 'REPACK_DATE_ASC',
  RepackDateDesc = 'REPACK_DATE_DESC',
  RepackStyleIdAsc = 'REPACK_STYLE_ID_ASC',
  RepackStyleIdDesc = 'REPACK_STYLE_ID_DESC',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  ShipDateAsc = 'SHIP_DATE_ASC',
  ShipDateDesc = 'SHIP_DATE_DESC',
  OrderNotesAsc = 'ORDER_NOTES_ASC',
  OrderNotesDesc = 'ORDER_NOTES_DESC',
  DelDateAsc = 'DEL_DATE_ASC',
  DelDateDesc = 'DEL_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type RepackStyle = Node & {
  __typename?: 'RepackStyle';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  styleName?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  lqdCode?: Maybe<Scalars['String']>;
  filmLength?: Maybe<Scalars['BigFloat']>;
  packOutWeight?: Maybe<Scalars['BigFloat']>;
  commonPackType?: Maybe<CommonPackType>;
  searchText?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `RepackStyle` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RepackStyleCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `styleName` field. */
  styleName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `styleDescription` field. */
  styleDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lqdCode` field. */
  lqdCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `filmLength` field. */
  filmLength?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `packOutWeight` field. */
  packOutWeight?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `RepackStyle` object types. All fields are combined with a logical ‘and.’ */
export type RepackStyleFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `styleName` field. */
  styleName?: Maybe<StringFilter>;
  /** Filter by the object’s `styleDescription` field. */
  styleDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `lqdCode` field. */
  lqdCode?: Maybe<StringFilter>;
  /** Filter by the object’s `filmLength` field. */
  filmLength?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `packOutWeight` field. */
  packOutWeight?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<RepackStyleFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<RepackStyleFilter>>;
  /** Negates the expression. */
  not?: Maybe<RepackStyleFilter>;
};

/** An input for mutations affecting `RepackStyle` */
export type RepackStyleInput = {
  id: Scalars['String'];
  styleName?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  lqdCode?: Maybe<Scalars['String']>;
  filmLength?: Maybe<Scalars['BigFloat']>;
  packOutWeight?: Maybe<Scalars['BigFloat']>;
};

/** Represents an update to a `RepackStyle`. Fields that are set will be updated. */
export type RepackStylePatch = {
  id?: Maybe<Scalars['String']>;
  styleName?: Maybe<Scalars['String']>;
  styleDescription?: Maybe<Scalars['String']>;
  lqdCode?: Maybe<Scalars['String']>;
  filmLength?: Maybe<Scalars['BigFloat']>;
  packOutWeight?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `RepackStyle` values. */
export type RepackStylesConnection = {
  __typename?: 'RepackStylesConnection';
  /** A list of `RepackStyle` objects. */
  nodes: Array<Maybe<RepackStyle>>;
  /** A list of edges which contains the `RepackStyle` and cursor to aid in pagination. */
  edges: Array<RepackStylesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RepackStyle` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `RepackStyle` edge in the connection. */
export type RepackStylesEdge = {
  __typename?: 'RepackStylesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RepackStyle` at the end of the edge. */
  node?: Maybe<RepackStyle>;
};

/** Methods to use when ordering `RepackStyle`. */
export enum RepackStylesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  StyleNameAsc = 'STYLE_NAME_ASC',
  StyleNameDesc = 'STYLE_NAME_DESC',
  StyleDescriptionAsc = 'STYLE_DESCRIPTION_ASC',
  StyleDescriptionDesc = 'STYLE_DESCRIPTION_DESC',
  LqdCodeAsc = 'LQD_CODE_ASC',
  LqdCodeDesc = 'LQD_CODE_DESC',
  FilmLengthAsc = 'FILM_LENGTH_ASC',
  FilmLengthDesc = 'FILM_LENGTH_DESC',
  PackOutWeightAsc = 'PACK_OUT_WEIGHT_ASC',
  PackOutWeightDesc = 'PACK_OUT_WEIGHT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ReviewShipperProjectionInput = {
  email: Scalars['String'];
  message: Scalars['String'];
  name: Scalars['String'];
  shipperName: Scalars['String'];
  isApproved: Scalars['Boolean'];
};

export type Shipper = Node & {
  __typename?: 'Shipper';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVessels: ShipperProjectionVesselsConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjections: ShipperProjectionsConnection;
  /** Reads and enables pagination through a set of `ShipperPersonContact`. */
  shipperPersonContacts: ShipperPersonContactsConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfos: ShipperProjectionVesselInfosConnection;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
  /** Reads and enables pagination through a set of `ShipperAdvance`. */
  shipperAdvances: ShipperAdvancesConnection;
  searchText?: Maybe<Scalars['String']>;
  vendor?: Maybe<Vendor>;
  /** Reads and enables pagination through a set of `Vessel`. */
  vesselsByShipperProjectionVesselShipperIdAndVesselId: ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesId: ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyId: ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProjectionProductShipperIdAndCommonSizeId: ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeId: ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProjectionProductShipperIdAndCustomerId: ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByShipperPersonContactShipperIdAndPersonContactId: ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionId: ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselId: ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSpecies`. */
  commonSpeciesByShipperProgramShipperIdAndCommonSpeciesId: ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonVariety`. */
  commonVarietiesByShipperProgramShipperIdAndCommonVarietyId: ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonSize`. */
  commonSizesByShipperProgramShipperIdAndCommonSizeId: ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `CommonPackType`. */
  commonPackTypesByShipperProgramShipperIdAndCommonPackTypeId: ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByShipperProgramShipperIdAndCustomerId: ShipperCustomersByShipperProgramShipperIdAndCustomerIdManyToManyConnection;
  /** Reads and enables pagination through a set of `ProductSpecies`. */
  productSpeciesByShipperAdvanceShipperIdAndSpeciesId: ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdManyToManyConnection;
};


export type ShipperShipperProjectionVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


export type ShipperShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};


export type ShipperShipperProjectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};


export type ShipperShipperPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
  condition?: Maybe<ShipperPersonContactCondition>;
  filter?: Maybe<ShipperPersonContactFilter>;
};


export type ShipperShipperProjectionVesselInfosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};


export type ShipperShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};


export type ShipperShipperAdvancesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
  condition?: Maybe<ShipperAdvanceCondition>;
  filter?: Maybe<ShipperAdvanceFilter>;
};


export type ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VesselsOrderBy>>;
  condition?: Maybe<VesselCondition>;
  filter?: Maybe<VesselFilter>;
};


export type ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};


export type ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};


export type ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


export type ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
  condition?: Maybe<CommonSpeciesCondition>;
  filter?: Maybe<CommonSpeciesFilter>;
};


export type ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
  condition?: Maybe<CommonVarietyCondition>;
  filter?: Maybe<CommonVarietyFilter>;
};


export type ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
  condition?: Maybe<CommonSizeCondition>;
  filter?: Maybe<CommonSizeFilter>;
};


export type ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
  condition?: Maybe<CommonPackTypeCondition>;
  filter?: Maybe<CommonPackTypeFilter>;
};


export type ShipperCustomersByShipperProgramShipperIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


export type ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
  condition?: Maybe<ProductSpeciesCondition>;
  filter?: Maybe<ProductSpeciesFilter>;
};

export type ShipperAdvance = Node & {
  __typename?: 'ShipperAdvance';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  advanceAmount: Scalars['BigFloat'];
  speciesId: Scalars['String'];
  shipperId: Scalars['String'];
  /** Reads a single `ProductSpecies` that is related to this `ShipperAdvance`. */
  species?: Maybe<ProductSpecies>;
  /** Reads a single `Shipper` that is related to this `ShipperAdvance`. */
  shipper?: Maybe<Shipper>;
};

/**
 * A condition to be used against `ShipperAdvance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ShipperAdvanceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `advanceAmount` field. */
  advanceAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `speciesId` field. */
  speciesId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ShipperAdvance` object types. All fields are combined with a logical ‘and.’ */
export type ShipperAdvanceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `advanceAmount` field. */
  advanceAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `speciesId` field. */
  speciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `species` relation. */
  species?: Maybe<ProductSpeciesFilter>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperAdvanceFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperAdvanceFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperAdvanceFilter>;
};

/** An input for mutations affecting `ShipperAdvance` */
export type ShipperAdvanceInput = {
  id?: Maybe<Scalars['BigInt']>;
  advanceAmount: Scalars['BigFloat'];
  speciesId?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  productSpeciesToSpeciesId?: Maybe<ShipperAdvanceSpeciesIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperAdvanceShipperIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperAdvanceNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperAdvance` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperAdvanceNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperAdvance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperAdvanceOnShipperAdvanceForShipperAdvanceShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `shipperAdvance` to look up the row to update. */
export type ShipperAdvanceOnShipperAdvanceForShipperAdvanceShipperIdFkeyUsingShipperAdvancePkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperAdvance` being updated. */
  patch: UpdateShipperAdvanceOnShipperAdvanceForShipperAdvanceShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperAdvanceOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `productSpecies` being updated. */
  patch: ProductSpeciesPatch;
};

/** The fields on `shipperAdvance` to look up the row to update. */
export type ShipperAdvanceOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyUsingShipperAdvancePkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperAdvance` being updated. */
  patch: UpdateShipperAdvanceOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperAdvance`. Fields that are set will be updated. */
export type ShipperAdvancePatch = {
  id?: Maybe<Scalars['BigInt']>;
  advanceAmount?: Maybe<Scalars['BigFloat']>;
  speciesId?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  productSpeciesToSpeciesId?: Maybe<ShipperAdvanceSpeciesIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperAdvanceShipperIdFkeyInput>;
};

/** The fields on `shipperAdvance` to look up the row to connect. */
export type ShipperAdvanceShipperAdvancePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperAdvance` to look up the row to delete. */
export type ShipperAdvanceShipperAdvancePkeyDelete = {
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `shipper` in the `ShipperAdvanceInput` mutation. */
export type ShipperAdvanceShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperAdvanceForShipperAdvanceShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperAdvanceOnShipperAdvanceForShipperAdvanceShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperAdvanceShipperIdFkeyShipperCreateInput>;
};

/** Input for the nested mutation of `shipperAdvance` in the `ShipperInput` mutation. */
export type ShipperAdvanceShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperAdvance` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperAdvanceShipperAdvancePkeyConnect>>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperAdvanceNodeIdConnect>>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperAdvanceShipperAdvancePkeyDelete>>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperAdvanceNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperAdvance` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperAdvanceOnShipperAdvanceForShipperAdvanceShipperIdFkeyUsingShipperAdvancePkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperAdvance` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperAdvanceForShipperAdvanceShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperAdvanceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperAdvanceShipperIdFkeyShipperAdvanceCreateInput>>;
};

/** The `shipperAdvance` to be created by this mutation. */
export type ShipperAdvanceShipperIdFkeyShipperAdvanceCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  advanceAmount: Scalars['BigFloat'];
  speciesId?: Maybe<Scalars['String']>;
  productSpeciesToSpeciesId?: Maybe<ShipperAdvanceSpeciesIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperAdvanceShipperIdFkeyInput>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperAdvanceShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** Input for the nested mutation of `productSpecies` in the `ShipperAdvanceInput` mutation. */
export type ShipperAdvanceSpeciesIdFkeyInput = {
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  connectById?: Maybe<ProductSpeciesProductSpeciesPkeyConnect>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<ProductSpecyNodeIdConnect>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  deleteById?: Maybe<ProductSpeciesProductSpeciesPkeyDelete>;
  /** The primary key(s) for `productSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ProductSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `productSpecies` for the far side of the relationship. */
  updateById?: Maybe<ProductSpeciesOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyUsingProductSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `productSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperAdvanceOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyNodeIdUpdate>;
  /** A `ProductSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperAdvanceSpeciesIdFkeyProductSpeciesCreateInput>;
};

/** Input for the nested mutation of `shipperAdvance` in the `ProductSpeciesInput` mutation. */
export type ShipperAdvanceSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperAdvance` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperAdvanceShipperAdvancePkeyConnect>>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperAdvanceNodeIdConnect>>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperAdvanceShipperAdvancePkeyDelete>>;
  /** The primary key(s) for `shipperAdvance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperAdvanceNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperAdvance` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperAdvanceOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyUsingShipperAdvancePkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperAdvance` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ProductSpeciesOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyNodeIdUpdate>>;
  /** A `ShipperAdvanceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperAdvanceSpeciesIdFkeyShipperAdvanceCreateInput>>;
};

/** The `productSpecies` to be created by this mutation. */
export type ShipperAdvanceSpeciesIdFkeyProductSpeciesCreateInput = {
  id: Scalars['String'];
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** The `shipperAdvance` to be created by this mutation. */
export type ShipperAdvanceSpeciesIdFkeyShipperAdvanceCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  advanceAmount: Scalars['BigFloat'];
  shipperId?: Maybe<Scalars['String']>;
  productSpeciesToSpeciesId?: Maybe<ShipperAdvanceSpeciesIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperAdvanceShipperIdFkeyInput>;
};

/** A connection to a list of `ShipperAdvance` values. */
export type ShipperAdvancesConnection = {
  __typename?: 'ShipperAdvancesConnection';
  /** A list of `ShipperAdvance` objects. */
  nodes: Array<Maybe<ShipperAdvance>>;
  /** A list of edges which contains the `ShipperAdvance` and cursor to aid in pagination. */
  edges: Array<ShipperAdvancesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperAdvance` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperAdvance` edge in the connection. */
export type ShipperAdvancesEdge = {
  __typename?: 'ShipperAdvancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperAdvance` at the end of the edge. */
  node?: Maybe<ShipperAdvance>;
};

/** Methods to use when ordering `ShipperAdvance`. */
export enum ShipperAdvancesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AdvanceAmountAsc = 'ADVANCE_AMOUNT_ASC',
  AdvanceAmountDesc = 'ADVANCE_AMOUNT_DESC',
  SpeciesIdAsc = 'SPECIES_ID_ASC',
  SpeciesIdDesc = 'SPECIES_ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductSpeciesBySpeciesIdIdAsc = 'PRODUCT_SPECIES_BY_SPECIES_ID__ID_ASC',
  ProductSpeciesBySpeciesIdIdDesc = 'PRODUCT_SPECIES_BY_SPECIES_ID__ID_DESC',
  ProductSpeciesBySpeciesIdSpeciesDescriptionAsc = 'PRODUCT_SPECIES_BY_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  ProductSpeciesBySpeciesIdSpeciesDescriptionDesc = 'PRODUCT_SPECIES_BY_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  ProductSpeciesBySpeciesIdSecondaryDescriptionAsc = 'PRODUCT_SPECIES_BY_SPECIES_ID__SECONDARY_DESCRIPTION_ASC',
  ProductSpeciesBySpeciesIdSecondaryDescriptionDesc = 'PRODUCT_SPECIES_BY_SPECIES_ID__SECONDARY_DESCRIPTION_DESC',
  ProductSpeciesBySpeciesIdFdaProductCodeAsc = 'PRODUCT_SPECIES_BY_SPECIES_ID__FDA_PRODUCT_CODE_ASC',
  ProductSpeciesBySpeciesIdFdaProductCodeDesc = 'PRODUCT_SPECIES_BY_SPECIES_ID__FDA_PRODUCT_CODE_DESC',
  ProductSpeciesBySpeciesIdFdaIndustryCodeAsc = 'PRODUCT_SPECIES_BY_SPECIES_ID__FDA_INDUSTRY_CODE_ASC',
  ProductSpeciesBySpeciesIdFdaIndustryCodeDesc = 'PRODUCT_SPECIES_BY_SPECIES_ID__FDA_INDUSTRY_CODE_DESC',
  ProductSpeciesBySpeciesIdDefaultTemperatureAsc = 'PRODUCT_SPECIES_BY_SPECIES_ID__DEFAULT_TEMPERATURE_ASC',
  ProductSpeciesBySpeciesIdDefaultTemperatureDesc = 'PRODUCT_SPECIES_BY_SPECIES_ID__DEFAULT_TEMPERATURE_DESC',
  ShipperByShipperIdIdAsc = 'SHIPPER_BY_SHIPPER_ID__ID_ASC',
  ShipperByShipperIdIdDesc = 'SHIPPER_BY_SHIPPER_ID__ID_DESC',
  ShipperByShipperIdShipperNameAsc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_ASC',
  ShipperByShipperIdShipperNameDesc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_DESC',
  ShipperByShipperIdCountryIdAsc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_ASC',
  ShipperByShipperIdCountryIdDesc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_DESC',
  ShipperByShipperIdGroupIdAsc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_ASC',
  ShipperByShipperIdGroupIdDesc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_DESC',
  ShipperByShipperIdLogoSrcAsc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_ASC',
  ShipperByShipperIdLogoSrcDesc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_DESC',
  ShipperByShipperIdNotesAsc = 'SHIPPER_BY_SHIPPER_ID__NOTES_ASC',
  ShipperByShipperIdNotesDesc = 'SHIPPER_BY_SHIPPER_ID__NOTES_DESC',
  ShipperByShipperIdWebsiteAsc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_ASC',
  ShipperByShipperIdWebsiteDesc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_DESC',
  ShipperByShipperIdSendProjectionRequestAsc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_ASC',
  ShipperByShipperIdSendProjectionRequestDesc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_DESC',
  ShipperByShipperIdProjectionRequestStartDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_ASC',
  ShipperByShipperIdProjectionRequestStartDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_DESC',
  ShipperByShipperIdProjectionRequestEndDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_ASC',
  ShipperByShipperIdProjectionRequestEndDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_DESC',
  ShipperByShipperIdVesselControlDaysUntilDueAsc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  ShipperByShipperIdVesselControlDaysUntilDueDesc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  ShipperByShipperIdPsaShipperIdAsc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_ASC',
  ShipperByShipperIdPsaShipperIdDesc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_DESC',
  ShipperByShipperIdCommissionRateAsc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_ASC',
  ShipperByShipperIdCommissionRateDesc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_DESC'
}

/** A connection to a list of `CommonPackType` values, with data from `ShipperProgram`. */
export type ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonPackTypesByShipperProgramShipperIdAndCommonPackTypeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonPackType` values, with data from `ShipperProjectionProduct`. */
export type ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdManyToManyConnection = {
  __typename?: 'ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdManyToManyConnection';
  /** A list of `CommonPackType` objects. */
  nodes: Array<Maybe<CommonPackType>>;
  /** A list of edges which contains the `CommonPackType`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonPackType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdManyToManyEdge = {
  __typename?: 'ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonPackType` at the end of the edge. */
  node?: Maybe<CommonPackType>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonPackType` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonPackTypesByShipperProjectionProductShipperIdAndCommonPackTypeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProgram`. */
export type ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonSizesByShipperProgramShipperIdAndCommonSizeIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSize` values, with data from `ShipperProjectionProduct`. */
export type ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdManyToManyConnection = {
  __typename?: 'ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdManyToManyConnection';
  /** A list of `CommonSize` objects. */
  nodes: Array<Maybe<CommonSize>>;
  /** A list of edges which contains the `CommonSize`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSize` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdManyToManyEdge = {
  __typename?: 'ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSize` at the end of the edge. */
  node?: Maybe<CommonSize>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSize` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonSizesByShipperProjectionProductShipperIdAndCommonSizeIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProgram`. */
export type ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonSpeciesByShipperProgramShipperIdAndCommonSpeciesIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonSpecies` values, with data from `ShipperProjectionProduct`. */
export type ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdManyToManyConnection = {
  __typename?: 'ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdManyToManyConnection';
  /** A list of `CommonSpecies` objects. */
  nodes: Array<Maybe<CommonSpecies>>;
  /** A list of edges which contains the `CommonSpecies`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdManyToManyEdge = {
  __typename?: 'ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonSpecies` at the end of the edge. */
  node?: Maybe<CommonSpecies>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonSpecies` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonSpeciesByShipperProjectionProductShipperIdAndCommonSpeciesIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProgram`. */
export type ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCommonVarietiesByShipperProgramShipperIdAndCommonVarietyIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `CommonVariety` values, with data from `ShipperProjectionProduct`. */
export type ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdManyToManyConnection = {
  __typename?: 'ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdManyToManyConnection';
  /** A list of `CommonVariety` objects. */
  nodes: Array<Maybe<CommonVariety>>;
  /** A list of edges which contains the `CommonVariety`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CommonVariety` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdManyToManyEdge = {
  __typename?: 'ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CommonVariety` at the end of the edge. */
  node?: Maybe<CommonVariety>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `CommonVariety` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCommonVarietiesByShipperProjectionProductShipperIdAndCommonVarietyIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A condition to be used against `Shipper` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ShipperCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperName` field. */
  shipperName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `logoSrc` field. */
  logoSrc?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `website` field. */
  website?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sendProjectionRequest` field. */
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `projectionRequestStartDate` field. */
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `projectionRequestEndDate` field. */
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `vesselControlDaysUntilDue` field. */
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `psaShipperId` field. */
  psaShipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commissionRate` field. */
  commissionRate?: Maybe<Scalars['BigFloat']>;
};

/** The `country` to be created by this mutation. */
export type ShipperCountryIdFkeyCountryCreateInput = {
  id: Scalars['String'];
  countryName: Scalars['String'];
  cmbId?: Maybe<Scalars['String']>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `country` in the `ShipperInput` mutation. */
export type ShipperCountryIdFkeyInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryCountryPkeyConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryCountryPkeyDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnShipperForShipperCountryIdFkeyUsingCountryPkeyUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperOnShipperForShipperCountryIdFkeyNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperCountryIdFkeyCountryCreateInput>;
};

/** Input for the nested mutation of `shipper` in the `CountryInput` mutation. */
export type ShipperCountryIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipper` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperShipperPkeyConnect>>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperNodeIdConnect>>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperShipperPkeyDelete>>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperOnShipperForShipperCountryIdFkeyUsingShipperPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnShipperForShipperCountryIdFkeyNodeIdUpdate>>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperCountryIdFkeyShipperCreateInput>>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperCountryIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProgram`. */
export type ShipperCustomersByShipperProgramShipperIdAndCustomerIdManyToManyConnection = {
  __typename?: 'ShipperCustomersByShipperProgramShipperIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProgram`, and the cursor to aid in pagination. */
  edges: Array<ShipperCustomersByShipperProgramShipperIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCustomersByShipperProgramShipperIdAndCustomerIdManyToManyEdge = {
  __typename?: 'ShipperCustomersByShipperProgramShipperIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProgram`. */
  shipperPrograms: ShipperProgramsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProgram`. */
export type ShipperCustomersByShipperProgramShipperIdAndCustomerIdManyToManyEdgeShipperProgramsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
  condition?: Maybe<ShipperProgramCondition>;
  filter?: Maybe<ShipperProgramFilter>;
};

/** A connection to a list of `Customer` values, with data from `ShipperProjectionProduct`. */
export type ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdManyToManyConnection = {
  __typename?: 'ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `ShipperProjectionProduct`, and the cursor to aid in pagination. */
  edges: Array<ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdManyToManyEdge = {
  __typename?: 'ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProducts: ShipperProjectionProductsConnection;
};


/** A `Customer` edge in the connection, with data from `ShipperProjectionProduct`. */
export type ShipperCustomersByShipperProjectionProductShipperIdAndCustomerIdManyToManyEdgeShipperProjectionProductsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/** A `String` edge in the connection. */
export type ShipperDistinctValueEdge = {
  __typename?: 'ShipperDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type ShipperDistinctValuesConnection = {
  __typename?: 'ShipperDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ShipperDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A filter to be used against `Shipper` object types. All fields are combined with a logical ‘and.’ */
export type ShipperFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperName` field. */
  shipperName?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<StringFilter>;
  /** Filter by the object’s `logoSrc` field. */
  logoSrc?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `website` field. */
  website?: Maybe<StringFilter>;
  /** Filter by the object’s `sendProjectionRequest` field. */
  sendProjectionRequest?: Maybe<BooleanFilter>;
  /** Filter by the object’s `projectionRequestStartDate` field. */
  projectionRequestStartDate?: Maybe<DateFilter>;
  /** Filter by the object’s `projectionRequestEndDate` field. */
  projectionRequestEndDate?: Maybe<DateFilter>;
  /** Filter by the object’s `vesselControlDaysUntilDue` field. */
  vesselControlDaysUntilDue?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `psaShipperId` field. */
  psaShipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `commissionRate` field. */
  commissionRate?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionVessels` relation. */
  shipperProjectionVessels?: Maybe<ShipperToManyShipperProjectionVesselFilter>;
  /** Some related `shipperProjectionVessels` exist. */
  shipperProjectionVesselsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProjectionProducts` relation. */
  shipperProjectionProducts?: Maybe<ShipperToManyShipperProjectionProductFilter>;
  /** Some related `shipperProjectionProducts` exist. */
  shipperProjectionProductsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProjections` relation. */
  shipperProjections?: Maybe<ShipperToManyShipperProjectionFilter>;
  /** Some related `shipperProjections` exist. */
  shipperProjectionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPersonContacts` relation. */
  shipperPersonContacts?: Maybe<ShipperToManyShipperPersonContactFilter>;
  /** Some related `shipperPersonContacts` exist. */
  shipperPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProjectionVesselInfos` relation. */
  shipperProjectionVesselInfos?: Maybe<ShipperToManyShipperProjectionVesselInfoFilter>;
  /** Some related `shipperProjectionVesselInfos` exist. */
  shipperProjectionVesselInfosExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperPrograms` relation. */
  shipperPrograms?: Maybe<ShipperToManyShipperProgramFilter>;
  /** Some related `shipperPrograms` exist. */
  shipperProgramsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperAdvances` relation. */
  shipperAdvances?: Maybe<ShipperToManyShipperAdvanceFilter>;
  /** Some related `shipperAdvances` exist. */
  shipperAdvancesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** A related `country` exists. */
  countryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperFilter>;
};

/** An input for mutations affecting `Shipper` */
export type ShipperInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipper` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperAdvanceForShipperAdvanceShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperAdvance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperAdvance` being updated. */
  patch: ShipperAdvancePatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperAdvanceForShipperAdvanceShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperAdvanceForShipperAdvanceShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperForShipperCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperForShipperCountryIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperForShipperCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProgramForShipperProgramShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProgramForShipperProgramShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProgramForShipperProgramShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: ShipperProjectionPatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProjectionForShipperProjectionShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperOnShipperProjectionVesselInfoForFkShipperIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVesselInfo` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: ShipperProjectionVesselInfoPatch;
};

/** The fields on `shipper` to look up the row to update. */
export type ShipperOnShipperProjectionVesselInfoForFkShipperIdUsingShipperPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: UpdateShipperOnShipperProjectionVesselInfoForFkShipperIdPatch;
  id: Scalars['String'];
};

/** Represents an update to a `Shipper`. Fields that are set will be updated. */
export type ShipperPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

export type ShipperPersonContact = Node & {
  __typename?: 'ShipperPersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
};

/**
 * A condition to be used against `ShipperPersonContact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ShipperPersonContactCondition = {
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ShipperPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ShipperPersonContactFilter = {
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperPersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperPersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperPersonContactFilter>;
};

/** An input for mutations affecting `ShipperPersonContact` */
export type ShipperPersonContactInput = {
  shipperId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperPersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperPersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The fields on `shipperPersonContact` to look up the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingShipperPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `shipperPersonContact` to look up the row to update. */
export type ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
  patch: UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** Represents an update to a `ShipperPersonContact`. Fields that are set will be updated. */
export type ShipperPersonContactPatch = {
  shipperId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `ShipperPersonContactInput` mutation. */
export type ShipperPersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperPersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** Input for the nested mutation of `shipperPersonContact` in the `PersonContactInput` mutation. */
export type ShipperPersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperPersonContactNodeIdConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyDelete>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyUsingShipperPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `ShipperPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperPersonContactPersonContactIdFkeyShipperPersonContactCreateInput>>;
};

/** The `personContact` to be created by this mutation. */
export type ShipperPersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** The `shipperPersonContact` to be created by this mutation. */
export type ShipperPersonContactPersonContactIdFkeyShipperPersonContactCreateInput = {
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperPersonContactInput` mutation. */
export type ShipperPersonContactShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperPersonContactShipperIdFkeyShipperCreateInput>;
};

/** Input for the nested mutation of `shipperPersonContact` in the `ShipperInput` mutation. */
export type ShipperPersonContactShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperPersonContactNodeIdConnect>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactShipperPersonContactPkeyDelete>>;
  /** The primary key(s) for `shipperPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByShipperIdAndPersonContactId?: Maybe<Array<ShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyUsingShipperPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperPersonContactShipperIdFkeyShipperPersonContactCreateInput>>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperPersonContactShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** The `shipperPersonContact` to be created by this mutation. */
export type ShipperPersonContactShipperIdFkeyShipperPersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** The fields on `shipperPersonContact` to look up the row to connect. */
export type ShipperPersonContactShipperPersonContactPkeyConnect = {
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The fields on `shipperPersonContact` to look up the row to delete. */
export type ShipperPersonContactShipperPersonContactPkeyDelete = {
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** A connection to a list of `PersonContact` values, with data from `ShipperPersonContact`. */
export type ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `ShipperPersonContact`, and the cursor to aid in pagination. */
  edges: Array<ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `ShipperPersonContact`. */
export type ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'ShipperPersonContactsByShipperPersonContactShipperIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A connection to a list of `ShipperPersonContact` values. */
export type ShipperPersonContactsConnection = {
  __typename?: 'ShipperPersonContactsConnection';
  /** A list of `ShipperPersonContact` objects. */
  nodes: Array<Maybe<ShipperPersonContact>>;
  /** A list of edges which contains the `ShipperPersonContact` and cursor to aid in pagination. */
  edges: Array<ShipperPersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperPersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperPersonContact` edge in the connection. */
export type ShipperPersonContactsEdge = {
  __typename?: 'ShipperPersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperPersonContact` at the end of the edge. */
  node?: Maybe<ShipperPersonContact>;
};

/** Methods to use when ordering `ShipperPersonContact`. */
export enum ShipperPersonContactsOrderBy {
  Natural = 'NATURAL',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperByShipperIdIdAsc = 'SHIPPER_BY_SHIPPER_ID__ID_ASC',
  ShipperByShipperIdIdDesc = 'SHIPPER_BY_SHIPPER_ID__ID_DESC',
  ShipperByShipperIdShipperNameAsc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_ASC',
  ShipperByShipperIdShipperNameDesc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_DESC',
  ShipperByShipperIdCountryIdAsc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_ASC',
  ShipperByShipperIdCountryIdDesc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_DESC',
  ShipperByShipperIdGroupIdAsc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_ASC',
  ShipperByShipperIdGroupIdDesc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_DESC',
  ShipperByShipperIdLogoSrcAsc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_ASC',
  ShipperByShipperIdLogoSrcDesc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_DESC',
  ShipperByShipperIdNotesAsc = 'SHIPPER_BY_SHIPPER_ID__NOTES_ASC',
  ShipperByShipperIdNotesDesc = 'SHIPPER_BY_SHIPPER_ID__NOTES_DESC',
  ShipperByShipperIdWebsiteAsc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_ASC',
  ShipperByShipperIdWebsiteDesc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_DESC',
  ShipperByShipperIdSendProjectionRequestAsc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_ASC',
  ShipperByShipperIdSendProjectionRequestDesc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_DESC',
  ShipperByShipperIdProjectionRequestStartDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_ASC',
  ShipperByShipperIdProjectionRequestStartDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_DESC',
  ShipperByShipperIdProjectionRequestEndDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_ASC',
  ShipperByShipperIdProjectionRequestEndDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_DESC',
  ShipperByShipperIdVesselControlDaysUntilDueAsc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  ShipperByShipperIdVesselControlDaysUntilDueDesc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  ShipperByShipperIdPsaShipperIdAsc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_ASC',
  ShipperByShipperIdPsaShipperIdDesc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_DESC',
  ShipperByShipperIdCommissionRateAsc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_ASC',
  ShipperByShipperIdCommissionRateDesc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_DESC',
  PersonContactByPersonContactIdIdAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_ASC',
  PersonContactByPersonContactIdIdDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_DESC',
  PersonContactByPersonContactIdFirstNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_ASC',
  PersonContactByPersonContactIdFirstNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_DESC',
  PersonContactByPersonContactIdLastNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_ASC',
  PersonContactByPersonContactIdLastNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_DESC',
  PersonContactByPersonContactIdIsPrimaryAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_ASC',
  PersonContactByPersonContactIdIsPrimaryDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_DESC',
  PersonContactByPersonContactIdEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_ASC',
  PersonContactByPersonContactIdEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_DESC',
  PersonContactByPersonContactIdSecondaryEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_ASC',
  PersonContactByPersonContactIdSecondaryEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_DESC',
  PersonContactByPersonContactIdHomePhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_ASC',
  PersonContactByPersonContactIdHomePhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_DESC',
  PersonContactByPersonContactIdCellPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_ASC',
  PersonContactByPersonContactIdCellPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_DESC',
  PersonContactByPersonContactIdWorkPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_ASC',
  PersonContactByPersonContactIdWorkPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_DESC',
  PersonContactByPersonContactIdWorkExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_ASC',
  PersonContactByPersonContactIdWorkExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_DESC',
  PersonContactByPersonContactIdImageSrcAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_ASC',
  PersonContactByPersonContactIdImageSrcDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_DESC',
  PersonContactByPersonContactIdIsInternalAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_ASC',
  PersonContactByPersonContactIdIsInternalDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_DESC',
  PersonContactByPersonContactIdRolesAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_ASC',
  PersonContactByPersonContactIdRolesDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_DESC',
  PersonContactByPersonContactIdHomeExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_ASC',
  PersonContactByPersonContactIdHomeExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_DESC',
  PersonContactByPersonContactIdLocationAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_ASC',
  PersonContactByPersonContactIdLocationDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_DESC'
}

/** A connection to a list of `ProductSpecies` values, with data from `ShipperAdvance`. */
export type ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdManyToManyConnection = {
  __typename?: 'ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdManyToManyConnection';
  /** A list of `ProductSpecies` objects. */
  nodes: Array<Maybe<ProductSpecies>>;
  /** A list of edges which contains the `ProductSpecies`, info from the `ShipperAdvance`, and the cursor to aid in pagination. */
  edges: Array<ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductSpecies` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ProductSpecies` edge in the connection, with data from `ShipperAdvance`. */
export type ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdManyToManyEdge = {
  __typename?: 'ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductSpecies` at the end of the edge. */
  node?: Maybe<ProductSpecies>;
  /** Reads and enables pagination through a set of `ShipperAdvance`. */
  shipperAdvancesBySpeciesId: ShipperAdvancesConnection;
};


/** A `ProductSpecies` edge in the connection, with data from `ShipperAdvance`. */
export type ShipperProductSpeciesByShipperAdvanceShipperIdAndSpeciesIdManyToManyEdgeShipperAdvancesBySpeciesIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
  condition?: Maybe<ShipperAdvanceCondition>;
  filter?: Maybe<ShipperAdvanceFilter>;
};

export type ShipperProgram = Node & {
  __typename?: 'ShipperProgram';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Shipper` that is related to this `ShipperProgram`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Customer` that is related to this `ShipperProgram`. */
  customer?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProgramEntry`. */
  shipperProgramEntries: ShipperProgramEntriesConnection;
};


export type ShipperProgramShipperProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryFilter>;
};

/** The `commonPackType` to be created by this mutation. */
export type ShipperProgramCommonPackTypeIdFkeyCommonPackTypeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonPackType` in the `ShipperProgramInput` mutation. */
export type ShipperProgramCommonPackTypeIdFkeyInput = {
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectById?: Maybe<CommonPackTypeCommonPackTypePkeyConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonPackTypeNodeIdConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteById?: Maybe<CommonPackTypeCommonPackTypePkeyDelete>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonPackTypeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateById?: Maybe<CommonPackTypeOnShipperProgramForShipperProgramCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramOnShipperProgramForShipperProgramCommonPackTypeIdFkeyNodeIdUpdate>;
  /** A `CommonPackTypeInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramCommonPackTypeIdFkeyCommonPackTypeCreateInput>;
};

/** Input for the nested mutation of `shipperProgram` in the `CommonPackTypeInput` mutation. */
export type ShipperProgramCommonPackTypeIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramShipperProgramPkeyConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramNodeIdConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramShipperProgramPkeyDelete>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramOnShipperProgramForShipperProgramCommonPackTypeIdFkeyUsingShipperProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonPackTypeOnShipperProgramForShipperProgramCommonPackTypeIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramCommonPackTypeIdFkeyShipperProgramCreateInput>>;
};

/** The `shipperProgram` to be created by this mutation. */
export type ShipperProgramCommonPackTypeIdFkeyShipperProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** The `commonSize` to be created by this mutation. */
export type ShipperProgramCommonSizeIdFkeyCommonSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSize` in the `ShipperProgramInput` mutation. */
export type ShipperProgramCommonSizeIdFkeyInput = {
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectById?: Maybe<CommonSizeCommonSizePkeyConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSizeNodeIdConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteById?: Maybe<CommonSizeCommonSizePkeyDelete>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateById?: Maybe<CommonSizeOnShipperProgramForShipperProgramCommonSizeIdFkeyUsingCommonSizePkeyUpdate>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramOnShipperProgramForShipperProgramCommonSizeIdFkeyNodeIdUpdate>;
  /** A `CommonSizeInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramCommonSizeIdFkeyCommonSizeCreateInput>;
};

/** Input for the nested mutation of `shipperProgram` in the `CommonSizeInput` mutation. */
export type ShipperProgramCommonSizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramShipperProgramPkeyConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramNodeIdConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramShipperProgramPkeyDelete>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramOnShipperProgramForShipperProgramCommonSizeIdFkeyUsingShipperProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSizeOnShipperProgramForShipperProgramCommonSizeIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramCommonSizeIdFkeyShipperProgramCreateInput>>;
};

/** The `shipperProgram` to be created by this mutation. */
export type ShipperProgramCommonSizeIdFkeyShipperProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** The `commonSpecies` to be created by this mutation. */
export type ShipperProgramCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `ShipperProgramInput` mutation. */
export type ShipperProgramCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnShipperProgramForShipperProgramCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramOnShipperProgramForShipperProgramCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `shipperProgram` in the `CommonSpeciesInput` mutation. */
export type ShipperProgramCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramShipperProgramPkeyConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramNodeIdConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramShipperProgramPkeyDelete>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramOnShipperProgramForShipperProgramCommonSpeciesIdFkeyUsingShipperProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnShipperProgramForShipperProgramCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramCommonSpeciesIdFkeyShipperProgramCreateInput>>;
};

/** The `shipperProgram` to be created by this mutation. */
export type ShipperProgramCommonSpeciesIdFkeyShipperProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** The `commonVariety` to be created by this mutation. */
export type ShipperProgramCommonVarietyIdFkeyCommonVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonVariety` in the `ShipperProgramInput` mutation. */
export type ShipperProgramCommonVarietyIdFkeyInput = {
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectById?: Maybe<CommonVarietyCommonVarietyPkeyConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonVarietyNodeIdConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteById?: Maybe<CommonVarietyCommonVarietyPkeyDelete>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonVarietyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateById?: Maybe<CommonVarietyOnShipperProgramForShipperProgramCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramOnShipperProgramForShipperProgramCommonVarietyIdFkeyNodeIdUpdate>;
  /** A `CommonVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramCommonVarietyIdFkeyCommonVarietyCreateInput>;
};

/** Input for the nested mutation of `shipperProgram` in the `CommonVarietyInput` mutation. */
export type ShipperProgramCommonVarietyIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramShipperProgramPkeyConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramNodeIdConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramShipperProgramPkeyDelete>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramOnShipperProgramForShipperProgramCommonVarietyIdFkeyUsingShipperProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonVarietyOnShipperProgramForShipperProgramCommonVarietyIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramCommonVarietyIdFkeyShipperProgramCreateInput>>;
};

/** The `shipperProgram` to be created by this mutation. */
export type ShipperProgramCommonVarietyIdFkeyShipperProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/**
 * A condition to be used against `ShipperProgram` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ShipperProgramCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
};

/** The `customer` to be created by this mutation. */
export type ShipperProgramCustomerIdFkeyCustomerCreateInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customer` in the `ShipperProgramInput` mutation. */
export type ShipperProgramCustomerIdFkeyInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerCustomerPkeyConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerCustomerPkeyDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnShipperProgramForShipperProgramCustomerIdFkeyUsingCustomerPkeyUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramOnShipperProgramForShipperProgramCustomerIdFkeyNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramCustomerIdFkeyCustomerCreateInput>;
};

/** Input for the nested mutation of `shipperProgram` in the `CustomerInput` mutation. */
export type ShipperProgramCustomerIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramShipperProgramPkeyConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramNodeIdConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramShipperProgramPkeyDelete>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramOnShipperProgramForShipperProgramCustomerIdFkeyUsingShipperProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnShipperProgramForShipperProgramCustomerIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramCustomerIdFkeyShipperProgramCreateInput>>;
};

/** The `shipperProgram` to be created by this mutation. */
export type ShipperProgramCustomerIdFkeyShipperProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** A connection to a list of `ShipperProgramEntry` values. */
export type ShipperProgramEntriesConnection = {
  __typename?: 'ShipperProgramEntriesConnection';
  /** A list of `ShipperProgramEntry` objects. */
  nodes: Array<Maybe<ShipperProgramEntry>>;
  /** A list of edges which contains the `ShipperProgramEntry` and cursor to aid in pagination. */
  edges: Array<ShipperProgramEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProgramEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProgramEntry` edge in the connection. */
export type ShipperProgramEntriesEdge = {
  __typename?: 'ShipperProgramEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProgramEntry` at the end of the edge. */
  node?: Maybe<ShipperProgramEntry>;
};

/** Methods to use when ordering `ShipperProgramEntry`. */
export enum ShipperProgramEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  ProgramDateAsc = 'PROGRAM_DATE_ASC',
  ProgramDateDesc = 'PROGRAM_DATE_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  ShipperProgramIdAsc = 'SHIPPER_PROGRAM_ID_ASC',
  ShipperProgramIdDesc = 'SHIPPER_PROGRAM_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperProgramByShipperProgramIdIdAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__ID_ASC',
  ShipperProgramByShipperProgramIdIdDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__ID_DESC',
  ShipperProgramByShipperProgramIdCommonSpeciesIdAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_SPECIES_ID_ASC',
  ShipperProgramByShipperProgramIdCommonSpeciesIdDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_SPECIES_ID_DESC',
  ShipperProgramByShipperProgramIdCommonVarietyIdAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_VARIETY_ID_ASC',
  ShipperProgramByShipperProgramIdCommonVarietyIdDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_VARIETY_ID_DESC',
  ShipperProgramByShipperProgramIdCommonSizeIdAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_SIZE_ID_ASC',
  ShipperProgramByShipperProgramIdCommonSizeIdDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_SIZE_ID_DESC',
  ShipperProgramByShipperProgramIdCommonPackTypeIdAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_PACK_TYPE_ID_ASC',
  ShipperProgramByShipperProgramIdCommonPackTypeIdDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__COMMON_PACK_TYPE_ID_DESC',
  ShipperProgramByShipperProgramIdShipperIdAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__SHIPPER_ID_ASC',
  ShipperProgramByShipperProgramIdShipperIdDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__SHIPPER_ID_DESC',
  ShipperProgramByShipperProgramIdArrivalPortAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__ARRIVAL_PORT_ASC',
  ShipperProgramByShipperProgramIdArrivalPortDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__ARRIVAL_PORT_DESC',
  ShipperProgramByShipperProgramIdPluAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__PLU_ASC',
  ShipperProgramByShipperProgramIdPluDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__PLU_DESC',
  ShipperProgramByShipperProgramIdNotesAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__NOTES_ASC',
  ShipperProgramByShipperProgramIdNotesDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__NOTES_DESC',
  ShipperProgramByShipperProgramIdCustomerIdAsc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__CUSTOMER_ID_ASC',
  ShipperProgramByShipperProgramIdCustomerIdDesc = 'SHIPPER_PROGRAM_BY_SHIPPER_PROGRAM_ID__CUSTOMER_ID_DESC',
  ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryIdCountAsc = 'SHIPPER_PROGRAM_ENTRY_CUSTOMER_PROGRAM_ENTRIES_BY_SHIPPER_PROGRAM_ENTRY_ID__COUNT_ASC',
  ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryIdCountDesc = 'SHIPPER_PROGRAM_ENTRY_CUSTOMER_PROGRAM_ENTRIES_BY_SHIPPER_PROGRAM_ENTRY_ID__COUNT_DESC'
}

export type ShipperProgramEntry = Node & {
  __typename?: 'ShipperProgramEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `ShipperProgram` that is related to this `ShipperProgramEntry`. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** Reads and enables pagination through a set of `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntryCustomerProgramEntries: ShipperProgramEntryCustomerProgramEntriesConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CustomerProgramEntry`. */
  customerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryId: ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdManyToManyConnection;
};


export type ShipperProgramEntryShipperProgramEntryCustomerProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCustomerProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};


export type ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerProgramEntriesOrderBy>>;
  condition?: Maybe<CustomerProgramEntryCondition>;
  filter?: Maybe<CustomerProgramEntryFilter>;
};

/**
 * A condition to be used against `ShipperProgramEntry` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProgramEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `programDate` field. */
  programDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `shipperProgramId` field. */
  shipperProgramId?: Maybe<Scalars['BigInt']>;
};

/** The `customerProgramEntry` to be created by this mutation. */
export type ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyCustomerProgramEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramId?: Maybe<Scalars['BigInt']>;
  isAdWeek?: Maybe<Scalars['Boolean']>;
  customerProgramToCustomerProgramId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customerProgramEntry` in the `ShipperProgramEntryCustomerProgramEntryInput` mutation. */
export type ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInput = {
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  connectById?: Maybe<CustomerProgramEntryCustomerProgramEntryPkeyConnect>;
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerProgramEntryNodeIdConnect>;
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  deleteById?: Maybe<CustomerProgramEntryCustomerProgramEntryPkeyDelete>;
  /** The primary key(s) for `customerProgramEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerProgramEntryNodeIdDelete>;
  /** The primary key(s) and patch data for `customerProgramEntry` for the far side of the relationship. */
  updateById?: Maybe<CustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyUsingCustomerProgramEntryPkeyUpdate>;
  /** The primary key(s) and patch data for `customerProgramEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyNodeIdUpdate>;
  /** A `CustomerProgramEntryInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyCustomerProgramEntryCreateInput>;
};

/** Input for the nested mutation of `shipperProgramEntryCustomerProgramEntry` in the `CustomerProgramEntryInput` mutation. */
export type ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgramEntryCustomerProgramEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryShipperProgramEntryCustomerProgramEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryShipperProgramEntryCustomerProgramEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyUsingShipperProgramEntryCustomerProgramEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramEntryCustomerProgramEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyShipperProgramEntryCustomerProgramEntryCreateInput>>;
};

/** The `shipperProgramEntryCustomerProgramEntry` to be created by this mutation. */
export type ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyShipperProgramEntryCustomerProgramEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramEntryId?: Maybe<Scalars['BigInt']>;
  customerProgramEntryToCustomerProgramEntryId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInput>;
  shipperProgramEntryToShipperProgramEntryId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInput>;
};

/** Input for the nested mutation of `shipperProgramEntry` in the `ShipperProgramEntryCustomerProgramEntryInput` mutation. */
export type ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInput = {
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  connectById?: Maybe<ShipperProgramEntryShipperProgramEntryPkeyConnect>;
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProgramEntryNodeIdConnect>;
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProgramEntryShipperProgramEntryPkeyDelete>;
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProgramEntryNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProgramEntry` for the far side of the relationship. */
  updateById?: Maybe<ShipperProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyUsingShipperProgramEntryPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProgramEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyNodeIdUpdate>;
  /** A `ShipperProgramEntryInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyShipperProgramEntryCreateInput>;
};

/** Input for the nested mutation of `shipperProgramEntryCustomerProgramEntry` in the `ShipperProgramEntryInput` mutation. */
export type ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgramEntryCustomerProgramEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryShipperProgramEntryCustomerProgramEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryShipperProgramEntryCustomerProgramEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyUsingShipperProgramEntryCustomerProgramEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgramEntryCustomerProgramEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramEntryCustomerProgramEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyShipperProgramEntryCustomerProgramEntryCreateInput>>;
};

/** The `shipperProgramEntry` to be created by this mutation. */
export type ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyShipperProgramEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramId?: Maybe<Scalars['BigInt']>;
  shipperProgramToShipperProgramId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInverseInput>;
};

/** The `shipperProgramEntryCustomerProgramEntry` to be created by this mutation. */
export type ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyShipperProgramEntryCustomerProgramEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramEntryId?: Maybe<Scalars['BigInt']>;
  customerProgramEntryToCustomerProgramEntryId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInput>;
  shipperProgramEntryToShipperProgramEntryId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInput>;
};

/** A connection to a list of `CustomerProgramEntry` values, with data from `ShipperProgramEntryCustomerProgramEntry`. */
export type ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdManyToManyConnection = {
  __typename?: 'ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdManyToManyConnection';
  /** A list of `CustomerProgramEntry` objects. */
  nodes: Array<Maybe<CustomerProgramEntry>>;
  /** A list of edges which contains the `CustomerProgramEntry`, info from the `ShipperProgramEntryCustomerProgramEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerProgramEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `CustomerProgramEntry` edge in the connection, with data from `ShipperProgramEntryCustomerProgramEntry`. */
export type ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdManyToManyEdge = {
  __typename?: 'ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerProgramEntry` at the end of the edge. */
  node?: Maybe<CustomerProgramEntry>;
  /** Reads and enables pagination through a set of `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntryCustomerProgramEntries: ShipperProgramEntryCustomerProgramEntriesConnection;
};


/** A `CustomerProgramEntry` edge in the connection, with data from `ShipperProgramEntryCustomerProgramEntry`. */
export type ShipperProgramEntryCustomerProgramEntriesByShipperProgramEntryCustomerProgramEntryShipperProgramEntryIdAndCustomerProgramEntryIdManyToManyEdgeShipperProgramEntryCustomerProgramEntriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
  condition?: Maybe<ShipperProgramEntryCustomerProgramEntryCondition>;
  filter?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};

/** A connection to a list of `ShipperProgramEntryCustomerProgramEntry` values. */
export type ShipperProgramEntryCustomerProgramEntriesConnection = {
  __typename?: 'ShipperProgramEntryCustomerProgramEntriesConnection';
  /** A list of `ShipperProgramEntryCustomerProgramEntry` objects. */
  nodes: Array<Maybe<ShipperProgramEntryCustomerProgramEntry>>;
  /** A list of edges which contains the `ShipperProgramEntryCustomerProgramEntry` and cursor to aid in pagination. */
  edges: Array<ShipperProgramEntryCustomerProgramEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProgramEntryCustomerProgramEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProgramEntryCustomerProgramEntry` edge in the connection. */
export type ShipperProgramEntryCustomerProgramEntriesEdge = {
  __typename?: 'ShipperProgramEntryCustomerProgramEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProgramEntryCustomerProgramEntry` at the end of the edge. */
  node?: Maybe<ShipperProgramEntryCustomerProgramEntry>;
};

/** Methods to use when ordering `ShipperProgramEntryCustomerProgramEntry`. */
export enum ShipperProgramEntryCustomerProgramEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  CustomerProgramEntryIdAsc = 'CUSTOMER_PROGRAM_ENTRY_ID_ASC',
  CustomerProgramEntryIdDesc = 'CUSTOMER_PROGRAM_ENTRY_ID_DESC',
  ShipperProgramEntryIdAsc = 'SHIPPER_PROGRAM_ENTRY_ID_ASC',
  ShipperProgramEntryIdDesc = 'SHIPPER_PROGRAM_ENTRY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerProgramEntryByCustomerProgramEntryIdIdAsc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__ID_ASC',
  CustomerProgramEntryByCustomerProgramEntryIdIdDesc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__ID_DESC',
  CustomerProgramEntryByCustomerProgramEntryIdNotesAsc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__NOTES_ASC',
  CustomerProgramEntryByCustomerProgramEntryIdNotesDesc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__NOTES_DESC',
  CustomerProgramEntryByCustomerProgramEntryIdProgramDateAsc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__PROGRAM_DATE_ASC',
  CustomerProgramEntryByCustomerProgramEntryIdProgramDateDesc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__PROGRAM_DATE_DESC',
  CustomerProgramEntryByCustomerProgramEntryIdPalletCountAsc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__PALLET_COUNT_ASC',
  CustomerProgramEntryByCustomerProgramEntryIdPalletCountDesc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__PALLET_COUNT_DESC',
  CustomerProgramEntryByCustomerProgramEntryIdCustomerProgramIdAsc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__CUSTOMER_PROGRAM_ID_ASC',
  CustomerProgramEntryByCustomerProgramEntryIdCustomerProgramIdDesc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__CUSTOMER_PROGRAM_ID_DESC',
  CustomerProgramEntryByCustomerProgramEntryIdIsAdWeekAsc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__IS_AD_WEEK_ASC',
  CustomerProgramEntryByCustomerProgramEntryIdIsAdWeekDesc = 'CUSTOMER_PROGRAM_ENTRY_BY_CUSTOMER_PROGRAM_ENTRY_ID__IS_AD_WEEK_DESC',
  ShipperProgramEntryByShipperProgramEntryIdIdAsc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__ID_ASC',
  ShipperProgramEntryByShipperProgramEntryIdIdDesc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__ID_DESC',
  ShipperProgramEntryByShipperProgramEntryIdNotesAsc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__NOTES_ASC',
  ShipperProgramEntryByShipperProgramEntryIdNotesDesc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__NOTES_DESC',
  ShipperProgramEntryByShipperProgramEntryIdProgramDateAsc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__PROGRAM_DATE_ASC',
  ShipperProgramEntryByShipperProgramEntryIdProgramDateDesc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__PROGRAM_DATE_DESC',
  ShipperProgramEntryByShipperProgramEntryIdPalletCountAsc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__PALLET_COUNT_ASC',
  ShipperProgramEntryByShipperProgramEntryIdPalletCountDesc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__PALLET_COUNT_DESC',
  ShipperProgramEntryByShipperProgramEntryIdShipperProgramIdAsc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__SHIPPER_PROGRAM_ID_ASC',
  ShipperProgramEntryByShipperProgramEntryIdShipperProgramIdDesc = 'SHIPPER_PROGRAM_ENTRY_BY_SHIPPER_PROGRAM_ENTRY_ID__SHIPPER_PROGRAM_ID_DESC'
}

export type ShipperProgramEntryCustomerProgramEntry = Node & {
  __typename?: 'ShipperProgramEntryCustomerProgramEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramEntryId?: Maybe<Scalars['BigInt']>;
  shipperProgramEntryId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `CustomerProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Reads a single `ShipperProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
};

/**
 * A condition to be used against `ShipperProgramEntryCustomerProgramEntry` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProgramEntryCustomerProgramEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `customerProgramEntryId` field. */
  customerProgramEntryId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperProgramEntryId` field. */
  shipperProgramEntryId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ShipperProgramEntryCustomerProgramEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProgramEntryCustomerProgramEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `customerProgramEntryId` field. */
  customerProgramEntryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperProgramEntryId` field. */
  shipperProgramEntryId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customerProgramEntry` relation. */
  customerProgramEntry?: Maybe<CustomerProgramEntryFilter>;
  /** A related `customerProgramEntry` exists. */
  customerProgramEntryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProgramEntry` relation. */
  shipperProgramEntry?: Maybe<ShipperProgramEntryFilter>;
  /** A related `shipperProgramEntry` exists. */
  shipperProgramEntryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProgramEntryCustomerProgramEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};

/** An input for mutations affecting `ShipperProgramEntryCustomerProgramEntry` */
export type ShipperProgramEntryCustomerProgramEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramEntryId?: Maybe<Scalars['BigInt']>;
  shipperProgramEntryId?: Maybe<Scalars['BigInt']>;
  customerProgramEntryToCustomerProgramEntryId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInput>;
  shipperProgramEntryToShipperProgramEntryId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProgramEntryCustomerProgramEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntryCustomerProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProgramEntryCustomerProgramEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntryCustomerProgramEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerProgramEntry` being updated. */
  patch: CustomerProgramEntryPatch;
};

/** The fields on `shipperProgramEntryCustomerProgramEntry` to look up the row to update. */
export type ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyUsingShipperProgramEntryCustomerProgramEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgramEntryCustomerProgramEntry` being updated. */
  patch: UpdateShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgramEntry` being updated. */
  patch: ShipperProgramEntryPatch;
};

/** The fields on `shipperProgramEntryCustomerProgramEntry` to look up the row to update. */
export type ShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyUsingShipperProgramEntryCustomerProgramEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgramEntryCustomerProgramEntry` being updated. */
  patch: UpdateShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProgramEntryCustomerProgramEntry`. Fields that are set will be updated. */
export type ShipperProgramEntryCustomerProgramEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramEntryId?: Maybe<Scalars['BigInt']>;
  shipperProgramEntryId?: Maybe<Scalars['BigInt']>;
  customerProgramEntryToCustomerProgramEntryId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInput>;
  shipperProgramEntryToShipperProgramEntryId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInput>;
};

/** The fields on `shipperProgramEntryCustomerProgramEntry` to look up the row to connect. */
export type ShipperProgramEntryCustomerProgramEntryShipperProgramEntryCustomerProgramEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProgramEntryCustomerProgramEntry` to look up the row to delete. */
export type ShipperProgramEntryCustomerProgramEntryShipperProgramEntryCustomerProgramEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against `ShipperProgramEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProgramEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `programDate` field. */
  programDate?: Maybe<DateFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `shipperProgramId` field. */
  shipperProgramId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProgramEntryCustomerProgramEntries` relation. */
  shipperProgramEntryCustomerProgramEntries?: Maybe<ShipperProgramEntryToManyShipperProgramEntryCustomerProgramEntryFilter>;
  /** Some related `shipperProgramEntryCustomerProgramEntries` exist. */
  shipperProgramEntryCustomerProgramEntriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipperProgram` relation. */
  shipperProgram?: Maybe<ShipperProgramFilter>;
  /** A related `shipperProgram` exists. */
  shipperProgramExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProgramEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProgramEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProgramEntryFilter>;
};

/** An input for mutations affecting `ShipperProgramEntry` */
export type ShipperProgramEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramId?: Maybe<Scalars['BigInt']>;
  shipperProgramToShipperProgramId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProgramEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProgramEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntryCustomerProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgramEntryCustomerProgramEntry` being updated. */
  patch: ShipperProgramEntryCustomerProgramEntryPatch;
};

/** The fields on `shipperProgramEntry` to look up the row to update. */
export type ShipperProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyUsingShipperProgramEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgramEntry` being updated. */
  patch: UpdateShipperProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramEntryOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** The fields on `shipperProgramEntry` to look up the row to update. */
export type ShipperProgramEntryOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyUsingShipperProgramEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgramEntry` being updated. */
  patch: UpdateShipperProgramEntryOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProgramEntry`. Fields that are set will be updated. */
export type ShipperProgramEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramId?: Maybe<Scalars['BigInt']>;
  shipperProgramToShipperProgramId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInverseInput>;
};

/** The fields on `shipperProgramEntry` to look up the row to connect. */
export type ShipperProgramEntryShipperProgramEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProgramEntry` to look up the row to delete. */
export type ShipperProgramEntryShipperProgramEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `shipperProgram` in the `ShipperProgramEntryInput` mutation. */
export type ShipperProgramEntryShipperProgramIdFkeyInput = {
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectById?: Maybe<ShipperProgramShipperProgramPkeyConnect>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProgramNodeIdConnect>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProgramShipperProgramPkeyDelete>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProgramNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateById?: Maybe<ShipperProgramOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyUsingShipperProgramPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramEntryOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyNodeIdUpdate>;
  /** A `ShipperProgramInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramEntryShipperProgramIdFkeyShipperProgramCreateInput>;
};

/** Input for the nested mutation of `shipperProgramEntry` in the `ShipperProgramInput` mutation. */
export type ShipperProgramEntryShipperProgramIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgramEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramEntryShipperProgramEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramEntryShipperProgramEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProgramEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgramEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramEntryOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyUsingShipperProgramEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgramEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProgramOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramEntryShipperProgramIdFkeyShipperProgramEntryCreateInput>>;
};

/** The `shipperProgram` to be created by this mutation. */
export type ShipperProgramEntryShipperProgramIdFkeyShipperProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** The `shipperProgramEntry` to be created by this mutation. */
export type ShipperProgramEntryShipperProgramIdFkeyShipperProgramEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramToShipperProgramId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInverseInput>;
};

/** A filter to be used against many `ShipperProgramEntryCustomerProgramEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProgramEntryToManyShipperProgramEntryCustomerProgramEntryFilter = {
  /** Every related `ShipperProgramEntryCustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
  /** Some related `ShipperProgramEntryCustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
  /** No related `ShipperProgramEntryCustomerProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramEntryCustomerProgramEntryFilter>;
};

/** A filter to be used against `ShipperProgram` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProgramFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProgramEntries` relation. */
  shipperProgramEntries?: Maybe<ShipperProgramToManyShipperProgramEntryFilter>;
  /** Some related `shipperProgramEntries` exist. */
  shipperProgramEntriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** A related `commonSpecies` exists. */
  commonSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonVariety` relation. */
  commonVariety?: Maybe<CommonVarietyFilter>;
  /** A related `commonVariety` exists. */
  commonVarietyExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSize` relation. */
  commonSize?: Maybe<CommonSizeFilter>;
  /** A related `commonSize` exists. */
  commonSizeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonPackType` relation. */
  commonPackType?: Maybe<CommonPackTypeFilter>;
  /** A related `commonPackType` exists. */
  commonPackTypeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** A related `customer` exists. */
  customerExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProgramFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProgramFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProgramFilter>;
};

/** An input for mutations affecting `ShipperProgram` */
export type ShipperProgramInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProgramNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProgramNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProgram` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProgramEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProgramEntry` being updated. */
  patch: ShipperProgramEntryPatch;
};

/** The fields on `shipperProgram` to look up the row to update. */
export type ShipperProgramOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyUsingShipperProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: UpdateShipperProgramOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** The fields on `shipperProgram` to look up the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonPackTypeIdFkeyUsingShipperProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: UpdateShipperProgramOnShipperProgramForShipperProgramCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: CommonSizePatch;
};

/** The fields on `shipperProgram` to look up the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonSizeIdFkeyUsingShipperProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: UpdateShipperProgramOnShipperProgramForShipperProgramCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `shipperProgram` to look up the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonSpeciesIdFkeyUsingShipperProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: UpdateShipperProgramOnShipperProgramForShipperProgramCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** The fields on `shipperProgram` to look up the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCommonVarietyIdFkeyUsingShipperProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: UpdateShipperProgramOnShipperProgramForShipperProgramCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The fields on `shipperProgram` to look up the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramCustomerIdFkeyUsingShipperProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: UpdateShipperProgramOnShipperProgramForShipperProgramCustomerIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `shipperProgram` to look up the row to update. */
export type ShipperProgramOnShipperProgramForShipperProgramShipperIdFkeyUsingShipperProgramPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProgram` being updated. */
  patch: UpdateShipperProgramOnShipperProgramForShipperProgramShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProgram`. Fields that are set will be updated. */
export type ShipperProgramPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperProgramInput` mutation. */
export type ShipperProgramShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProgramForShipperProgramShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProgramOnShipperProgramForShipperProgramShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProgramShipperIdFkeyShipperCreateInput>;
};

/** Input for the nested mutation of `shipperProgram` in the `ShipperInput` mutation. */
export type ShipperProgramShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProgram` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProgramShipperProgramPkeyConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProgramNodeIdConnect>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProgramShipperProgramPkeyDelete>>;
  /** The primary key(s) for `shipperProgram` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProgramNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProgramOnShipperProgramForShipperProgramShipperIdFkeyUsingShipperProgramPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProgram` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProgramForShipperProgramShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperProgramInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProgramShipperIdFkeyShipperProgramCreateInput>>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperProgramShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** The `shipperProgram` to be created by this mutation. */
export type ShipperProgramShipperIdFkeyShipperProgramCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** The fields on `shipperProgram` to look up the row to connect. */
export type ShipperProgramShipperProgramPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProgram` to look up the row to delete. */
export type ShipperProgramShipperProgramPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against many `ShipperProgramEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProgramToManyShipperProgramEntryFilter = {
  /** Every related `ShipperProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramEntryFilter>;
  /** Some related `ShipperProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramEntryFilter>;
  /** No related `ShipperProgramEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramEntryFilter>;
};

/** A connection to a list of `ShipperProgram` values. */
export type ShipperProgramsConnection = {
  __typename?: 'ShipperProgramsConnection';
  /** A list of `ShipperProgram` objects. */
  nodes: Array<Maybe<ShipperProgram>>;
  /** A list of edges which contains the `ShipperProgram` and cursor to aid in pagination. */
  edges: Array<ShipperProgramsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProgram` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProgram` edge in the connection. */
export type ShipperProgramsEdge = {
  __typename?: 'ShipperProgramsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProgram` at the end of the edge. */
  node?: Maybe<ShipperProgram>;
};

/** Methods to use when ordering `ShipperProgram`. */
export enum ShipperProgramsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  CommonVarietyIdAsc = 'COMMON_VARIETY_ID_ASC',
  CommonVarietyIdDesc = 'COMMON_VARIETY_ID_DESC',
  CommonSizeIdAsc = 'COMMON_SIZE_ID_ASC',
  CommonSizeIdDesc = 'COMMON_SIZE_ID_DESC',
  CommonPackTypeIdAsc = 'COMMON_PACK_TYPE_ID_ASC',
  CommonPackTypeIdDesc = 'COMMON_PACK_TYPE_ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  ArrivalPortAsc = 'ARRIVAL_PORT_ASC',
  ArrivalPortDesc = 'ARRIVAL_PORT_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC',
  CommonVarietyByCommonVarietyIdIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_ASC',
  CommonVarietyByCommonVarietyIdIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_DESC',
  CommonVarietyByCommonVarietyIdVarietyNameAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_ASC',
  CommonVarietyByCommonVarietyIdVarietyNameDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_DESC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_ASC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_DESC',
  CommonVarietyByCommonVarietyIdUiColorAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_ASC',
  CommonVarietyByCommonVarietyIdUiColorDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_DESC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_ASC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_DESC',
  CommonVarietyByCommonVarietyIdProductVarietyIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_ASC',
  CommonVarietyByCommonVarietyIdProductVarietyIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_DESC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSizeByCommonSizeIdIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_ASC',
  CommonSizeByCommonSizeIdIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_DESC',
  CommonSizeByCommonSizeIdSizeNameAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_ASC',
  CommonSizeByCommonSizeIdSizeNameDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_DESC',
  CommonSizeByCommonSizeIdSizeDescriptionAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_ASC',
  CommonSizeByCommonSizeIdSizeDescriptionDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_DESC',
  CommonSizeByCommonSizeIdCommonSpeciesIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_ASC',
  CommonSizeByCommonSizeIdCommonSpeciesIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_DESC',
  CommonSizeByCommonSizeIdProductSizeIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_ASC',
  CommonSizeByCommonSizeIdProductSizeIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_DESC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_ASC',
  CommonPackTypeByCommonPackTypeIdIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_DESC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_ASC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_ASC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_DESC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdPalletWeightAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_ASC',
  CommonPackTypeByCommonPackTypeIdPalletWeightDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_DESC',
  CommonPackTypeByCommonPackTypeIdBoxCountAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_ASC',
  CommonPackTypeByCommonPackTypeIdBoxCountDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_DESC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_ASC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_DESC',
  ShipperByShipperIdIdAsc = 'SHIPPER_BY_SHIPPER_ID__ID_ASC',
  ShipperByShipperIdIdDesc = 'SHIPPER_BY_SHIPPER_ID__ID_DESC',
  ShipperByShipperIdShipperNameAsc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_ASC',
  ShipperByShipperIdShipperNameDesc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_DESC',
  ShipperByShipperIdCountryIdAsc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_ASC',
  ShipperByShipperIdCountryIdDesc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_DESC',
  ShipperByShipperIdGroupIdAsc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_ASC',
  ShipperByShipperIdGroupIdDesc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_DESC',
  ShipperByShipperIdLogoSrcAsc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_ASC',
  ShipperByShipperIdLogoSrcDesc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_DESC',
  ShipperByShipperIdNotesAsc = 'SHIPPER_BY_SHIPPER_ID__NOTES_ASC',
  ShipperByShipperIdNotesDesc = 'SHIPPER_BY_SHIPPER_ID__NOTES_DESC',
  ShipperByShipperIdWebsiteAsc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_ASC',
  ShipperByShipperIdWebsiteDesc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_DESC',
  ShipperByShipperIdSendProjectionRequestAsc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_ASC',
  ShipperByShipperIdSendProjectionRequestDesc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_DESC',
  ShipperByShipperIdProjectionRequestStartDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_ASC',
  ShipperByShipperIdProjectionRequestStartDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_DESC',
  ShipperByShipperIdProjectionRequestEndDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_ASC',
  ShipperByShipperIdProjectionRequestEndDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_DESC',
  ShipperByShipperIdVesselControlDaysUntilDueAsc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  ShipperByShipperIdVesselControlDaysUntilDueDesc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  ShipperByShipperIdPsaShipperIdAsc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_ASC',
  ShipperByShipperIdPsaShipperIdDesc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_DESC',
  ShipperByShipperIdCommissionRateAsc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_ASC',
  ShipperByShipperIdCommissionRateDesc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCustomerNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_ASC',
  CustomerByCustomerIdCustomerNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_DESC',
  CustomerByCustomerIdAddress_1Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_ASC',
  CustomerByCustomerIdAddress_1Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_DESC',
  CustomerByCustomerIdAddress_2Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_ASC',
  CustomerByCustomerIdAddress_2Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_DESC',
  CustomerByCustomerIdCityAsc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_ASC',
  CustomerByCustomerIdCityDesc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_DESC',
  CustomerByCustomerIdPostalStateAsc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_ASC',
  CustomerByCustomerIdPostalStateDesc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_DESC',
  CustomerByCustomerIdZipCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_ASC',
  CustomerByCustomerIdZipCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_DESC',
  CustomerByCustomerIdCountryIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_ASC',
  CustomerByCustomerIdCountryIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerByCustomerIdLogoSrcAsc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_ASC',
  CustomerByCustomerIdLogoSrcDesc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_DESC',
  CustomerByCustomerIdNotesAsc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_ASC',
  CustomerByCustomerIdNotesDesc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_DESC',
  CustomerByCustomerIdWebsiteAsc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_ASC',
  CustomerByCustomerIdWebsiteDesc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_DESC',
  CustomerByCustomerIdActiveAsc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_ASC',
  CustomerByCustomerIdActiveDesc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_DESC',
  CustomerByCustomerIdSalesUserCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_ASC',
  CustomerByCustomerIdSalesUserCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_DESC',
  ShipperProgramEntriesByShipperProgramIdCountAsc = 'SHIPPER_PROGRAM_ENTRIES_BY_SHIPPER_PROGRAM_ID__COUNT_ASC',
  ShipperProgramEntriesByShipperProgramIdCountDesc = 'SHIPPER_PROGRAM_ENTRIES_BY_SHIPPER_PROGRAM_ID__COUNT_DESC'
}

export type ShipperProjection = Node & {
  __typename?: 'ShipperProjection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  submittedAt?: Maybe<Scalars['Datetime']>;
  shipperComments?: Maybe<Scalars['String']>;
  jvComments?: Maybe<Scalars['String']>;
  approvedAt?: Maybe<Scalars['Datetime']>;
  rejectedAt?: Maybe<Scalars['Datetime']>;
  shipperId?: Maybe<Scalars['String']>;
  reviewStatus?: Maybe<Scalars['Int']>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfosByProjectionId: ShipperProjectionVesselInfosConnection;
  searchText?: Maybe<Scalars['String']>;
  totalPallets?: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselId: ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionVesselInfoProjectionIdAndShipperId: ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdManyToManyConnection;
};


export type ShipperProjectionShipperProjectionVesselInfosByProjectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};


export type ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


export type ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};

/**
 * A condition to be used against `ShipperProjection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `submittedAt` field. */
  submittedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `shipperComments` field. */
  shipperComments?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `jvComments` field. */
  jvComments?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `approvedAt` field. */
  approvedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `rejectedAt` field. */
  rejectedAt?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `reviewStatus` field. */
  reviewStatus?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `ShipperProjectionEntry` values. */
export type ShipperProjectionEntriesConnection = {
  __typename?: 'ShipperProjectionEntriesConnection';
  /** A list of `ShipperProjectionEntry` objects. */
  nodes: Array<Maybe<ShipperProjectionEntry>>;
  /** A list of edges which contains the `ShipperProjectionEntry` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionEntriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionEntry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionEntry` edge in the connection. */
export type ShipperProjectionEntriesEdge = {
  __typename?: 'ShipperProjectionEntriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionEntry` at the end of the edge. */
  node?: Maybe<ShipperProjectionEntry>;
};

/** Methods to use when ordering `ShipperProjectionEntry`. */
export enum ShipperProjectionEntriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  VesselInfoIdAsc = 'VESSEL_INFO_ID_ASC',
  VesselInfoIdDesc = 'VESSEL_INFO_ID_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdIdAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__ID_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdIdDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__ID_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdVesselNameAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__VESSEL_NAME_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdVesselNameDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__VESSEL_NAME_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdDepartureDateAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__DEPARTURE_DATE_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdDepartureDateDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__DEPARTURE_DATE_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdArrivalDateAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__ARRIVAL_DATE_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdArrivalDateDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__ARRIVAL_DATE_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdArrivalPortAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__ARRIVAL_PORT_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdArrivalPortDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__ARRIVAL_PORT_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdVesselStatusAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__VESSEL_STATUS_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdVesselStatusDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__VESSEL_STATUS_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdProjectionIdAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__PROJECTION_ID_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdProjectionIdDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__PROJECTION_ID_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdVesselIdAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__VESSEL_ID_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdVesselIdDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__VESSEL_ID_DESC',
  ShipperProjectionVesselInfoByVesselInfoIdShipperIdAsc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__SHIPPER_ID_ASC',
  ShipperProjectionVesselInfoByVesselInfoIdShipperIdDesc = 'SHIPPER_PROJECTION_VESSEL_INFO_BY_VESSEL_INFO_ID__SHIPPER_ID_DESC',
  ShipperProjectionProductByProductIdIdAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__ID_ASC',
  ShipperProjectionProductByProductIdIdDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__ID_DESC',
  ShipperProjectionProductByProductIdSpeciesAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__SPECIES_ASC',
  ShipperProjectionProductByProductIdSpeciesDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__SPECIES_DESC',
  ShipperProjectionProductByProductIdVarietyAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__VARIETY_ASC',
  ShipperProjectionProductByProductIdVarietyDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__VARIETY_DESC',
  ShipperProjectionProductByProductIdSizeAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__SIZE_ASC',
  ShipperProjectionProductByProductIdSizeDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__SIZE_DESC',
  ShipperProjectionProductByProductIdPackTypeAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__PACK_TYPE_ASC',
  ShipperProjectionProductByProductIdPackTypeDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__PACK_TYPE_DESC',
  ShipperProjectionProductByProductIdPluAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__PLU_ASC',
  ShipperProjectionProductByProductIdPluDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__PLU_DESC',
  ShipperProjectionProductByProductIdShipperIdAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__SHIPPER_ID_ASC',
  ShipperProjectionProductByProductIdShipperIdDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__SHIPPER_ID_DESC',
  ShipperProjectionProductByProductIdCommonSpeciesIdAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_SPECIES_ID_ASC',
  ShipperProjectionProductByProductIdCommonSpeciesIdDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_SPECIES_ID_DESC',
  ShipperProjectionProductByProductIdCommonVarietyIdAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_VARIETY_ID_ASC',
  ShipperProjectionProductByProductIdCommonVarietyIdDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_VARIETY_ID_DESC',
  ShipperProjectionProductByProductIdCommonSizeIdAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_SIZE_ID_ASC',
  ShipperProjectionProductByProductIdCommonSizeIdDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_SIZE_ID_DESC',
  ShipperProjectionProductByProductIdCommonPackTypeIdAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_PACK_TYPE_ID_ASC',
  ShipperProjectionProductByProductIdCommonPackTypeIdDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__COMMON_PACK_TYPE_ID_DESC',
  ShipperProjectionProductByProductIdCustomerIdAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__CUSTOMER_ID_ASC',
  ShipperProjectionProductByProductIdCustomerIdDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__CUSTOMER_ID_DESC',
  ShipperProjectionProductByProductIdCustomerValueAsc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__CUSTOMER_VALUE_ASC',
  ShipperProjectionProductByProductIdCustomerValueDesc = 'SHIPPER_PROJECTION_PRODUCT_BY_PRODUCT_ID__CUSTOMER_VALUE_DESC'
}

export type ShipperProjectionEntry = Node & {
  __typename?: 'ShipperProjectionEntry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselInfoId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `ShipperProjectionVesselInfo` that is related to this `ShipperProjectionEntry`. */
  vesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
};

/**
 * A condition to be used against `ShipperProjectionEntry` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionEntryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `vesselInfoId` field. */
  vesselInfoId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ShipperProjectionEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionEntryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `vesselInfoId` field. */
  vesselInfoId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselInfo` relation. */
  vesselInfo?: Maybe<ShipperProjectionVesselInfoFilter>;
  /** A related `vesselInfo` exists. */
  vesselInfoExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `product` relation. */
  product?: Maybe<ShipperProjectionProductFilter>;
  /** A related `product` exists. */
  productExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionEntryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionEntryFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionEntryFilter>;
};

/** An input for mutations affecting `ShipperProjectionEntry` */
export type ShipperProjectionEntryInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselInfoId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselInfoToVesselInfoId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionEntryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionEntryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** The fields on `shipperProjectionEntry` to look up the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVesselInfo` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: ShipperProjectionVesselInfoPatch;
};

/** The fields on `shipperProjectionEntry` to look up the row to update. */
export type ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyUsingShipperProjectionEntryPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProjectionEntry`. Fields that are set will be updated. */
export type ShipperProjectionEntryPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselInfoId?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselInfoToVesselInfoId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `ShipperProjectionEntryInput` mutation. */
export type ShipperProjectionEntryProductIdFkeyInput = {
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<ShipperProjectionProductShipperProjectionProductPkeyConnect>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProjectionProductNodeIdConnect>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProjectionProductShipperProjectionProductPkeyDelete>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProjectionProductNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionProductPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionEntryProductIdFkeyShipperProjectionProductCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionEntry` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionEntryProductIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionEntryProductIdFkeyShipperProjectionEntryCreateInput>>;
};

/** The `shipperProjectionEntry` to be created by this mutation. */
export type ShipperProjectionEntryProductIdFkeyShipperProjectionEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselInfoId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselInfoToVesselInfoId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionEntryProductIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The fields on `shipperProjectionEntry` to look up the row to connect. */
export type ShipperProjectionEntryShipperProjectionEntryPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProjectionEntry` to look up the row to delete. */
export type ShipperProjectionEntryShipperProjectionEntryPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `shipperProjectionVesselInfo` in the `ShipperProjectionEntryInput` mutation. */
export type ShipperProjectionEntryVesselInfoIdFkeyInput = {
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectById?: Maybe<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyConnect>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProjectionVesselInfoNodeIdConnect>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyDelete>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProjectionVesselInfoNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateById?: Maybe<ShipperProjectionVesselInfoOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyUsingShipperProjectionVesselInfoPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyNodeIdUpdate>;
  /** A `ShipperProjectionVesselInfoInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyShipperProjectionVesselInfoCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionEntry` in the `ShipperProjectionVesselInfoInput` mutation. */
export type ShipperProjectionEntryVesselInfoIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionEntry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionEntryShipperProjectionEntryPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionEntry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionEntryNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyUsingShipperProjectionEntryPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionEntry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProjectionVesselInfoOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionEntryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionEntryVesselInfoIdFkeyShipperProjectionEntryCreateInput>>;
};

/** The `shipperProjectionEntry` to be created by this mutation. */
export type ShipperProjectionEntryVesselInfoIdFkeyShipperProjectionEntryCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselInfoToVesselInfoId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
};

/** The `shipperProjectionVesselInfo` to be created by this mutation. */
export type ShipperProjectionEntryVesselInfoIdFkeyShipperProjectionVesselInfoCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** A filter to be used against `ShipperProjection` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `submittedAt` field. */
  submittedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `shipperComments` field. */
  shipperComments?: Maybe<StringFilter>;
  /** Filter by the object’s `jvComments` field. */
  jvComments?: Maybe<StringFilter>;
  /** Filter by the object’s `approvedAt` field. */
  approvedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `rejectedAt` field. */
  rejectedAt?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `reviewStatus` field. */
  reviewStatus?: Maybe<IntFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `totalPallets` field. */
  totalPallets?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperProjectionVesselInfosByProjectionId` relation. */
  shipperProjectionVesselInfosByProjectionId?: Maybe<ShipperProjectionToManyShipperProjectionVesselInfoFilter>;
  /** Some related `shipperProjectionVesselInfosByProjectionId` exist. */
  shipperProjectionVesselInfosByProjectionIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionFilter>;
};

/** An input for mutations affecting `ShipperProjection` */
export type ShipperProjectionInput = {
  id?: Maybe<Scalars['BigInt']>;
  submittedAt?: Maybe<Scalars['Datetime']>;
  shipperComments?: Maybe<Scalars['String']>;
  jvComments?: Maybe<Scalars['String']>;
  approvedAt?: Maybe<Scalars['Datetime']>;
  rejectedAt?: Maybe<Scalars['Datetime']>;
  shipperId?: Maybe<Scalars['String']>;
  reviewStatus?: Maybe<Scalars['Int']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `shipperProjection` to look up the row to update. */
export type ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperProjectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: UpdateShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVesselInfo` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: ShipperProjectionVesselInfoPatch;
};

/** The fields on `shipperProjection` to look up the row to update. */
export type ShipperProjectionOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyUsingShipperProjectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: UpdateShipperProjectionOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProjection`. Fields that are set will be updated. */
export type ShipperProjectionPatch = {
  id?: Maybe<Scalars['BigInt']>;
  submittedAt?: Maybe<Scalars['Datetime']>;
  shipperComments?: Maybe<Scalars['String']>;
  jvComments?: Maybe<Scalars['String']>;
  approvedAt?: Maybe<Scalars['Datetime']>;
  rejectedAt?: Maybe<Scalars['Datetime']>;
  shipperId?: Maybe<Scalars['String']>;
  reviewStatus?: Maybe<Scalars['Int']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInverseInput>;
};

export type ShipperProjectionProduct = Node & {
  __typename?: 'ShipperProjectionProduct';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProjectionProduct`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProjectionProduct`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProjectionProduct`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProjectionProduct`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `ShipperProjectionProduct`. */
  customer?: Maybe<Customer>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByProductId: ShipperProjectionEntriesConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoId: ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdManyToManyConnection;
};


export type ShipperProjectionProductShipperProjectionEntriesByProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};


export type ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** The `commonPackType` to be created by this mutation. */
export type ShipperProjectionProductCommonPackTypeIdFkeyCommonPackTypeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonPackType` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionProductCommonPackTypeIdFkeyInput = {
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectById?: Maybe<CommonPackTypeCommonPackTypePkeyConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonPackTypeNodeIdConnect>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteById?: Maybe<CommonPackTypeCommonPackTypePkeyDelete>;
  /** The primary key(s) for `commonPackType` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonPackTypeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateById?: Maybe<CommonPackTypeOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyUsingCommonPackTypePkeyUpdate>;
  /** The primary key(s) and patch data for `commonPackType` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyNodeIdUpdate>;
  /** A `CommonPackTypeInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyCommonPackTypeCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `CommonPackTypeInput` mutation. */
export type ShipperProjectionProductCommonPackTypeIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyUsingShipperProjectionProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonPackTypeOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionProductCommonPackTypeIdFkeyShipperProjectionProductCreateInput>>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionProductCommonPackTypeIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The `commonSize` to be created by this mutation. */
export type ShipperProjectionProductCommonSizeIdFkeyCommonSizeCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSize` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionProductCommonSizeIdFkeyInput = {
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectById?: Maybe<CommonSizeCommonSizePkeyConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSizeNodeIdConnect>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteById?: Maybe<CommonSizeCommonSizePkeyDelete>;
  /** The primary key(s) for `commonSize` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSizeNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateById?: Maybe<CommonSizeOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyUsingCommonSizePkeyUpdate>;
  /** The primary key(s) and patch data for `commonSize` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyNodeIdUpdate>;
  /** A `CommonSizeInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionProductCommonSizeIdFkeyCommonSizeCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `CommonSizeInput` mutation. */
export type ShipperProjectionProductCommonSizeIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyUsingShipperProjectionProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSizeOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionProductCommonSizeIdFkeyShipperProjectionProductCreateInput>>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionProductCommonSizeIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The `commonSpecies` to be created by this mutation. */
export type ShipperProjectionProductCommonSpeciesIdFkeyCommonSpeciesCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonSpecies` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionProductCommonSpeciesIdFkeyInput = {
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectById?: Maybe<CommonSpeciesCommonSpeciesPkeyConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonSpecyNodeIdConnect>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteById?: Maybe<CommonSpeciesCommonSpeciesPkeyDelete>;
  /** The primary key(s) for `commonSpecies` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonSpecyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateById?: Maybe<CommonSpeciesOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyUsingCommonSpeciesPkeyUpdate>;
  /** The primary key(s) and patch data for `commonSpecies` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyNodeIdUpdate>;
  /** A `CommonSpeciesInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyCommonSpeciesCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `CommonSpeciesInput` mutation. */
export type ShipperProjectionProductCommonSpeciesIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyUsingShipperProjectionProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonSpeciesOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionProductCommonSpeciesIdFkeyShipperProjectionProductCreateInput>>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionProductCommonSpeciesIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The `commonVariety` to be created by this mutation. */
export type ShipperProjectionProductCommonVarietyIdFkeyCommonVarietyCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `commonVariety` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionProductCommonVarietyIdFkeyInput = {
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectById?: Maybe<CommonVarietyCommonVarietyPkeyConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  connectByNodeId?: Maybe<CommonVarietyNodeIdConnect>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteById?: Maybe<CommonVarietyCommonVarietyPkeyDelete>;
  /** The primary key(s) for `commonVariety` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CommonVarietyNodeIdDelete>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateById?: Maybe<CommonVarietyOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyUsingCommonVarietyPkeyUpdate>;
  /** The primary key(s) and patch data for `commonVariety` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyNodeIdUpdate>;
  /** A `CommonVarietyInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyCommonVarietyCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `CommonVarietyInput` mutation. */
export type ShipperProjectionProductCommonVarietyIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyUsingShipperProjectionProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CommonVarietyOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionProductCommonVarietyIdFkeyShipperProjectionProductCreateInput>>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionProductCommonVarietyIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/**
 * A condition to be used against `ShipperProjectionProduct` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionProductCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `species` field. */
  species?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `variety` field. */
  variety?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `size` field. */
  size?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `packType` field. */
  packType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `plu` field. */
  plu?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `customerValue` field. */
  customerValue?: Maybe<Scalars['String']>;
};

/** The `customer` to be created by this mutation. */
export type ShipperProjectionProductCustomerIdFkeyCustomerCreateInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customer` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionProductCustomerIdFkeyInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerCustomerPkeyConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerCustomerPkeyDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyUsingCustomerPkeyUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionProductCustomerIdFkeyCustomerCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `CustomerInput` mutation. */
export type ShipperProjectionProductCustomerIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyUsingShipperProjectionProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionProductCustomerIdFkeyShipperProjectionProductCreateInput>>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionProductCustomerIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** A filter to be used against `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionProductFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `species` field. */
  species?: Maybe<StringFilter>;
  /** Filter by the object’s `variety` field. */
  variety?: Maybe<StringFilter>;
  /** Filter by the object’s `size` field. */
  size?: Maybe<StringFilter>;
  /** Filter by the object’s `packType` field. */
  packType?: Maybe<StringFilter>;
  /** Filter by the object’s `plu` field. */
  plu?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `commonSpeciesId` field. */
  commonSpeciesId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonVarietyId` field. */
  commonVarietyId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonSizeId` field. */
  commonSizeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `commonPackTypeId` field. */
  commonPackTypeId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `customerValue` field. */
  customerValue?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionEntriesByProductId` relation. */
  shipperProjectionEntriesByProductId?: Maybe<ShipperProjectionProductToManyShipperProjectionEntryFilter>;
  /** Some related `shipperProjectionEntriesByProductId` exist. */
  shipperProjectionEntriesByProductIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSpecies` relation. */
  commonSpecies?: Maybe<CommonSpeciesFilter>;
  /** A related `commonSpecies` exists. */
  commonSpeciesExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonVariety` relation. */
  commonVariety?: Maybe<CommonVarietyFilter>;
  /** A related `commonVariety` exists. */
  commonVarietyExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonSize` relation. */
  commonSize?: Maybe<CommonSizeFilter>;
  /** A related `commonSize` exists. */
  commonSizeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `commonPackType` relation. */
  commonPackType?: Maybe<CommonPackTypeFilter>;
  /** A related `commonPackType` exists. */
  commonPackTypeExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** A related `customer` exists. */
  customerExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionProductFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionProductFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionProductFilter>;
};

/** An input for mutations affecting `ShipperProjectionProduct` */
export type ShipperProjectionProductInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionProductNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionProductNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjectionProduct` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonPackType` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSize` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSize` being updated. */
  patch: CommonSizePatch;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonSpecies` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `commonVariety` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `commonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `shipperProjectionProduct` to look up the row to update. */
export type ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperProjectionProductPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
  patch: UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProjectionProduct`. Fields that are set will be updated. */
export type ShipperProjectionProductPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperProjectionProductInput` mutation. */
export type ShipperProjectionProductShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionProductShipperIdFkeyShipperCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionProduct` in the `ShipperInput` mutation. */
export type ShipperProjectionProductShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionProduct` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionProductShipperProjectionProductPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionProduct` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionProductNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyUsingShipperProjectionProductPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionProduct` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionProductInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionProductShipperIdFkeyShipperProjectionProductCreateInput>>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperProjectionProductShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** The `shipperProjectionProduct` to be created by this mutation. */
export type ShipperProjectionProductShipperIdFkeyShipperProjectionProductCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** The fields on `shipperProjectionProduct` to look up the row to connect. */
export type ShipperProjectionProductShipperProjectionProductPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProjectionProduct` to look up the row to delete. */
export type ShipperProjectionProductShipperProjectionProductPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `ShipperProjectionVesselInfo` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdManyToManyConnection = {
  __typename?: 'ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdManyToManyConnection';
  /** A list of `ShipperProjectionVesselInfo` objects. */
  nodes: Array<Maybe<ShipperProjectionVesselInfo>>;
  /** A list of edges which contains the `ShipperProjectionVesselInfo`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVesselInfo` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionVesselInfo` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdManyToManyEdge = {
  __typename?: 'ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVesselInfo` at the end of the edge. */
  node?: Maybe<ShipperProjectionVesselInfo>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByVesselInfoId: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjectionVesselInfo` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionProductShipperProjectionVesselInfosByShipperProjectionEntryProductIdAndVesselInfoIdManyToManyEdgeShipperProjectionEntriesByVesselInfoIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** A filter to be used against many `ShipperProjectionEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionProductToManyShipperProjectionEntryFilter = {
  /** Every related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionEntryFilter>;
  /** Some related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionEntryFilter>;
  /** No related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionEntryFilter>;
};

/** A connection to a list of `ShipperProjectionProduct` values. */
export type ShipperProjectionProductsConnection = {
  __typename?: 'ShipperProjectionProductsConnection';
  /** A list of `ShipperProjectionProduct` objects. */
  nodes: Array<Maybe<ShipperProjectionProduct>>;
  /** A list of edges which contains the `ShipperProjectionProduct` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionProductsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionProduct` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionProduct` edge in the connection. */
export type ShipperProjectionProductsEdge = {
  __typename?: 'ShipperProjectionProductsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionProduct` at the end of the edge. */
  node?: Maybe<ShipperProjectionProduct>;
};

/** Methods to use when ordering `ShipperProjectionProduct`. */
export enum ShipperProjectionProductsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SpeciesAsc = 'SPECIES_ASC',
  SpeciesDesc = 'SPECIES_DESC',
  VarietyAsc = 'VARIETY_ASC',
  VarietyDesc = 'VARIETY_DESC',
  SizeAsc = 'SIZE_ASC',
  SizeDesc = 'SIZE_DESC',
  PackTypeAsc = 'PACK_TYPE_ASC',
  PackTypeDesc = 'PACK_TYPE_DESC',
  PluAsc = 'PLU_ASC',
  PluDesc = 'PLU_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  CommonSpeciesIdAsc = 'COMMON_SPECIES_ID_ASC',
  CommonSpeciesIdDesc = 'COMMON_SPECIES_ID_DESC',
  CommonVarietyIdAsc = 'COMMON_VARIETY_ID_ASC',
  CommonVarietyIdDesc = 'COMMON_VARIETY_ID_DESC',
  CommonSizeIdAsc = 'COMMON_SIZE_ID_ASC',
  CommonSizeIdDesc = 'COMMON_SIZE_ID_DESC',
  CommonPackTypeIdAsc = 'COMMON_PACK_TYPE_ID_ASC',
  CommonPackTypeIdDesc = 'COMMON_PACK_TYPE_ID_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  CustomerValueAsc = 'CUSTOMER_VALUE_ASC',
  CustomerValueDesc = 'CUSTOMER_VALUE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperByShipperIdIdAsc = 'SHIPPER_BY_SHIPPER_ID__ID_ASC',
  ShipperByShipperIdIdDesc = 'SHIPPER_BY_SHIPPER_ID__ID_DESC',
  ShipperByShipperIdShipperNameAsc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_ASC',
  ShipperByShipperIdShipperNameDesc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_DESC',
  ShipperByShipperIdCountryIdAsc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_ASC',
  ShipperByShipperIdCountryIdDesc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_DESC',
  ShipperByShipperIdGroupIdAsc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_ASC',
  ShipperByShipperIdGroupIdDesc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_DESC',
  ShipperByShipperIdLogoSrcAsc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_ASC',
  ShipperByShipperIdLogoSrcDesc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_DESC',
  ShipperByShipperIdNotesAsc = 'SHIPPER_BY_SHIPPER_ID__NOTES_ASC',
  ShipperByShipperIdNotesDesc = 'SHIPPER_BY_SHIPPER_ID__NOTES_DESC',
  ShipperByShipperIdWebsiteAsc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_ASC',
  ShipperByShipperIdWebsiteDesc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_DESC',
  ShipperByShipperIdSendProjectionRequestAsc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_ASC',
  ShipperByShipperIdSendProjectionRequestDesc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_DESC',
  ShipperByShipperIdProjectionRequestStartDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_ASC',
  ShipperByShipperIdProjectionRequestStartDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_DESC',
  ShipperByShipperIdProjectionRequestEndDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_ASC',
  ShipperByShipperIdProjectionRequestEndDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_DESC',
  ShipperByShipperIdVesselControlDaysUntilDueAsc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  ShipperByShipperIdVesselControlDaysUntilDueDesc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  ShipperByShipperIdPsaShipperIdAsc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_ASC',
  ShipperByShipperIdPsaShipperIdDesc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_DESC',
  ShipperByShipperIdCommissionRateAsc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_ASC',
  ShipperByShipperIdCommissionRateDesc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_DESC',
  CommonSpeciesByCommonSpeciesIdIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_ASC',
  CommonSpeciesByCommonSpeciesIdIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__ID_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesNameDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_NAME_DESC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_ASC',
  CommonSpeciesByCommonSpeciesIdSpeciesDescriptionDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__SPECIES_DESCRIPTION_DESC',
  CommonSpeciesByCommonSpeciesIdUiColorAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_ASC',
  CommonSpeciesByCommonSpeciesIdUiColorDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__UI_COLOR_DESC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_ASC',
  CommonSpeciesByCommonSpeciesIdCommonCategoryIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__COMMON_CATEGORY_ID_DESC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_ASC',
  CommonSpeciesByCommonSpeciesIdProductSpeciesIdDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PRODUCT_SPECIES_ID_DESC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSpeciesByCommonSpeciesIdDefaultInvSortKeyDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSpeciesByCommonSpeciesIdPalletWeightAsc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_ASC',
  CommonSpeciesByCommonSpeciesIdPalletWeightDesc = 'COMMON_SPECIES_BY_COMMON_SPECIES_ID__PALLET_WEIGHT_DESC',
  CommonVarietyByCommonVarietyIdIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_ASC',
  CommonVarietyByCommonVarietyIdIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__ID_DESC',
  CommonVarietyByCommonVarietyIdVarietyNameAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_ASC',
  CommonVarietyByCommonVarietyIdVarietyNameDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_NAME_DESC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_ASC',
  CommonVarietyByCommonVarietyIdVarietyDescriptionDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__VARIETY_DESCRIPTION_DESC',
  CommonVarietyByCommonVarietyIdUiColorAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_ASC',
  CommonVarietyByCommonVarietyIdUiColorDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__UI_COLOR_DESC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_ASC',
  CommonVarietyByCommonVarietyIdCommonSpeciesIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__COMMON_SPECIES_ID_DESC',
  CommonVarietyByCommonVarietyIdProductVarietyIdAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_ASC',
  CommonVarietyByCommonVarietyIdProductVarietyIdDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__PRODUCT_VARIETY_ID_DESC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyAsc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonVarietyByCommonVarietyIdDefaultInvSortKeyDesc = 'COMMON_VARIETY_BY_COMMON_VARIETY_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonSizeByCommonSizeIdIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_ASC',
  CommonSizeByCommonSizeIdIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__ID_DESC',
  CommonSizeByCommonSizeIdSizeNameAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_ASC',
  CommonSizeByCommonSizeIdSizeNameDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_NAME_DESC',
  CommonSizeByCommonSizeIdSizeDescriptionAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_ASC',
  CommonSizeByCommonSizeIdSizeDescriptionDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__SIZE_DESCRIPTION_DESC',
  CommonSizeByCommonSizeIdCommonSpeciesIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_ASC',
  CommonSizeByCommonSizeIdCommonSpeciesIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__COMMON_SPECIES_ID_DESC',
  CommonSizeByCommonSizeIdProductSizeIdAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_ASC',
  CommonSizeByCommonSizeIdProductSizeIdDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__PRODUCT_SIZE_ID_DESC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyAsc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonSizeByCommonSizeIdDefaultInvSortKeyDesc = 'COMMON_SIZE_BY_COMMON_SIZE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_ASC',
  CommonPackTypeByCommonPackTypeIdIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeNameDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_NAME_DESC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_ASC',
  CommonPackTypeByCommonPackTypeIdPackTypeDescriptionDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_TYPE_DESCRIPTION_DESC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_ASC',
  CommonPackTypeByCommonPackTypeIdCommonSpeciesIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__COMMON_SPECIES_ID_DESC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_ASC',
  CommonPackTypeByCommonPackTypeIdPackMasterIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PACK_MASTER_ID_DESC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_ASC',
  CommonPackTypeByCommonPackTypeIdDefaultInvSortKeyDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__DEFAULT_INV_SORT_KEY_DESC',
  CommonPackTypeByCommonPackTypeIdPalletWeightAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_ASC',
  CommonPackTypeByCommonPackTypeIdPalletWeightDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__PALLET_WEIGHT_DESC',
  CommonPackTypeByCommonPackTypeIdBoxCountAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_ASC',
  CommonPackTypeByCommonPackTypeIdBoxCountDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__BOX_COUNT_DESC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdAsc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_ASC',
  CommonPackTypeByCommonPackTypeIdRepackStyleIdDesc = 'COMMON_PACK_TYPE_BY_COMMON_PACK_TYPE_ID__REPACK_STYLE_ID_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCustomerNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_ASC',
  CustomerByCustomerIdCustomerNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_DESC',
  CustomerByCustomerIdAddress_1Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_ASC',
  CustomerByCustomerIdAddress_1Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_DESC',
  CustomerByCustomerIdAddress_2Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_ASC',
  CustomerByCustomerIdAddress_2Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_DESC',
  CustomerByCustomerIdCityAsc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_ASC',
  CustomerByCustomerIdCityDesc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_DESC',
  CustomerByCustomerIdPostalStateAsc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_ASC',
  CustomerByCustomerIdPostalStateDesc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_DESC',
  CustomerByCustomerIdZipCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_ASC',
  CustomerByCustomerIdZipCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_DESC',
  CustomerByCustomerIdCountryIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_ASC',
  CustomerByCustomerIdCountryIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerByCustomerIdLogoSrcAsc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_ASC',
  CustomerByCustomerIdLogoSrcDesc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_DESC',
  CustomerByCustomerIdNotesAsc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_ASC',
  CustomerByCustomerIdNotesDesc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_DESC',
  CustomerByCustomerIdWebsiteAsc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_ASC',
  CustomerByCustomerIdWebsiteDesc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_DESC',
  CustomerByCustomerIdActiveAsc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_ASC',
  CustomerByCustomerIdActiveDesc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_DESC',
  CustomerByCustomerIdSalesUserCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_ASC',
  CustomerByCustomerIdSalesUserCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_DESC',
  ShipperProjectionEntriesByProductIdCountAsc = 'SHIPPER_PROJECTION_ENTRIES_BY_PRODUCT_ID__COUNT_ASC',
  ShipperProjectionEntriesByProductIdCountDesc = 'SHIPPER_PROJECTION_ENTRIES_BY_PRODUCT_ID__COUNT_DESC'
}

/** Input for the nested mutation of `shipper` in the `ShipperProjectionInput` mutation. */
export type ShipperProjectionShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionShipperIdFkeyShipperCreateInput>;
};

/** Input for the nested mutation of `shipperProjection` in the `ShipperInput` mutation. */
export type ShipperProjectionShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjection` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionShipperProjectionPkeyConnect>>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionNodeIdConnect>>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionShipperProjectionPkeyDelete>>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyUsingShipperProjectionPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProjectionForShipperProjectionShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionShipperIdFkeyShipperProjectionCreateInput>>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperProjectionShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** The `shipperProjection` to be created by this mutation. */
export type ShipperProjectionShipperIdFkeyShipperProjectionCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  submittedAt?: Maybe<Scalars['Datetime']>;
  shipperComments?: Maybe<Scalars['String']>;
  jvComments?: Maybe<Scalars['String']>;
  approvedAt?: Maybe<Scalars['Datetime']>;
  rejectedAt?: Maybe<Scalars['Datetime']>;
  reviewStatus?: Maybe<Scalars['Int']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInverseInput>;
};

/** The fields on `shipperProjection` to look up the row to connect. */
export type ShipperProjectionShipperProjectionPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProjection` to look up the row to delete. */
export type ShipperProjectionShipperProjectionPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `ShipperProjectionVessel` values, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdManyToManyConnection = {
  __typename?: 'ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdManyToManyConnection';
  /** A list of `ShipperProjectionVessel` objects. */
  nodes: Array<Maybe<ShipperProjectionVessel>>;
  /** A list of edges which contains the `ShipperProjectionVessel`, info from the `ShipperProjectionVesselInfo`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdManyToManyEdge = {
  __typename?: 'ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVessel` at the end of the edge. */
  node?: Maybe<ShipperProjectionVessel>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfosByVesselId: ShipperProjectionVesselInfosConnection;
};


/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionShipperProjectionVesselsByShipperProjectionVesselInfoProjectionIdAndVesselIdManyToManyEdgeShipperProjectionVesselInfosByVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdManyToManyConnection = {
  __typename?: 'ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionVesselInfo`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdManyToManyEdge = {
  __typename?: 'ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfos: ShipperProjectionVesselInfosConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionShippersByShipperProjectionVesselInfoProjectionIdAndShipperIdManyToManyEdgeShipperProjectionVesselInfosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** A filter to be used against many `ShipperProjectionVesselInfo` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionToManyShipperProjectionVesselInfoFilter = {
  /** Every related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionVesselInfoFilter>;
  /** Some related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionVesselInfoFilter>;
  /** No related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionVesselInfoFilter>;
};

export type ShipperProjectionVessel = Node & {
  __typename?: 'ShipperProjectionVessel';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  shipperId?: Maybe<Scalars['String']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Vessel` that is related to this `ShipperProjectionVessel`. */
  vessel?: Maybe<Vessel>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfosByVesselId: ShipperProjectionVesselInfosConnection;
  /** Reads and enables pagination through a set of `ShipperProjection`. */
  shipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionId: ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdManyToManyConnection;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionVesselInfoVesselIdAndShipperId: ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdManyToManyConnection;
};


export type ShipperProjectionVesselShipperProjectionVesselInfosByVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};


export type ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
  condition?: Maybe<ShipperProjectionCondition>;
  filter?: Maybe<ShipperProjectionFilter>;
};


export type ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};

/**
 * A condition to be used against `ShipperProjectionVessel` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionVesselCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselId` field. */
  vesselId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ShipperProjectionVessel` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionVesselFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselId` field. */
  vesselId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperProjectionVesselInfosByVesselId` relation. */
  shipperProjectionVesselInfosByVesselId?: Maybe<ShipperProjectionVesselToManyShipperProjectionVesselInfoFilter>;
  /** Some related `shipperProjectionVesselInfosByVesselId` exist. */
  shipperProjectionVesselInfosByVesselIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `vessel` relation. */
  vessel?: Maybe<VesselFilter>;
  /** A related `vessel` exists. */
  vesselExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionVesselFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionVesselFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionVesselFilter>;
};

export type ShipperProjectionVesselInfo = Node & {
  __typename?: 'ShipperProjectionVesselInfo';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionVesselInfo`. */
  projection?: Maybe<ShipperProjection>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionVesselInfo`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVesselInfo`. */
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByVesselInfoId: ShipperProjectionEntriesConnection;
  /** Reads and enables pagination through a set of `ShipperProjectionProduct`. */
  shipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductId: ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdManyToManyConnection;
};


export type ShipperProjectionVesselInfoShipperProjectionEntriesByVesselInfoIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};


export type ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
  condition?: Maybe<ShipperProjectionProductCondition>;
  filter?: Maybe<ShipperProjectionProductFilter>;
};

/**
 * A condition to be used against `ShipperProjectionVesselInfo` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ShipperProjectionVesselInfoCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselName` field. */
  vesselName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `departureDate` field. */
  departureDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselStatus` field. */
  vesselStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `projectionId` field. */
  projectionId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselId` field. */
  vesselId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ShipperProjectionVesselInfo` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionVesselInfoFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselName` field. */
  vesselName?: Maybe<StringFilter>;
  /** Filter by the object’s `departureDate` field. */
  departureDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselStatus` field. */
  vesselStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `projectionId` field. */
  projectionId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselId` field. */
  vesselId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionEntriesByVesselInfoId` relation. */
  shipperProjectionEntriesByVesselInfoId?: Maybe<ShipperProjectionVesselInfoToManyShipperProjectionEntryFilter>;
  /** Some related `shipperProjectionEntriesByVesselInfoId` exist. */
  shipperProjectionEntriesByVesselInfoIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `projection` relation. */
  projection?: Maybe<ShipperProjectionFilter>;
  /** A related `projection` exists. */
  projectionExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `vessel` relation. */
  vessel?: Maybe<ShipperProjectionVesselFilter>;
  /** A related `vessel` exists. */
  vesselExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `shipper` relation. */
  shipper?: Maybe<ShipperFilter>;
  /** A related `shipper` exists. */
  shipperExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ShipperProjectionVesselInfoFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ShipperProjectionVesselInfoFilter>>;
  /** Negates the expression. */
  not?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** An input for mutations affecting `ShipperProjectionVesselInfo` */
export type ShipperProjectionVesselInfoInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionVesselInfoNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVesselInfo` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionVesselInfoNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVesselInfo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionEntry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
};

/** The fields on `shipperProjectionVesselInfo` to look up the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyUsingShipperProjectionVesselInfoPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: UpdateShipperProjectionVesselInfoOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForFkShipperIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `shipperProjectionVesselInfo` to look up the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForFkShipperIdUsingShipperProjectionVesselInfoPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: UpdateShipperProjectionVesselInfoOnShipperProjectionVesselInfoForFkShipperIdPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjection` being updated. */
  patch: ShipperProjectionPatch;
};

/** The fields on `shipperProjectionVesselInfo` to look up the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyUsingShipperProjectionVesselInfoPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: UpdateShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
};

/** The fields on `shipperProjectionVesselInfo` to look up the row to update. */
export type ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyUsingShipperProjectionVesselInfoPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: UpdateShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProjectionVesselInfo`. Fields that are set will be updated. */
export type ShipperProjectionVesselInfoPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipperProjection` in the `ShipperProjectionVesselInfoInput` mutation. */
export type ShipperProjectionVesselInfoProjectionIdFkeyInput = {
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectById?: Maybe<ShipperProjectionShipperProjectionPkeyConnect>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProjectionNodeIdConnect>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProjectionShipperProjectionPkeyDelete>;
  /** The primary key(s) for `shipperProjection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProjectionNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateById?: Maybe<ShipperProjectionOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyUsingShipperProjectionPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProjection` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyNodeIdUpdate>;
  /** A `ShipperProjectionInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyShipperProjectionCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionVesselInfo` in the `ShipperProjectionInput` mutation. */
export type ShipperProjectionVesselInfoProjectionIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionVesselInfo` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionVesselInfoNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionVesselInfoNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyUsingShipperProjectionVesselInfoPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProjectionOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionVesselInfoInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionVesselInfoProjectionIdFkeyShipperProjectionVesselInfoCreateInput>>;
};

/** The `shipperProjection` to be created by this mutation. */
export type ShipperProjectionVesselInfoProjectionIdFkeyShipperProjectionCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  submittedAt?: Maybe<Scalars['Datetime']>;
  shipperComments?: Maybe<Scalars['String']>;
  jvComments?: Maybe<Scalars['String']>;
  approvedAt?: Maybe<Scalars['Datetime']>;
  rejectedAt?: Maybe<Scalars['Datetime']>;
  shipperId?: Maybe<Scalars['String']>;
  reviewStatus?: Maybe<Scalars['Int']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInverseInput>;
};

/** The `shipperProjectionVesselInfo` to be created by this mutation. */
export type ShipperProjectionVesselInfoProjectionIdFkeyShipperProjectionVesselInfoCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** A connection to a list of `ShipperProjectionProduct` values, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdManyToManyConnection = {
  __typename?: 'ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdManyToManyConnection';
  /** A list of `ShipperProjectionProduct` objects. */
  nodes: Array<Maybe<ShipperProjectionProduct>>;
  /** A list of edges which contains the `ShipperProjectionProduct`, info from the `ShipperProjectionEntry`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionProduct` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionProduct` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdManyToManyEdge = {
  __typename?: 'ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionProduct` at the end of the edge. */
  node?: Maybe<ShipperProjectionProduct>;
  /** Reads and enables pagination through a set of `ShipperProjectionEntry`. */
  shipperProjectionEntriesByProductId: ShipperProjectionEntriesConnection;
};


/** A `ShipperProjectionProduct` edge in the connection, with data from `ShipperProjectionEntry`. */
export type ShipperProjectionVesselInfoShipperProjectionProductsByShipperProjectionEntryVesselInfoIdAndProductIdManyToManyEdgeShipperProjectionEntriesByProductIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
  condition?: Maybe<ShipperProjectionEntryCondition>;
  filter?: Maybe<ShipperProjectionEntryFilter>;
};

/** The fields on `shipperProjectionVesselInfo` to look up the row to connect. */
export type ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProjectionVesselInfo` to look up the row to delete. */
export type ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A filter to be used against many `ShipperProjectionEntry` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionVesselInfoToManyShipperProjectionEntryFilter = {
  /** Every related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionEntryFilter>;
  /** Some related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionEntryFilter>;
  /** No related `ShipperProjectionEntry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionEntryFilter>;
};

/** Input for the nested mutation of `shipperProjectionVessel` in the `ShipperProjectionVesselInfoInput` mutation. */
export type ShipperProjectionVesselInfoVesselIdFkeyInput = {
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectById?: Maybe<ShipperProjectionVesselShipperProjectionVesselPkeyConnect>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperProjectionVesselNodeIdConnect>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteById?: Maybe<ShipperProjectionVesselShipperProjectionVesselPkeyDelete>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperProjectionVesselNodeIdDelete>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateById?: Maybe<ShipperProjectionVesselOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyUsingShipperProjectionVesselPkeyUpdate>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyNodeIdUpdate>;
  /** A `ShipperProjectionVesselInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyShipperProjectionVesselCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionVesselInfo` in the `ShipperProjectionVesselInput` mutation. */
export type ShipperProjectionVesselInfoVesselIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionVesselInfo` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionVesselInfoNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionVesselInfoShipperProjectionVesselInfoPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionVesselInfo` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionVesselInfoNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyUsingShipperProjectionVesselInfoPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionVesselInfo` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperProjectionVesselOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionVesselInfoInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionVesselInfoVesselIdFkeyShipperProjectionVesselInfoCreateInput>>;
};

/** The `shipperProjectionVessel` to be created by this mutation. */
export type ShipperProjectionVesselInfoVesselIdFkeyShipperProjectionVesselCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** The `shipperProjectionVesselInfo` to be created by this mutation. */
export type ShipperProjectionVesselInfoVesselIdFkeyShipperProjectionVesselInfoCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** A connection to a list of `ShipperProjectionVesselInfo` values. */
export type ShipperProjectionVesselInfosConnection = {
  __typename?: 'ShipperProjectionVesselInfosConnection';
  /** A list of `ShipperProjectionVesselInfo` objects. */
  nodes: Array<Maybe<ShipperProjectionVesselInfo>>;
  /** A list of edges which contains the `ShipperProjectionVesselInfo` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselInfosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVesselInfo` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionVesselInfo` edge in the connection. */
export type ShipperProjectionVesselInfosEdge = {
  __typename?: 'ShipperProjectionVesselInfosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVesselInfo` at the end of the edge. */
  node?: Maybe<ShipperProjectionVesselInfo>;
};

/** Methods to use when ordering `ShipperProjectionVesselInfo`. */
export enum ShipperProjectionVesselInfosOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselNameAsc = 'VESSEL_NAME_ASC',
  VesselNameDesc = 'VESSEL_NAME_DESC',
  DepartureDateAsc = 'DEPARTURE_DATE_ASC',
  DepartureDateDesc = 'DEPARTURE_DATE_DESC',
  ArrivalDateAsc = 'ARRIVAL_DATE_ASC',
  ArrivalDateDesc = 'ARRIVAL_DATE_DESC',
  ArrivalPortAsc = 'ARRIVAL_PORT_ASC',
  ArrivalPortDesc = 'ARRIVAL_PORT_DESC',
  VesselStatusAsc = 'VESSEL_STATUS_ASC',
  VesselStatusDesc = 'VESSEL_STATUS_DESC',
  ProjectionIdAsc = 'PROJECTION_ID_ASC',
  ProjectionIdDesc = 'PROJECTION_ID_DESC',
  VesselIdAsc = 'VESSEL_ID_ASC',
  VesselIdDesc = 'VESSEL_ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperProjectionByProjectionIdIdAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__ID_ASC',
  ShipperProjectionByProjectionIdIdDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__ID_DESC',
  ShipperProjectionByProjectionIdSubmittedAtAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__SUBMITTED_AT_ASC',
  ShipperProjectionByProjectionIdSubmittedAtDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__SUBMITTED_AT_DESC',
  ShipperProjectionByProjectionIdShipperCommentsAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__SHIPPER_COMMENTS_ASC',
  ShipperProjectionByProjectionIdShipperCommentsDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__SHIPPER_COMMENTS_DESC',
  ShipperProjectionByProjectionIdJvCommentsAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__JV_COMMENTS_ASC',
  ShipperProjectionByProjectionIdJvCommentsDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__JV_COMMENTS_DESC',
  ShipperProjectionByProjectionIdApprovedAtAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__APPROVED_AT_ASC',
  ShipperProjectionByProjectionIdApprovedAtDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__APPROVED_AT_DESC',
  ShipperProjectionByProjectionIdRejectedAtAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__REJECTED_AT_ASC',
  ShipperProjectionByProjectionIdRejectedAtDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__REJECTED_AT_DESC',
  ShipperProjectionByProjectionIdShipperIdAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__SHIPPER_ID_ASC',
  ShipperProjectionByProjectionIdShipperIdDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__SHIPPER_ID_DESC',
  ShipperProjectionByProjectionIdReviewStatusAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__REVIEW_STATUS_ASC',
  ShipperProjectionByProjectionIdReviewStatusDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__REVIEW_STATUS_DESC',
  ShipperProjectionByProjectionIdTotalPalletsAsc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__TOTAL_PALLETS_ASC',
  ShipperProjectionByProjectionIdTotalPalletsDesc = 'SHIPPER_PROJECTION_BY_PROJECTION_ID__TOTAL_PALLETS_DESC',
  ShipperProjectionVesselByVesselIdIdAsc = 'SHIPPER_PROJECTION_VESSEL_BY_VESSEL_ID__ID_ASC',
  ShipperProjectionVesselByVesselIdIdDesc = 'SHIPPER_PROJECTION_VESSEL_BY_VESSEL_ID__ID_DESC',
  ShipperProjectionVesselByVesselIdShipperIdAsc = 'SHIPPER_PROJECTION_VESSEL_BY_VESSEL_ID__SHIPPER_ID_ASC',
  ShipperProjectionVesselByVesselIdShipperIdDesc = 'SHIPPER_PROJECTION_VESSEL_BY_VESSEL_ID__SHIPPER_ID_DESC',
  ShipperProjectionVesselByVesselIdVesselIdAsc = 'SHIPPER_PROJECTION_VESSEL_BY_VESSEL_ID__VESSEL_ID_ASC',
  ShipperProjectionVesselByVesselIdVesselIdDesc = 'SHIPPER_PROJECTION_VESSEL_BY_VESSEL_ID__VESSEL_ID_DESC',
  ShipperByShipperIdIdAsc = 'SHIPPER_BY_SHIPPER_ID__ID_ASC',
  ShipperByShipperIdIdDesc = 'SHIPPER_BY_SHIPPER_ID__ID_DESC',
  ShipperByShipperIdShipperNameAsc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_ASC',
  ShipperByShipperIdShipperNameDesc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_DESC',
  ShipperByShipperIdCountryIdAsc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_ASC',
  ShipperByShipperIdCountryIdDesc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_DESC',
  ShipperByShipperIdGroupIdAsc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_ASC',
  ShipperByShipperIdGroupIdDesc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_DESC',
  ShipperByShipperIdLogoSrcAsc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_ASC',
  ShipperByShipperIdLogoSrcDesc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_DESC',
  ShipperByShipperIdNotesAsc = 'SHIPPER_BY_SHIPPER_ID__NOTES_ASC',
  ShipperByShipperIdNotesDesc = 'SHIPPER_BY_SHIPPER_ID__NOTES_DESC',
  ShipperByShipperIdWebsiteAsc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_ASC',
  ShipperByShipperIdWebsiteDesc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_DESC',
  ShipperByShipperIdSendProjectionRequestAsc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_ASC',
  ShipperByShipperIdSendProjectionRequestDesc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_DESC',
  ShipperByShipperIdProjectionRequestStartDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_ASC',
  ShipperByShipperIdProjectionRequestStartDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_DESC',
  ShipperByShipperIdProjectionRequestEndDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_ASC',
  ShipperByShipperIdProjectionRequestEndDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_DESC',
  ShipperByShipperIdVesselControlDaysUntilDueAsc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  ShipperByShipperIdVesselControlDaysUntilDueDesc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  ShipperByShipperIdPsaShipperIdAsc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_ASC',
  ShipperByShipperIdPsaShipperIdDesc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_DESC',
  ShipperByShipperIdCommissionRateAsc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_ASC',
  ShipperByShipperIdCommissionRateDesc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_DESC',
  ShipperProjectionEntriesByVesselInfoIdCountAsc = 'SHIPPER_PROJECTION_ENTRIES_BY_VESSEL_INFO_ID__COUNT_ASC',
  ShipperProjectionEntriesByVesselInfoIdCountDesc = 'SHIPPER_PROJECTION_ENTRIES_BY_VESSEL_INFO_ID__COUNT_DESC'
}

/** An input for mutations affecting `ShipperProjectionVessel` */
export type ShipperProjectionVesselInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ShipperProjectionVesselNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ShipperProjectionVesselNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipper` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipper` being updated. */
  patch: ShipperPatch;
};

/** The fields on `shipperProjectionVessel` to look up the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperProjectionVesselPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: UpdateShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `vessel` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `vessel` being updated. */
  patch: VesselPatch;
};

/** The fields on `shipperProjectionVessel` to look up the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyUsingShipperProjectionVesselPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: UpdateShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVesselInfo` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
  patch: ShipperProjectionVesselInfoPatch;
};

/** The fields on `shipperProjectionVessel` to look up the row to update. */
export type ShipperProjectionVesselOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyUsingShipperProjectionVesselPkeyUpdate = {
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: UpdateShipperProjectionVesselOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `ShipperProjectionVessel`. Fields that are set will be updated. */
export type ShipperProjectionVesselPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** Input for the nested mutation of `shipper` in the `ShipperProjectionVesselInput` mutation. */
export type ShipperProjectionVesselShipperIdFkeyInput = {
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectById?: Maybe<ShipperShipperPkeyConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  connectByNodeId?: Maybe<ShipperNodeIdConnect>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteById?: Maybe<ShipperShipperPkeyDelete>;
  /** The primary key(s) for `shipper` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ShipperNodeIdDelete>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateById?: Maybe<ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperPkeyUpdate>;
  /** The primary key(s) and patch data for `shipper` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate>;
  /** A `ShipperInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionVesselShipperIdFkeyShipperCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionVessel` in the `ShipperInput` mutation. */
export type ShipperProjectionVesselShipperIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionVessel` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionVesselShipperProjectionVesselPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionVesselNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionVesselShipperProjectionVesselPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionVesselNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyUsingShipperProjectionVesselPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionVesselInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionVesselShipperIdFkeyShipperProjectionVesselCreateInput>>;
};

/** The `shipper` to be created by this mutation. */
export type ShipperProjectionVesselShipperIdFkeyShipperCreateInput = {
  id: Scalars['String'];
  shipperName: Scalars['String'];
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** The `shipperProjectionVessel` to be created by this mutation. */
export type ShipperProjectionVesselShipperIdFkeyShipperProjectionVesselCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** The fields on `shipperProjectionVessel` to look up the row to connect. */
export type ShipperProjectionVesselShipperProjectionVesselPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `shipperProjectionVessel` to look up the row to delete. */
export type ShipperProjectionVesselShipperProjectionVesselPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `ShipperProjection` values, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdManyToManyConnection = {
  __typename?: 'ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdManyToManyConnection';
  /** A list of `ShipperProjection` objects. */
  nodes: Array<Maybe<ShipperProjection>>;
  /** A list of edges which contains the `ShipperProjection`, info from the `ShipperProjectionVesselInfo`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdManyToManyEdge = {
  __typename?: 'ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjection` at the end of the edge. */
  node?: Maybe<ShipperProjection>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfosByProjectionId: ShipperProjectionVesselInfosConnection;
};


/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionVesselShipperProjectionsByShipperProjectionVesselInfoVesselIdAndProjectionIdManyToManyEdgeShipperProjectionVesselInfosByProjectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdManyToManyConnection = {
  __typename?: 'ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionVesselInfo`, and the cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdManyToManyEdge = {
  __typename?: 'ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfos: ShipperProjectionVesselInfosConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperProjectionVesselShippersByShipperProjectionVesselInfoVesselIdAndShipperIdManyToManyEdgeShipperProjectionVesselInfosArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** A filter to be used against many `ShipperProjectionVesselInfo` object types. All fields are combined with a logical ‘and.’ */
export type ShipperProjectionVesselToManyShipperProjectionVesselInfoFilter = {
  /** Every related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionVesselInfoFilter>;
  /** Some related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionVesselInfoFilter>;
  /** No related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** Input for the nested mutation of `vessel` in the `ShipperProjectionVesselInput` mutation. */
export type ShipperProjectionVesselVesselIdFkeyInput = {
  /** The primary key(s) for `vessel` for the far side of the relationship. */
  connectById?: Maybe<VesselVesselPkeyConnect>;
  /** The primary key(s) for `vessel` for the far side of the relationship. */
  connectByNodeId?: Maybe<VesselNodeIdConnect>;
  /** The primary key(s) for `vessel` for the far side of the relationship. */
  deleteById?: Maybe<VesselVesselPkeyDelete>;
  /** The primary key(s) for `vessel` for the far side of the relationship. */
  deleteByNodeId?: Maybe<VesselNodeIdDelete>;
  /** The primary key(s) and patch data for `vessel` for the far side of the relationship. */
  updateById?: Maybe<VesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyUsingVesselPkeyUpdate>;
  /** The primary key(s) and patch data for `vessel` for the far side of the relationship. */
  updateByNodeId?: Maybe<ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyNodeIdUpdate>;
  /** A `VesselInput` object that will be created and connected to this object. */
  create?: Maybe<ShipperProjectionVesselVesselIdFkeyVesselCreateInput>;
};

/** Input for the nested mutation of `shipperProjectionVessel` in the `VesselInput` mutation. */
export type ShipperProjectionVesselVesselIdFkeyInverseInput = {
  /** Flag indicating whether all other `shipperProjectionVessel` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectById?: Maybe<Array<ShipperProjectionVesselShipperProjectionVesselPkeyConnect>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ShipperProjectionVesselNodeIdConnect>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteById?: Maybe<Array<ShipperProjectionVesselShipperProjectionVesselPkeyDelete>>;
  /** The primary key(s) for `shipperProjectionVessel` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ShipperProjectionVesselNodeIdDelete>>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateById?: Maybe<Array<ShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyUsingShipperProjectionVesselPkeyUpdate>>;
  /** The primary key(s) and patch data for `shipperProjectionVessel` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<VesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyNodeIdUpdate>>;
  /** A `ShipperProjectionVesselInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ShipperProjectionVesselVesselIdFkeyShipperProjectionVesselCreateInput>>;
};

/** The `shipperProjectionVessel` to be created by this mutation. */
export type ShipperProjectionVesselVesselIdFkeyShipperProjectionVesselCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** The `vessel` to be created by this mutation. */
export type ShipperProjectionVesselVesselIdFkeyVesselCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
  preVesselCode?: Maybe<Scalars['String']>;
  invFlag?: Maybe<Scalars['Boolean']>;
  scheduleNotes?: Maybe<Scalars['String']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselVesselIdFkeyInverseInput>;
};

/** A connection to a list of `ShipperProjectionVessel` values. */
export type ShipperProjectionVesselsConnection = {
  __typename?: 'ShipperProjectionVesselsConnection';
  /** A list of `ShipperProjectionVessel` objects. */
  nodes: Array<Maybe<ShipperProjectionVessel>>;
  /** A list of edges which contains the `ShipperProjectionVessel` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionVesselsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionVessel` edge in the connection. */
export type ShipperProjectionVesselsEdge = {
  __typename?: 'ShipperProjectionVesselsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVessel` at the end of the edge. */
  node?: Maybe<ShipperProjectionVessel>;
};

/** Methods to use when ordering `ShipperProjectionVessel`. */
export enum ShipperProjectionVesselsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  VesselIdAsc = 'VESSEL_ID_ASC',
  VesselIdDesc = 'VESSEL_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperByShipperIdIdAsc = 'SHIPPER_BY_SHIPPER_ID__ID_ASC',
  ShipperByShipperIdIdDesc = 'SHIPPER_BY_SHIPPER_ID__ID_DESC',
  ShipperByShipperIdShipperNameAsc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_ASC',
  ShipperByShipperIdShipperNameDesc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_DESC',
  ShipperByShipperIdCountryIdAsc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_ASC',
  ShipperByShipperIdCountryIdDesc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_DESC',
  ShipperByShipperIdGroupIdAsc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_ASC',
  ShipperByShipperIdGroupIdDesc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_DESC',
  ShipperByShipperIdLogoSrcAsc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_ASC',
  ShipperByShipperIdLogoSrcDesc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_DESC',
  ShipperByShipperIdNotesAsc = 'SHIPPER_BY_SHIPPER_ID__NOTES_ASC',
  ShipperByShipperIdNotesDesc = 'SHIPPER_BY_SHIPPER_ID__NOTES_DESC',
  ShipperByShipperIdWebsiteAsc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_ASC',
  ShipperByShipperIdWebsiteDesc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_DESC',
  ShipperByShipperIdSendProjectionRequestAsc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_ASC',
  ShipperByShipperIdSendProjectionRequestDesc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_DESC',
  ShipperByShipperIdProjectionRequestStartDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_ASC',
  ShipperByShipperIdProjectionRequestStartDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_DESC',
  ShipperByShipperIdProjectionRequestEndDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_ASC',
  ShipperByShipperIdProjectionRequestEndDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_DESC',
  ShipperByShipperIdVesselControlDaysUntilDueAsc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  ShipperByShipperIdVesselControlDaysUntilDueDesc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  ShipperByShipperIdPsaShipperIdAsc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_ASC',
  ShipperByShipperIdPsaShipperIdDesc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_DESC',
  ShipperByShipperIdCommissionRateAsc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_ASC',
  ShipperByShipperIdCommissionRateDesc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_DESC',
  VesselByVesselIdIdAsc = 'VESSEL_BY_VESSEL_ID__ID_ASC',
  VesselByVesselIdIdDesc = 'VESSEL_BY_VESSEL_ID__ID_DESC',
  VesselByVesselIdVesselCodeAsc = 'VESSEL_BY_VESSEL_ID__VESSEL_CODE_ASC',
  VesselByVesselIdVesselCodeDesc = 'VESSEL_BY_VESSEL_ID__VESSEL_CODE_DESC',
  VesselByVesselIdVesselNameAsc = 'VESSEL_BY_VESSEL_ID__VESSEL_NAME_ASC',
  VesselByVesselIdVesselNameDesc = 'VESSEL_BY_VESSEL_ID__VESSEL_NAME_DESC',
  VesselByVesselIdArrivalPortAsc = 'VESSEL_BY_VESSEL_ID__ARRIVAL_PORT_ASC',
  VesselByVesselIdArrivalPortDesc = 'VESSEL_BY_VESSEL_ID__ARRIVAL_PORT_DESC',
  VesselByVesselIdCountryIdAsc = 'VESSEL_BY_VESSEL_ID__COUNTRY_ID_ASC',
  VesselByVesselIdCountryIdDesc = 'VESSEL_BY_VESSEL_ID__COUNTRY_ID_DESC',
  VesselByVesselIdDepartureDateAsc = 'VESSEL_BY_VESSEL_ID__DEPARTURE_DATE_ASC',
  VesselByVesselIdDepartureDateDesc = 'VESSEL_BY_VESSEL_ID__DEPARTURE_DATE_DESC',
  VesselByVesselIdArrivalDateAsc = 'VESSEL_BY_VESSEL_ID__ARRIVAL_DATE_ASC',
  VesselByVesselIdArrivalDateDesc = 'VESSEL_BY_VESSEL_ID__ARRIVAL_DATE_DESC',
  VesselByVesselIdDischargeDateAsc = 'VESSEL_BY_VESSEL_ID__DISCHARGE_DATE_ASC',
  VesselByVesselIdDischargeDateDesc = 'VESSEL_BY_VESSEL_ID__DISCHARGE_DATE_DESC',
  VesselByVesselIdCoastAsc = 'VESSEL_BY_VESSEL_ID__COAST_ASC',
  VesselByVesselIdCoastDesc = 'VESSEL_BY_VESSEL_ID__COAST_DESC',
  VesselByVesselIdIsPreAsc = 'VESSEL_BY_VESSEL_ID__IS_PRE_ASC',
  VesselByVesselIdIsPreDesc = 'VESSEL_BY_VESSEL_ID__IS_PRE_DESC',
  VesselByVesselIdPreVesselCodeAsc = 'VESSEL_BY_VESSEL_ID__PRE_VESSEL_CODE_ASC',
  VesselByVesselIdPreVesselCodeDesc = 'VESSEL_BY_VESSEL_ID__PRE_VESSEL_CODE_DESC',
  VesselByVesselIdInvFlagAsc = 'VESSEL_BY_VESSEL_ID__INV_FLAG_ASC',
  VesselByVesselIdInvFlagDesc = 'VESSEL_BY_VESSEL_ID__INV_FLAG_DESC',
  VesselByVesselIdScheduleNotesAsc = 'VESSEL_BY_VESSEL_ID__SCHEDULE_NOTES_ASC',
  VesselByVesselIdScheduleNotesDesc = 'VESSEL_BY_VESSEL_ID__SCHEDULE_NOTES_DESC',
  VesselByVesselIdIsAvailableAsc = 'VESSEL_BY_VESSEL_ID__IS_AVAILABLE_ASC',
  VesselByVesselIdIsAvailableDesc = 'VESSEL_BY_VESSEL_ID__IS_AVAILABLE_DESC',
  ShipperProjectionVesselInfosByVesselIdCountAsc = 'SHIPPER_PROJECTION_VESSEL_INFOS_BY_VESSEL_ID__COUNT_ASC',
  ShipperProjectionVesselInfosByVesselIdCountDesc = 'SHIPPER_PROJECTION_VESSEL_INFOS_BY_VESSEL_ID__COUNT_DESC'
}

/** A connection to a list of `ShipperProjection` values. */
export type ShipperProjectionsConnection = {
  __typename?: 'ShipperProjectionsConnection';
  /** A list of `ShipperProjection` objects. */
  nodes: Array<Maybe<ShipperProjection>>;
  /** A list of edges which contains the `ShipperProjection` and cursor to aid in pagination. */
  edges: Array<ShipperProjectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjection` edge in the connection. */
export type ShipperProjectionsEdge = {
  __typename?: 'ShipperProjectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjection` at the end of the edge. */
  node?: Maybe<ShipperProjection>;
};

/** Methods to use when ordering `ShipperProjection`. */
export enum ShipperProjectionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SubmittedAtAsc = 'SUBMITTED_AT_ASC',
  SubmittedAtDesc = 'SUBMITTED_AT_DESC',
  ShipperCommentsAsc = 'SHIPPER_COMMENTS_ASC',
  ShipperCommentsDesc = 'SHIPPER_COMMENTS_DESC',
  JvCommentsAsc = 'JV_COMMENTS_ASC',
  JvCommentsDesc = 'JV_COMMENTS_DESC',
  ApprovedAtAsc = 'APPROVED_AT_ASC',
  ApprovedAtDesc = 'APPROVED_AT_DESC',
  RejectedAtAsc = 'REJECTED_AT_ASC',
  RejectedAtDesc = 'REJECTED_AT_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  ReviewStatusAsc = 'REVIEW_STATUS_ASC',
  ReviewStatusDesc = 'REVIEW_STATUS_DESC',
  TotalPalletsAsc = 'TOTAL_PALLETS_ASC',
  TotalPalletsDesc = 'TOTAL_PALLETS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperByShipperIdIdAsc = 'SHIPPER_BY_SHIPPER_ID__ID_ASC',
  ShipperByShipperIdIdDesc = 'SHIPPER_BY_SHIPPER_ID__ID_DESC',
  ShipperByShipperIdShipperNameAsc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_ASC',
  ShipperByShipperIdShipperNameDesc = 'SHIPPER_BY_SHIPPER_ID__SHIPPER_NAME_DESC',
  ShipperByShipperIdCountryIdAsc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_ASC',
  ShipperByShipperIdCountryIdDesc = 'SHIPPER_BY_SHIPPER_ID__COUNTRY_ID_DESC',
  ShipperByShipperIdGroupIdAsc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_ASC',
  ShipperByShipperIdGroupIdDesc = 'SHIPPER_BY_SHIPPER_ID__GROUP_ID_DESC',
  ShipperByShipperIdLogoSrcAsc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_ASC',
  ShipperByShipperIdLogoSrcDesc = 'SHIPPER_BY_SHIPPER_ID__LOGO_SRC_DESC',
  ShipperByShipperIdNotesAsc = 'SHIPPER_BY_SHIPPER_ID__NOTES_ASC',
  ShipperByShipperIdNotesDesc = 'SHIPPER_BY_SHIPPER_ID__NOTES_DESC',
  ShipperByShipperIdWebsiteAsc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_ASC',
  ShipperByShipperIdWebsiteDesc = 'SHIPPER_BY_SHIPPER_ID__WEBSITE_DESC',
  ShipperByShipperIdSendProjectionRequestAsc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_ASC',
  ShipperByShipperIdSendProjectionRequestDesc = 'SHIPPER_BY_SHIPPER_ID__SEND_PROJECTION_REQUEST_DESC',
  ShipperByShipperIdProjectionRequestStartDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_ASC',
  ShipperByShipperIdProjectionRequestStartDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_START_DATE_DESC',
  ShipperByShipperIdProjectionRequestEndDateAsc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_ASC',
  ShipperByShipperIdProjectionRequestEndDateDesc = 'SHIPPER_BY_SHIPPER_ID__PROJECTION_REQUEST_END_DATE_DESC',
  ShipperByShipperIdVesselControlDaysUntilDueAsc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  ShipperByShipperIdVesselControlDaysUntilDueDesc = 'SHIPPER_BY_SHIPPER_ID__VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  ShipperByShipperIdPsaShipperIdAsc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_ASC',
  ShipperByShipperIdPsaShipperIdDesc = 'SHIPPER_BY_SHIPPER_ID__PSA_SHIPPER_ID_DESC',
  ShipperByShipperIdCommissionRateAsc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_ASC',
  ShipperByShipperIdCommissionRateDesc = 'SHIPPER_BY_SHIPPER_ID__COMMISSION_RATE_DESC',
  ShipperProjectionVesselInfosByProjectionIdCountAsc = 'SHIPPER_PROJECTION_VESSEL_INFOS_BY_PROJECTION_ID__COUNT_ASC',
  ShipperProjectionVesselInfosByProjectionIdCountDesc = 'SHIPPER_PROJECTION_VESSEL_INFOS_BY_PROJECTION_ID__COUNT_DESC'
}

/** The fields on `shipper` to look up the row to connect. */
export type ShipperShipperPkeyConnect = {
  id: Scalars['String'];
};

/** The fields on `shipper` to look up the row to delete. */
export type ShipperShipperPkeyDelete = {
  id: Scalars['String'];
};

/** A connection to a list of `ShipperProjectionVessel` values, with data from `ShipperProjectionVesselInfo`. */
export type ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdManyToManyConnection = {
  __typename?: 'ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdManyToManyConnection';
  /** A list of `ShipperProjectionVessel` objects. */
  nodes: Array<Maybe<ShipperProjectionVessel>>;
  /** A list of edges which contains the `ShipperProjectionVessel`, info from the `ShipperProjectionVesselInfo`, and the cursor to aid in pagination. */
  edges: Array<ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjectionVessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdManyToManyEdge = {
  __typename?: 'ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjectionVessel` at the end of the edge. */
  node?: Maybe<ShipperProjectionVessel>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfosByVesselId: ShipperProjectionVesselInfosConnection;
};


/** A `ShipperProjectionVessel` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperShipperProjectionVesselsByShipperProjectionVesselInfoShipperIdAndVesselIdManyToManyEdgeShipperProjectionVesselInfosByVesselIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** A connection to a list of `ShipperProjection` values, with data from `ShipperProjectionVesselInfo`. */
export type ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdManyToManyConnection = {
  __typename?: 'ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdManyToManyConnection';
  /** A list of `ShipperProjection` objects. */
  nodes: Array<Maybe<ShipperProjection>>;
  /** A list of edges which contains the `ShipperProjection`, info from the `ShipperProjectionVesselInfo`, and the cursor to aid in pagination. */
  edges: Array<ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ShipperProjection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdManyToManyEdge = {
  __typename?: 'ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ShipperProjection` at the end of the edge. */
  node?: Maybe<ShipperProjection>;
  /** Reads and enables pagination through a set of `ShipperProjectionVesselInfo`. */
  shipperProjectionVesselInfosByProjectionId: ShipperProjectionVesselInfosConnection;
};


/** A `ShipperProjection` edge in the connection, with data from `ShipperProjectionVesselInfo`. */
export type ShipperShipperProjectionsByShipperProjectionVesselInfoShipperIdAndProjectionIdManyToManyEdgeShipperProjectionVesselInfosByProjectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselInfoCondition>;
  filter?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** A filter to be used against many `ShipperAdvance` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperAdvanceFilter = {
  /** Every related `ShipperAdvance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperAdvanceFilter>;
  /** Some related `ShipperAdvance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperAdvanceFilter>;
  /** No related `ShipperAdvance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperAdvanceFilter>;
};

/** A filter to be used against many `ShipperPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperPersonContactFilter = {
  /** Every related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperPersonContactFilter>;
  /** Some related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperPersonContactFilter>;
  /** No related `ShipperPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperPersonContactFilter>;
};

/** A filter to be used against many `ShipperProgram` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProgramFilter = {
  /** Every related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProgramFilter>;
  /** Some related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProgramFilter>;
  /** No related `ShipperProgram` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProgramFilter>;
};

/** A filter to be used against many `ShipperProjection` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProjectionFilter = {
  /** Every related `ShipperProjection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionFilter>;
  /** Some related `ShipperProjection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionFilter>;
  /** No related `ShipperProjection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionFilter>;
};

/** A filter to be used against many `ShipperProjectionProduct` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProjectionProductFilter = {
  /** Every related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionProductFilter>;
  /** Some related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionProductFilter>;
  /** No related `ShipperProjectionProduct` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionProductFilter>;
};

/** A filter to be used against many `ShipperProjectionVessel` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProjectionVesselFilter = {
  /** Every related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionVesselFilter>;
  /** Some related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionVesselFilter>;
  /** No related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionVesselFilter>;
};

/** A filter to be used against many `ShipperProjectionVesselInfo` object types. All fields are combined with a logical ‘and.’ */
export type ShipperToManyShipperProjectionVesselInfoFilter = {
  /** Every related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionVesselInfoFilter>;
  /** Some related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionVesselInfoFilter>;
  /** No related `ShipperProjectionVesselInfo` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionVesselInfoFilter>;
};

/** A connection to a list of `Vessel` values, with data from `ShipperProjectionVessel`. */
export type ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdManyToManyConnection = {
  __typename?: 'ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdManyToManyConnection';
  /** A list of `Vessel` objects. */
  nodes: Array<Maybe<Vessel>>;
  /** A list of edges which contains the `Vessel`, info from the `ShipperProjectionVessel`, and the cursor to aid in pagination. */
  edges: Array<ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Vessel` edge in the connection, with data from `ShipperProjectionVessel`. */
export type ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdManyToManyEdge = {
  __typename?: 'ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vessel` at the end of the edge. */
  node?: Maybe<Vessel>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVessels: ShipperProjectionVesselsConnection;
};


/** A `Vessel` edge in the connection, with data from `ShipperProjectionVessel`. */
export type ShipperVesselsByShipperProjectionVesselShipperIdAndVesselIdManyToManyEdgeShipperProjectionVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};

/** A connection to a list of `Shipper` values. */
export type ShippersConnection = {
  __typename?: 'ShippersConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper` and cursor to aid in pagination. */
  edges: Array<ShippersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection. */
export type ShippersEdge = {
  __typename?: 'ShippersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
};

/** Methods to use when ordering `Shipper`. */
export enum ShippersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ShipperNameAsc = 'SHIPPER_NAME_ASC',
  ShipperNameDesc = 'SHIPPER_NAME_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  LogoSrcAsc = 'LOGO_SRC_ASC',
  LogoSrcDesc = 'LOGO_SRC_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  WebsiteAsc = 'WEBSITE_ASC',
  WebsiteDesc = 'WEBSITE_DESC',
  SendProjectionRequestAsc = 'SEND_PROJECTION_REQUEST_ASC',
  SendProjectionRequestDesc = 'SEND_PROJECTION_REQUEST_DESC',
  ProjectionRequestStartDateAsc = 'PROJECTION_REQUEST_START_DATE_ASC',
  ProjectionRequestStartDateDesc = 'PROJECTION_REQUEST_START_DATE_DESC',
  ProjectionRequestEndDateAsc = 'PROJECTION_REQUEST_END_DATE_ASC',
  ProjectionRequestEndDateDesc = 'PROJECTION_REQUEST_END_DATE_DESC',
  VesselControlDaysUntilDueAsc = 'VESSEL_CONTROL_DAYS_UNTIL_DUE_ASC',
  VesselControlDaysUntilDueDesc = 'VESSEL_CONTROL_DAYS_UNTIL_DUE_DESC',
  PsaShipperIdAsc = 'PSA_SHIPPER_ID_ASC',
  PsaShipperIdDesc = 'PSA_SHIPPER_ID_DESC',
  CommissionRateAsc = 'COMMISSION_RATE_ASC',
  CommissionRateDesc = 'COMMISSION_RATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdCountryNameAsc = 'COUNTRY_BY_COUNTRY_ID__COUNTRY_NAME_ASC',
  CountryByCountryIdCountryNameDesc = 'COUNTRY_BY_COUNTRY_ID__COUNTRY_NAME_DESC',
  CountryByCountryIdCmbIdAsc = 'COUNTRY_BY_COUNTRY_ID__CMB_ID_ASC',
  CountryByCountryIdCmbIdDesc = 'COUNTRY_BY_COUNTRY_ID__CMB_ID_DESC',
  ShipperProjectionVesselsByShipperIdCountAsc = 'SHIPPER_PROJECTION_VESSELS_BY_SHIPPER_ID__COUNT_ASC',
  ShipperProjectionVesselsByShipperIdCountDesc = 'SHIPPER_PROJECTION_VESSELS_BY_SHIPPER_ID__COUNT_DESC',
  ShipperProjectionProductsByShipperIdCountAsc = 'SHIPPER_PROJECTION_PRODUCTS_BY_SHIPPER_ID__COUNT_ASC',
  ShipperProjectionProductsByShipperIdCountDesc = 'SHIPPER_PROJECTION_PRODUCTS_BY_SHIPPER_ID__COUNT_DESC',
  ShipperProjectionsByShipperIdCountAsc = 'SHIPPER_PROJECTIONS_BY_SHIPPER_ID__COUNT_ASC',
  ShipperProjectionsByShipperIdCountDesc = 'SHIPPER_PROJECTIONS_BY_SHIPPER_ID__COUNT_DESC',
  ShipperPersonContactsByShipperIdCountAsc = 'SHIPPER_PERSON_CONTACTS_BY_SHIPPER_ID__COUNT_ASC',
  ShipperPersonContactsByShipperIdCountDesc = 'SHIPPER_PERSON_CONTACTS_BY_SHIPPER_ID__COUNT_DESC',
  ShipperProjectionVesselInfosByShipperIdCountAsc = 'SHIPPER_PROJECTION_VESSEL_INFOS_BY_SHIPPER_ID__COUNT_ASC',
  ShipperProjectionVesselInfosByShipperIdCountDesc = 'SHIPPER_PROJECTION_VESSEL_INFOS_BY_SHIPPER_ID__COUNT_DESC',
  ShipperProgramsByShipperIdCountAsc = 'SHIPPER_PROGRAMS_BY_SHIPPER_ID__COUNT_ASC',
  ShipperProgramsByShipperIdCountDesc = 'SHIPPER_PROGRAMS_BY_SHIPPER_ID__COUNT_DESC',
  ShipperAdvancesByShipperIdCountAsc = 'SHIPPER_ADVANCES_BY_SHIPPER_ID__COUNT_ASC',
  ShipperAdvancesByShipperIdCountDesc = 'SHIPPER_ADVANCES_BY_SHIPPER_ID__COUNT_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contains the specified list of values. */
  contains?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contained by the specified list of values. */
  containedBy?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Any array item is equal to the specified value. */
  anyEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: Maybe<Scalars['String']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: Maybe<Scalars['String']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: Maybe<Scalars['String']>;
};

export type TruckLoad = Node & {
  __typename?: 'TruckLoad';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  loadId?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  ryanNumber?: Maybe<Scalars['String']>;
  truckerName?: Maybe<Scalars['String']>;
  expeditorName?: Maybe<Scalars['String']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeIn?: Maybe<Scalars['Datetime']>;
  timeOut?: Maybe<Scalars['Datetime']>;
  timeConfirmed?: Maybe<Scalars['Datetime']>;
  warehouseId?: Maybe<Scalars['String']>;
  changeFlag?: Maybe<Scalars['Boolean']>;
  licensePlate?: Maybe<Scalars['String']>;
  inUse?: Maybe<Scalars['Boolean']>;
  cartage?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  loadLock?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  shipDate?: Maybe<Scalars['Date']>;
  cartageVendorId?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `InvoiceHeader`. */
  invoiceHeaders: InvoiceHeadersConnection;
  orderMaster?: Maybe<OrderMaster>;
  originalTruckLoad?: Maybe<TruckLoad>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets: PalletsConnection;
  /** Reads and enables pagination through a set of `TruckLoad`. */
  rejectedTruckLoads: TruckLoadsConnection;
  searchText?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `TruckLoad`. */
  splitTruckLoads: TruckLoadsConnection;
  vendor?: Maybe<Vendor>;
  warehouse?: Maybe<Warehouse>;
};


export type TruckLoadInvoiceHeadersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InvoiceHeaderFilter>;
};


export type TruckLoadPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletFilter>;
};


export type TruckLoadRejectedTruckLoadsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<TruckLoadFilter>;
};


export type TruckLoadSplitTruckLoadsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<TruckLoadFilter>;
};

/**
 * A condition to be used against `TruckLoad` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TruckLoadCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `loadId` field. */
  loadId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `loadStatus` field. */
  loadStatus?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fob` field. */
  fob?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `ryanNumber` field. */
  ryanNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `truckerName` field. */
  truckerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `expeditorName` field. */
  expeditorName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `timeStarted` field. */
  timeStarted?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeCompleted` field. */
  timeCompleted?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeIn` field. */
  timeIn?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeOut` field. */
  timeOut?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeConfirmed` field. */
  timeConfirmed?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `changeFlag` field. */
  changeFlag?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `licensePlate` field. */
  licensePlate?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inUse` field. */
  inUse?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `cartage` field. */
  cartage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `temperature` field. */
  temperature?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `loadLock` field. */
  loadLock?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipDate` field. */
  shipDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `cartageVendorId` field. */
  cartageVendorId?: Maybe<Scalars['String']>;
};

/** A filter to be used against `TruckLoad` object types. All fields are combined with a logical ‘and.’ */
export type TruckLoadFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `loadId` field. */
  loadId?: Maybe<StringFilter>;
  /** Filter by the object’s `loadStatus` field. */
  loadStatus?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `fob` field. */
  fob?: Maybe<BooleanFilter>;
  /** Filter by the object’s `ryanNumber` field. */
  ryanNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `truckerName` field. */
  truckerName?: Maybe<StringFilter>;
  /** Filter by the object’s `expeditorName` field. */
  expeditorName?: Maybe<StringFilter>;
  /** Filter by the object’s `timeStarted` field. */
  timeStarted?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeCompleted` field. */
  timeCompleted?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeIn` field. */
  timeIn?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeOut` field. */
  timeOut?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeConfirmed` field. */
  timeConfirmed?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `changeFlag` field. */
  changeFlag?: Maybe<BooleanFilter>;
  /** Filter by the object’s `licensePlate` field. */
  licensePlate?: Maybe<StringFilter>;
  /** Filter by the object’s `inUse` field. */
  inUse?: Maybe<BooleanFilter>;
  /** Filter by the object’s `cartage` field. */
  cartage?: Maybe<StringFilter>;
  /** Filter by the object’s `temperature` field. */
  temperature?: Maybe<StringFilter>;
  /** Filter by the object’s `loadLock` field. */
  loadLock?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `shipDate` field. */
  shipDate?: Maybe<DateFilter>;
  /** Filter by the object’s `cartageVendorId` field. */
  cartageVendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: Maybe<IntFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TruckLoadFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TruckLoadFilter>>;
  /** Negates the expression. */
  not?: Maybe<TruckLoadFilter>;
};

/** An input for mutations affecting `TruckLoad` */
export type TruckLoadInput = {
  id?: Maybe<Scalars['BigInt']>;
  loadId?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  ryanNumber?: Maybe<Scalars['String']>;
  truckerName?: Maybe<Scalars['String']>;
  expeditorName?: Maybe<Scalars['String']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeIn?: Maybe<Scalars['Datetime']>;
  timeOut?: Maybe<Scalars['Datetime']>;
  timeConfirmed?: Maybe<Scalars['Datetime']>;
  warehouseId?: Maybe<Scalars['String']>;
  changeFlag?: Maybe<Scalars['Boolean']>;
  licensePlate?: Maybe<Scalars['String']>;
  inUse?: Maybe<Scalars['Boolean']>;
  cartage?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  loadLock?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  shipDate?: Maybe<Scalars['Date']>;
  cartageVendorId?: Maybe<Scalars['String']>;
};

/** Represents an update to a `TruckLoad`. Fields that are set will be updated. */
export type TruckLoadPatch = {
  id?: Maybe<Scalars['BigInt']>;
  loadId?: Maybe<Scalars['String']>;
  loadStatus?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  ryanNumber?: Maybe<Scalars['String']>;
  truckerName?: Maybe<Scalars['String']>;
  expeditorName?: Maybe<Scalars['String']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeIn?: Maybe<Scalars['Datetime']>;
  timeOut?: Maybe<Scalars['Datetime']>;
  timeConfirmed?: Maybe<Scalars['Datetime']>;
  warehouseId?: Maybe<Scalars['String']>;
  changeFlag?: Maybe<Scalars['Boolean']>;
  licensePlate?: Maybe<Scalars['String']>;
  inUse?: Maybe<Scalars['Boolean']>;
  cartage?: Maybe<Scalars['String']>;
  temperature?: Maybe<Scalars['String']>;
  loadLock?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  shipDate?: Maybe<Scalars['Date']>;
  cartageVendorId?: Maybe<Scalars['String']>;
};

/** A connection to a list of `TruckLoad` values. */
export type TruckLoadsConnection = {
  __typename?: 'TruckLoadsConnection';
  /** A list of `TruckLoad` objects. */
  nodes: Array<Maybe<TruckLoad>>;
  /** A list of edges which contains the `TruckLoad` and cursor to aid in pagination. */
  edges: Array<TruckLoadsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TruckLoad` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TruckLoad` edge in the connection. */
export type TruckLoadsEdge = {
  __typename?: 'TruckLoadsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TruckLoad` at the end of the edge. */
  node?: Maybe<TruckLoad>;
};

/** Methods to use when ordering `TruckLoad`. */
export enum TruckLoadsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LoadIdAsc = 'LOAD_ID_ASC',
  LoadIdDesc = 'LOAD_ID_DESC',
  LoadStatusAsc = 'LOAD_STATUS_ASC',
  LoadStatusDesc = 'LOAD_STATUS_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  FobAsc = 'FOB_ASC',
  FobDesc = 'FOB_DESC',
  RyanNumberAsc = 'RYAN_NUMBER_ASC',
  RyanNumberDesc = 'RYAN_NUMBER_DESC',
  TruckerNameAsc = 'TRUCKER_NAME_ASC',
  TruckerNameDesc = 'TRUCKER_NAME_DESC',
  ExpeditorNameAsc = 'EXPEDITOR_NAME_ASC',
  ExpeditorNameDesc = 'EXPEDITOR_NAME_DESC',
  TimeStartedAsc = 'TIME_STARTED_ASC',
  TimeStartedDesc = 'TIME_STARTED_DESC',
  TimeCompletedAsc = 'TIME_COMPLETED_ASC',
  TimeCompletedDesc = 'TIME_COMPLETED_DESC',
  TimeInAsc = 'TIME_IN_ASC',
  TimeInDesc = 'TIME_IN_DESC',
  TimeOutAsc = 'TIME_OUT_ASC',
  TimeOutDesc = 'TIME_OUT_DESC',
  TimeConfirmedAsc = 'TIME_CONFIRMED_ASC',
  TimeConfirmedDesc = 'TIME_CONFIRMED_DESC',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  ChangeFlagAsc = 'CHANGE_FLAG_ASC',
  ChangeFlagDesc = 'CHANGE_FLAG_DESC',
  LicensePlateAsc = 'LICENSE_PLATE_ASC',
  LicensePlateDesc = 'LICENSE_PLATE_DESC',
  InUseAsc = 'IN_USE_ASC',
  InUseDesc = 'IN_USE_DESC',
  CartageAsc = 'CARTAGE_ASC',
  CartageDesc = 'CARTAGE_DESC',
  TemperatureAsc = 'TEMPERATURE_ASC',
  TemperatureDesc = 'TEMPERATURE_DESC',
  LoadLockAsc = 'LOAD_LOCK_ASC',
  LoadLockDesc = 'LOAD_LOCK_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  ShipDateAsc = 'SHIP_DATE_ASC',
  ShipDateDesc = 'SHIP_DATE_DESC',
  CartageVendorIdAsc = 'CARTAGE_VENDOR_ID_ASC',
  CartageVendorIdDesc = 'CARTAGE_VENDOR_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type TruckRate = Node & {
  __typename?: 'TruckRate';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  locationDescription?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  isDefault?: Maybe<Scalars['Boolean']>;
  fullLoadRate?: Maybe<Scalars['BigFloat']>;
  palletRate1?: Maybe<Scalars['BigFloat']>;
  palletRate2?: Maybe<Scalars['BigFloat']>;
  palletRate3?: Maybe<Scalars['BigFloat']>;
  palletRate4?: Maybe<Scalars['BigFloat']>;
  palletRate5?: Maybe<Scalars['BigFloat']>;
  palletRate6?: Maybe<Scalars['BigFloat']>;
  palletRate7?: Maybe<Scalars['BigFloat']>;
  palletRate8?: Maybe<Scalars['BigFloat']>;
  palletRate9?: Maybe<Scalars['BigFloat']>;
  palletRate10?: Maybe<Scalars['BigFloat']>;
  palletRate11?: Maybe<Scalars['BigFloat']>;
  palletRate12?: Maybe<Scalars['BigFloat']>;
  palletRate13?: Maybe<Scalars['BigFloat']>;
  palletRate14?: Maybe<Scalars['BigFloat']>;
  palletRate15?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `TruckRateCustomer`. */
  truckRateCustomers: TruckRateCustomersConnection;
  vendor?: Maybe<Vendor>;
  /** Reads and enables pagination through a set of `Customer`. */
  customersByTruckRateCustomerTruckRateIdAndCustomerId: TruckRateCustomersByTruckRateCustomerTruckRateIdAndCustomerIdManyToManyConnection;
};


export type TruckRateTruckRateCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TruckRateCustomersOrderBy>>;
  condition?: Maybe<TruckRateCustomerCondition>;
  filter?: Maybe<TruckRateCustomerFilter>;
};


export type TruckRateCustomersByTruckRateCustomerTruckRateIdAndCustomerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};

/**
 * A condition to be used against `TruckRate` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TruckRateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `locationDescription` field. */
  locationDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalState` field. */
  postalState?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isDefault` field. */
  isDefault?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `fullLoadRate` field. */
  fullLoadRate?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate1` field. */
  palletRate1?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate2` field. */
  palletRate2?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate3` field. */
  palletRate3?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate4` field. */
  palletRate4?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate5` field. */
  palletRate5?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate6` field. */
  palletRate6?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate7` field. */
  palletRate7?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate8` field. */
  palletRate8?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate9` field. */
  palletRate9?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate10` field. */
  palletRate10?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate11` field. */
  palletRate11?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate12` field. */
  palletRate12?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate13` field. */
  palletRate13?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate14` field. */
  palletRate14?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `palletRate15` field. */
  palletRate15?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

export type TruckRateCustomer = Node & {
  __typename?: 'TruckRateCustomer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
  /** Reads a single `TruckRate` that is related to this `TruckRateCustomer`. */
  truckRate?: Maybe<TruckRate>;
  /** Reads a single `Customer` that is related to this `TruckRateCustomer`. */
  customer?: Maybe<Customer>;
};

/**
 * A condition to be used against `TruckRateCustomer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TruckRateCustomerCondition = {
  /** Checks for equality with the object’s `truckRateId` field. */
  truckRateId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['String']>;
};

/** The `customer` to be created by this mutation. */
export type TruckRateCustomerCustomerIdFkeyCustomerCreateInput = {
  id: Scalars['String'];
  customerName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active: Scalars['Boolean'];
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** Input for the nested mutation of `customer` in the `TruckRateCustomerInput` mutation. */
export type TruckRateCustomerCustomerIdFkeyInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerCustomerPkeyConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerCustomerPkeyDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyUsingCustomerPkeyUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<TruckRateCustomerCustomerIdFkeyCustomerCreateInput>;
};

/** Input for the nested mutation of `truckRateCustomer` in the `CustomerInput` mutation. */
export type TruckRateCustomerCustomerIdFkeyInverseInput = {
  /** Flag indicating whether all other `truckRateCustomer` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  connectByTruckRateIdAndCustomerId?: Maybe<Array<TruckRateCustomerTruckRateCustomerPkeyConnect>>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TruckRateCustomerNodeIdConnect>>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  deleteByTruckRateIdAndCustomerId?: Maybe<Array<TruckRateCustomerTruckRateCustomerPkeyDelete>>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TruckRateCustomerNodeIdDelete>>;
  /** The primary key(s) and patch data for `truckRateCustomer` for the far side of the relationship. */
  updateByTruckRateIdAndCustomerId?: Maybe<Array<TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyUsingTruckRateCustomerPkeyUpdate>>;
  /** The primary key(s) and patch data for `truckRateCustomer` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyNodeIdUpdate>>;
  /** A `TruckRateCustomerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TruckRateCustomerCustomerIdFkeyTruckRateCustomerCreateInput>>;
};

/** The `truckRateCustomer` to be created by this mutation. */
export type TruckRateCustomerCustomerIdFkeyTruckRateCustomerCreateInput = {
  truckRateId?: Maybe<Scalars['BigInt']>;
  truckRateToTruckRateId?: Maybe<TruckRateCustomerTruckRateIdFkeyInput>;
  customerToCustomerId?: Maybe<TruckRateCustomerCustomerIdFkeyInput>;
};

/** A filter to be used against `TruckRateCustomer` object types. All fields are combined with a logical ‘and.’ */
export type TruckRateCustomerFilter = {
  /** Filter by the object’s `truckRateId` field. */
  truckRateId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<StringFilter>;
  /** Filter by the object’s `truckRate` relation. */
  truckRate?: Maybe<TruckRateFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TruckRateCustomerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TruckRateCustomerFilter>>;
  /** Negates the expression. */
  not?: Maybe<TruckRateCustomerFilter>;
};

/** An input for mutations affecting `TruckRateCustomer` */
export type TruckRateCustomerInput = {
  truckRateId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  truckRateToTruckRateId?: Maybe<TruckRateCustomerTruckRateIdFkeyInput>;
  customerToCustomerId?: Maybe<TruckRateCustomerCustomerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TruckRateCustomerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `truckRateCustomer` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TruckRateCustomerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `truckRateCustomer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The fields on `truckRateCustomer` to look up the row to update. */
export type TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyUsingTruckRateCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `truckRateCustomer` being updated. */
  patch: UpdateTruckRateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyPatch;
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `truckRate` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `truckRate` being updated. */
  patch: TruckRatePatch;
};

/** The fields on `truckRateCustomer` to look up the row to update. */
export type TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyUsingTruckRateCustomerPkeyUpdate = {
  /** An object where the defined keys will be set on the `truckRateCustomer` being updated. */
  patch: UpdateTruckRateCustomerOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyPatch;
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
};

/** Represents an update to a `TruckRateCustomer`. Fields that are set will be updated. */
export type TruckRateCustomerPatch = {
  truckRateId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  truckRateToTruckRateId?: Maybe<TruckRateCustomerTruckRateIdFkeyInput>;
  customerToCustomerId?: Maybe<TruckRateCustomerCustomerIdFkeyInput>;
};

/** The fields on `truckRateCustomer` to look up the row to connect. */
export type TruckRateCustomerTruckRateCustomerPkeyConnect = {
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
};

/** The fields on `truckRateCustomer` to look up the row to delete. */
export type TruckRateCustomerTruckRateCustomerPkeyDelete = {
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
};

/** Input for the nested mutation of `truckRate` in the `TruckRateCustomerInput` mutation. */
export type TruckRateCustomerTruckRateIdFkeyInput = {
  /** The primary key(s) for `truckRate` for the far side of the relationship. */
  connectById?: Maybe<TruckRateTruckRatePkeyConnect>;
  /** The primary key(s) for `truckRate` for the far side of the relationship. */
  connectByNodeId?: Maybe<TruckRateNodeIdConnect>;
  /** The primary key(s) for `truckRate` for the far side of the relationship. */
  deleteById?: Maybe<TruckRateTruckRatePkeyDelete>;
  /** The primary key(s) for `truckRate` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TruckRateNodeIdDelete>;
  /** The primary key(s) and patch data for `truckRate` for the far side of the relationship. */
  updateById?: Maybe<TruckRateOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyUsingTruckRatePkeyUpdate>;
  /** The primary key(s) and patch data for `truckRate` for the far side of the relationship. */
  updateByNodeId?: Maybe<TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyNodeIdUpdate>;
  /** A `TruckRateInput` object that will be created and connected to this object. */
  create?: Maybe<TruckRateCustomerTruckRateIdFkeyTruckRateCreateInput>;
};

/** Input for the nested mutation of `truckRateCustomer` in the `TruckRateInput` mutation. */
export type TruckRateCustomerTruckRateIdFkeyInverseInput = {
  /** Flag indicating whether all other `truckRateCustomer` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  connectByTruckRateIdAndCustomerId?: Maybe<Array<TruckRateCustomerTruckRateCustomerPkeyConnect>>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TruckRateCustomerNodeIdConnect>>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  deleteByTruckRateIdAndCustomerId?: Maybe<Array<TruckRateCustomerTruckRateCustomerPkeyDelete>>;
  /** The primary key(s) for `truckRateCustomer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TruckRateCustomerNodeIdDelete>>;
  /** The primary key(s) and patch data for `truckRateCustomer` for the far side of the relationship. */
  updateByTruckRateIdAndCustomerId?: Maybe<Array<TruckRateCustomerOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyUsingTruckRateCustomerPkeyUpdate>>;
  /** The primary key(s) and patch data for `truckRateCustomer` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TruckRateOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyNodeIdUpdate>>;
  /** A `TruckRateCustomerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TruckRateCustomerTruckRateIdFkeyTruckRateCustomerCreateInput>>;
};

/** The `truckRate` to be created by this mutation. */
export type TruckRateCustomerTruckRateIdFkeyTruckRateCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  locationDescription?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  isDefault?: Maybe<Scalars['Boolean']>;
  fullLoadRate?: Maybe<Scalars['BigFloat']>;
  palletRate1?: Maybe<Scalars['BigFloat']>;
  palletRate2?: Maybe<Scalars['BigFloat']>;
  palletRate3?: Maybe<Scalars['BigFloat']>;
  palletRate4?: Maybe<Scalars['BigFloat']>;
  palletRate5?: Maybe<Scalars['BigFloat']>;
  palletRate6?: Maybe<Scalars['BigFloat']>;
  palletRate7?: Maybe<Scalars['BigFloat']>;
  palletRate8?: Maybe<Scalars['BigFloat']>;
  palletRate9?: Maybe<Scalars['BigFloat']>;
  palletRate10?: Maybe<Scalars['BigFloat']>;
  palletRate11?: Maybe<Scalars['BigFloat']>;
  palletRate12?: Maybe<Scalars['BigFloat']>;
  palletRate13?: Maybe<Scalars['BigFloat']>;
  palletRate14?: Maybe<Scalars['BigFloat']>;
  palletRate15?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerTruckRateIdFkeyInverseInput>;
};

/** The `truckRateCustomer` to be created by this mutation. */
export type TruckRateCustomerTruckRateIdFkeyTruckRateCustomerCreateInput = {
  customerId?: Maybe<Scalars['String']>;
  truckRateToTruckRateId?: Maybe<TruckRateCustomerTruckRateIdFkeyInput>;
  customerToCustomerId?: Maybe<TruckRateCustomerCustomerIdFkeyInput>;
};

/** A connection to a list of `Customer` values, with data from `TruckRateCustomer`. */
export type TruckRateCustomersByTruckRateCustomerTruckRateIdAndCustomerIdManyToManyConnection = {
  __typename?: 'TruckRateCustomersByTruckRateCustomerTruckRateIdAndCustomerIdManyToManyConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer`, info from the `TruckRateCustomer`, and the cursor to aid in pagination. */
  edges: Array<TruckRateCustomersByTruckRateCustomerTruckRateIdAndCustomerIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection, with data from `TruckRateCustomer`. */
export type TruckRateCustomersByTruckRateCustomerTruckRateIdAndCustomerIdManyToManyEdge = {
  __typename?: 'TruckRateCustomersByTruckRateCustomerTruckRateIdAndCustomerIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** A connection to a list of `TruckRateCustomer` values. */
export type TruckRateCustomersConnection = {
  __typename?: 'TruckRateCustomersConnection';
  /** A list of `TruckRateCustomer` objects. */
  nodes: Array<Maybe<TruckRateCustomer>>;
  /** A list of edges which contains the `TruckRateCustomer` and cursor to aid in pagination. */
  edges: Array<TruckRateCustomersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TruckRateCustomer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TruckRateCustomer` edge in the connection. */
export type TruckRateCustomersEdge = {
  __typename?: 'TruckRateCustomersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TruckRateCustomer` at the end of the edge. */
  node?: Maybe<TruckRateCustomer>;
};

/** Methods to use when ordering `TruckRateCustomer`. */
export enum TruckRateCustomersOrderBy {
  Natural = 'NATURAL',
  TruckRateIdAsc = 'TRUCK_RATE_ID_ASC',
  TruckRateIdDesc = 'TRUCK_RATE_ID_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TruckRateByTruckRateIdIdAsc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__ID_ASC',
  TruckRateByTruckRateIdIdDesc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__ID_DESC',
  TruckRateByTruckRateIdLocationDescriptionAsc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__LOCATION_DESCRIPTION_ASC',
  TruckRateByTruckRateIdLocationDescriptionDesc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__LOCATION_DESCRIPTION_DESC',
  TruckRateByTruckRateIdVendorIdAsc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__VENDOR_ID_ASC',
  TruckRateByTruckRateIdVendorIdDesc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__VENDOR_ID_DESC',
  TruckRateByTruckRateIdPostalStateAsc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__POSTAL_STATE_ASC',
  TruckRateByTruckRateIdPostalStateDesc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__POSTAL_STATE_DESC',
  TruckRateByTruckRateIdIsDefaultAsc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__IS_DEFAULT_ASC',
  TruckRateByTruckRateIdIsDefaultDesc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__IS_DEFAULT_DESC',
  TruckRateByTruckRateIdFullLoadRateAsc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__FULL_LOAD_RATE_ASC',
  TruckRateByTruckRateIdFullLoadRateDesc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__FULL_LOAD_RATE_DESC',
  TruckRateByTruckRateIdPalletRate_1Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_1_ASC',
  TruckRateByTruckRateIdPalletRate_1Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_1_DESC',
  TruckRateByTruckRateIdPalletRate_2Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_2_ASC',
  TruckRateByTruckRateIdPalletRate_2Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_2_DESC',
  TruckRateByTruckRateIdPalletRate_3Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_3_ASC',
  TruckRateByTruckRateIdPalletRate_3Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_3_DESC',
  TruckRateByTruckRateIdPalletRate_4Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_4_ASC',
  TruckRateByTruckRateIdPalletRate_4Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_4_DESC',
  TruckRateByTruckRateIdPalletRate_5Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_5_ASC',
  TruckRateByTruckRateIdPalletRate_5Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_5_DESC',
  TruckRateByTruckRateIdPalletRate_6Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_6_ASC',
  TruckRateByTruckRateIdPalletRate_6Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_6_DESC',
  TruckRateByTruckRateIdPalletRate_7Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_7_ASC',
  TruckRateByTruckRateIdPalletRate_7Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_7_DESC',
  TruckRateByTruckRateIdPalletRate_8Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_8_ASC',
  TruckRateByTruckRateIdPalletRate_8Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_8_DESC',
  TruckRateByTruckRateIdPalletRate_9Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_9_ASC',
  TruckRateByTruckRateIdPalletRate_9Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_9_DESC',
  TruckRateByTruckRateIdPalletRate_10Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_10_ASC',
  TruckRateByTruckRateIdPalletRate_10Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_10_DESC',
  TruckRateByTruckRateIdPalletRate_11Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_11_ASC',
  TruckRateByTruckRateIdPalletRate_11Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_11_DESC',
  TruckRateByTruckRateIdPalletRate_12Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_12_ASC',
  TruckRateByTruckRateIdPalletRate_12Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_12_DESC',
  TruckRateByTruckRateIdPalletRate_13Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_13_ASC',
  TruckRateByTruckRateIdPalletRate_13Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_13_DESC',
  TruckRateByTruckRateIdPalletRate_14Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_14_ASC',
  TruckRateByTruckRateIdPalletRate_14Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_14_DESC',
  TruckRateByTruckRateIdPalletRate_15Asc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_15_ASC',
  TruckRateByTruckRateIdPalletRate_15Desc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__PALLET_RATE_15_DESC',
  TruckRateByTruckRateIdNotesAsc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__NOTES_ASC',
  TruckRateByTruckRateIdNotesDesc = 'TRUCK_RATE_BY_TRUCK_RATE_ID__NOTES_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCustomerNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_ASC',
  CustomerByCustomerIdCustomerNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__CUSTOMER_NAME_DESC',
  CustomerByCustomerIdAddress_1Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_ASC',
  CustomerByCustomerIdAddress_1Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_1_DESC',
  CustomerByCustomerIdAddress_2Asc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_ASC',
  CustomerByCustomerIdAddress_2Desc = 'CUSTOMER_BY_CUSTOMER_ID__ADDRESS_2_DESC',
  CustomerByCustomerIdCityAsc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_ASC',
  CustomerByCustomerIdCityDesc = 'CUSTOMER_BY_CUSTOMER_ID__CITY_DESC',
  CustomerByCustomerIdPostalStateAsc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_ASC',
  CustomerByCustomerIdPostalStateDesc = 'CUSTOMER_BY_CUSTOMER_ID__POSTAL_STATE_DESC',
  CustomerByCustomerIdZipCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_ASC',
  CustomerByCustomerIdZipCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__ZIP_CODE_DESC',
  CustomerByCustomerIdCountryIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_ASC',
  CustomerByCustomerIdCountryIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__COUNTRY_ID_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerByCustomerIdLogoSrcAsc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_ASC',
  CustomerByCustomerIdLogoSrcDesc = 'CUSTOMER_BY_CUSTOMER_ID__LOGO_SRC_DESC',
  CustomerByCustomerIdNotesAsc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_ASC',
  CustomerByCustomerIdNotesDesc = 'CUSTOMER_BY_CUSTOMER_ID__NOTES_DESC',
  CustomerByCustomerIdWebsiteAsc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_ASC',
  CustomerByCustomerIdWebsiteDesc = 'CUSTOMER_BY_CUSTOMER_ID__WEBSITE_DESC',
  CustomerByCustomerIdActiveAsc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_ASC',
  CustomerByCustomerIdActiveDesc = 'CUSTOMER_BY_CUSTOMER_ID__ACTIVE_DESC',
  CustomerByCustomerIdSalesUserCodeAsc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_ASC',
  CustomerByCustomerIdSalesUserCodeDesc = 'CUSTOMER_BY_CUSTOMER_ID__SALES_USER_CODE_DESC'
}

/** A filter to be used against `TruckRate` object types. All fields are combined with a logical ‘and.’ */
export type TruckRateFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `locationDescription` field. */
  locationDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `postalState` field. */
  postalState?: Maybe<StringFilter>;
  /** Filter by the object’s `isDefault` field. */
  isDefault?: Maybe<BooleanFilter>;
  /** Filter by the object’s `fullLoadRate` field. */
  fullLoadRate?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate1` field. */
  palletRate1?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate2` field. */
  palletRate2?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate3` field. */
  palletRate3?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate4` field. */
  palletRate4?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate5` field. */
  palletRate5?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate6` field. */
  palletRate6?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate7` field. */
  palletRate7?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate8` field. */
  palletRate8?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate9` field. */
  palletRate9?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate10` field. */
  palletRate10?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate11` field. */
  palletRate11?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate12` field. */
  palletRate12?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate13` field. */
  palletRate13?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate14` field. */
  palletRate14?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `palletRate15` field. */
  palletRate15?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `truckRateCustomers` relation. */
  truckRateCustomers?: Maybe<TruckRateToManyTruckRateCustomerFilter>;
  /** Some related `truckRateCustomers` exist. */
  truckRateCustomersExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TruckRateFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TruckRateFilter>>;
  /** Negates the expression. */
  not?: Maybe<TruckRateFilter>;
};

/** An input for mutations affecting `TruckRate` */
export type TruckRateInput = {
  id?: Maybe<Scalars['BigInt']>;
  locationDescription?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  isDefault?: Maybe<Scalars['Boolean']>;
  fullLoadRate?: Maybe<Scalars['BigFloat']>;
  palletRate1?: Maybe<Scalars['BigFloat']>;
  palletRate2?: Maybe<Scalars['BigFloat']>;
  palletRate3?: Maybe<Scalars['BigFloat']>;
  palletRate4?: Maybe<Scalars['BigFloat']>;
  palletRate5?: Maybe<Scalars['BigFloat']>;
  palletRate6?: Maybe<Scalars['BigFloat']>;
  palletRate7?: Maybe<Scalars['BigFloat']>;
  palletRate8?: Maybe<Scalars['BigFloat']>;
  palletRate9?: Maybe<Scalars['BigFloat']>;
  palletRate10?: Maybe<Scalars['BigFloat']>;
  palletRate11?: Maybe<Scalars['BigFloat']>;
  palletRate12?: Maybe<Scalars['BigFloat']>;
  palletRate13?: Maybe<Scalars['BigFloat']>;
  palletRate14?: Maybe<Scalars['BigFloat']>;
  palletRate15?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerTruckRateIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TruckRateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `truckRate` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TruckRateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `truckRate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TruckRateOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `truckRateCustomer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `truckRateCustomer` being updated. */
  patch: TruckRateCustomerPatch;
};

/** The fields on `truckRate` to look up the row to update. */
export type TruckRateOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyUsingTruckRatePkeyUpdate = {
  /** An object where the defined keys will be set on the `truckRate` being updated. */
  patch: UpdateTruckRateOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `TruckRate`. Fields that are set will be updated. */
export type TruckRatePatch = {
  id?: Maybe<Scalars['BigInt']>;
  locationDescription?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  isDefault?: Maybe<Scalars['Boolean']>;
  fullLoadRate?: Maybe<Scalars['BigFloat']>;
  palletRate1?: Maybe<Scalars['BigFloat']>;
  palletRate2?: Maybe<Scalars['BigFloat']>;
  palletRate3?: Maybe<Scalars['BigFloat']>;
  palletRate4?: Maybe<Scalars['BigFloat']>;
  palletRate5?: Maybe<Scalars['BigFloat']>;
  palletRate6?: Maybe<Scalars['BigFloat']>;
  palletRate7?: Maybe<Scalars['BigFloat']>;
  palletRate8?: Maybe<Scalars['BigFloat']>;
  palletRate9?: Maybe<Scalars['BigFloat']>;
  palletRate10?: Maybe<Scalars['BigFloat']>;
  palletRate11?: Maybe<Scalars['BigFloat']>;
  palletRate12?: Maybe<Scalars['BigFloat']>;
  palletRate13?: Maybe<Scalars['BigFloat']>;
  palletRate14?: Maybe<Scalars['BigFloat']>;
  palletRate15?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerTruckRateIdFkeyInverseInput>;
};

/** A filter to be used against many `TruckRateCustomer` object types. All fields are combined with a logical ‘and.’ */
export type TruckRateToManyTruckRateCustomerFilter = {
  /** Every related `TruckRateCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TruckRateCustomerFilter>;
  /** Some related `TruckRateCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TruckRateCustomerFilter>;
  /** No related `TruckRateCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TruckRateCustomerFilter>;
};

/** The fields on `truckRate` to look up the row to connect. */
export type TruckRateTruckRatePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `truckRate` to look up the row to delete. */
export type TruckRateTruckRatePkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `TruckRate` values. */
export type TruckRatesConnection = {
  __typename?: 'TruckRatesConnection';
  /** A list of `TruckRate` objects. */
  nodes: Array<Maybe<TruckRate>>;
  /** A list of edges which contains the `TruckRate` and cursor to aid in pagination. */
  edges: Array<TruckRatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TruckRate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TruckRate` edge in the connection. */
export type TruckRatesEdge = {
  __typename?: 'TruckRatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TruckRate` at the end of the edge. */
  node?: Maybe<TruckRate>;
};

/** Methods to use when ordering `TruckRate`. */
export enum TruckRatesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocationDescriptionAsc = 'LOCATION_DESCRIPTION_ASC',
  LocationDescriptionDesc = 'LOCATION_DESCRIPTION_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  PostalStateAsc = 'POSTAL_STATE_ASC',
  PostalStateDesc = 'POSTAL_STATE_DESC',
  IsDefaultAsc = 'IS_DEFAULT_ASC',
  IsDefaultDesc = 'IS_DEFAULT_DESC',
  FullLoadRateAsc = 'FULL_LOAD_RATE_ASC',
  FullLoadRateDesc = 'FULL_LOAD_RATE_DESC',
  PalletRate_1Asc = 'PALLET_RATE_1_ASC',
  PalletRate_1Desc = 'PALLET_RATE_1_DESC',
  PalletRate_2Asc = 'PALLET_RATE_2_ASC',
  PalletRate_2Desc = 'PALLET_RATE_2_DESC',
  PalletRate_3Asc = 'PALLET_RATE_3_ASC',
  PalletRate_3Desc = 'PALLET_RATE_3_DESC',
  PalletRate_4Asc = 'PALLET_RATE_4_ASC',
  PalletRate_4Desc = 'PALLET_RATE_4_DESC',
  PalletRate_5Asc = 'PALLET_RATE_5_ASC',
  PalletRate_5Desc = 'PALLET_RATE_5_DESC',
  PalletRate_6Asc = 'PALLET_RATE_6_ASC',
  PalletRate_6Desc = 'PALLET_RATE_6_DESC',
  PalletRate_7Asc = 'PALLET_RATE_7_ASC',
  PalletRate_7Desc = 'PALLET_RATE_7_DESC',
  PalletRate_8Asc = 'PALLET_RATE_8_ASC',
  PalletRate_8Desc = 'PALLET_RATE_8_DESC',
  PalletRate_9Asc = 'PALLET_RATE_9_ASC',
  PalletRate_9Desc = 'PALLET_RATE_9_DESC',
  PalletRate_10Asc = 'PALLET_RATE_10_ASC',
  PalletRate_10Desc = 'PALLET_RATE_10_DESC',
  PalletRate_11Asc = 'PALLET_RATE_11_ASC',
  PalletRate_11Desc = 'PALLET_RATE_11_DESC',
  PalletRate_12Asc = 'PALLET_RATE_12_ASC',
  PalletRate_12Desc = 'PALLET_RATE_12_DESC',
  PalletRate_13Asc = 'PALLET_RATE_13_ASC',
  PalletRate_13Desc = 'PALLET_RATE_13_DESC',
  PalletRate_14Asc = 'PALLET_RATE_14_ASC',
  PalletRate_14Desc = 'PALLET_RATE_14_DESC',
  PalletRate_15Asc = 'PALLET_RATE_15_ASC',
  PalletRate_15Desc = 'PALLET_RATE_15_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TruckRateCustomersByTruckRateIdCountAsc = 'TRUCK_RATE_CUSTOMERS_BY_TRUCK_RATE_ID__COUNT_ASC',
  TruckRateCustomersByTruckRateIdCountDesc = 'TRUCK_RATE_CUSTOMERS_BY_TRUCK_RATE_ID__COUNT_DESC'
}

export type Unpaid = Node & {
  __typename?: 'Unpaid';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselCode: Scalars['String'];
  shipperId: Scalars['String'];
  invoiceId: Scalars['String'];
  isUrgent?: Maybe<Scalars['Boolean']>;
  isApproved?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  invoice?: Maybe<InvoiceHeader>;
  isPaid?: Maybe<Scalars['Boolean']>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
  vesselControl?: Maybe<VesselControl>;
};

/** A condition to be used against `Unpaid` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UnpaidCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isUrgent` field. */
  isUrgent?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `isApproved` field. */
  isApproved?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Unpaid` object types. All fields are combined with a logical ‘and.’ */
export type UnpaidFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<StringFilter>;
  /** Filter by the object’s `isUrgent` field. */
  isUrgent?: Maybe<BooleanFilter>;
  /** Filter by the object’s `isApproved` field. */
  isApproved?: Maybe<BooleanFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `isPaid` field. */
  isPaid?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UnpaidFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UnpaidFilter>>;
  /** Negates the expression. */
  not?: Maybe<UnpaidFilter>;
};

/** An input for mutations affecting `Unpaid` */
export type UnpaidInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  shipperId: Scalars['String'];
  invoiceId: Scalars['String'];
  isUrgent?: Maybe<Scalars['Boolean']>;
  isApproved?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
};

/** Represents an update to a `Unpaid`. Fields that are set will be updated. */
export type UnpaidPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['String']>;
  isUrgent?: Maybe<Scalars['Boolean']>;
  isApproved?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
};

export type UnpaidReminderInput = {
  invoiceId: Scalars['String'];
  customerName: Scalars['String'];
  flag: Scalars['String'];
  isUrgent: Scalars['Boolean'];
  truckLoadId: Scalars['String'];
};

export type UnpaidRemindersInput = {
  message: Scalars['String'];
  startOfWeek: Scalars['String'];
  endOfWeek: Scalars['String'];
  unpaidReminders: Array<Maybe<UnpaidSalesUserInput>>;
};

export type UnpaidSalesUserInput = {
  userCode: Scalars['String'];
  firstName: Scalars['String'];
  email: Scalars['String'];
  pastUnpaids: Array<Maybe<UnpaidVesselInput>>;
  currentUnpaids: Array<Maybe<UnpaidVesselInput>>;
  futureUnpaids: Array<Maybe<UnpaidVesselInput>>;
};

export type UnpaidShipperInput = {
  shipperId: Scalars['String'];
  shipperName: Scalars['String'];
  unpaids: Array<Maybe<UnpaidReminderInput>>;
};

export type UnpaidVesselInput = {
  vesselCode: Scalars['String'];
  vesselName: Scalars['String'];
  dueDate: Scalars['String'];
  shipDate: Scalars['String'];
  shippers: Array<Maybe<UnpaidShipperInput>>;
};

/** A connection to a list of `Unpaid` values. */
export type UnpaidsConnection = {
  __typename?: 'UnpaidsConnection';
  /** A list of `Unpaid` objects. */
  nodes: Array<Maybe<Unpaid>>;
  /** A list of edges which contains the `Unpaid` and cursor to aid in pagination. */
  edges: Array<UnpaidsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Unpaid` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Unpaid` edge in the connection. */
export type UnpaidsEdge = {
  __typename?: 'UnpaidsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Unpaid` at the end of the edge. */
  node?: Maybe<Unpaid>;
};

/** Methods to use when ordering `Unpaid`. */
export enum UnpaidsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  IsUrgentAsc = 'IS_URGENT_ASC',
  IsUrgentDesc = 'IS_URGENT_DESC',
  IsApprovedAsc = 'IS_APPROVED_ASC',
  IsApprovedDesc = 'IS_APPROVED_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `updateAgendaItemByNodeId` mutation. */
export type UpdateAgendaItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AgendaItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AgendaItem` being updated. */
  patch: AgendaItemPatch;
};

/** All input for the `updateAgendaItem` mutation. */
export type UpdateAgendaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `AgendaItem` being updated. */
  patch: AgendaItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `AgendaItem` mutation. */
export type UpdateAgendaItemPayload = {
  __typename?: 'UpdateAgendaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` that was updated by this mutation. */
  agendaItem?: Maybe<AgendaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AgendaItem`. May be used by Relay 1. */
  agendaItemEdge?: Maybe<AgendaItemsEdge>;
};


/** The output of our update `AgendaItem` mutation. */
export type UpdateAgendaItemPayloadAgendaItemEdgeArgs = {
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
};

/** All input for the `updateCalendarEventByNodeId` mutation. */
export type UpdateCalendarEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CalendarEvent` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CalendarEvent` being updated. */
  patch: CalendarEventPatch;
};

/** All input for the `updateCalendarEvent` mutation. */
export type UpdateCalendarEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CalendarEvent` being updated. */
  patch: CalendarEventPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CalendarEvent` mutation. */
export type UpdateCalendarEventPayload = {
  __typename?: 'UpdateCalendarEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` that was updated by this mutation. */
  calendarEvent?: Maybe<CalendarEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CalendarEvent`. May be used by Relay 1. */
  calendarEventEdge?: Maybe<CalendarEventsEdge>;
};


/** The output of our update `CalendarEvent` mutation. */
export type UpdateCalendarEventPayloadCalendarEventEdgeArgs = {
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
};

/** All input for the `updateCheckHeaderByNodeId` mutation. */
export type UpdateCheckHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CheckHeader` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CheckHeader` being updated. */
  patch: CheckHeaderPatch;
};

/** All input for the `updateCheckHeader` mutation. */
export type UpdateCheckHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CheckHeader` being updated. */
  patch: CheckHeaderPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CheckHeader` mutation. */
export type UpdateCheckHeaderPayload = {
  __typename?: 'UpdateCheckHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CheckHeader` that was updated by this mutation. */
  checkHeader?: Maybe<CheckHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CheckHeader`. May be used by Relay 1. */
  checkHeaderEdge?: Maybe<CheckHeadersEdge>;
};


/** The output of our update `CheckHeader` mutation. */
export type UpdateCheckHeaderPayloadCheckHeaderEdgeArgs = {
  orderBy?: Maybe<Array<CheckHeadersOrderBy>>;
};

/** All input for the `updateChileDepartureInspectionPalletByNodeId` mutation. */
export type UpdateChileDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ChileDepartureInspectionPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ChileDepartureInspectionPallet` being updated. */
  patch: ChileDepartureInspectionPalletPatch;
};

/** All input for the `updateChileDepartureInspectionPallet` mutation. */
export type UpdateChileDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ChileDepartureInspectionPallet` being updated. */
  patch: ChileDepartureInspectionPalletPatch;
  id: Scalars['String'];
};

/** The output of our update `ChileDepartureInspectionPallet` mutation. */
export type UpdateChileDepartureInspectionPalletPayload = {
  __typename?: 'UpdateChileDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` that was updated by this mutation. */
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ChileDepartureInspectionPallet`. May be used by Relay 1. */
  chileDepartureInspectionPalletEdge?: Maybe<ChileDepartureInspectionPalletsEdge>;
};


/** The output of our update `ChileDepartureInspectionPallet` mutation. */
export type UpdateChileDepartureInspectionPalletPayloadChileDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
};

/** All input for the `updateCommonCategoryByNodeId` mutation. */
export type UpdateCommonCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonCategory` being updated. */
  patch: CommonCategoryPatch;
};

/** All input for the `updateCommonCategory` mutation. */
export type UpdateCommonCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonCategory` being updated. */
  patch: CommonCategoryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonCategory` mutation. */
export type UpdateCommonCategoryPayload = {
  __typename?: 'UpdateCommonCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonCategory` that was updated by this mutation. */
  commonCategory?: Maybe<CommonCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CommonCategory`. May be used by Relay 1. */
  commonCategoryEdge?: Maybe<CommonCategoriesEdge>;
};


/** The output of our update `CommonCategory` mutation. */
export type UpdateCommonCategoryPayloadCommonCategoryEdgeArgs = {
  orderBy?: Maybe<Array<CommonCategoriesOrderBy>>;
};

/** All input for the `updateCommonPackTypeByNodeId` mutation. */
export type UpdateCommonPackTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonPackType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonPackType` being updated. */
  patch: CommonPackTypePatch;
};

/** All input for the `updateCommonPackType` mutation. */
export type UpdateCommonPackTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonPackType` being updated. */
  patch: CommonPackTypePatch;
  id: Scalars['BigInt'];
};

/** All input for the `updateCommonPackTypePackMasterByNodeId` mutation. */
export type UpdateCommonPackTypePackMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonPackTypePackMaster` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonPackTypePackMaster` being updated. */
  patch: CommonPackTypePackMasterPatch;
};

/** All input for the `updateCommonPackTypePackMaster` mutation. */
export type UpdateCommonPackTypePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonPackTypePackMaster` being updated. */
  patch: CommonPackTypePackMasterPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonPackTypePackMaster` mutation. */
export type UpdateCommonPackTypePackMasterPayload = {
  __typename?: 'UpdateCommonPackTypePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypePackMaster` that was updated by this mutation. */
  commonPackTypePackMaster?: Maybe<CommonPackTypePackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypePackMaster`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `PackMaster` that is related to this `CommonPackTypePackMaster`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackTypePackMaster`. May be used by Relay 1. */
  commonPackTypePackMasterEdge?: Maybe<CommonPackTypePackMastersEdge>;
};


/** The output of our update `CommonPackTypePackMaster` mutation. */
export type UpdateCommonPackTypePackMasterPayloadCommonPackTypePackMasterEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
};

/** The output of our update `CommonPackType` mutation. */
export type UpdateCommonPackTypePayload = {
  __typename?: 'UpdateCommonPackTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackType` that was updated by this mutation. */
  commonPackType?: Maybe<CommonPackType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonPackType`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `PackMaster` that is related to this `CommonPackType`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackType`. May be used by Relay 1. */
  commonPackTypeEdge?: Maybe<CommonPackTypesEdge>;
};


/** The output of our update `CommonPackType` mutation. */
export type UpdateCommonPackTypePayloadCommonPackTypeEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
};

/** All input for the `updateCommonPackTypeTagByNodeId` mutation. */
export type UpdateCommonPackTypeTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonPackTypeTag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonPackTypeTag` being updated. */
  patch: CommonPackTypeTagPatch;
};

/** All input for the `updateCommonPackTypeTag` mutation. */
export type UpdateCommonPackTypeTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonPackTypeTag` being updated. */
  patch: CommonPackTypeTagPatch;
  tagText: Scalars['String'];
  commonPackTypeId: Scalars['BigInt'];
};

/** The output of our update `CommonPackTypeTag` mutation. */
export type UpdateCommonPackTypeTagPayload = {
  __typename?: 'UpdateCommonPackTypeTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypeTag` that was updated by this mutation. */
  commonPackTypeTag?: Maybe<CommonPackTypeTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypeTag`. */
  commonPackType?: Maybe<CommonPackType>;
  /** An edge for our `CommonPackTypeTag`. May be used by Relay 1. */
  commonPackTypeTagEdge?: Maybe<CommonPackTypeTagsEdge>;
};


/** The output of our update `CommonPackTypeTag` mutation. */
export type UpdateCommonPackTypeTagPayloadCommonPackTypeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypeTagsOrderBy>>;
};

/** All input for the `updateCommonSizeByNodeId` mutation. */
export type UpdateCommonSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSize` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonSize` being updated. */
  patch: CommonSizePatch;
};

/** All input for the `updateCommonSize` mutation. */
export type UpdateCommonSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonSize` being updated. */
  patch: CommonSizePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonSize` mutation. */
export type UpdateCommonSizePayload = {
  __typename?: 'UpdateCommonSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSize` that was updated by this mutation. */
  commonSize?: Maybe<CommonSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSize`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSize` that is related to this `CommonSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSize`. May be used by Relay 1. */
  commonSizeEdge?: Maybe<CommonSizesEdge>;
};


/** The output of our update `CommonSize` mutation. */
export type UpdateCommonSizePayloadCommonSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
};

/** All input for the `updateCommonSizeProductSizeByNodeId` mutation. */
export type UpdateCommonSizeProductSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSizeProductSize` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonSizeProductSize` being updated. */
  patch: CommonSizeProductSizePatch;
};

/** All input for the `updateCommonSizeProductSize` mutation. */
export type UpdateCommonSizeProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonSizeProductSize` being updated. */
  patch: CommonSizeProductSizePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonSizeProductSize` mutation. */
export type UpdateCommonSizeProductSizePayload = {
  __typename?: 'UpdateCommonSizeProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeProductSize` that was updated by this mutation. */
  commonSizeProductSize?: Maybe<CommonSizeProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeProductSize`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `ProductSize` that is related to this `CommonSizeProductSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSizeProductSize`. May be used by Relay 1. */
  commonSizeProductSizeEdge?: Maybe<CommonSizeProductSizesEdge>;
};


/** The output of our update `CommonSizeProductSize` mutation. */
export type UpdateCommonSizeProductSizePayloadCommonSizeProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
};

/** All input for the `updateCommonSizeTagByNodeId` mutation. */
export type UpdateCommonSizeTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSizeTag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonSizeTag` being updated. */
  patch: CommonSizeTagPatch;
};

/** All input for the `updateCommonSizeTag` mutation. */
export type UpdateCommonSizeTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonSizeTag` being updated. */
  patch: CommonSizeTagPatch;
  tagText: Scalars['String'];
  commonSizeId: Scalars['BigInt'];
};

/** The output of our update `CommonSizeTag` mutation. */
export type UpdateCommonSizeTagPayload = {
  __typename?: 'UpdateCommonSizeTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeTag` that was updated by this mutation. */
  commonSizeTag?: Maybe<CommonSizeTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeTag`. */
  commonSize?: Maybe<CommonSize>;
  /** An edge for our `CommonSizeTag`. May be used by Relay 1. */
  commonSizeTagEdge?: Maybe<CommonSizeTagsEdge>;
};


/** The output of our update `CommonSizeTag` mutation. */
export type UpdateCommonSizeTagPayloadCommonSizeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeTagsOrderBy>>;
};

/** All input for the `updateCommonSpeciesByNodeId` mutation. */
export type UpdateCommonSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSpecies` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonSpecies` being updated. */
  patch: CommonSpeciesPatch;
};

/** All input for the `updateCommonSpecies` mutation. */
export type UpdateCommonSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonSpecies` being updated. */
  patch: CommonSpeciesPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonSpecies` mutation. */
export type UpdateCommonSpeciesPayload = {
  __typename?: 'UpdateCommonSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpecies` that was updated by this mutation. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonCategory` that is related to this `CommonSpecies`. */
  commonCategory?: Maybe<CommonCategory>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpecies`. May be used by Relay 1. */
  commonSpeciesEdge?: Maybe<CommonSpeciesEdge>;
};


/** The output of our update `CommonSpecies` mutation. */
export type UpdateCommonSpeciesPayloadCommonSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
};

/** All input for the `updateCommonSpeciesProductSpeciesByNodeId` mutation. */
export type UpdateCommonSpeciesProductSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSpeciesProductSpecies` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonSpeciesProductSpecies` being updated. */
  patch: CommonSpeciesProductSpeciesPatch;
};

/** All input for the `updateCommonSpeciesProductSpecies` mutation. */
export type UpdateCommonSpeciesProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonSpeciesProductSpecies` being updated. */
  patch: CommonSpeciesProductSpeciesPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonSpeciesProductSpecies` mutation. */
export type UpdateCommonSpeciesProductSpeciesPayload = {
  __typename?: 'UpdateCommonSpeciesProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesProductSpecies` that was updated by this mutation. */
  commonSpeciesProductSpecies?: Maybe<CommonSpeciesProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpeciesProductSpecies`. May be used by Relay 1. */
  commonSpeciesProductSpeciesEdge?: Maybe<CommonSpeciesProductSpeciesEdge>;
};


/** The output of our update `CommonSpeciesProductSpecies` mutation. */
export type UpdateCommonSpeciesProductSpeciesPayloadCommonSpeciesProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
};

/** All input for the `updateCommonSpeciesTagByNodeId` mutation. */
export type UpdateCommonSpeciesTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonSpeciesTag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonSpeciesTag` being updated. */
  patch: CommonSpeciesTagPatch;
};

/** All input for the `updateCommonSpeciesTag` mutation. */
export type UpdateCommonSpeciesTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonSpeciesTag` being updated. */
  patch: CommonSpeciesTagPatch;
  tagText: Scalars['String'];
  commonSpeciesId: Scalars['BigInt'];
};

/** The output of our update `CommonSpeciesTag` mutation. */
export type UpdateCommonSpeciesTagPayload = {
  __typename?: 'UpdateCommonSpeciesTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesTag` that was updated by this mutation. */
  commonSpeciesTag?: Maybe<CommonSpeciesTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesTag`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** An edge for our `CommonSpeciesTag`. May be used by Relay 1. */
  commonSpeciesTagEdge?: Maybe<CommonSpeciesTagsEdge>;
};


/** The output of our update `CommonSpeciesTag` mutation. */
export type UpdateCommonSpeciesTagPayloadCommonSpeciesTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesTagsOrderBy>>;
};

/** All input for the `updateCommonVarietyByNodeId` mutation. */
export type UpdateCommonVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonVariety` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonVariety` being updated. */
  patch: CommonVarietyPatch;
};

/** All input for the `updateCommonVariety` mutation. */
export type UpdateCommonVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonVariety` being updated. */
  patch: CommonVarietyPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonVariety` mutation. */
export type UpdateCommonVarietyPayload = {
  __typename?: 'UpdateCommonVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVariety` that was updated by this mutation. */
  commonVariety?: Maybe<CommonVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonVariety`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductVariety` that is related to this `CommonVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVariety`. May be used by Relay 1. */
  commonVarietyEdge?: Maybe<CommonVarietiesEdge>;
};


/** The output of our update `CommonVariety` mutation. */
export type UpdateCommonVarietyPayloadCommonVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
};

/** All input for the `updateCommonVarietyProductVarietyByNodeId` mutation. */
export type UpdateCommonVarietyProductVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonVarietyProductVariety` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonVarietyProductVariety` being updated. */
  patch: CommonVarietyProductVarietyPatch;
};

/** All input for the `updateCommonVarietyProductVariety` mutation. */
export type UpdateCommonVarietyProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonVarietyProductVariety` being updated. */
  patch: CommonVarietyProductVarietyPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CommonVarietyProductVariety` mutation. */
export type UpdateCommonVarietyProductVarietyPayload = {
  __typename?: 'UpdateCommonVarietyProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyProductVariety` that was updated by this mutation. */
  commonVarietyProductVariety?: Maybe<CommonVarietyProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyProductVariety`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `ProductVariety` that is related to this `CommonVarietyProductVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVarietyProductVariety`. May be used by Relay 1. */
  commonVarietyProductVarietyEdge?: Maybe<CommonVarietyProductVarietiesEdge>;
};


/** The output of our update `CommonVarietyProductVariety` mutation. */
export type UpdateCommonVarietyProductVarietyPayloadCommonVarietyProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
};

/** All input for the `updateCommonVarietyTagByNodeId` mutation. */
export type UpdateCommonVarietyTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CommonVarietyTag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CommonVarietyTag` being updated. */
  patch: CommonVarietyTagPatch;
};

/** All input for the `updateCommonVarietyTag` mutation. */
export type UpdateCommonVarietyTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CommonVarietyTag` being updated. */
  patch: CommonVarietyTagPatch;
  tagText: Scalars['String'];
  commonVarietyId: Scalars['BigInt'];
};

/** The output of our update `CommonVarietyTag` mutation. */
export type UpdateCommonVarietyTagPayload = {
  __typename?: 'UpdateCommonVarietyTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyTag` that was updated by this mutation. */
  commonVarietyTag?: Maybe<CommonVarietyTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyTag`. */
  commonVariety?: Maybe<CommonVariety>;
  /** An edge for our `CommonVarietyTag`. May be used by Relay 1. */
  commonVarietyTagEdge?: Maybe<CommonVarietyTagsEdge>;
};


/** The output of our update `CommonVarietyTag` mutation. */
export type UpdateCommonVarietyTagPayloadCommonVarietyTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyTagsOrderBy>>;
};

/** All input for the `updateContactGroupByNodeId` mutation. */
export type UpdateContactGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ContactGroup` being updated. */
  patch: ContactGroupPatch;
};

/** All input for the `updateContactGroup` mutation. */
export type UpdateContactGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ContactGroup` being updated. */
  patch: ContactGroupPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ContactGroup` mutation. */
export type UpdateContactGroupPayload = {
  __typename?: 'UpdateContactGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` that was updated by this mutation. */
  contactGroup?: Maybe<ContactGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** An edge for our `ContactGroup`. May be used by Relay 1. */
  contactGroupEdge?: Maybe<ContactGroupsEdge>;
};


/** The output of our update `ContactGroup` mutation. */
export type UpdateContactGroupPayloadContactGroupEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
};

/** All input for the `updateContactGroupPersonContactByNodeId` mutation. */
export type UpdateContactGroupPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContactGroupPersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ContactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
};

/** All input for the `updateContactGroupPersonContact` mutation. */
export type UpdateContactGroupPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ContactGroupPersonContact` being updated. */
  patch: ContactGroupPersonContactPatch;
  groupId: Scalars['BigInt'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `ContactGroupPersonContact` mutation. */
export type UpdateContactGroupPersonContactPayload = {
  __typename?: 'UpdateContactGroupPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` that was updated by this mutation. */
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ContactGroupPersonContact`. May be used by Relay 1. */
  contactGroupPersonContactEdge?: Maybe<ContactGroupPersonContactsEdge>;
};


/** The output of our update `ContactGroupPersonContact` mutation. */
export type UpdateContactGroupPersonContactPayloadContactGroupPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
};

/** All input for the `updateContainerByNodeId` mutation. */
export type UpdateContainerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Container` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Container` being updated. */
  patch: ContainerPatch;
};

/** All input for the `updateContainer` mutation. */
export type UpdateContainerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Container` being updated. */
  patch: ContainerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Container` mutation. */
export type UpdateContainerPayload = {
  __typename?: 'UpdateContainerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Container` that was updated by this mutation. */
  container?: Maybe<Container>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Container`. May be used by Relay 1. */
  containerEdge?: Maybe<ContainersEdge>;
};


/** The output of our update `Container` mutation. */
export type UpdateContainerPayloadContainerEdgeArgs = {
  orderBy?: Maybe<Array<ContainersOrderBy>>;
};

/** All input for the `updateContainerTreatmentByNodeId` mutation. */
export type UpdateContainerTreatmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContainerTreatment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ContainerTreatment` being updated. */
  patch: ContainerTreatmentPatch;
};

/** All input for the `updateContainerTreatment` mutation. */
export type UpdateContainerTreatmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ContainerTreatment` being updated. */
  patch: ContainerTreatmentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ContainerTreatment` mutation. */
export type UpdateContainerTreatmentPayload = {
  __typename?: 'UpdateContainerTreatmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContainerTreatment` that was updated by this mutation. */
  containerTreatment?: Maybe<ContainerTreatment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Container` that is related to this `ContainerTreatment`. */
  container?: Maybe<Container>;
  /** An edge for our `ContainerTreatment`. May be used by Relay 1. */
  containerTreatmentEdge?: Maybe<ContainerTreatmentsEdge>;
};


/** The output of our update `ContainerTreatment` mutation. */
export type UpdateContainerTreatmentPayloadContainerTreatmentEdgeArgs = {
  orderBy?: Maybe<Array<ContainerTreatmentsOrderBy>>;
};

/** All input for the `updateCountryByNodeId` mutation. */
export type UpdateCountryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Country` being updated. */
  patch: CountryPatch;
};

/** All input for the `updateCountry` mutation. */
export type UpdateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Country` being updated. */
  patch: CountryPatch;
  id: Scalars['String'];
};

/** The output of our update `Country` mutation. */
export type UpdateCountryPayload = {
  __typename?: 'UpdateCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was updated by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our update `Country` mutation. */
export type UpdateCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the `updateCustomerByNodeId` mutation. */
export type UpdateCustomerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Customer` being updated. */
  patch: CustomerPatch;
};

/** All input for the `updateCustomer` mutation. */
export type UpdateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Customer` being updated. */
  patch: CustomerPatch;
  id: Scalars['String'];
};

/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayload = {
  __typename?: 'UpdateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was updated by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the `updateCustomerPaymentByNodeId` mutation. */
export type UpdateCustomerPaymentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerPayment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerPayment` being updated. */
  patch: CustomerPaymentPatch;
};

/** All input for the `updateCustomerPayment` mutation. */
export type UpdateCustomerPaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerPayment` being updated. */
  patch: CustomerPaymentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CustomerPayment` mutation. */
export type UpdateCustomerPaymentPayload = {
  __typename?: 'UpdateCustomerPaymentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPayment` that was updated by this mutation. */
  customerPayment?: Maybe<CustomerPayment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerPayment`. May be used by Relay 1. */
  customerPaymentEdge?: Maybe<CustomerPaymentsEdge>;
};


/** The output of our update `CustomerPayment` mutation. */
export type UpdateCustomerPaymentPayloadCustomerPaymentEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPaymentsOrderBy>>;
};

/** All input for the `updateCustomerPersonContactByNodeId` mutation. */
export type UpdateCustomerPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerPersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
};

/** All input for the `updateCustomerPersonContact` mutation. */
export type UpdateCustomerPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerPersonContact` being updated. */
  patch: CustomerPersonContactPatch;
  customerId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `CustomerPersonContact` mutation. */
export type UpdateCustomerPersonContactPayload = {
  __typename?: 'UpdateCustomerPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` that was updated by this mutation. */
  customerPersonContact?: Maybe<CustomerPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `CustomerPersonContact`. May be used by Relay 1. */
  customerPersonContactEdge?: Maybe<CustomerPersonContactsEdge>;
};


/** The output of our update `CustomerPersonContact` mutation. */
export type UpdateCustomerPersonContactPayloadCustomerPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
};

/** All input for the `updateCustomerProgramByNodeId` mutation. */
export type UpdateCustomerProgramByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerProgram` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerProgram` being updated. */
  patch: CustomerProgramPatch;
};

/** All input for the `updateCustomerProgramEntryByNodeId` mutation. */
export type UpdateCustomerProgramEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerProgramEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerProgramEntry` being updated. */
  patch: CustomerProgramEntryPatch;
};

/** All input for the `updateCustomerProgramEntry` mutation. */
export type UpdateCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerProgramEntry` being updated. */
  patch: CustomerProgramEntryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CustomerProgramEntry` mutation. */
export type UpdateCustomerProgramEntryPayload = {
  __typename?: 'UpdateCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgramEntry` that was updated by this mutation. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgram` that is related to this `CustomerProgramEntry`. */
  customerProgram?: Maybe<CustomerProgram>;
  /** An edge for our `CustomerProgramEntry`. May be used by Relay 1. */
  customerProgramEntryEdge?: Maybe<CustomerProgramEntriesEdge>;
};


/** The output of our update `CustomerProgramEntry` mutation. */
export type UpdateCustomerProgramEntryPayloadCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramEntriesOrderBy>>;
};

/** All input for the `updateCustomerProgram` mutation. */
export type UpdateCustomerProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerProgram` being updated. */
  patch: CustomerProgramPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CustomerProgram` mutation. */
export type UpdateCustomerProgramPayload = {
  __typename?: 'UpdateCustomerProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgram` that was updated by this mutation. */
  customerProgram?: Maybe<CustomerProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CustomerProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `CustomerProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `CustomerProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `CustomerProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `CustomerProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `CustomerProgram`. May be used by Relay 1. */
  customerProgramEdge?: Maybe<CustomerProgramsEdge>;
};


/** The output of our update `CustomerProgram` mutation. */
export type UpdateCustomerProgramPayloadCustomerProgramEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
};

/** All input for the `updateCustomerVolumeDiscountByNodeId` mutation. */
export type UpdateCustomerVolumeDiscountByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerVolumeDiscount` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerVolumeDiscount` being updated. */
  patch: CustomerVolumeDiscountPatch;
};

/** All input for the `updateCustomerVolumeDiscount` mutation. */
export type UpdateCustomerVolumeDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerVolumeDiscount` being updated. */
  patch: CustomerVolumeDiscountPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CustomerVolumeDiscount` mutation. */
export type UpdateCustomerVolumeDiscountPayload = {
  __typename?: 'UpdateCustomerVolumeDiscountPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerVolumeDiscount` that was updated by this mutation. */
  customerVolumeDiscount?: Maybe<CustomerVolumeDiscount>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerVolumeDiscount`. May be used by Relay 1. */
  customerVolumeDiscountEdge?: Maybe<CustomerVolumeDiscountsEdge>;
};


/** The output of our update `CustomerVolumeDiscount` mutation. */
export type UpdateCustomerVolumeDiscountPayloadCustomerVolumeDiscountEdgeArgs = {
  orderBy?: Maybe<Array<CustomerVolumeDiscountsOrderBy>>;
};

/** All input for the `updateExpenseHeaderByNodeId` mutation. */
export type UpdateExpenseHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ExpenseHeader` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ExpenseHeader` being updated. */
  patch: ExpenseHeaderPatch;
};

/** All input for the `updateExpenseHeader` mutation. */
export type UpdateExpenseHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ExpenseHeader` being updated. */
  patch: ExpenseHeaderPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ExpenseHeader` mutation. */
export type UpdateExpenseHeaderPayload = {
  __typename?: 'UpdateExpenseHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeader` that was updated by this mutation. */
  expenseHeader?: Maybe<ExpenseHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeader`. May be used by Relay 1. */
  expenseHeaderEdge?: Maybe<ExpenseHeadersEdge>;
};


/** The output of our update `ExpenseHeader` mutation. */
export type UpdateExpenseHeaderPayloadExpenseHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeadersOrderBy>>;
};

/** All input for the `updateExpenseHeaderReviewByNodeId` mutation. */
export type UpdateExpenseHeaderReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ExpenseHeaderReview` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ExpenseHeaderReview` being updated. */
  patch: ExpenseHeaderReviewPatch;
};

/** All input for the `updateExpenseHeaderReview` mutation. */
export type UpdateExpenseHeaderReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ExpenseHeaderReview` being updated. */
  patch: ExpenseHeaderReviewPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ExpenseHeaderReview` mutation. */
export type UpdateExpenseHeaderReviewPayload = {
  __typename?: 'UpdateExpenseHeaderReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeaderReview` that was updated by this mutation. */
  expenseHeaderReview?: Maybe<ExpenseHeaderReview>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeaderReview`. May be used by Relay 1. */
  expenseHeaderReviewEdge?: Maybe<ExpenseHeaderReviewsEdge>;
};


/** The output of our update `ExpenseHeaderReview` mutation. */
export type UpdateExpenseHeaderReviewPayloadExpenseHeaderReviewEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeaderReviewsOrderBy>>;
};

/** All input for the `updateExpenseItemByNodeId` mutation. */
export type UpdateExpenseItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ExpenseItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ExpenseItem` being updated. */
  patch: ExpenseItemPatch;
};

/** All input for the `updateExpenseItem` mutation. */
export type UpdateExpenseItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ExpenseItem` being updated. */
  patch: ExpenseItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ExpenseItem` mutation. */
export type UpdateExpenseItemPayload = {
  __typename?: 'UpdateExpenseItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseItem` that was updated by this mutation. */
  expenseItem?: Maybe<ExpenseItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseItem`. May be used by Relay 1. */
  expenseItemEdge?: Maybe<ExpenseItemsEdge>;
};


/** The output of our update `ExpenseItem` mutation. */
export type UpdateExpenseItemPayloadExpenseItemEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseItemsOrderBy>>;
};

/** All input for the `updateInventoryItemByNodeId` mutation. */
export type UpdateInventoryItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InventoryItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `InventoryItem` being updated. */
  patch: InventoryItemPatch;
};

/** All input for the `updateInventoryItem` mutation. */
export type UpdateInventoryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `InventoryItem` being updated. */
  patch: InventoryItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `InventoryItem` mutation. */
export type UpdateInventoryItemPayload = {
  __typename?: 'UpdateInventoryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` that was updated by this mutation. */
  inventoryItem?: Maybe<InventoryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InventoryItem`. May be used by Relay 1. */
  inventoryItemEdge?: Maybe<InventoryItemsEdge>;
};


/** The output of our update `InventoryItem` mutation. */
export type UpdateInventoryItemPayloadInventoryItemEdgeArgs = {
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
};

/** All input for the `updateInvoiceHeaderByNodeId` mutation. */
export type UpdateInvoiceHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InvoiceHeader` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `InvoiceHeader` being updated. */
  patch: InvoiceHeaderPatch;
};

/** All input for the `updateInvoiceHeader` mutation. */
export type UpdateInvoiceHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `InvoiceHeader` being updated. */
  patch: InvoiceHeaderPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `InvoiceHeader` mutation. */
export type UpdateInvoiceHeaderPayload = {
  __typename?: 'UpdateInvoiceHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceHeader` that was updated by this mutation. */
  invoiceHeader?: Maybe<InvoiceHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceHeader`. May be used by Relay 1. */
  invoiceHeaderEdge?: Maybe<InvoiceHeadersEdge>;
};


/** The output of our update `InvoiceHeader` mutation. */
export type UpdateInvoiceHeaderPayloadInvoiceHeaderEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceHeadersOrderBy>>;
};

/** All input for the `updateInvoiceItemByNodeId` mutation. */
export type UpdateInvoiceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InvoiceItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `InvoiceItem` being updated. */
  patch: InvoiceItemPatch;
};

/** All input for the `updateInvoiceItemHistoryByNodeId` mutation. */
export type UpdateInvoiceItemHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `InvoiceItemHistory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `InvoiceItemHistory` being updated. */
  patch: InvoiceItemHistoryPatch;
};

/** All input for the `updateInvoiceItemHistory` mutation. */
export type UpdateInvoiceItemHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `InvoiceItemHistory` being updated. */
  patch: InvoiceItemHistoryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `InvoiceItemHistory` mutation. */
export type UpdateInvoiceItemHistoryPayload = {
  __typename?: 'UpdateInvoiceItemHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItemHistory` that was updated by this mutation. */
  invoiceItemHistory?: Maybe<InvoiceItemHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItemHistory`. May be used by Relay 1. */
  invoiceItemHistoryEdge?: Maybe<InvoiceItemHistoriesEdge>;
};


/** The output of our update `InvoiceItemHistory` mutation. */
export type UpdateInvoiceItemHistoryPayloadInvoiceItemHistoryEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemHistoriesOrderBy>>;
};

/** All input for the `updateInvoiceItem` mutation. */
export type UpdateInvoiceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `InvoiceItem` being updated. */
  patch: InvoiceItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `InvoiceItem` mutation. */
export type UpdateInvoiceItemPayload = {
  __typename?: 'UpdateInvoiceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItem` that was updated by this mutation. */
  invoiceItem?: Maybe<InvoiceItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItem`. May be used by Relay 1. */
  invoiceItemEdge?: Maybe<InvoiceItemsEdge>;
};


/** The output of our update `InvoiceItem` mutation. */
export type UpdateInvoiceItemPayloadInvoiceItemEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemsOrderBy>>;
};

/** All input for the `updateLoadNumberByNodeId` mutation. */
export type UpdateLoadNumberByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LoadNumber` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LoadNumber` being updated. */
  patch: LoadNumberPatch;
};

/** All input for the `updateLoadNumber` mutation. */
export type UpdateLoadNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LoadNumber` being updated. */
  patch: LoadNumberPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `LoadNumber` mutation. */
export type UpdateLoadNumberPayload = {
  __typename?: 'UpdateLoadNumberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LoadNumber` that was updated by this mutation. */
  loadNumber?: Maybe<LoadNumber>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LoadNumber`. */
  user?: Maybe<User>;
  /** An edge for our `LoadNumber`. May be used by Relay 1. */
  loadNumberEdge?: Maybe<LoadNumbersEdge>;
};


/** The output of our update `LoadNumber` mutation. */
export type UpdateLoadNumberPayloadLoadNumberEdgeArgs = {
  orderBy?: Maybe<Array<LoadNumbersOrderBy>>;
};

/** All input for the `updateOrderCommentByNodeId` mutation. */
export type UpdateOrderCommentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderComment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderComment` being updated. */
  patch: OrderCommentPatch;
};

/** All input for the `updateOrderComment` mutation. */
export type UpdateOrderCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderComment` being updated. */
  patch: OrderCommentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `OrderComment` mutation. */
export type UpdateOrderCommentPayload = {
  __typename?: 'UpdateOrderCommentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderComment` that was updated by this mutation. */
  orderComment?: Maybe<OrderComment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderComment`. May be used by Relay 1. */
  orderCommentEdge?: Maybe<OrderCommentsEdge>;
};


/** The output of our update `OrderComment` mutation. */
export type UpdateOrderCommentPayloadOrderCommentEdgeArgs = {
  orderBy?: Maybe<Array<OrderCommentsOrderBy>>;
};

/** All input for the `updateOrderEntryByNodeId` mutation. */
export type UpdateOrderEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderEntry` being updated. */
  patch: OrderEntryPatch;
};

/** All input for the `updateOrderEntry` mutation. */
export type UpdateOrderEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderEntry` being updated. */
  patch: OrderEntryPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updateOrderEntryItemByNodeId` mutation. */
export type UpdateOrderEntryItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderEntryItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderEntryItem` being updated. */
  patch: OrderEntryItemPatch;
};

/** All input for the `updateOrderEntryItem` mutation. */
export type UpdateOrderEntryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderEntryItem` being updated. */
  patch: OrderEntryItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `OrderEntryItem` mutation. */
export type UpdateOrderEntryItemPayload = {
  __typename?: 'UpdateOrderEntryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryItem` that was updated by this mutation. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntry` that is related to this `OrderEntryItem`. */
  orderEntry?: Maybe<OrderEntry>;
  /** An edge for our `OrderEntryItem`. May be used by Relay 1. */
  orderEntryItemEdge?: Maybe<OrderEntryItemsEdge>;
};


/** The output of our update `OrderEntryItem` mutation. */
export type UpdateOrderEntryItemPayloadOrderEntryItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryItemsOrderBy>>;
};

/** The output of our update `OrderEntry` mutation. */
export type UpdateOrderEntryPayload = {
  __typename?: 'UpdateOrderEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntry` that was updated by this mutation. */
  orderEntry?: Maybe<OrderEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderEntry`. May be used by Relay 1. */
  orderEntryEdge?: Maybe<OrderEntriesEdge>;
};


/** The output of our update `OrderEntry` mutation. */
export type UpdateOrderEntryPayloadOrderEntryEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntriesOrderBy>>;
};

/** All input for the `updateOrderEntryReviewItemByNodeId` mutation. */
export type UpdateOrderEntryReviewItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderEntryReviewItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderEntryReviewItem` being updated. */
  patch: OrderEntryReviewItemPatch;
};

/** All input for the `updateOrderEntryReviewItem` mutation. */
export type UpdateOrderEntryReviewItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderEntryReviewItem` being updated. */
  patch: OrderEntryReviewItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `OrderEntryReviewItem` mutation. */
export type UpdateOrderEntryReviewItemPayload = {
  __typename?: 'UpdateOrderEntryReviewItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryReviewItem` that was updated by this mutation. */
  orderEntryReviewItem?: Maybe<OrderEntryReviewItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntryItem` that is related to this `OrderEntryReviewItem`. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  /** An edge for our `OrderEntryReviewItem`. May be used by Relay 1. */
  orderEntryReviewItemEdge?: Maybe<OrderEntryReviewItemsEdge>;
};


/** The output of our update `OrderEntryReviewItem` mutation. */
export type UpdateOrderEntryReviewItemPayloadOrderEntryReviewItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryReviewItemsOrderBy>>;
};

/** All input for the `updateOrderItemByNodeId` mutation. */
export type UpdateOrderItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderItem` being updated. */
  patch: OrderItemPatch;
};

/** All input for the `updateOrderItem` mutation. */
export type UpdateOrderItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderItem` being updated. */
  patch: OrderItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `OrderItem` mutation. */
export type UpdateOrderItemPayload = {
  __typename?: 'UpdateOrderItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderItem` that was updated by this mutation. */
  orderItem?: Maybe<OrderItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderItem`. May be used by Relay 1. */
  orderItemEdge?: Maybe<OrderItemsEdge>;
};


/** The output of our update `OrderItem` mutation. */
export type UpdateOrderItemPayloadOrderItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderItemsOrderBy>>;
};

/** All input for the `updateOrderMasterByNodeId` mutation. */
export type UpdateOrderMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderMaster` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderMaster` being updated. */
  patch: OrderMasterPatch;
};

/** All input for the `updateOrderMaster` mutation. */
export type UpdateOrderMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderMaster` being updated. */
  patch: OrderMasterPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `OrderMaster` mutation. */
export type UpdateOrderMasterPayload = {
  __typename?: 'UpdateOrderMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderMaster` that was updated by this mutation. */
  orderMaster?: Maybe<OrderMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderMaster`. May be used by Relay 1. */
  orderMasterEdge?: Maybe<OrderMastersEdge>;
};


/** The output of our update `OrderMaster` mutation. */
export type UpdateOrderMasterPayloadOrderMasterEdgeArgs = {
  orderBy?: Maybe<Array<OrderMastersOrderBy>>;
};

/** All input for the `updateOrderNumberByNodeId` mutation. */
export type UpdateOrderNumberByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderNumber` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderNumber` being updated. */
  patch: OrderNumberPatch;
};

/** All input for the `updateOrderNumber` mutation. */
export type UpdateOrderNumberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderNumber` being updated. */
  patch: OrderNumberPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `OrderNumber` mutation. */
export type UpdateOrderNumberPayload = {
  __typename?: 'UpdateOrderNumberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderNumber` that was updated by this mutation. */
  orderNumber?: Maybe<OrderNumber>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderNumber`. May be used by Relay 1. */
  orderNumberEdge?: Maybe<OrderNumbersEdge>;
};


/** The output of our update `OrderNumber` mutation. */
export type UpdateOrderNumberPayloadOrderNumberEdgeArgs = {
  orderBy?: Maybe<Array<OrderNumbersOrderBy>>;
};

/** All input for the `updateOrderPalletByNodeId` mutation. */
export type UpdateOrderPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OrderPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OrderPallet` being updated. */
  patch: OrderPalletPatch;
};

/** All input for the `updateOrderPallet` mutation. */
export type UpdateOrderPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OrderPallet` being updated. */
  patch: OrderPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `OrderPallet` mutation. */
export type UpdateOrderPalletPayload = {
  __typename?: 'UpdateOrderPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderPallet` that was updated by this mutation. */
  orderPallet?: Maybe<OrderPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderPallet`. May be used by Relay 1. */
  orderPalletEdge?: Maybe<OrderPalletsEdge>;
};


/** The output of our update `OrderPallet` mutation. */
export type UpdateOrderPalletPayloadOrderPalletEdgeArgs = {
  orderBy?: Maybe<Array<OrderPalletsOrderBy>>;
};

/** All input for the `updatePackAtmosphereByNodeId` mutation. */
export type UpdatePackAtmosphereByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackAtmosphere` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackAtmosphere` being updated. */
  patch: PackAtmospherePatch;
};

/** All input for the `updatePackAtmosphereByShipperIdAndMaCode` mutation. */
export type UpdatePackAtmosphereByShipperIdAndMaCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackAtmosphere` being updated. */
  patch: PackAtmospherePatch;
  shipperId: Scalars['String'];
  maCode: Scalars['String'];
};

/** All input for the `updatePackAtmosphere` mutation. */
export type UpdatePackAtmosphereInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackAtmosphere` being updated. */
  patch: PackAtmospherePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackAtmosphere` mutation. */
export type UpdatePackAtmospherePayload = {
  __typename?: 'UpdatePackAtmospherePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` that was updated by this mutation. */
  packAtmosphere?: Maybe<PackAtmosphere>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackAtmosphere`. May be used by Relay 1. */
  packAtmosphereEdge?: Maybe<PackAtmospheresEdge>;
};


/** The output of our update `PackAtmosphere` mutation. */
export type UpdatePackAtmospherePayloadPackAtmosphereEdgeArgs = {
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
};

/** All input for the `updatePackBoxStyleByNodeId` mutation. */
export type UpdatePackBoxStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxStyle` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackBoxStyle` being updated. */
  patch: PackBoxStylePatch;
};

/** All input for the `updatePackBoxStyleByShipperIdAndBoxStyle` mutation. */
export type UpdatePackBoxStyleByShipperIdAndBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxStyle` being updated. */
  patch: PackBoxStylePatch;
  shipperId: Scalars['String'];
  boxStyle: Scalars['String'];
};

/** All input for the `updatePackBoxStyle` mutation. */
export type UpdatePackBoxStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxStyle` being updated. */
  patch: PackBoxStylePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackBoxStyle` mutation. */
export type UpdatePackBoxStylePayload = {
  __typename?: 'UpdatePackBoxStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` that was updated by this mutation. */
  packBoxStyle?: Maybe<PackBoxStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxStyle`. May be used by Relay 1. */
  packBoxStyleEdge?: Maybe<PackBoxStylesEdge>;
};


/** The output of our update `PackBoxStyle` mutation. */
export type UpdatePackBoxStylePayloadPackBoxStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
};

/** All input for the `updatePackBoxTypeByNodeId` mutation. */
export type UpdatePackBoxTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackBoxType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackBoxType` being updated. */
  patch: PackBoxTypePatch;
};

/** All input for the `updatePackBoxTypeByShipperIdAndBoxType` mutation. */
export type UpdatePackBoxTypeByShipperIdAndBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxType` being updated. */
  patch: PackBoxTypePatch;
  shipperId: Scalars['String'];
  boxType: Scalars['String'];
};

/** All input for the `updatePackBoxType` mutation. */
export type UpdatePackBoxTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackBoxType` being updated. */
  patch: PackBoxTypePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackBoxType` mutation. */
export type UpdatePackBoxTypePayload = {
  __typename?: 'UpdatePackBoxTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` that was updated by this mutation. */
  packBoxType?: Maybe<PackBoxType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxType`. May be used by Relay 1. */
  packBoxTypeEdge?: Maybe<PackBoxTypesEdge>;
};


/** The output of our update `PackBoxType` mutation. */
export type UpdatePackBoxTypePayloadPackBoxTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
};

/** All input for the `updatePackDestinationByNodeId` mutation. */
export type UpdatePackDestinationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackDestination` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackDestination` being updated. */
  patch: PackDestinationPatch;
};

/** All input for the `updatePackDestinationByShipperIdAndDestinationCode` mutation. */
export type UpdatePackDestinationByShipperIdAndDestinationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackDestination` being updated. */
  patch: PackDestinationPatch;
  shipperId: Scalars['String'];
  destinationCode: Scalars['String'];
};

/** All input for the `updatePackDestination` mutation. */
export type UpdatePackDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackDestination` being updated. */
  patch: PackDestinationPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackDestination` mutation. */
export type UpdatePackDestinationPayload = {
  __typename?: 'UpdatePackDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` that was updated by this mutation. */
  packDestination?: Maybe<PackDestination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackDestination`. May be used by Relay 1. */
  packDestinationEdge?: Maybe<PackDestinationsEdge>;
};


/** The output of our update `PackDestination` mutation. */
export type UpdatePackDestinationPayloadPackDestinationEdgeArgs = {
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
};

/** All input for the `updatePackGradeByNodeId` mutation. */
export type UpdatePackGradeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackGrade` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackGrade` being updated. */
  patch: PackGradePatch;
};

/** All input for the `updatePackGradeByShipperIdAndGradeCode` mutation. */
export type UpdatePackGradeByShipperIdAndGradeCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackGrade` being updated. */
  patch: PackGradePatch;
  shipperId: Scalars['String'];
  gradeCode: Scalars['String'];
};

/** All input for the `updatePackGrade` mutation. */
export type UpdatePackGradeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackGrade` being updated. */
  patch: PackGradePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackGrade` mutation. */
export type UpdatePackGradePayload = {
  __typename?: 'UpdatePackGradePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` that was updated by this mutation. */
  packGrade?: Maybe<PackGrade>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackGrade`. May be used by Relay 1. */
  packGradeEdge?: Maybe<PackGradesEdge>;
};


/** The output of our update `PackGrade` mutation. */
export type UpdatePackGradePayloadPackGradeEdgeArgs = {
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
};

/** All input for the `updatePackHoldByNodeId` mutation. */
export type UpdatePackHoldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackHold` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackHold` being updated. */
  patch: PackHoldPatch;
};

/** All input for the `updatePackHoldByShipperIdAndHoldCode` mutation. */
export type UpdatePackHoldByShipperIdAndHoldCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackHold` being updated. */
  patch: PackHoldPatch;
  shipperId: Scalars['String'];
  holdCode: Scalars['String'];
};

/** All input for the `updatePackHold` mutation. */
export type UpdatePackHoldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackHold` being updated. */
  patch: PackHoldPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackHold` mutation. */
export type UpdatePackHoldPayload = {
  __typename?: 'UpdatePackHoldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` that was updated by this mutation. */
  packHold?: Maybe<PackHold>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackHold`. May be used by Relay 1. */
  packHoldEdge?: Maybe<PackHoldsEdge>;
};


/** The output of our update `PackHold` mutation. */
export type UpdatePackHoldPayloadPackHoldEdgeArgs = {
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
};

/** All input for the `updatePackLabelByNodeId` mutation. */
export type UpdatePackLabelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLabel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackLabel` being updated. */
  patch: PackLabelPatch;
};

/** All input for the `updatePackLabelByShipperIdAndLabelCode` mutation. */
export type UpdatePackLabelByShipperIdAndLabelCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLabel` being updated. */
  patch: PackLabelPatch;
  shipperId: Scalars['String'];
  labelCode: Scalars['String'];
};

/** All input for the `updatePackLabel` mutation. */
export type UpdatePackLabelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLabel` being updated. */
  patch: PackLabelPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackLabel` mutation. */
export type UpdatePackLabelPayload = {
  __typename?: 'UpdatePackLabelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` that was updated by this mutation. */
  packLabel?: Maybe<PackLabel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLabel`. May be used by Relay 1. */
  packLabelEdge?: Maybe<PackLabelsEdge>;
};


/** The output of our update `PackLabel` mutation. */
export type UpdatePackLabelPayloadPackLabelEdgeArgs = {
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
};

/** All input for the `updatePackLinerByNodeId` mutation. */
export type UpdatePackLinerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackLiner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackLiner` being updated. */
  patch: PackLinerPatch;
};

/** All input for the `updatePackLinerByShipperIdAndLinerCode` mutation. */
export type UpdatePackLinerByShipperIdAndLinerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLiner` being updated. */
  patch: PackLinerPatch;
  shipperId: Scalars['String'];
  linerCode: Scalars['String'];
};

/** All input for the `updatePackLiner` mutation. */
export type UpdatePackLinerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackLiner` being updated. */
  patch: PackLinerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackLiner` mutation. */
export type UpdatePackLinerPayload = {
  __typename?: 'UpdatePackLinerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` that was updated by this mutation. */
  packLiner?: Maybe<PackLiner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLiner`. May be used by Relay 1. */
  packLinerEdge?: Maybe<PackLinersEdge>;
};


/** The output of our update `PackLiner` mutation. */
export type UpdatePackLinerPayloadPackLinerEdgeArgs = {
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
};

/** All input for the `updatePackMasterByNodeId` mutation. */
export type UpdatePackMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackMaster` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackMaster` being updated. */
  patch: PackMasterPatch;
};

/** All input for the `updatePackMaster` mutation. */
export type UpdatePackMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackMaster` being updated. */
  patch: PackMasterPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackMaster` mutation. */
export type UpdatePackMasterPayload = {
  __typename?: 'UpdatePackMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` that was updated by this mutation. */
  packMaster?: Maybe<PackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackMaster`. May be used by Relay 1. */
  packMasterEdge?: Maybe<PackMastersEdge>;
};


/** The output of our update `PackMaster` mutation. */
export type UpdatePackMasterPayloadPackMasterEdgeArgs = {
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
};

/** All input for the `updatePackOutByNodeId` mutation. */
export type UpdatePackOutByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackOut` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackOut` being updated. */
  patch: PackOutPatch;
};

/** All input for the `updatePackOutByShipperIdAndOutCode` mutation. */
export type UpdatePackOutByShipperIdAndOutCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackOut` being updated. */
  patch: PackOutPatch;
  shipperId: Scalars['String'];
  outCode: Scalars['String'];
};

/** All input for the `updatePackOut` mutation. */
export type UpdatePackOutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackOut` being updated. */
  patch: PackOutPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackOut` mutation. */
export type UpdatePackOutPayload = {
  __typename?: 'UpdatePackOutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` that was updated by this mutation. */
  packOut?: Maybe<PackOut>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackOut`. May be used by Relay 1. */
  packOutEdge?: Maybe<PackOutsEdge>;
};


/** The output of our update `PackOut` mutation. */
export type UpdatePackOutPayloadPackOutEdgeArgs = {
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
};

/** All input for the `updatePackPalletTypeByNodeId` mutation. */
export type UpdatePackPalletTypeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackPalletType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackPalletType` being updated. */
  patch: PackPalletTypePatch;
};

/** All input for the `updatePackPalletTypeByShipperIdAndPalletType` mutation. */
export type UpdatePackPalletTypeByShipperIdAndPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackPalletType` being updated. */
  patch: PackPalletTypePatch;
  shipperId: Scalars['String'];
  palletType: Scalars['String'];
};

/** All input for the `updatePackPalletType` mutation. */
export type UpdatePackPalletTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackPalletType` being updated. */
  patch: PackPalletTypePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackPalletType` mutation. */
export type UpdatePackPalletTypePayload = {
  __typename?: 'UpdatePackPalletTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` that was updated by this mutation. */
  packPalletType?: Maybe<PackPalletType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackPalletType`. May be used by Relay 1. */
  packPalletTypeEdge?: Maybe<PackPalletTypesEdge>;
};


/** The output of our update `PackPalletType` mutation. */
export type UpdatePackPalletTypePayloadPackPalletTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
};

/** All input for the `updatePackProductionByNodeId` mutation. */
export type UpdatePackProductionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackProduction` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackProduction` being updated. */
  patch: PackProductionPatch;
};

/** All input for the `updatePackProductionByShipperIdAndProductionCode` mutation. */
export type UpdatePackProductionByShipperIdAndProductionCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackProduction` being updated. */
  patch: PackProductionPatch;
  shipperId: Scalars['String'];
  productionCode: Scalars['String'];
};

/** All input for the `updatePackProduction` mutation. */
export type UpdatePackProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackProduction` being updated. */
  patch: PackProductionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackProduction` mutation. */
export type UpdatePackProductionPayload = {
  __typename?: 'UpdatePackProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` that was updated by this mutation. */
  packProduction?: Maybe<PackProduction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackProduction`. May be used by Relay 1. */
  packProductionEdge?: Maybe<PackProductionsEdge>;
};


/** The output of our update `PackProduction` mutation. */
export type UpdatePackProductionPayloadPackProductionEdgeArgs = {
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
};

/** All input for the `updatePackSpecialByNodeId` mutation. */
export type UpdatePackSpecialByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackSpecial` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackSpecial` being updated. */
  patch: PackSpecialPatch;
};

/** All input for the `updatePackSpecialByShipperIdAndCustomerCode` mutation. */
export type UpdatePackSpecialByShipperIdAndCustomerCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackSpecial` being updated. */
  patch: PackSpecialPatch;
  shipperId: Scalars['String'];
  customerCode: Scalars['String'];
};

/** All input for the `updatePackSpecial` mutation. */
export type UpdatePackSpecialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackSpecial` being updated. */
  patch: PackSpecialPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackSpecial` mutation. */
export type UpdatePackSpecialPayload = {
  __typename?: 'UpdatePackSpecialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` that was updated by this mutation. */
  packSpecial?: Maybe<PackSpecial>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackSpecial`. May be used by Relay 1. */
  packSpecialEdge?: Maybe<PackSpecialsEdge>;
};


/** The output of our update `PackSpecial` mutation. */
export type UpdatePackSpecialPayloadPackSpecialEdgeArgs = {
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
};

/** All input for the `updatePackStyleByNodeId` mutation. */
export type UpdatePackStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackStyle` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackStyle` being updated. */
  patch: PackStylePatch;
};

/** All input for the `updatePackStyleByShipperIdAndPackStyle` mutation. */
export type UpdatePackStyleByShipperIdAndPackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackStyle` being updated. */
  patch: PackStylePatch;
  shipperId: Scalars['String'];
  packStyle: Scalars['String'];
};

/** All input for the `updatePackStyle` mutation. */
export type UpdatePackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackStyle` being updated. */
  patch: PackStylePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackStyle` mutation. */
export type UpdatePackStylePayload = {
  __typename?: 'UpdatePackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` that was updated by this mutation. */
  packStyle?: Maybe<PackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackStyle`. May be used by Relay 1. */
  packStyleEdge?: Maybe<PackStylesEdge>;
};


/** The output of our update `PackStyle` mutation. */
export type UpdatePackStylePayloadPackStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
};

/** All input for the `updatePackTreeRipeByNodeId` mutation. */
export type UpdatePackTreeRipeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PackTreeRipe` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PackTreeRipe` being updated. */
  patch: PackTreeRipePatch;
};

/** All input for the `updatePackTreeRipeByShipperIdAndTreeRipe` mutation. */
export type UpdatePackTreeRipeByShipperIdAndTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackTreeRipe` being updated. */
  patch: PackTreeRipePatch;
  shipperId: Scalars['String'];
  treeRipe: Scalars['String'];
};

/** All input for the `updatePackTreeRipe` mutation. */
export type UpdatePackTreeRipeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PackTreeRipe` being updated. */
  patch: PackTreeRipePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PackTreeRipe` mutation. */
export type UpdatePackTreeRipePayload = {
  __typename?: 'UpdatePackTreeRipePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` that was updated by this mutation. */
  packTreeRipe?: Maybe<PackTreeRipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackTreeRipe`. May be used by Relay 1. */
  packTreeRipeEdge?: Maybe<PackTreeRipesEdge>;
};


/** The output of our update `PackTreeRipe` mutation. */
export type UpdatePackTreeRipePayloadPackTreeRipeEdgeArgs = {
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
};

/** All input for the `updatePalletByNodeId` mutation. */
export type UpdatePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Pallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Pallet` being updated. */
  patch: PalletPatch;
};

/** All input for the `updatePallet` mutation. */
export type UpdatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Pallet` being updated. */
  patch: PalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Pallet` mutation. */
export type UpdatePalletPayload = {
  __typename?: 'UpdatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` that was updated by this mutation. */
  pallet?: Maybe<Pallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Pallet`. May be used by Relay 1. */
  palletEdge?: Maybe<PalletsEdge>;
};


/** The output of our update `Pallet` mutation. */
export type UpdatePalletPayloadPalletEdgeArgs = {
  orderBy?: Maybe<Array<PalletsOrderBy>>;
};

/** All input for the `updatePalletSectionByNodeId` mutation. */
export type UpdatePalletSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PalletSection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PalletSection` being updated. */
  patch: PalletSectionPatch;
};

/** All input for the `updatePalletSection` mutation. */
export type UpdatePalletSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PalletSection` being updated. */
  patch: PalletSectionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PalletSection` mutation. */
export type UpdatePalletSectionPayload = {
  __typename?: 'UpdatePalletSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` that was updated by this mutation. */
  palletSection?: Maybe<PalletSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletSection`. May be used by Relay 1. */
  palletSectionEdge?: Maybe<PalletSectionsEdge>;
};


/** The output of our update `PalletSection` mutation. */
export type UpdatePalletSectionPayloadPalletSectionEdgeArgs = {
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
};

/** All input for the `updatePersonContactByNodeId` mutation. */
export type UpdatePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PersonContact` being updated. */
  patch: PersonContactPatch;
};

/** All input for the `updatePersonContact` mutation. */
export type UpdatePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PersonContact` being updated. */
  patch: PersonContactPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PersonContact` mutation. */
export type UpdatePersonContactPayload = {
  __typename?: 'UpdatePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` that was updated by this mutation. */
  personContact?: Maybe<PersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PersonContact`. May be used by Relay 1. */
  personContactEdge?: Maybe<PersonContactsEdge>;
};


/** The output of our update `PersonContact` mutation. */
export type UpdatePersonContactPayloadPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
};

/** All input for the `updatePeruDepartureInspectionByNodeId` mutation. */
export type UpdatePeruDepartureInspectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PeruDepartureInspection` being updated. */
  patch: PeruDepartureInspectionPatch;
};

/** All input for the `updatePeruDepartureInspection` mutation. */
export type UpdatePeruDepartureInspectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PeruDepartureInspection` being updated. */
  patch: PeruDepartureInspectionPatch;
  containerId: Scalars['String'];
};

/** All input for the `updatePeruDepartureInspectionPalletByNodeId` mutation. */
export type UpdatePeruDepartureInspectionPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PeruDepartureInspectionPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PeruDepartureInspectionPallet` being updated. */
  patch: PeruDepartureInspectionPalletPatch;
};

/** All input for the `updatePeruDepartureInspectionPallet` mutation. */
export type UpdatePeruDepartureInspectionPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PeruDepartureInspectionPallet` being updated. */
  patch: PeruDepartureInspectionPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PeruDepartureInspectionPallet` mutation. */
export type UpdatePeruDepartureInspectionPalletPayload = {
  __typename?: 'UpdatePeruDepartureInspectionPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` that was updated by this mutation. */
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
  /** An edge for our `PeruDepartureInspectionPallet`. May be used by Relay 1. */
  peruDepartureInspectionPalletEdge?: Maybe<PeruDepartureInspectionPalletsEdge>;
};


/** The output of our update `PeruDepartureInspectionPallet` mutation. */
export type UpdatePeruDepartureInspectionPalletPayloadPeruDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
};

/** The output of our update `PeruDepartureInspection` mutation. */
export type UpdatePeruDepartureInspectionPayload = {
  __typename?: 'UpdatePeruDepartureInspectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` that was updated by this mutation. */
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PeruDepartureInspection`. May be used by Relay 1. */
  peruDepartureInspectionEdge?: Maybe<PeruDepartureInspectionsEdge>;
};


/** The output of our update `PeruDepartureInspection` mutation. */
export type UpdatePeruDepartureInspectionPayloadPeruDepartureInspectionEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
};

/** All input for the `updatePriceCategoryByNodeId` mutation. */
export type UpdatePriceCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceCategory` being updated. */
  patch: PriceCategoryPatch;
};

/** All input for the `updatePriceCategory` mutation. */
export type UpdatePriceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceCategory` being updated. */
  patch: PriceCategoryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceCategory` mutation. */
export type UpdatePriceCategoryPayload = {
  __typename?: 'UpdatePriceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` that was updated by this mutation. */
  priceCategory?: Maybe<PriceCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PriceCategory`. May be used by Relay 1. */
  priceCategoryEdge?: Maybe<PriceCategoriesEdge>;
};


/** The output of our update `PriceCategory` mutation. */
export type UpdatePriceCategoryPayloadPriceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
};

/** All input for the `updatePriceEntryByNodeId` mutation. */
export type UpdatePriceEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceEntry` being updated. */
  patch: PriceEntryPatch;
};

/** All input for the `updatePriceEntry` mutation. */
export type UpdatePriceEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceEntry` being updated. */
  patch: PriceEntryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceEntry` mutation. */
export type UpdatePriceEntryPayload = {
  __typename?: 'UpdatePriceEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` that was updated by this mutation. */
  priceEntry?: Maybe<PriceEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
  /** An edge for our `PriceEntry`. May be used by Relay 1. */
  priceEntryEdge?: Maybe<PriceEntriesEdge>;
};


/** The output of our update `PriceEntry` mutation. */
export type UpdatePriceEntryPayloadPriceEntryEdgeArgs = {
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
};

/** All input for the `updatePriceProductByNodeId` mutation. */
export type UpdatePriceProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceProduct` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceProduct` being updated. */
  patch: PriceProductPatch;
};

/** All input for the `updatePriceProduct` mutation. */
export type UpdatePriceProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceProduct` being updated. */
  patch: PriceProductPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceProduct` mutation. */
export type UpdatePriceProductPayload = {
  __typename?: 'UpdatePriceProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` that was updated by this mutation. */
  priceProduct?: Maybe<PriceProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** An edge for our `PriceProduct`. May be used by Relay 1. */
  priceProductEdge?: Maybe<PriceProductsEdge>;
};


/** The output of our update `PriceProduct` mutation. */
export type UpdatePriceProductPayloadPriceProductEdgeArgs = {
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
};

/** All input for the `updatePriceSizeByNodeId` mutation. */
export type UpdatePriceSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PriceSize` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PriceSize` being updated. */
  patch: PriceSizePatch;
};

/** All input for the `updatePriceSize` mutation. */
export type UpdatePriceSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PriceSize` being updated. */
  patch: PriceSizePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PriceSize` mutation. */
export type UpdatePriceSizePayload = {
  __typename?: 'UpdatePriceSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` that was updated by this mutation. */
  priceSize?: Maybe<PriceSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** An edge for our `PriceSize`. May be used by Relay 1. */
  priceSizeEdge?: Maybe<PriceSizesEdge>;
};


/** The output of our update `PriceSize` mutation. */
export type UpdatePriceSizePayloadPriceSizeEdgeArgs = {
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
};

/** All input for the `updateProductMasterByNodeId` mutation. */
export type UpdateProductMasterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductMaster` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductMaster` being updated. */
  patch: ProductMasterPatch;
};

/** All input for the `updateProductMaster` mutation. */
export type UpdateProductMasterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductMaster` being updated. */
  patch: ProductMasterPatch;
  id: Scalars['String'];
};

/** The output of our update `ProductMaster` mutation. */
export type UpdateProductMasterPayload = {
  __typename?: 'UpdateProductMasterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` that was updated by this mutation. */
  productMaster?: Maybe<ProductMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductMaster`. May be used by Relay 1. */
  productMasterEdge?: Maybe<ProductMastersEdge>;
};


/** The output of our update `ProductMaster` mutation. */
export type UpdateProductMasterPayloadProductMasterEdgeArgs = {
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
};

/** All input for the `updateProductSizeByNodeId` mutation. */
export type UpdateProductSizeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSize` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductSize` being updated. */
  patch: ProductSizePatch;
};

/** All input for the `updateProductSize` mutation. */
export type UpdateProductSizeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductSize` being updated. */
  patch: ProductSizePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ProductSize` mutation. */
export type UpdateProductSizePayload = {
  __typename?: 'UpdateProductSizePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` that was updated by this mutation. */
  productSize?: Maybe<ProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSize`. May be used by Relay 1. */
  productSizeEdge?: Maybe<ProductSizesEdge>;
};


/** The output of our update `ProductSize` mutation. */
export type UpdateProductSizePayloadProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
};

/** All input for the `updateProductSpeciesByNodeId` mutation. */
export type UpdateProductSpeciesByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductSpecies` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductSpecies` being updated. */
  patch: ProductSpeciesPatch;
};

/** All input for the `updateProductSpecies` mutation. */
export type UpdateProductSpeciesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductSpecies` being updated. */
  patch: ProductSpeciesPatch;
  id: Scalars['String'];
};

/** The output of our update `ProductSpecies` mutation. */
export type UpdateProductSpeciesPayload = {
  __typename?: 'UpdateProductSpeciesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` that was updated by this mutation. */
  productSpecies?: Maybe<ProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSpecies`. May be used by Relay 1. */
  productSpeciesEdge?: Maybe<ProductSpeciesEdge>;
};


/** The output of our update `ProductSpecies` mutation. */
export type UpdateProductSpeciesPayloadProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
};

/** All input for the `updateProductVarietyByNodeId` mutation. */
export type UpdateProductVarietyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductVariety` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductVariety` being updated. */
  patch: ProductVarietyPatch;
};

/** All input for the `updateProductVariety` mutation. */
export type UpdateProductVarietyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductVariety` being updated. */
  patch: ProductVarietyPatch;
  id: Scalars['String'];
};

/** The output of our update `ProductVariety` mutation. */
export type UpdateProductVarietyPayload = {
  __typename?: 'UpdateProductVarietyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` that was updated by this mutation. */
  productVariety?: Maybe<ProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductVariety`. May be used by Relay 1. */
  productVarietyEdge?: Maybe<ProductVarietiesEdge>;
};


/** The output of our update `ProductVariety` mutation. */
export type UpdateProductVarietyPayloadProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
};

/** All input for the `updatePsaApplePalletByNodeId` mutation. */
export type UpdatePsaApplePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaApplePallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaApplePallet` being updated. */
  patch: PsaApplePalletPatch;
};

/** All input for the `updatePsaApplePallet` mutation. */
export type UpdatePsaApplePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaApplePallet` being updated. */
  patch: PsaApplePalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaApplePallet` mutation. */
export type UpdatePsaApplePalletPayload = {
  __typename?: 'UpdatePsaApplePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` that was updated by this mutation. */
  psaApplePallet?: Maybe<PsaApplePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaApplePallet`. May be used by Relay 1. */
  psaApplePalletEdge?: Maybe<PsaApplePalletsEdge>;
};


/** The output of our update `PsaApplePallet` mutation. */
export type UpdatePsaApplePalletPayloadPsaApplePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
};

/** All input for the `updatePsaArrivalPictureByNodeId` mutation. */
export type UpdatePsaArrivalPictureByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalPicture` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaArrivalPicture` being updated. */
  patch: PsaArrivalPicturePatch;
};

/** All input for the `updatePsaArrivalPicture` mutation. */
export type UpdatePsaArrivalPictureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaArrivalPicture` being updated. */
  patch: PsaArrivalPicturePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaArrivalPicture` mutation. */
export type UpdatePsaArrivalPicturePayload = {
  __typename?: 'UpdatePsaArrivalPicturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` that was updated by this mutation. */
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalPicture`. May be used by Relay 1. */
  psaArrivalPictureEdge?: Maybe<PsaArrivalPicturesEdge>;
};


/** The output of our update `PsaArrivalPicture` mutation. */
export type UpdatePsaArrivalPicturePayloadPsaArrivalPictureEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
};

/** All input for the `updatePsaArrivalReportByNodeId` mutation. */
export type UpdatePsaArrivalReportByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaArrivalReport` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaArrivalReport` being updated. */
  patch: PsaArrivalReportPatch;
};

/** All input for the `updatePsaArrivalReport` mutation. */
export type UpdatePsaArrivalReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaArrivalReport` being updated. */
  patch: PsaArrivalReportPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaArrivalReport` mutation. */
export type UpdatePsaArrivalReportPayload = {
  __typename?: 'UpdatePsaArrivalReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` that was updated by this mutation. */
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalReport`. May be used by Relay 1. */
  psaArrivalReportEdge?: Maybe<PsaArrivalReportsEdge>;
};


/** The output of our update `PsaArrivalReport` mutation. */
export type UpdatePsaArrivalReportPayloadPsaArrivalReportEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
};

/** All input for the `updatePsaCherryPalletByNodeId` mutation. */
export type UpdatePsaCherryPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCherryPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaCherryPallet` being updated. */
  patch: PsaCherryPalletPatch;
};

/** All input for the `updatePsaCherryPallet` mutation. */
export type UpdatePsaCherryPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaCherryPallet` being updated. */
  patch: PsaCherryPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaCherryPallet` mutation. */
export type UpdatePsaCherryPalletPayload = {
  __typename?: 'UpdatePsaCherryPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` that was updated by this mutation. */
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCherryPallet`. May be used by Relay 1. */
  psaCherryPalletEdge?: Maybe<PsaCherryPalletsEdge>;
};


/** The output of our update `PsaCherryPallet` mutation. */
export type UpdatePsaCherryPalletPayloadPsaCherryPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
};

/** All input for the `updatePsaCitrusPalletByNodeId` mutation. */
export type UpdatePsaCitrusPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaCitrusPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaCitrusPallet` being updated. */
  patch: PsaCitrusPalletPatch;
};

/** All input for the `updatePsaCitrusPallet` mutation. */
export type UpdatePsaCitrusPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaCitrusPallet` being updated. */
  patch: PsaCitrusPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaCitrusPallet` mutation. */
export type UpdatePsaCitrusPalletPayload = {
  __typename?: 'UpdatePsaCitrusPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` that was updated by this mutation. */
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCitrusPallet`. May be used by Relay 1. */
  psaCitrusPalletEdge?: Maybe<PsaCitrusPalletsEdge>;
};


/** The output of our update `PsaCitrusPallet` mutation. */
export type UpdatePsaCitrusPalletPayloadPsaCitrusPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
};

/** All input for the `updatePsaGrapePalletByNodeId` mutation. */
export type UpdatePsaGrapePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaGrapePallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaGrapePallet` being updated. */
  patch: PsaGrapePalletPatch;
};

/** All input for the `updatePsaGrapePallet` mutation. */
export type UpdatePsaGrapePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaGrapePallet` being updated. */
  patch: PsaGrapePalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaGrapePallet` mutation. */
export type UpdatePsaGrapePalletPayload = {
  __typename?: 'UpdatePsaGrapePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` that was updated by this mutation. */
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaGrapePallet`. May be used by Relay 1. */
  psaGrapePalletEdge?: Maybe<PsaGrapePalletsEdge>;
};


/** The output of our update `PsaGrapePallet` mutation. */
export type UpdatePsaGrapePalletPayloadPsaGrapePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
};

/** All input for the `updatePsaLemonPalletByNodeId` mutation. */
export type UpdatePsaLemonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaLemonPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaLemonPallet` being updated. */
  patch: PsaLemonPalletPatch;
};

/** All input for the `updatePsaLemonPallet` mutation. */
export type UpdatePsaLemonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaLemonPallet` being updated. */
  patch: PsaLemonPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaLemonPallet` mutation. */
export type UpdatePsaLemonPalletPayload = {
  __typename?: 'UpdatePsaLemonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` that was updated by this mutation. */
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaLemonPallet`. May be used by Relay 1. */
  psaLemonPalletEdge?: Maybe<PsaLemonPalletsEdge>;
};


/** The output of our update `PsaLemonPallet` mutation. */
export type UpdatePsaLemonPalletPayloadPsaLemonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
};

/** All input for the `updatePsaPearPalletByNodeId` mutation. */
export type UpdatePsaPearPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPearPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaPearPallet` being updated. */
  patch: PsaPearPalletPatch;
};

/** All input for the `updatePsaPearPallet` mutation. */
export type UpdatePsaPearPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaPearPallet` being updated. */
  patch: PsaPearPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaPearPallet` mutation. */
export type UpdatePsaPearPalletPayload = {
  __typename?: 'UpdatePsaPearPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` that was updated by this mutation. */
  psaPearPallet?: Maybe<PsaPearPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPearPallet`. May be used by Relay 1. */
  psaPearPalletEdge?: Maybe<PsaPearPalletsEdge>;
};


/** The output of our update `PsaPearPallet` mutation. */
export type UpdatePsaPearPalletPayloadPsaPearPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
};

/** All input for the `updatePsaPersimmonPalletByNodeId` mutation. */
export type UpdatePsaPersimmonPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPersimmonPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaPersimmonPallet` being updated. */
  patch: PsaPersimmonPalletPatch;
};

/** All input for the `updatePsaPersimmonPallet` mutation. */
export type UpdatePsaPersimmonPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaPersimmonPallet` being updated. */
  patch: PsaPersimmonPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaPersimmonPallet` mutation. */
export type UpdatePsaPersimmonPalletPayload = {
  __typename?: 'UpdatePsaPersimmonPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` that was updated by this mutation. */
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPersimmonPallet`. May be used by Relay 1. */
  psaPersimmonPalletEdge?: Maybe<PsaPersimmonPalletsEdge>;
};


/** The output of our update `PsaPersimmonPallet` mutation. */
export type UpdatePsaPersimmonPalletPayloadPsaPersimmonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
};

/** All input for the `updatePsaPomegranatePalletByNodeId` mutation. */
export type UpdatePsaPomegranatePalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaPomegranatePallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaPomegranatePallet` being updated. */
  patch: PsaPomegranatePalletPatch;
};

/** All input for the `updatePsaPomegranatePallet` mutation. */
export type UpdatePsaPomegranatePalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaPomegranatePallet` being updated. */
  patch: PsaPomegranatePalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaPomegranatePallet` mutation. */
export type UpdatePsaPomegranatePalletPayload = {
  __typename?: 'UpdatePsaPomegranatePalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` that was updated by this mutation. */
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPomegranatePallet`. May be used by Relay 1. */
  psaPomegranatePalletEdge?: Maybe<PsaPomegranatePalletsEdge>;
};


/** The output of our update `PsaPomegranatePallet` mutation. */
export type UpdatePsaPomegranatePalletPayloadPsaPomegranatePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
};

/** All input for the `updatePsaStoneFruitPalletByNodeId` mutation. */
export type UpdatePsaStoneFruitPalletByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PsaStoneFruitPallet` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PsaStoneFruitPallet` being updated. */
  patch: PsaStoneFruitPalletPatch;
};

/** All input for the `updatePsaStoneFruitPallet` mutation. */
export type UpdatePsaStoneFruitPalletInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PsaStoneFruitPallet` being updated. */
  patch: PsaStoneFruitPalletPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `PsaStoneFruitPallet` mutation. */
export type UpdatePsaStoneFruitPalletPayload = {
  __typename?: 'UpdatePsaStoneFruitPalletPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` that was updated by this mutation. */
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaStoneFruitPallet`. May be used by Relay 1. */
  psaStoneFruitPalletEdge?: Maybe<PsaStoneFruitPalletsEdge>;
};


/** The output of our update `PsaStoneFruitPallet` mutation. */
export type UpdatePsaStoneFruitPalletPayloadPsaStoneFruitPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
};

/** All input for the `updateRepackHeaderByNodeId` mutation. */
export type UpdateRepackHeaderByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackHeader` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RepackHeader` being updated. */
  patch: RepackHeaderPatch;
};

/** All input for the `updateRepackHeader` mutation. */
export type UpdateRepackHeaderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RepackHeader` being updated. */
  patch: RepackHeaderPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `RepackHeader` mutation. */
export type UpdateRepackHeaderPayload = {
  __typename?: 'UpdateRepackHeaderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackHeader` that was updated by this mutation. */
  repackHeader?: Maybe<RepackHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackHeader`. May be used by Relay 1. */
  repackHeaderEdge?: Maybe<RepackHeadersEdge>;
};


/** The output of our update `RepackHeader` mutation. */
export type UpdateRepackHeaderPayloadRepackHeaderEdgeArgs = {
  orderBy?: Maybe<Array<RepackHeadersOrderBy>>;
};

/** All input for the `updateRepackItemByNodeId` mutation. */
export type UpdateRepackItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RepackItem` being updated. */
  patch: RepackItemPatch;
};

/** All input for the `updateRepackItem` mutation. */
export type UpdateRepackItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RepackItem` being updated. */
  patch: RepackItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `RepackItem` mutation. */
export type UpdateRepackItemPayload = {
  __typename?: 'UpdateRepackItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackItem` that was updated by this mutation. */
  repackItem?: Maybe<RepackItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackItem`. May be used by Relay 1. */
  repackItemEdge?: Maybe<RepackItemsEdge>;
};


/** The output of our update `RepackItem` mutation. */
export type UpdateRepackItemPayloadRepackItemEdgeArgs = {
  orderBy?: Maybe<Array<RepackItemsOrderBy>>;
};

/** All input for the `updateRepackQueueByNodeId` mutation. */
export type UpdateRepackQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackQueue` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RepackQueue` being updated. */
  patch: RepackQueuePatch;
};

/** All input for the `updateRepackQueue` mutation. */
export type UpdateRepackQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RepackQueue` being updated. */
  patch: RepackQueuePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `RepackQueue` mutation. */
export type UpdateRepackQueuePayload = {
  __typename?: 'UpdateRepackQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackQueue` that was updated by this mutation. */
  repackQueue?: Maybe<RepackQueue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackQueue`. May be used by Relay 1. */
  repackQueueEdge?: Maybe<RepackQueuesEdge>;
};


/** The output of our update `RepackQueue` mutation. */
export type UpdateRepackQueuePayloadRepackQueueEdgeArgs = {
  orderBy?: Maybe<Array<RepackQueuesOrderBy>>;
};

/** All input for the `updateRepackStyleByNodeId` mutation. */
export type UpdateRepackStyleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RepackStyle` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RepackStyle` being updated. */
  patch: RepackStylePatch;
};

/** All input for the `updateRepackStyle` mutation. */
export type UpdateRepackStyleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `RepackStyle` being updated. */
  patch: RepackStylePatch;
  id: Scalars['String'];
};

/** The output of our update `RepackStyle` mutation. */
export type UpdateRepackStylePayload = {
  __typename?: 'UpdateRepackStylePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackStyle` that was updated by this mutation. */
  repackStyle?: Maybe<RepackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackStyle`. May be used by Relay 1. */
  repackStyleEdge?: Maybe<RepackStylesEdge>;
};


/** The output of our update `RepackStyle` mutation. */
export type UpdateRepackStylePayloadRepackStyleEdgeArgs = {
  orderBy?: Maybe<Array<RepackStylesOrderBy>>;
};

/** All input for the `updateShipperAdvanceByNodeId` mutation. */
export type UpdateShipperAdvanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperAdvance` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperAdvance` being updated. */
  patch: ShipperAdvancePatch;
};

/** All input for the `updateShipperAdvance` mutation. */
export type UpdateShipperAdvanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperAdvance` being updated. */
  patch: ShipperAdvancePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperAdvance` mutation. */
export type UpdateShipperAdvancePayload = {
  __typename?: 'UpdateShipperAdvancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperAdvance` that was updated by this mutation. */
  shipperAdvance?: Maybe<ShipperAdvance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ProductSpecies` that is related to this `ShipperAdvance`. */
  species?: Maybe<ProductSpecies>;
  /** Reads a single `Shipper` that is related to this `ShipperAdvance`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperAdvance`. May be used by Relay 1. */
  shipperAdvanceEdge?: Maybe<ShipperAdvancesEdge>;
};


/** The output of our update `ShipperAdvance` mutation. */
export type UpdateShipperAdvancePayloadShipperAdvanceEdgeArgs = {
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
};

/** All input for the `updateShipperByNodeId` mutation. */
export type UpdateShipperByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipper` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Shipper` being updated. */
  patch: ShipperPatch;
};

/** All input for the `updateShipper` mutation. */
export type UpdateShipperInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Shipper` being updated. */
  patch: ShipperPatch;
  id: Scalars['String'];
};

/** The output of our update `Shipper` mutation. */
export type UpdateShipperPayload = {
  __typename?: 'UpdateShipperPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` that was updated by this mutation. */
  shipper?: Maybe<Shipper>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** An edge for our `Shipper`. May be used by Relay 1. */
  shipperEdge?: Maybe<ShippersEdge>;
};


/** The output of our update `Shipper` mutation. */
export type UpdateShipperPayloadShipperEdgeArgs = {
  orderBy?: Maybe<Array<ShippersOrderBy>>;
};

/** All input for the `updateShipperPersonContactByNodeId` mutation. */
export type UpdateShipperPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperPersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
};

/** All input for the `updateShipperPersonContact` mutation. */
export type UpdateShipperPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperPersonContact` being updated. */
  patch: ShipperPersonContactPatch;
  shipperId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `ShipperPersonContact` mutation. */
export type UpdateShipperPersonContactPayload = {
  __typename?: 'UpdateShipperPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` that was updated by this mutation. */
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ShipperPersonContact`. May be used by Relay 1. */
  shipperPersonContactEdge?: Maybe<ShipperPersonContactsEdge>;
};


/** The output of our update `ShipperPersonContact` mutation. */
export type UpdateShipperPersonContactPayloadShipperPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
};

/** All input for the `updateShipperProgramByNodeId` mutation. */
export type UpdateShipperProgramByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProgram` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProgram` being updated. */
  patch: ShipperProgramPatch;
};

/** All input for the `updateShipperProgramEntryByNodeId` mutation. */
export type UpdateShipperProgramEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProgramEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProgramEntry` being updated. */
  patch: ShipperProgramEntryPatch;
};

/** All input for the `updateShipperProgramEntryCustomerProgramEntryByNodeId` mutation. */
export type UpdateShipperProgramEntryCustomerProgramEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProgramEntryCustomerProgramEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProgramEntryCustomerProgramEntry` being updated. */
  patch: ShipperProgramEntryCustomerProgramEntryPatch;
};

/** All input for the `updateShipperProgramEntryCustomerProgramEntry` mutation. */
export type UpdateShipperProgramEntryCustomerProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProgramEntryCustomerProgramEntry` being updated. */
  patch: ShipperProgramEntryCustomerProgramEntryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type UpdateShipperProgramEntryCustomerProgramEntryPayload = {
  __typename?: 'UpdateShipperProgramEntryCustomerProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntryCustomerProgramEntry` that was updated by this mutation. */
  shipperProgramEntryCustomerProgramEntry?: Maybe<ShipperProgramEntryCustomerProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Reads a single `ShipperProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  /** An edge for our `ShipperProgramEntryCustomerProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryCustomerProgramEntryEdge?: Maybe<ShipperProgramEntryCustomerProgramEntriesEdge>;
};


/** The output of our update `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type UpdateShipperProgramEntryCustomerProgramEntryPayloadShipperProgramEntryCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
};

/** All input for the `updateShipperProgramEntry` mutation. */
export type UpdateShipperProgramEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProgramEntry` being updated. */
  patch: ShipperProgramEntryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProgramEntry` mutation. */
export type UpdateShipperProgramEntryPayload = {
  __typename?: 'UpdateShipperProgramEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntry` that was updated by this mutation. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProgram` that is related to this `ShipperProgramEntry`. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** An edge for our `ShipperProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryEdge?: Maybe<ShipperProgramEntriesEdge>;
};


/** The output of our update `ShipperProgramEntry` mutation. */
export type UpdateShipperProgramEntryPayloadShipperProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntriesOrderBy>>;
};

/** All input for the `updateShipperProgram` mutation. */
export type UpdateShipperProgramInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProgram` being updated. */
  patch: ShipperProgramPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProgram` mutation. */
export type UpdateShipperProgramPayload = {
  __typename?: 'UpdateShipperProgramPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgram` that was updated by this mutation. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Shipper` that is related to this `ShipperProgram`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Customer` that is related to this `ShipperProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProgram`. May be used by Relay 1. */
  shipperProgramEdge?: Maybe<ShipperProgramsEdge>;
};


/** The output of our update `ShipperProgram` mutation. */
export type UpdateShipperProgramPayloadShipperProgramEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
};

/** All input for the `updateShipperProjectionByNodeId` mutation. */
export type UpdateShipperProjectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjection` being updated. */
  patch: ShipperProjectionPatch;
};

/** All input for the `updateShipperProjectionEntryByNodeId` mutation. */
export type UpdateShipperProjectionEntryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionEntry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
};

/** All input for the `updateShipperProjectionEntry` mutation. */
export type UpdateShipperProjectionEntryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjectionEntry` being updated. */
  patch: ShipperProjectionEntryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjectionEntry` mutation. */
export type UpdateShipperProjectionEntryPayload = {
  __typename?: 'UpdateShipperProjectionEntryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` that was updated by this mutation. */
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjectionVesselInfo` that is related to this `ShipperProjectionEntry`. */
  vesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** An edge for our `ShipperProjectionEntry`. May be used by Relay 1. */
  shipperProjectionEntryEdge?: Maybe<ShipperProjectionEntriesEdge>;
};


/** The output of our update `ShipperProjectionEntry` mutation. */
export type UpdateShipperProjectionEntryPayloadShipperProjectionEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
};

/** All input for the `updateShipperProjection` mutation. */
export type UpdateShipperProjectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjection` being updated. */
  patch: ShipperProjectionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjection` mutation. */
export type UpdateShipperProjectionPayload = {
  __typename?: 'UpdateShipperProjectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` that was updated by this mutation. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our update `ShipperProjection` mutation. */
export type UpdateShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the `updateShipperProjectionProductByNodeId` mutation. */
export type UpdateShipperProjectionProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionProduct` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
};

/** All input for the `updateShipperProjectionProduct` mutation. */
export type UpdateShipperProjectionProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjectionProduct` being updated. */
  patch: ShipperProjectionProductPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjectionProduct` mutation. */
export type UpdateShipperProjectionProductPayload = {
  __typename?: 'UpdateShipperProjectionProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` that was updated by this mutation. */
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProjectionProduct`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProjectionProduct`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProjectionProduct`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProjectionProduct`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `ShipperProjectionProduct`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProjectionProduct`. May be used by Relay 1. */
  shipperProjectionProductEdge?: Maybe<ShipperProjectionProductsEdge>;
};


/** The output of our update `ShipperProjectionProduct` mutation. */
export type UpdateShipperProjectionProductPayloadShipperProjectionProductEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
};

/** All input for the `updateShipperProjectionVesselByNodeId` mutation. */
export type UpdateShipperProjectionVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionVessel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
};

/** All input for the `updateShipperProjectionVesselInfoByNodeId` mutation. */
export type UpdateShipperProjectionVesselInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ShipperProjectionVesselInfo` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ShipperProjectionVesselInfo` being updated. */
  patch: ShipperProjectionVesselInfoPatch;
};

/** All input for the `updateShipperProjectionVesselInfo` mutation. */
export type UpdateShipperProjectionVesselInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjectionVesselInfo` being updated. */
  patch: ShipperProjectionVesselInfoPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjectionVesselInfo` mutation. */
export type UpdateShipperProjectionVesselInfoPayload = {
  __typename?: 'UpdateShipperProjectionVesselInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVesselInfo` that was updated by this mutation. */
  shipperProjectionVesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionVesselInfo`. */
  projection?: Maybe<ShipperProjection>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionVesselInfo`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVesselInfo`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionVesselInfo`. May be used by Relay 1. */
  shipperProjectionVesselInfoEdge?: Maybe<ShipperProjectionVesselInfosEdge>;
};


/** The output of our update `ShipperProjectionVesselInfo` mutation. */
export type UpdateShipperProjectionVesselInfoPayloadShipperProjectionVesselInfoEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
};

/** All input for the `updateShipperProjectionVessel` mutation. */
export type UpdateShipperProjectionVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ShipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `ShipperProjectionVessel` mutation. */
export type UpdateShipperProjectionVesselPayload = {
  __typename?: 'UpdateShipperProjectionVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` that was updated by this mutation. */
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Vessel` that is related to this `ShipperProjectionVessel`. */
  vessel?: Maybe<Vessel>;
  /** An edge for our `ShipperProjectionVessel`. May be used by Relay 1. */
  shipperProjectionVesselEdge?: Maybe<ShipperProjectionVesselsEdge>;
};


/** The output of our update `ShipperProjectionVessel` mutation. */
export type UpdateShipperProjectionVesselPayloadShipperProjectionVesselEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
};

/** All input for the `updateTruckLoadByNodeId` mutation. */
export type UpdateTruckLoadByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TruckLoad` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TruckLoad` being updated. */
  patch: TruckLoadPatch;
};

/** All input for the `updateTruckLoad` mutation. */
export type UpdateTruckLoadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TruckLoad` being updated. */
  patch: TruckLoadPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `TruckLoad` mutation. */
export type UpdateTruckLoadPayload = {
  __typename?: 'UpdateTruckLoadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckLoad` that was updated by this mutation. */
  truckLoad?: Maybe<TruckLoad>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckLoad`. May be used by Relay 1. */
  truckLoadEdge?: Maybe<TruckLoadsEdge>;
};


/** The output of our update `TruckLoad` mutation. */
export type UpdateTruckLoadPayloadTruckLoadEdgeArgs = {
  orderBy?: Maybe<Array<TruckLoadsOrderBy>>;
};

/** All input for the `updateTruckRateByNodeId` mutation. */
export type UpdateTruckRateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TruckRate` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TruckRate` being updated. */
  patch: TruckRatePatch;
};

/** All input for the `updateTruckRateCustomerByNodeId` mutation. */
export type UpdateTruckRateCustomerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TruckRateCustomer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TruckRateCustomer` being updated. */
  patch: TruckRateCustomerPatch;
};

/** All input for the `updateTruckRateCustomer` mutation. */
export type UpdateTruckRateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TruckRateCustomer` being updated. */
  patch: TruckRateCustomerPatch;
  truckRateId: Scalars['BigInt'];
  customerId: Scalars['String'];
};

/** The output of our update `TruckRateCustomer` mutation. */
export type UpdateTruckRateCustomerPayload = {
  __typename?: 'UpdateTruckRateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRateCustomer` that was updated by this mutation. */
  truckRateCustomer?: Maybe<TruckRateCustomer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TruckRate` that is related to this `TruckRateCustomer`. */
  truckRate?: Maybe<TruckRate>;
  /** Reads a single `Customer` that is related to this `TruckRateCustomer`. */
  customer?: Maybe<Customer>;
  /** An edge for our `TruckRateCustomer`. May be used by Relay 1. */
  truckRateCustomerEdge?: Maybe<TruckRateCustomersEdge>;
};


/** The output of our update `TruckRateCustomer` mutation. */
export type UpdateTruckRateCustomerPayloadTruckRateCustomerEdgeArgs = {
  orderBy?: Maybe<Array<TruckRateCustomersOrderBy>>;
};

/** All input for the `updateTruckRate` mutation. */
export type UpdateTruckRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TruckRate` being updated. */
  patch: TruckRatePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `TruckRate` mutation. */
export type UpdateTruckRatePayload = {
  __typename?: 'UpdateTruckRatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRate` that was updated by this mutation. */
  truckRate?: Maybe<TruckRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckRate`. May be used by Relay 1. */
  truckRateEdge?: Maybe<TruckRatesEdge>;
};


/** The output of our update `TruckRate` mutation. */
export type UpdateTruckRatePayloadTruckRateEdgeArgs = {
  orderBy?: Maybe<Array<TruckRatesOrderBy>>;
};

/** All input for the `updateUnpaidByNodeId` mutation. */
export type UpdateUnpaidByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Unpaid` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Unpaid` being updated. */
  patch: UnpaidPatch;
};

/** All input for the `updateUnpaid` mutation. */
export type UpdateUnpaidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Unpaid` being updated. */
  patch: UnpaidPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Unpaid` mutation. */
export type UpdateUnpaidPayload = {
  __typename?: 'UpdateUnpaidPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Unpaid` that was updated by this mutation. */
  unpaid?: Maybe<Unpaid>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Unpaid`. May be used by Relay 1. */
  unpaidEdge?: Maybe<UnpaidsEdge>;
};


/** The output of our update `Unpaid` mutation. */
export type UpdateUnpaidPayloadUnpaidEdgeArgs = {
  orderBy?: Maybe<Array<UnpaidsOrderBy>>;
};

/** All input for the `updateUserBookmarkByNodeId` mutation. */
export type UpdateUserBookmarkByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserBookmark` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserBookmark` being updated. */
  patch: UserBookmarkPatch;
};

/** All input for the `updateUserBookmark` mutation. */
export type UpdateUserBookmarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserBookmark` being updated. */
  patch: UserBookmarkPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `UserBookmark` mutation. */
export type UpdateUserBookmarkPayload = {
  __typename?: 'UpdateUserBookmarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserBookmark` that was updated by this mutation. */
  userBookmark?: Maybe<UserBookmark>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserBookmark`. */
  user?: Maybe<User>;
  /** An edge for our `UserBookmark`. May be used by Relay 1. */
  userBookmarkEdge?: Maybe<UserBookmarksEdge>;
};


/** The output of our update `UserBookmark` mutation. */
export type UpdateUserBookmarkPayloadUserBookmarkEdgeArgs = {
  orderBy?: Maybe<Array<UserBookmarksOrderBy>>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByPin` mutation. */
export type UpdateUserByPinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  pin: Scalars['String'];
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updateUserMessageByNodeId` mutation. */
export type UpdateUserMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserMessage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserMessage` being updated. */
  patch: UserMessagePatch;
};

/** All input for the `updateUserMessage` mutation. */
export type UpdateUserMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserMessage` being updated. */
  patch: UserMessagePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `UserMessage` mutation. */
export type UpdateUserMessagePayload = {
  __typename?: 'UpdateUserMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` that was updated by this mutation. */
  userMessage?: Maybe<UserMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
  /** An edge for our `UserMessage`. May be used by Relay 1. */
  userMessageEdge?: Maybe<UserMessagesEdge>;
};


/** The output of our update `UserMessage` mutation. */
export type UpdateUserMessagePayloadUserMessageEdgeArgs = {
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserRoleByUserIdAndRoleName` mutation. */
export type UpdateUserRoleByUserIdAndRoleNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserRole` being updated. */
  patch: UserRolePatch;
  userId: Scalars['BigInt'];
  roleName: Scalars['String'];
};

/** The output of our update `UserRole` mutation. */
export type UpdateUserRolePayload = {
  __typename?: 'UpdateUserRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserRole` that was updated by this mutation. */
  userRole?: Maybe<UserRole>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>;
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>;
};


/** The output of our update `UserRole` mutation. */
export type UpdateUserRolePayloadUserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>;
};

/** All input for the `updateVendorByNodeId` mutation. */
export type UpdateVendorByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vendor` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Vendor` being updated. */
  patch: VendorPatch;
};

/** All input for the `updateVendor` mutation. */
export type UpdateVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Vendor` being updated. */
  patch: VendorPatch;
  id: Scalars['String'];
};

/** The output of our update `Vendor` mutation. */
export type UpdateVendorPayload = {
  __typename?: 'UpdateVendorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was updated by this mutation. */
  vendor?: Maybe<Vendor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our update `Vendor` mutation. */
export type UpdateVendorPayloadVendorEdgeArgs = {
  orderBy?: Maybe<Array<VendorsOrderBy>>;
};

/** All input for the `updateVendorPersonContactByNodeId` mutation. */
export type UpdateVendorPersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VendorPersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VendorPersonContact` being updated. */
  patch: VendorPersonContactPatch;
};

/** All input for the `updateVendorPersonContact` mutation. */
export type UpdateVendorPersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VendorPersonContact` being updated. */
  patch: VendorPersonContactPatch;
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `VendorPersonContact` mutation. */
export type UpdateVendorPersonContactPayload = {
  __typename?: 'UpdateVendorPersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VendorPersonContact` that was updated by this mutation. */
  vendorPersonContact?: Maybe<VendorPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vendor` that is related to this `VendorPersonContact`. */
  vendor?: Maybe<Vendor>;
  /** Reads a single `PersonContact` that is related to this `VendorPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `VendorPersonContact`. May be used by Relay 1. */
  vendorPersonContactEdge?: Maybe<VendorPersonContactsEdge>;
};


/** The output of our update `VendorPersonContact` mutation. */
export type UpdateVendorPersonContactPayloadVendorPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<VendorPersonContactsOrderBy>>;
};

/** All input for the `updateVesselByNodeId` mutation. */
export type UpdateVesselByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vessel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Vessel` being updated. */
  patch: VesselPatch;
};

/** All input for the `updateVesselControlByNodeId` mutation. */
export type UpdateVesselControlByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VesselControl` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VesselControl` being updated. */
  patch: VesselControlPatch;
};

/** All input for the `updateVesselControl` mutation. */
export type UpdateVesselControlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VesselControl` being updated. */
  patch: VesselControlPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `VesselControl` mutation. */
export type UpdateVesselControlPayload = {
  __typename?: 'UpdateVesselControlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VesselControl` that was updated by this mutation. */
  vesselControl?: Maybe<VesselControl>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VesselControl`. May be used by Relay 1. */
  vesselControlEdge?: Maybe<VesselControlsEdge>;
};


/** The output of our update `VesselControl` mutation. */
export type UpdateVesselControlPayloadVesselControlEdgeArgs = {
  orderBy?: Maybe<Array<VesselControlsOrderBy>>;
};

/** All input for the `updateVessel` mutation. */
export type UpdateVesselInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Vessel` being updated. */
  patch: VesselPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Vessel` mutation. */
export type UpdateVesselPayload = {
  __typename?: 'UpdateVesselPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` that was updated by this mutation. */
  vessel?: Maybe<Vessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vessel`. May be used by Relay 1. */
  vesselEdge?: Maybe<VesselsEdge>;
};


/** The output of our update `Vessel` mutation. */
export type UpdateVesselPayloadVesselEdgeArgs = {
  orderBy?: Maybe<Array<VesselsOrderBy>>;
};

/** All input for the `updateWarehouseByNodeId` mutation. */
export type UpdateWarehouseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  patch: WarehousePatch;
};

/** All input for the `updateWarehouse` mutation. */
export type UpdateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  patch: WarehousePatch;
  id: Scalars['String'];
};

/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayload = {
  __typename?: 'UpdateWarehousePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was updated by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayloadWarehouseEdgeArgs = {
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
};

/** All input for the `updateWarehousePersonContactByNodeId` mutation. */
export type UpdateWarehousePersonContactByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WarehousePersonContact` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WarehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
};

/** All input for the `updateWarehousePersonContact` mutation. */
export type UpdateWarehousePersonContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `WarehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The output of our update `WarehousePersonContact` mutation. */
export type UpdateWarehousePersonContactPayload = {
  __typename?: 'UpdateWarehousePersonContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` that was updated by this mutation. */
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `WarehousePersonContact`. May be used by Relay 1. */
  warehousePersonContactEdge?: Maybe<WarehousePersonContactsEdge>;
};


/** The output of our update `WarehousePersonContact` mutation. */
export type UpdateWarehousePersonContactPayloadWarehousePersonContactEdgeArgs = {
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
};

/** All input for the `updateWireRequestAccountOfSaleItemByNodeId` mutation. */
export type UpdateWireRequestAccountOfSaleItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestAccountOfSaleItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WireRequestAccountOfSaleItem` being updated. */
  patch: WireRequestAccountOfSaleItemPatch;
};

/** All input for the `updateWireRequestAccountOfSaleItem` mutation. */
export type UpdateWireRequestAccountOfSaleItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `WireRequestAccountOfSaleItem` being updated. */
  patch: WireRequestAccountOfSaleItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `WireRequestAccountOfSaleItem` mutation. */
export type UpdateWireRequestAccountOfSaleItemPayload = {
  __typename?: 'UpdateWireRequestAccountOfSaleItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestAccountOfSaleItem` that was updated by this mutation. */
  wireRequestAccountOfSaleItem?: Maybe<WireRequestAccountOfSaleItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestAccountOfSaleItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestAccountOfSaleItem`. May be used by Relay 1. */
  wireRequestAccountOfSaleItemEdge?: Maybe<WireRequestAccountOfSaleItemsEdge>;
};


/** The output of our update `WireRequestAccountOfSaleItem` mutation. */
export type UpdateWireRequestAccountOfSaleItemPayloadWireRequestAccountOfSaleItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestAccountOfSaleItemsOrderBy>>;
};

/** All input for the `updateWireRequestByNodeId` mutation. */
export type UpdateWireRequestByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequest` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WireRequest` being updated. */
  patch: WireRequestPatch;
};

/** All input for the `updateWireRequest` mutation. */
export type UpdateWireRequestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `WireRequest` being updated. */
  patch: WireRequestPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updateWireRequestMiscItemByNodeId` mutation. */
export type UpdateWireRequestMiscItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestMiscItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WireRequestMiscItem` being updated. */
  patch: WireRequestMiscItemPatch;
};

/** All input for the `updateWireRequestMiscItem` mutation. */
export type UpdateWireRequestMiscItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `WireRequestMiscItem` being updated. */
  patch: WireRequestMiscItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `WireRequestMiscItem` mutation. */
export type UpdateWireRequestMiscItemPayload = {
  __typename?: 'UpdateWireRequestMiscItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestMiscItem` that was updated by this mutation. */
  wireRequestMiscItem?: Maybe<WireRequestMiscItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestMiscItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestMiscItem`. May be used by Relay 1. */
  wireRequestMiscItemEdge?: Maybe<WireRequestMiscItemsEdge>;
};


/** The output of our update `WireRequestMiscItem` mutation. */
export type UpdateWireRequestMiscItemPayloadWireRequestMiscItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestMiscItemsOrderBy>>;
};

/** All input for the `updateWireRequestOceanFreightItemByNodeId` mutation. */
export type UpdateWireRequestOceanFreightItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestOceanFreightItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WireRequestOceanFreightItem` being updated. */
  patch: WireRequestOceanFreightItemPatch;
};

/** All input for the `updateWireRequestOceanFreightItem` mutation. */
export type UpdateWireRequestOceanFreightItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `WireRequestOceanFreightItem` being updated. */
  patch: WireRequestOceanFreightItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `WireRequestOceanFreightItem` mutation. */
export type UpdateWireRequestOceanFreightItemPayload = {
  __typename?: 'UpdateWireRequestOceanFreightItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestOceanFreightItem` that was updated by this mutation. */
  wireRequestOceanFreightItem?: Maybe<WireRequestOceanFreightItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestOceanFreightItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestOceanFreightItem`. May be used by Relay 1. */
  wireRequestOceanFreightItemEdge?: Maybe<WireRequestOceanFreightItemsEdge>;
};


/** The output of our update `WireRequestOceanFreightItem` mutation. */
export type UpdateWireRequestOceanFreightItemPayloadWireRequestOceanFreightItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestOceanFreightItemsOrderBy>>;
};

/** The output of our update `WireRequest` mutation. */
export type UpdateWireRequestPayload = {
  __typename?: 'UpdateWireRequestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequest` that was updated by this mutation. */
  wireRequest?: Maybe<WireRequest>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `WireRequest`. May be used by Relay 1. */
  wireRequestEdge?: Maybe<WireRequestsEdge>;
};


/** The output of our update `WireRequest` mutation. */
export type UpdateWireRequestPayloadWireRequestEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestsOrderBy>>;
};

/** All input for the `updateWireRequestShipperAdvanceItemByNodeId` mutation. */
export type UpdateWireRequestShipperAdvanceItemByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WireRequestShipperAdvanceItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WireRequestShipperAdvanceItem` being updated. */
  patch: WireRequestShipperAdvanceItemPatch;
};

/** All input for the `updateWireRequestShipperAdvanceItem` mutation. */
export type UpdateWireRequestShipperAdvanceItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `WireRequestShipperAdvanceItem` being updated. */
  patch: WireRequestShipperAdvanceItemPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `WireRequestShipperAdvanceItem` mutation. */
export type UpdateWireRequestShipperAdvanceItemPayload = {
  __typename?: 'UpdateWireRequestShipperAdvanceItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestShipperAdvanceItem` that was updated by this mutation. */
  wireRequestShipperAdvanceItem?: Maybe<WireRequestShipperAdvanceItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestShipperAdvanceItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestShipperAdvanceItem`. May be used by Relay 1. */
  wireRequestShipperAdvanceItemEdge?: Maybe<WireRequestShipperAdvanceItemsEdge>;
};


/** The output of our update `WireRequestShipperAdvanceItem` mutation. */
export type UpdateWireRequestShipperAdvanceItemPayloadWireRequestShipperAdvanceItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestShipperAdvanceItemsOrderBy>>;
};

/** All input for the upsert `AgendaItem` mutation. */
export type UpsertAgendaItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` to be upserted by this mutation. */
  agendaItem: AgendaItemInput;
};

/** The output of our upsert `AgendaItem` mutation. */
export type UpsertAgendaItemPayload = {
  __typename?: 'UpsertAgendaItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgendaItem` that were upserted by this mutation. */
  agendaItem?: Maybe<AgendaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `AgendaItem`. May be used by Relay 1. */
  agendaItemEdge?: Maybe<AgendaItemsEdge>;
};


/** The output of our upsert `AgendaItem` mutation. */
export type UpsertAgendaItemPayloadAgendaItemEdgeArgs = {
  orderBy?: Maybe<Array<AgendaItemsOrderBy>>;
};

/** All input for the upsert `CalendarEvent` mutation. */
export type UpsertCalendarEventInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` to be upserted by this mutation. */
  calendarEvent: CalendarEventInput;
};

/** The output of our upsert `CalendarEvent` mutation. */
export type UpsertCalendarEventPayload = {
  __typename?: 'UpsertCalendarEventPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CalendarEvent` that were upserted by this mutation. */
  calendarEvent?: Maybe<CalendarEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CalendarEvent`. May be used by Relay 1. */
  calendarEventEdge?: Maybe<CalendarEventsEdge>;
};


/** The output of our upsert `CalendarEvent` mutation. */
export type UpsertCalendarEventPayloadCalendarEventEdgeArgs = {
  orderBy?: Maybe<Array<CalendarEventsOrderBy>>;
};

/** All input for the upsert `CheckHeader` mutation. */
export type UpsertCheckHeaderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CheckHeader` to be upserted by this mutation. */
  checkHeader: CheckHeaderInput;
};

/** The output of our upsert `CheckHeader` mutation. */
export type UpsertCheckHeaderPayload = {
  __typename?: 'UpsertCheckHeaderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CheckHeader` that were upserted by this mutation. */
  checkHeader?: Maybe<CheckHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CheckHeader`. May be used by Relay 1. */
  checkHeaderEdge?: Maybe<CheckHeadersEdge>;
};


/** The output of our upsert `CheckHeader` mutation. */
export type UpsertCheckHeaderPayloadCheckHeaderEdgeArgs = {
  orderBy?: Maybe<Array<CheckHeadersOrderBy>>;
};

/** All input for the upsert `ChileDepartureInspectionPallet` mutation. */
export type UpsertChileDepartureInspectionPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` to be upserted by this mutation. */
  chileDepartureInspectionPallet: ChileDepartureInspectionPalletInput;
};

/** The output of our upsert `ChileDepartureInspectionPallet` mutation. */
export type UpsertChileDepartureInspectionPalletPayload = {
  __typename?: 'UpsertChileDepartureInspectionPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ChileDepartureInspectionPallet` that were upserted by this mutation. */
  chileDepartureInspectionPallet?: Maybe<ChileDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ChileDepartureInspectionPallet`. May be used by Relay 1. */
  chileDepartureInspectionPalletEdge?: Maybe<ChileDepartureInspectionPalletsEdge>;
};


/** The output of our upsert `ChileDepartureInspectionPallet` mutation. */
export type UpsertChileDepartureInspectionPalletPayloadChileDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<ChileDepartureInspectionPalletsOrderBy>>;
};

/** All input for the upsert `CommonCategory` mutation. */
export type UpsertCommonCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonCategory` to be upserted by this mutation. */
  commonCategory: CommonCategoryInput;
};

/** The output of our upsert `CommonCategory` mutation. */
export type UpsertCommonCategoryPayload = {
  __typename?: 'UpsertCommonCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonCategory` that were upserted by this mutation. */
  commonCategory?: Maybe<CommonCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CommonCategory`. May be used by Relay 1. */
  commonCategoryEdge?: Maybe<CommonCategoriesEdge>;
};


/** The output of our upsert `CommonCategory` mutation. */
export type UpsertCommonCategoryPayloadCommonCategoryEdgeArgs = {
  orderBy?: Maybe<Array<CommonCategoriesOrderBy>>;
};

/** All input for the upsert `CommonPackType` mutation. */
export type UpsertCommonPackTypeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackType` to be upserted by this mutation. */
  commonPackType: CommonPackTypeInput;
};

/** All input for the upsert `CommonPackTypePackMaster` mutation. */
export type UpsertCommonPackTypePackMasterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypePackMaster` to be upserted by this mutation. */
  commonPackTypePackMaster: CommonPackTypePackMasterInput;
};

/** The output of our upsert `CommonPackTypePackMaster` mutation. */
export type UpsertCommonPackTypePackMasterPayload = {
  __typename?: 'UpsertCommonPackTypePackMasterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypePackMaster` that were upserted by this mutation. */
  commonPackTypePackMaster?: Maybe<CommonPackTypePackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypePackMaster`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `PackMaster` that is related to this `CommonPackTypePackMaster`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackTypePackMaster`. May be used by Relay 1. */
  commonPackTypePackMasterEdge?: Maybe<CommonPackTypePackMastersEdge>;
};


/** The output of our upsert `CommonPackTypePackMaster` mutation. */
export type UpsertCommonPackTypePackMasterPayloadCommonPackTypePackMasterEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypePackMastersOrderBy>>;
};

/** The output of our upsert `CommonPackType` mutation. */
export type UpsertCommonPackTypePayload = {
  __typename?: 'UpsertCommonPackTypePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackType` that were upserted by this mutation. */
  commonPackType?: Maybe<CommonPackType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonPackType`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `PackMaster` that is related to this `CommonPackType`. */
  packMaster?: Maybe<PackMaster>;
  /** An edge for our `CommonPackType`. May be used by Relay 1. */
  commonPackTypeEdge?: Maybe<CommonPackTypesEdge>;
};


/** The output of our upsert `CommonPackType` mutation. */
export type UpsertCommonPackTypePayloadCommonPackTypeEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypesOrderBy>>;
};

/** All input for the upsert `CommonPackTypeTag` mutation. */
export type UpsertCommonPackTypeTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypeTag` to be upserted by this mutation. */
  commonPackTypeTag: CommonPackTypeTagInput;
};

/** The output of our upsert `CommonPackTypeTag` mutation. */
export type UpsertCommonPackTypeTagPayload = {
  __typename?: 'UpsertCommonPackTypeTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonPackTypeTag` that were upserted by this mutation. */
  commonPackTypeTag?: Maybe<CommonPackTypeTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonPackType` that is related to this `CommonPackTypeTag`. */
  commonPackType?: Maybe<CommonPackType>;
  /** An edge for our `CommonPackTypeTag`. May be used by Relay 1. */
  commonPackTypeTagEdge?: Maybe<CommonPackTypeTagsEdge>;
};


/** The output of our upsert `CommonPackTypeTag` mutation. */
export type UpsertCommonPackTypeTagPayloadCommonPackTypeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonPackTypeTagsOrderBy>>;
};

/** All input for the upsert `CommonSize` mutation. */
export type UpsertCommonSizeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSize` to be upserted by this mutation. */
  commonSize: CommonSizeInput;
};

/** The output of our upsert `CommonSize` mutation. */
export type UpsertCommonSizePayload = {
  __typename?: 'UpsertCommonSizePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSize` that were upserted by this mutation. */
  commonSize?: Maybe<CommonSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSize`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSize` that is related to this `CommonSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSize`. May be used by Relay 1. */
  commonSizeEdge?: Maybe<CommonSizesEdge>;
};


/** The output of our upsert `CommonSize` mutation. */
export type UpsertCommonSizePayloadCommonSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizesOrderBy>>;
};

/** All input for the upsert `CommonSizeProductSize` mutation. */
export type UpsertCommonSizeProductSizeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeProductSize` to be upserted by this mutation. */
  commonSizeProductSize: CommonSizeProductSizeInput;
};

/** The output of our upsert `CommonSizeProductSize` mutation. */
export type UpsertCommonSizeProductSizePayload = {
  __typename?: 'UpsertCommonSizeProductSizePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeProductSize` that were upserted by this mutation. */
  commonSizeProductSize?: Maybe<CommonSizeProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeProductSize`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `ProductSize` that is related to this `CommonSizeProductSize`. */
  productSize?: Maybe<ProductSize>;
  /** An edge for our `CommonSizeProductSize`. May be used by Relay 1. */
  commonSizeProductSizeEdge?: Maybe<CommonSizeProductSizesEdge>;
};


/** The output of our upsert `CommonSizeProductSize` mutation. */
export type UpsertCommonSizeProductSizePayloadCommonSizeProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeProductSizesOrderBy>>;
};

/** All input for the upsert `CommonSizeTag` mutation. */
export type UpsertCommonSizeTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeTag` to be upserted by this mutation. */
  commonSizeTag: CommonSizeTagInput;
};

/** The output of our upsert `CommonSizeTag` mutation. */
export type UpsertCommonSizeTagPayload = {
  __typename?: 'UpsertCommonSizeTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSizeTag` that were upserted by this mutation. */
  commonSizeTag?: Maybe<CommonSizeTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSize` that is related to this `CommonSizeTag`. */
  commonSize?: Maybe<CommonSize>;
  /** An edge for our `CommonSizeTag`. May be used by Relay 1. */
  commonSizeTagEdge?: Maybe<CommonSizeTagsEdge>;
};


/** The output of our upsert `CommonSizeTag` mutation. */
export type UpsertCommonSizeTagPayloadCommonSizeTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSizeTagsOrderBy>>;
};

/** All input for the upsert `CommonSpecies` mutation. */
export type UpsertCommonSpeciesInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpecies` to be upserted by this mutation. */
  commonSpecies: CommonSpeciesInput;
};

/** The output of our upsert `CommonSpecies` mutation. */
export type UpsertCommonSpeciesPayload = {
  __typename?: 'UpsertCommonSpeciesPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpecies` that were upserted by this mutation. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonCategory` that is related to this `CommonSpecies`. */
  commonCategory?: Maybe<CommonCategory>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpecies`. May be used by Relay 1. */
  commonSpeciesEdge?: Maybe<CommonSpeciesEdge>;
};


/** The output of our upsert `CommonSpecies` mutation. */
export type UpsertCommonSpeciesPayloadCommonSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesOrderBy>>;
};

/** All input for the upsert `CommonSpeciesProductSpecies` mutation. */
export type UpsertCommonSpeciesProductSpeciesInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesProductSpecies` to be upserted by this mutation. */
  commonSpeciesProductSpecies: CommonSpeciesProductSpeciesInput;
};

/** The output of our upsert `CommonSpeciesProductSpecies` mutation. */
export type UpsertCommonSpeciesProductSpeciesPayload = {
  __typename?: 'UpsertCommonSpeciesProductSpeciesPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesProductSpecies` that were upserted by this mutation. */
  commonSpeciesProductSpecies?: Maybe<CommonSpeciesProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductSpecies` that is related to this `CommonSpeciesProductSpecies`. */
  productSpecies?: Maybe<ProductSpecies>;
  /** An edge for our `CommonSpeciesProductSpecies`. May be used by Relay 1. */
  commonSpeciesProductSpeciesEdge?: Maybe<CommonSpeciesProductSpeciesEdge>;
};


/** The output of our upsert `CommonSpeciesProductSpecies` mutation. */
export type UpsertCommonSpeciesProductSpeciesPayloadCommonSpeciesProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesProductSpeciesOrderBy>>;
};

/** All input for the upsert `CommonSpeciesTag` mutation. */
export type UpsertCommonSpeciesTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesTag` to be upserted by this mutation. */
  commonSpeciesTag: CommonSpeciesTagInput;
};

/** The output of our upsert `CommonSpeciesTag` mutation. */
export type UpsertCommonSpeciesTagPayload = {
  __typename?: 'UpsertCommonSpeciesTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonSpeciesTag` that were upserted by this mutation. */
  commonSpeciesTag?: Maybe<CommonSpeciesTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonSpeciesTag`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** An edge for our `CommonSpeciesTag`. May be used by Relay 1. */
  commonSpeciesTagEdge?: Maybe<CommonSpeciesTagsEdge>;
};


/** The output of our upsert `CommonSpeciesTag` mutation. */
export type UpsertCommonSpeciesTagPayloadCommonSpeciesTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonSpeciesTagsOrderBy>>;
};

/** All input for the upsert `CommonVariety` mutation. */
export type UpsertCommonVarietyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVariety` to be upserted by this mutation. */
  commonVariety: CommonVarietyInput;
};

/** The output of our upsert `CommonVariety` mutation. */
export type UpsertCommonVarietyPayload = {
  __typename?: 'UpsertCommonVarietyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVariety` that were upserted by this mutation. */
  commonVariety?: Maybe<CommonVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CommonVariety`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `ProductVariety` that is related to this `CommonVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVariety`. May be used by Relay 1. */
  commonVarietyEdge?: Maybe<CommonVarietiesEdge>;
};


/** The output of our upsert `CommonVariety` mutation. */
export type UpsertCommonVarietyPayloadCommonVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietiesOrderBy>>;
};

/** All input for the upsert `CommonVarietyProductVariety` mutation. */
export type UpsertCommonVarietyProductVarietyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyProductVariety` to be upserted by this mutation. */
  commonVarietyProductVariety: CommonVarietyProductVarietyInput;
};

/** The output of our upsert `CommonVarietyProductVariety` mutation. */
export type UpsertCommonVarietyProductVarietyPayload = {
  __typename?: 'UpsertCommonVarietyProductVarietyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyProductVariety` that were upserted by this mutation. */
  commonVarietyProductVariety?: Maybe<CommonVarietyProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyProductVariety`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `ProductVariety` that is related to this `CommonVarietyProductVariety`. */
  productVariety?: Maybe<ProductVariety>;
  /** An edge for our `CommonVarietyProductVariety`. May be used by Relay 1. */
  commonVarietyProductVarietyEdge?: Maybe<CommonVarietyProductVarietiesEdge>;
};


/** The output of our upsert `CommonVarietyProductVariety` mutation. */
export type UpsertCommonVarietyProductVarietyPayloadCommonVarietyProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyProductVarietiesOrderBy>>;
};

/** All input for the upsert `CommonVarietyTag` mutation. */
export type UpsertCommonVarietyTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyTag` to be upserted by this mutation. */
  commonVarietyTag: CommonVarietyTagInput;
};

/** The output of our upsert `CommonVarietyTag` mutation. */
export type UpsertCommonVarietyTagPayload = {
  __typename?: 'UpsertCommonVarietyTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CommonVarietyTag` that were upserted by this mutation. */
  commonVarietyTag?: Maybe<CommonVarietyTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonVariety` that is related to this `CommonVarietyTag`. */
  commonVariety?: Maybe<CommonVariety>;
  /** An edge for our `CommonVarietyTag`. May be used by Relay 1. */
  commonVarietyTagEdge?: Maybe<CommonVarietyTagsEdge>;
};


/** The output of our upsert `CommonVarietyTag` mutation. */
export type UpsertCommonVarietyTagPayloadCommonVarietyTagEdgeArgs = {
  orderBy?: Maybe<Array<CommonVarietyTagsOrderBy>>;
};

/** All input for the upsert `ContactGroup` mutation. */
export type UpsertContactGroupInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` to be upserted by this mutation. */
  contactGroup: ContactGroupInput;
};

/** The output of our upsert `ContactGroup` mutation. */
export type UpsertContactGroupPayload = {
  __typename?: 'UpsertContactGroupPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroup` that were upserted by this mutation. */
  contactGroup?: Maybe<ContactGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ContactGroup`. */
  user?: Maybe<User>;
  /** An edge for our `ContactGroup`. May be used by Relay 1. */
  contactGroupEdge?: Maybe<ContactGroupsEdge>;
};


/** The output of our upsert `ContactGroup` mutation. */
export type UpsertContactGroupPayloadContactGroupEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
};

/** All input for the upsert `ContactGroupPersonContact` mutation. */
export type UpsertContactGroupPersonContactInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` to be upserted by this mutation. */
  contactGroupPersonContact: ContactGroupPersonContactInput;
};

/** The output of our upsert `ContactGroupPersonContact` mutation. */
export type UpsertContactGroupPersonContactPayload = {
  __typename?: 'UpsertContactGroupPersonContactPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContactGroupPersonContact` that were upserted by this mutation. */
  contactGroupPersonContact?: Maybe<ContactGroupPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ContactGroup` that is related to this `ContactGroupPersonContact`. */
  group?: Maybe<ContactGroup>;
  /** Reads a single `PersonContact` that is related to this `ContactGroupPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ContactGroupPersonContact`. May be used by Relay 1. */
  contactGroupPersonContactEdge?: Maybe<ContactGroupPersonContactsEdge>;
};


/** The output of our upsert `ContactGroupPersonContact` mutation. */
export type UpsertContactGroupPersonContactPayloadContactGroupPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ContactGroupPersonContactsOrderBy>>;
};

/** All input for the upsert `Container` mutation. */
export type UpsertContainerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Container` to be upserted by this mutation. */
  container: ContainerInput;
};

/** The output of our upsert `Container` mutation. */
export type UpsertContainerPayload = {
  __typename?: 'UpsertContainerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Container` that were upserted by this mutation. */
  container?: Maybe<Container>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Container`. May be used by Relay 1. */
  containerEdge?: Maybe<ContainersEdge>;
};


/** The output of our upsert `Container` mutation. */
export type UpsertContainerPayloadContainerEdgeArgs = {
  orderBy?: Maybe<Array<ContainersOrderBy>>;
};

/** All input for the upsert `ContainerTreatment` mutation. */
export type UpsertContainerTreatmentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContainerTreatment` to be upserted by this mutation. */
  containerTreatment: ContainerTreatmentInput;
};

/** The output of our upsert `ContainerTreatment` mutation. */
export type UpsertContainerTreatmentPayload = {
  __typename?: 'UpsertContainerTreatmentPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContainerTreatment` that were upserted by this mutation. */
  containerTreatment?: Maybe<ContainerTreatment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Container` that is related to this `ContainerTreatment`. */
  container?: Maybe<Container>;
  /** An edge for our `ContainerTreatment`. May be used by Relay 1. */
  containerTreatmentEdge?: Maybe<ContainerTreatmentsEdge>;
};


/** The output of our upsert `ContainerTreatment` mutation. */
export type UpsertContainerTreatmentPayloadContainerTreatmentEdgeArgs = {
  orderBy?: Maybe<Array<ContainerTreatmentsOrderBy>>;
};

/** All input for the upsert `Country` mutation. */
export type UpsertCountryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` to be upserted by this mutation. */
  country: CountryInput;
};

/** The output of our upsert `Country` mutation. */
export type UpsertCountryPayload = {
  __typename?: 'UpsertCountryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that were upserted by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our upsert `Country` mutation. */
export type UpsertCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the upsert `Customer` mutation. */
export type UpsertCustomerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` to be upserted by this mutation. */
  customer: CustomerInput;
};

/** The output of our upsert `Customer` mutation. */
export type UpsertCustomerPayload = {
  __typename?: 'UpsertCustomerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that were upserted by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our upsert `Customer` mutation. */
export type UpsertCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the upsert `CustomerPayment` mutation. */
export type UpsertCustomerPaymentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPayment` to be upserted by this mutation. */
  customerPayment: CustomerPaymentInput;
};

/** The output of our upsert `CustomerPayment` mutation. */
export type UpsertCustomerPaymentPayload = {
  __typename?: 'UpsertCustomerPaymentPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPayment` that were upserted by this mutation. */
  customerPayment?: Maybe<CustomerPayment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerPayment`. May be used by Relay 1. */
  customerPaymentEdge?: Maybe<CustomerPaymentsEdge>;
};


/** The output of our upsert `CustomerPayment` mutation. */
export type UpsertCustomerPaymentPayloadCustomerPaymentEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPaymentsOrderBy>>;
};

/** All input for the upsert `CustomerPersonContact` mutation. */
export type UpsertCustomerPersonContactInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` to be upserted by this mutation. */
  customerPersonContact: CustomerPersonContactInput;
};

/** The output of our upsert `CustomerPersonContact` mutation. */
export type UpsertCustomerPersonContactPayload = {
  __typename?: 'UpsertCustomerPersonContactPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerPersonContact` that were upserted by this mutation. */
  customerPersonContact?: Maybe<CustomerPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerPersonContact`. */
  customer?: Maybe<Customer>;
  /** Reads a single `PersonContact` that is related to this `CustomerPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `CustomerPersonContact`. May be used by Relay 1. */
  customerPersonContactEdge?: Maybe<CustomerPersonContactsEdge>;
};


/** The output of our upsert `CustomerPersonContact` mutation. */
export type UpsertCustomerPersonContactPayloadCustomerPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<CustomerPersonContactsOrderBy>>;
};

/** All input for the upsert `CustomerProgramEntry` mutation. */
export type UpsertCustomerProgramEntryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgramEntry` to be upserted by this mutation. */
  customerProgramEntry: CustomerProgramEntryInput;
};

/** The output of our upsert `CustomerProgramEntry` mutation. */
export type UpsertCustomerProgramEntryPayload = {
  __typename?: 'UpsertCustomerProgramEntryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgramEntry` that were upserted by this mutation. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgram` that is related to this `CustomerProgramEntry`. */
  customerProgram?: Maybe<CustomerProgram>;
  /** An edge for our `CustomerProgramEntry`. May be used by Relay 1. */
  customerProgramEntryEdge?: Maybe<CustomerProgramEntriesEdge>;
};


/** The output of our upsert `CustomerProgramEntry` mutation. */
export type UpsertCustomerProgramEntryPayloadCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramEntriesOrderBy>>;
};

/** All input for the upsert `CustomerProgram` mutation. */
export type UpsertCustomerProgramInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgram` to be upserted by this mutation. */
  customerProgram: CustomerProgramInput;
};

/** The output of our upsert `CustomerProgram` mutation. */
export type UpsertCustomerProgramPayload = {
  __typename?: 'UpsertCustomerProgramPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerProgram` that were upserted by this mutation. */
  customerProgram?: Maybe<CustomerProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `CustomerProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `CustomerProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `CustomerProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `CustomerProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `CustomerProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `CustomerProgram`. May be used by Relay 1. */
  customerProgramEdge?: Maybe<CustomerProgramsEdge>;
};


/** The output of our upsert `CustomerProgram` mutation. */
export type UpsertCustomerProgramPayloadCustomerProgramEdgeArgs = {
  orderBy?: Maybe<Array<CustomerProgramsOrderBy>>;
};

/** All input for the upsert `CustomerVolumeDiscount` mutation. */
export type UpsertCustomerVolumeDiscountInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerVolumeDiscount` to be upserted by this mutation. */
  customerVolumeDiscount: CustomerVolumeDiscountInput;
};

/** The output of our upsert `CustomerVolumeDiscount` mutation. */
export type UpsertCustomerVolumeDiscountPayload = {
  __typename?: 'UpsertCustomerVolumeDiscountPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerVolumeDiscount` that were upserted by this mutation. */
  customerVolumeDiscount?: Maybe<CustomerVolumeDiscount>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerVolumeDiscount`. May be used by Relay 1. */
  customerVolumeDiscountEdge?: Maybe<CustomerVolumeDiscountsEdge>;
};


/** The output of our upsert `CustomerVolumeDiscount` mutation. */
export type UpsertCustomerVolumeDiscountPayloadCustomerVolumeDiscountEdgeArgs = {
  orderBy?: Maybe<Array<CustomerVolumeDiscountsOrderBy>>;
};

/** All input for the upsert `ExpenseHeader` mutation. */
export type UpsertExpenseHeaderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeader` to be upserted by this mutation. */
  expenseHeader: ExpenseHeaderInput;
};

/** The output of our upsert `ExpenseHeader` mutation. */
export type UpsertExpenseHeaderPayload = {
  __typename?: 'UpsertExpenseHeaderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeader` that were upserted by this mutation. */
  expenseHeader?: Maybe<ExpenseHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeader`. May be used by Relay 1. */
  expenseHeaderEdge?: Maybe<ExpenseHeadersEdge>;
};


/** The output of our upsert `ExpenseHeader` mutation. */
export type UpsertExpenseHeaderPayloadExpenseHeaderEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeadersOrderBy>>;
};

/** All input for the upsert `ExpenseHeaderReview` mutation. */
export type UpsertExpenseHeaderReviewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeaderReview` to be upserted by this mutation. */
  expenseHeaderReview: ExpenseHeaderReviewInput;
};

/** The output of our upsert `ExpenseHeaderReview` mutation. */
export type UpsertExpenseHeaderReviewPayload = {
  __typename?: 'UpsertExpenseHeaderReviewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseHeaderReview` that were upserted by this mutation. */
  expenseHeaderReview?: Maybe<ExpenseHeaderReview>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseHeaderReview`. May be used by Relay 1. */
  expenseHeaderReviewEdge?: Maybe<ExpenseHeaderReviewsEdge>;
};


/** The output of our upsert `ExpenseHeaderReview` mutation. */
export type UpsertExpenseHeaderReviewPayloadExpenseHeaderReviewEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseHeaderReviewsOrderBy>>;
};

/** All input for the upsert `ExpenseItem` mutation. */
export type UpsertExpenseItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseItem` to be upserted by this mutation. */
  expenseItem: ExpenseItemInput;
};

/** The output of our upsert `ExpenseItem` mutation. */
export type UpsertExpenseItemPayload = {
  __typename?: 'UpsertExpenseItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ExpenseItem` that were upserted by this mutation. */
  expenseItem?: Maybe<ExpenseItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ExpenseItem`. May be used by Relay 1. */
  expenseItemEdge?: Maybe<ExpenseItemsEdge>;
};


/** The output of our upsert `ExpenseItem` mutation. */
export type UpsertExpenseItemPayloadExpenseItemEdgeArgs = {
  orderBy?: Maybe<Array<ExpenseItemsOrderBy>>;
};

/** All input for the upsert `InventoryItem` mutation. */
export type UpsertInventoryItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` to be upserted by this mutation. */
  inventoryItem: InventoryItemInput;
};

/** The output of our upsert `InventoryItem` mutation. */
export type UpsertInventoryItemPayload = {
  __typename?: 'UpsertInventoryItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InventoryItem` that were upserted by this mutation. */
  inventoryItem?: Maybe<InventoryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InventoryItem`. May be used by Relay 1. */
  inventoryItemEdge?: Maybe<InventoryItemsEdge>;
};


/** The output of our upsert `InventoryItem` mutation. */
export type UpsertInventoryItemPayloadInventoryItemEdgeArgs = {
  orderBy?: Maybe<Array<InventoryItemsOrderBy>>;
};

/** All input for the upsert `InvoiceHeader` mutation. */
export type UpsertInvoiceHeaderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceHeader` to be upserted by this mutation. */
  invoiceHeader: InvoiceHeaderInput;
};

/** The output of our upsert `InvoiceHeader` mutation. */
export type UpsertInvoiceHeaderPayload = {
  __typename?: 'UpsertInvoiceHeaderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceHeader` that were upserted by this mutation. */
  invoiceHeader?: Maybe<InvoiceHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceHeader`. May be used by Relay 1. */
  invoiceHeaderEdge?: Maybe<InvoiceHeadersEdge>;
};


/** The output of our upsert `InvoiceHeader` mutation. */
export type UpsertInvoiceHeaderPayloadInvoiceHeaderEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceHeadersOrderBy>>;
};

/** All input for the upsert `InvoiceItemHistory` mutation. */
export type UpsertInvoiceItemHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItemHistory` to be upserted by this mutation. */
  invoiceItemHistory: InvoiceItemHistoryInput;
};

/** The output of our upsert `InvoiceItemHistory` mutation. */
export type UpsertInvoiceItemHistoryPayload = {
  __typename?: 'UpsertInvoiceItemHistoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItemHistory` that were upserted by this mutation. */
  invoiceItemHistory?: Maybe<InvoiceItemHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItemHistory`. May be used by Relay 1. */
  invoiceItemHistoryEdge?: Maybe<InvoiceItemHistoriesEdge>;
};


/** The output of our upsert `InvoiceItemHistory` mutation. */
export type UpsertInvoiceItemHistoryPayloadInvoiceItemHistoryEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemHistoriesOrderBy>>;
};

/** All input for the upsert `InvoiceItem` mutation. */
export type UpsertInvoiceItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItem` to be upserted by this mutation. */
  invoiceItem: InvoiceItemInput;
};

/** The output of our upsert `InvoiceItem` mutation. */
export type UpsertInvoiceItemPayload = {
  __typename?: 'UpsertInvoiceItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `InvoiceItem` that were upserted by this mutation. */
  invoiceItem?: Maybe<InvoiceItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `InvoiceItem`. May be used by Relay 1. */
  invoiceItemEdge?: Maybe<InvoiceItemsEdge>;
};


/** The output of our upsert `InvoiceItem` mutation. */
export type UpsertInvoiceItemPayloadInvoiceItemEdgeArgs = {
  orderBy?: Maybe<Array<InvoiceItemsOrderBy>>;
};

/** All input for the upsert `LoadNumber` mutation. */
export type UpsertLoadNumberInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LoadNumber` to be upserted by this mutation. */
  loadNumber: LoadNumberInput;
};

/** The output of our upsert `LoadNumber` mutation. */
export type UpsertLoadNumberPayload = {
  __typename?: 'UpsertLoadNumberPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LoadNumber` that were upserted by this mutation. */
  loadNumber?: Maybe<LoadNumber>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LoadNumber`. */
  user?: Maybe<User>;
  /** An edge for our `LoadNumber`. May be used by Relay 1. */
  loadNumberEdge?: Maybe<LoadNumbersEdge>;
};


/** The output of our upsert `LoadNumber` mutation. */
export type UpsertLoadNumberPayloadLoadNumberEdgeArgs = {
  orderBy?: Maybe<Array<LoadNumbersOrderBy>>;
};

/** All input for the upsert `OrderComment` mutation. */
export type UpsertOrderCommentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderComment` to be upserted by this mutation. */
  orderComment: OrderCommentInput;
};

/** The output of our upsert `OrderComment` mutation. */
export type UpsertOrderCommentPayload = {
  __typename?: 'UpsertOrderCommentPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderComment` that were upserted by this mutation. */
  orderComment?: Maybe<OrderComment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderComment`. May be used by Relay 1. */
  orderCommentEdge?: Maybe<OrderCommentsEdge>;
};


/** The output of our upsert `OrderComment` mutation. */
export type UpsertOrderCommentPayloadOrderCommentEdgeArgs = {
  orderBy?: Maybe<Array<OrderCommentsOrderBy>>;
};

/** All input for the upsert `OrderEntry` mutation. */
export type UpsertOrderEntryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntry` to be upserted by this mutation. */
  orderEntry: OrderEntryInput;
};

/** All input for the upsert `OrderEntryItem` mutation. */
export type UpsertOrderEntryItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryItem` to be upserted by this mutation. */
  orderEntryItem: OrderEntryItemInput;
};

/** The output of our upsert `OrderEntryItem` mutation. */
export type UpsertOrderEntryItemPayload = {
  __typename?: 'UpsertOrderEntryItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryItem` that were upserted by this mutation. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntry` that is related to this `OrderEntryItem`. */
  orderEntry?: Maybe<OrderEntry>;
  /** An edge for our `OrderEntryItem`. May be used by Relay 1. */
  orderEntryItemEdge?: Maybe<OrderEntryItemsEdge>;
};


/** The output of our upsert `OrderEntryItem` mutation. */
export type UpsertOrderEntryItemPayloadOrderEntryItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryItemsOrderBy>>;
};

/** The output of our upsert `OrderEntry` mutation. */
export type UpsertOrderEntryPayload = {
  __typename?: 'UpsertOrderEntryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntry` that were upserted by this mutation. */
  orderEntry?: Maybe<OrderEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderEntry`. May be used by Relay 1. */
  orderEntryEdge?: Maybe<OrderEntriesEdge>;
};


/** The output of our upsert `OrderEntry` mutation. */
export type UpsertOrderEntryPayloadOrderEntryEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntriesOrderBy>>;
};

/** All input for the upsert `OrderEntryReviewItem` mutation. */
export type UpsertOrderEntryReviewItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryReviewItem` to be upserted by this mutation. */
  orderEntryReviewItem: OrderEntryReviewItemInput;
};

/** The output of our upsert `OrderEntryReviewItem` mutation. */
export type UpsertOrderEntryReviewItemPayload = {
  __typename?: 'UpsertOrderEntryReviewItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderEntryReviewItem` that were upserted by this mutation. */
  orderEntryReviewItem?: Maybe<OrderEntryReviewItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `OrderEntryItem` that is related to this `OrderEntryReviewItem`. */
  orderEntryItem?: Maybe<OrderEntryItem>;
  /** An edge for our `OrderEntryReviewItem`. May be used by Relay 1. */
  orderEntryReviewItemEdge?: Maybe<OrderEntryReviewItemsEdge>;
};


/** The output of our upsert `OrderEntryReviewItem` mutation. */
export type UpsertOrderEntryReviewItemPayloadOrderEntryReviewItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderEntryReviewItemsOrderBy>>;
};

/** All input for the upsert `OrderItem` mutation. */
export type UpsertOrderItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderItem` to be upserted by this mutation. */
  orderItem: OrderItemInput;
};

/** The output of our upsert `OrderItem` mutation. */
export type UpsertOrderItemPayload = {
  __typename?: 'UpsertOrderItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderItem` that were upserted by this mutation. */
  orderItem?: Maybe<OrderItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderItem`. May be used by Relay 1. */
  orderItemEdge?: Maybe<OrderItemsEdge>;
};


/** The output of our upsert `OrderItem` mutation. */
export type UpsertOrderItemPayloadOrderItemEdgeArgs = {
  orderBy?: Maybe<Array<OrderItemsOrderBy>>;
};

/** All input for the upsert `OrderMaster` mutation. */
export type UpsertOrderMasterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderMaster` to be upserted by this mutation. */
  orderMaster: OrderMasterInput;
};

/** The output of our upsert `OrderMaster` mutation. */
export type UpsertOrderMasterPayload = {
  __typename?: 'UpsertOrderMasterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderMaster` that were upserted by this mutation. */
  orderMaster?: Maybe<OrderMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderMaster`. May be used by Relay 1. */
  orderMasterEdge?: Maybe<OrderMastersEdge>;
};


/** The output of our upsert `OrderMaster` mutation. */
export type UpsertOrderMasterPayloadOrderMasterEdgeArgs = {
  orderBy?: Maybe<Array<OrderMastersOrderBy>>;
};

/** All input for the upsert `OrderNumber` mutation. */
export type UpsertOrderNumberInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderNumber` to be upserted by this mutation. */
  orderNumber: OrderNumberInput;
};

/** The output of our upsert `OrderNumber` mutation. */
export type UpsertOrderNumberPayload = {
  __typename?: 'UpsertOrderNumberPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderNumber` that were upserted by this mutation. */
  orderNumber?: Maybe<OrderNumber>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderNumber`. May be used by Relay 1. */
  orderNumberEdge?: Maybe<OrderNumbersEdge>;
};


/** The output of our upsert `OrderNumber` mutation. */
export type UpsertOrderNumberPayloadOrderNumberEdgeArgs = {
  orderBy?: Maybe<Array<OrderNumbersOrderBy>>;
};

/** All input for the upsert `OrderPallet` mutation. */
export type UpsertOrderPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderPallet` to be upserted by this mutation. */
  orderPallet: OrderPalletInput;
};

/** The output of our upsert `OrderPallet` mutation. */
export type UpsertOrderPalletPayload = {
  __typename?: 'UpsertOrderPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OrderPallet` that were upserted by this mutation. */
  orderPallet?: Maybe<OrderPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `OrderPallet`. May be used by Relay 1. */
  orderPalletEdge?: Maybe<OrderPalletsEdge>;
};


/** The output of our upsert `OrderPallet` mutation. */
export type UpsertOrderPalletPayloadOrderPalletEdgeArgs = {
  orderBy?: Maybe<Array<OrderPalletsOrderBy>>;
};

/** All input for the upsert `PackAtmosphere` mutation. */
export type UpsertPackAtmosphereInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` to be upserted by this mutation. */
  packAtmosphere: PackAtmosphereInput;
};

/** The output of our upsert `PackAtmosphere` mutation. */
export type UpsertPackAtmospherePayload = {
  __typename?: 'UpsertPackAtmospherePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackAtmosphere` that were upserted by this mutation. */
  packAtmosphere?: Maybe<PackAtmosphere>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackAtmosphere`. May be used by Relay 1. */
  packAtmosphereEdge?: Maybe<PackAtmospheresEdge>;
};


/** The output of our upsert `PackAtmosphere` mutation. */
export type UpsertPackAtmospherePayloadPackAtmosphereEdgeArgs = {
  orderBy?: Maybe<Array<PackAtmospheresOrderBy>>;
};

/** All input for the upsert `PackBoxStyle` mutation. */
export type UpsertPackBoxStyleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` to be upserted by this mutation. */
  packBoxStyle: PackBoxStyleInput;
};

/** The output of our upsert `PackBoxStyle` mutation. */
export type UpsertPackBoxStylePayload = {
  __typename?: 'UpsertPackBoxStylePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxStyle` that were upserted by this mutation. */
  packBoxStyle?: Maybe<PackBoxStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxStyle`. May be used by Relay 1. */
  packBoxStyleEdge?: Maybe<PackBoxStylesEdge>;
};


/** The output of our upsert `PackBoxStyle` mutation. */
export type UpsertPackBoxStylePayloadPackBoxStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxStylesOrderBy>>;
};

/** All input for the upsert `PackBoxType` mutation. */
export type UpsertPackBoxTypeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` to be upserted by this mutation. */
  packBoxType: PackBoxTypeInput;
};

/** The output of our upsert `PackBoxType` mutation. */
export type UpsertPackBoxTypePayload = {
  __typename?: 'UpsertPackBoxTypePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackBoxType` that were upserted by this mutation. */
  packBoxType?: Maybe<PackBoxType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackBoxType`. May be used by Relay 1. */
  packBoxTypeEdge?: Maybe<PackBoxTypesEdge>;
};


/** The output of our upsert `PackBoxType` mutation. */
export type UpsertPackBoxTypePayloadPackBoxTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackBoxTypesOrderBy>>;
};

/** All input for the upsert `PackDestination` mutation. */
export type UpsertPackDestinationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` to be upserted by this mutation. */
  packDestination: PackDestinationInput;
};

/** The output of our upsert `PackDestination` mutation. */
export type UpsertPackDestinationPayload = {
  __typename?: 'UpsertPackDestinationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackDestination` that were upserted by this mutation. */
  packDestination?: Maybe<PackDestination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackDestination`. May be used by Relay 1. */
  packDestinationEdge?: Maybe<PackDestinationsEdge>;
};


/** The output of our upsert `PackDestination` mutation. */
export type UpsertPackDestinationPayloadPackDestinationEdgeArgs = {
  orderBy?: Maybe<Array<PackDestinationsOrderBy>>;
};

/** All input for the upsert `PackGrade` mutation. */
export type UpsertPackGradeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` to be upserted by this mutation. */
  packGrade: PackGradeInput;
};

/** The output of our upsert `PackGrade` mutation. */
export type UpsertPackGradePayload = {
  __typename?: 'UpsertPackGradePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackGrade` that were upserted by this mutation. */
  packGrade?: Maybe<PackGrade>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackGrade`. May be used by Relay 1. */
  packGradeEdge?: Maybe<PackGradesEdge>;
};


/** The output of our upsert `PackGrade` mutation. */
export type UpsertPackGradePayloadPackGradeEdgeArgs = {
  orderBy?: Maybe<Array<PackGradesOrderBy>>;
};

/** All input for the upsert `PackHold` mutation. */
export type UpsertPackHoldInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` to be upserted by this mutation. */
  packHold: PackHoldInput;
};

/** The output of our upsert `PackHold` mutation. */
export type UpsertPackHoldPayload = {
  __typename?: 'UpsertPackHoldPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackHold` that were upserted by this mutation. */
  packHold?: Maybe<PackHold>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackHold`. May be used by Relay 1. */
  packHoldEdge?: Maybe<PackHoldsEdge>;
};


/** The output of our upsert `PackHold` mutation. */
export type UpsertPackHoldPayloadPackHoldEdgeArgs = {
  orderBy?: Maybe<Array<PackHoldsOrderBy>>;
};

/** All input for the upsert `PackLabel` mutation. */
export type UpsertPackLabelInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` to be upserted by this mutation. */
  packLabel: PackLabelInput;
};

/** The output of our upsert `PackLabel` mutation. */
export type UpsertPackLabelPayload = {
  __typename?: 'UpsertPackLabelPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLabel` that were upserted by this mutation. */
  packLabel?: Maybe<PackLabel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLabel`. May be used by Relay 1. */
  packLabelEdge?: Maybe<PackLabelsEdge>;
};


/** The output of our upsert `PackLabel` mutation. */
export type UpsertPackLabelPayloadPackLabelEdgeArgs = {
  orderBy?: Maybe<Array<PackLabelsOrderBy>>;
};

/** All input for the upsert `PackLiner` mutation. */
export type UpsertPackLinerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` to be upserted by this mutation. */
  packLiner: PackLinerInput;
};

/** The output of our upsert `PackLiner` mutation. */
export type UpsertPackLinerPayload = {
  __typename?: 'UpsertPackLinerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackLiner` that were upserted by this mutation. */
  packLiner?: Maybe<PackLiner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackLiner`. May be used by Relay 1. */
  packLinerEdge?: Maybe<PackLinersEdge>;
};


/** The output of our upsert `PackLiner` mutation. */
export type UpsertPackLinerPayloadPackLinerEdgeArgs = {
  orderBy?: Maybe<Array<PackLinersOrderBy>>;
};

/** All input for the upsert `PackMaster` mutation. */
export type UpsertPackMasterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` to be upserted by this mutation. */
  packMaster: PackMasterInput;
};

/** The output of our upsert `PackMaster` mutation. */
export type UpsertPackMasterPayload = {
  __typename?: 'UpsertPackMasterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackMaster` that were upserted by this mutation. */
  packMaster?: Maybe<PackMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackMaster`. May be used by Relay 1. */
  packMasterEdge?: Maybe<PackMastersEdge>;
};


/** The output of our upsert `PackMaster` mutation. */
export type UpsertPackMasterPayloadPackMasterEdgeArgs = {
  orderBy?: Maybe<Array<PackMastersOrderBy>>;
};

/** All input for the upsert `PackOut` mutation. */
export type UpsertPackOutInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` to be upserted by this mutation. */
  packOut: PackOutInput;
};

/** The output of our upsert `PackOut` mutation. */
export type UpsertPackOutPayload = {
  __typename?: 'UpsertPackOutPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackOut` that were upserted by this mutation. */
  packOut?: Maybe<PackOut>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackOut`. May be used by Relay 1. */
  packOutEdge?: Maybe<PackOutsEdge>;
};


/** The output of our upsert `PackOut` mutation. */
export type UpsertPackOutPayloadPackOutEdgeArgs = {
  orderBy?: Maybe<Array<PackOutsOrderBy>>;
};

/** All input for the upsert `PackPalletType` mutation. */
export type UpsertPackPalletTypeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` to be upserted by this mutation. */
  packPalletType: PackPalletTypeInput;
};

/** The output of our upsert `PackPalletType` mutation. */
export type UpsertPackPalletTypePayload = {
  __typename?: 'UpsertPackPalletTypePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackPalletType` that were upserted by this mutation. */
  packPalletType?: Maybe<PackPalletType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackPalletType`. May be used by Relay 1. */
  packPalletTypeEdge?: Maybe<PackPalletTypesEdge>;
};


/** The output of our upsert `PackPalletType` mutation. */
export type UpsertPackPalletTypePayloadPackPalletTypeEdgeArgs = {
  orderBy?: Maybe<Array<PackPalletTypesOrderBy>>;
};

/** All input for the upsert `PackProduction` mutation. */
export type UpsertPackProductionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` to be upserted by this mutation. */
  packProduction: PackProductionInput;
};

/** The output of our upsert `PackProduction` mutation. */
export type UpsertPackProductionPayload = {
  __typename?: 'UpsertPackProductionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackProduction` that were upserted by this mutation. */
  packProduction?: Maybe<PackProduction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackProduction`. May be used by Relay 1. */
  packProductionEdge?: Maybe<PackProductionsEdge>;
};


/** The output of our upsert `PackProduction` mutation. */
export type UpsertPackProductionPayloadPackProductionEdgeArgs = {
  orderBy?: Maybe<Array<PackProductionsOrderBy>>;
};

/** All input for the upsert `PackSpecial` mutation. */
export type UpsertPackSpecialInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` to be upserted by this mutation. */
  packSpecial: PackSpecialInput;
};

/** The output of our upsert `PackSpecial` mutation. */
export type UpsertPackSpecialPayload = {
  __typename?: 'UpsertPackSpecialPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackSpecial` that were upserted by this mutation. */
  packSpecial?: Maybe<PackSpecial>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackSpecial`. May be used by Relay 1. */
  packSpecialEdge?: Maybe<PackSpecialsEdge>;
};


/** The output of our upsert `PackSpecial` mutation. */
export type UpsertPackSpecialPayloadPackSpecialEdgeArgs = {
  orderBy?: Maybe<Array<PackSpecialsOrderBy>>;
};

/** All input for the upsert `PackStyle` mutation. */
export type UpsertPackStyleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` to be upserted by this mutation. */
  packStyle: PackStyleInput;
};

/** The output of our upsert `PackStyle` mutation. */
export type UpsertPackStylePayload = {
  __typename?: 'UpsertPackStylePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackStyle` that were upserted by this mutation. */
  packStyle?: Maybe<PackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackStyle`. May be used by Relay 1. */
  packStyleEdge?: Maybe<PackStylesEdge>;
};


/** The output of our upsert `PackStyle` mutation. */
export type UpsertPackStylePayloadPackStyleEdgeArgs = {
  orderBy?: Maybe<Array<PackStylesOrderBy>>;
};

/** All input for the upsert `PackTreeRipe` mutation. */
export type UpsertPackTreeRipeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` to be upserted by this mutation. */
  packTreeRipe: PackTreeRipeInput;
};

/** The output of our upsert `PackTreeRipe` mutation. */
export type UpsertPackTreeRipePayload = {
  __typename?: 'UpsertPackTreeRipePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PackTreeRipe` that were upserted by this mutation. */
  packTreeRipe?: Maybe<PackTreeRipe>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PackTreeRipe`. May be used by Relay 1. */
  packTreeRipeEdge?: Maybe<PackTreeRipesEdge>;
};


/** The output of our upsert `PackTreeRipe` mutation. */
export type UpsertPackTreeRipePayloadPackTreeRipeEdgeArgs = {
  orderBy?: Maybe<Array<PackTreeRipesOrderBy>>;
};

/** All input for the upsert `Pallet` mutation. */
export type UpsertPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` to be upserted by this mutation. */
  pallet: PalletInput;
};

/** The output of our upsert `Pallet` mutation. */
export type UpsertPalletPayload = {
  __typename?: 'UpsertPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Pallet` that were upserted by this mutation. */
  pallet?: Maybe<Pallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Pallet`. May be used by Relay 1. */
  palletEdge?: Maybe<PalletsEdge>;
};


/** The output of our upsert `Pallet` mutation. */
export type UpsertPalletPayloadPalletEdgeArgs = {
  orderBy?: Maybe<Array<PalletsOrderBy>>;
};

/** All input for the upsert `PalletSection` mutation. */
export type UpsertPalletSectionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` to be upserted by this mutation. */
  palletSection: PalletSectionInput;
};

/** The output of our upsert `PalletSection` mutation. */
export type UpsertPalletSectionPayload = {
  __typename?: 'UpsertPalletSectionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PalletSection` that were upserted by this mutation. */
  palletSection?: Maybe<PalletSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PalletSection`. May be used by Relay 1. */
  palletSectionEdge?: Maybe<PalletSectionsEdge>;
};


/** The output of our upsert `PalletSection` mutation. */
export type UpsertPalletSectionPayloadPalletSectionEdgeArgs = {
  orderBy?: Maybe<Array<PalletSectionsOrderBy>>;
};

/** All input for the upsert `PersonContact` mutation. */
export type UpsertPersonContactInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` to be upserted by this mutation. */
  personContact: PersonContactInput;
};

/** The output of our upsert `PersonContact` mutation. */
export type UpsertPersonContactPayload = {
  __typename?: 'UpsertPersonContactPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PersonContact` that were upserted by this mutation. */
  personContact?: Maybe<PersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PersonContact`. May be used by Relay 1. */
  personContactEdge?: Maybe<PersonContactsEdge>;
};


/** The output of our upsert `PersonContact` mutation. */
export type UpsertPersonContactPayloadPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
};

/** All input for the upsert `PeruDepartureInspection` mutation. */
export type UpsertPeruDepartureInspectionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` to be upserted by this mutation. */
  peruDepartureInspection: PeruDepartureInspectionInput;
};

/** All input for the upsert `PeruDepartureInspectionPallet` mutation. */
export type UpsertPeruDepartureInspectionPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` to be upserted by this mutation. */
  peruDepartureInspectionPallet: PeruDepartureInspectionPalletInput;
};

/** The output of our upsert `PeruDepartureInspectionPallet` mutation. */
export type UpsertPeruDepartureInspectionPalletPayload = {
  __typename?: 'UpsertPeruDepartureInspectionPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspectionPallet` that were upserted by this mutation. */
  peruDepartureInspectionPallet?: Maybe<PeruDepartureInspectionPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PeruDepartureInspection` that is related to this `PeruDepartureInspectionPallet`. */
  container?: Maybe<PeruDepartureInspection>;
  /** An edge for our `PeruDepartureInspectionPallet`. May be used by Relay 1. */
  peruDepartureInspectionPalletEdge?: Maybe<PeruDepartureInspectionPalletsEdge>;
};


/** The output of our upsert `PeruDepartureInspectionPallet` mutation. */
export type UpsertPeruDepartureInspectionPalletPayloadPeruDepartureInspectionPalletEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionPalletsOrderBy>>;
};

/** The output of our upsert `PeruDepartureInspection` mutation. */
export type UpsertPeruDepartureInspectionPayload = {
  __typename?: 'UpsertPeruDepartureInspectionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PeruDepartureInspection` that were upserted by this mutation. */
  peruDepartureInspection?: Maybe<PeruDepartureInspection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PeruDepartureInspection`. May be used by Relay 1. */
  peruDepartureInspectionEdge?: Maybe<PeruDepartureInspectionsEdge>;
};


/** The output of our upsert `PeruDepartureInspection` mutation. */
export type UpsertPeruDepartureInspectionPayloadPeruDepartureInspectionEdgeArgs = {
  orderBy?: Maybe<Array<PeruDepartureInspectionsOrderBy>>;
};

/** All input for the upsert `PriceCategory` mutation. */
export type UpsertPriceCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` to be upserted by this mutation. */
  priceCategory: PriceCategoryInput;
};

/** The output of our upsert `PriceCategory` mutation. */
export type UpsertPriceCategoryPayload = {
  __typename?: 'UpsertPriceCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceCategory` that were upserted by this mutation. */
  priceCategory?: Maybe<PriceCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PriceCategory`. May be used by Relay 1. */
  priceCategoryEdge?: Maybe<PriceCategoriesEdge>;
};


/** The output of our upsert `PriceCategory` mutation. */
export type UpsertPriceCategoryPayloadPriceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<PriceCategoriesOrderBy>>;
};

/** All input for the upsert `PriceEntry` mutation. */
export type UpsertPriceEntryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` to be upserted by this mutation. */
  priceEntry: PriceEntryInput;
};

/** The output of our upsert `PriceEntry` mutation. */
export type UpsertPriceEntryPayload = {
  __typename?: 'UpsertPriceEntryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceEntry` that were upserted by this mutation. */
  priceEntry?: Maybe<PriceEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceSize` that is related to this `PriceEntry`. */
  size?: Maybe<PriceSize>;
  /** An edge for our `PriceEntry`. May be used by Relay 1. */
  priceEntryEdge?: Maybe<PriceEntriesEdge>;
};


/** The output of our upsert `PriceEntry` mutation. */
export type UpsertPriceEntryPayloadPriceEntryEdgeArgs = {
  orderBy?: Maybe<Array<PriceEntriesOrderBy>>;
};

/** All input for the upsert `PriceProduct` mutation. */
export type UpsertPriceProductInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` to be upserted by this mutation. */
  priceProduct: PriceProductInput;
};

/** The output of our upsert `PriceProduct` mutation. */
export type UpsertPriceProductPayload = {
  __typename?: 'UpsertPriceProductPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceProduct` that were upserted by this mutation. */
  priceProduct?: Maybe<PriceProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceCategory` that is related to this `PriceProduct`. */
  category?: Maybe<PriceCategory>;
  /** An edge for our `PriceProduct`. May be used by Relay 1. */
  priceProductEdge?: Maybe<PriceProductsEdge>;
};


/** The output of our upsert `PriceProduct` mutation. */
export type UpsertPriceProductPayloadPriceProductEdgeArgs = {
  orderBy?: Maybe<Array<PriceProductsOrderBy>>;
};

/** All input for the upsert `PriceSize` mutation. */
export type UpsertPriceSizeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` to be upserted by this mutation. */
  priceSize: PriceSizeInput;
};

/** The output of our upsert `PriceSize` mutation. */
export type UpsertPriceSizePayload = {
  __typename?: 'UpsertPriceSizePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PriceSize` that were upserted by this mutation. */
  priceSize?: Maybe<PriceSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PriceProduct` that is related to this `PriceSize`. */
  product?: Maybe<PriceProduct>;
  /** An edge for our `PriceSize`. May be used by Relay 1. */
  priceSizeEdge?: Maybe<PriceSizesEdge>;
};


/** The output of our upsert `PriceSize` mutation. */
export type UpsertPriceSizePayloadPriceSizeEdgeArgs = {
  orderBy?: Maybe<Array<PriceSizesOrderBy>>;
};

/** All input for the upsert `ProductMaster` mutation. */
export type UpsertProductMasterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` to be upserted by this mutation. */
  productMaster: ProductMasterInput;
};

/** The output of our upsert `ProductMaster` mutation. */
export type UpsertProductMasterPayload = {
  __typename?: 'UpsertProductMasterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductMaster` that were upserted by this mutation. */
  productMaster?: Maybe<ProductMaster>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductMaster`. May be used by Relay 1. */
  productMasterEdge?: Maybe<ProductMastersEdge>;
};


/** The output of our upsert `ProductMaster` mutation. */
export type UpsertProductMasterPayloadProductMasterEdgeArgs = {
  orderBy?: Maybe<Array<ProductMastersOrderBy>>;
};

/** All input for the upsert `ProductSize` mutation. */
export type UpsertProductSizeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` to be upserted by this mutation. */
  productSize: ProductSizeInput;
};

/** The output of our upsert `ProductSize` mutation. */
export type UpsertProductSizePayload = {
  __typename?: 'UpsertProductSizePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSize` that were upserted by this mutation. */
  productSize?: Maybe<ProductSize>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSize`. May be used by Relay 1. */
  productSizeEdge?: Maybe<ProductSizesEdge>;
};


/** The output of our upsert `ProductSize` mutation. */
export type UpsertProductSizePayloadProductSizeEdgeArgs = {
  orderBy?: Maybe<Array<ProductSizesOrderBy>>;
};

/** All input for the upsert `ProductSpecies` mutation. */
export type UpsertProductSpeciesInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` to be upserted by this mutation. */
  productSpecies: ProductSpeciesInput;
};

/** The output of our upsert `ProductSpecies` mutation. */
export type UpsertProductSpeciesPayload = {
  __typename?: 'UpsertProductSpeciesPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductSpecies` that were upserted by this mutation. */
  productSpecies?: Maybe<ProductSpecies>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductSpecies`. May be used by Relay 1. */
  productSpeciesEdge?: Maybe<ProductSpeciesEdge>;
};


/** The output of our upsert `ProductSpecies` mutation. */
export type UpsertProductSpeciesPayloadProductSpeciesEdgeArgs = {
  orderBy?: Maybe<Array<ProductSpeciesOrderBy>>;
};

/** All input for the upsert `ProductVariety` mutation. */
export type UpsertProductVarietyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` to be upserted by this mutation. */
  productVariety: ProductVarietyInput;
};

/** The output of our upsert `ProductVariety` mutation. */
export type UpsertProductVarietyPayload = {
  __typename?: 'UpsertProductVarietyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductVariety` that were upserted by this mutation. */
  productVariety?: Maybe<ProductVariety>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductVariety`. May be used by Relay 1. */
  productVarietyEdge?: Maybe<ProductVarietiesEdge>;
};


/** The output of our upsert `ProductVariety` mutation. */
export type UpsertProductVarietyPayloadProductVarietyEdgeArgs = {
  orderBy?: Maybe<Array<ProductVarietiesOrderBy>>;
};

/** All input for the upsert `PsaApplePallet` mutation. */
export type UpsertPsaApplePalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` to be upserted by this mutation. */
  psaApplePallet: PsaApplePalletInput;
};

/** The output of our upsert `PsaApplePallet` mutation. */
export type UpsertPsaApplePalletPayload = {
  __typename?: 'UpsertPsaApplePalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaApplePallet` that were upserted by this mutation. */
  psaApplePallet?: Maybe<PsaApplePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaApplePallet`. May be used by Relay 1. */
  psaApplePalletEdge?: Maybe<PsaApplePalletsEdge>;
};


/** The output of our upsert `PsaApplePallet` mutation. */
export type UpsertPsaApplePalletPayloadPsaApplePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaApplePalletsOrderBy>>;
};

/** All input for the upsert `PsaArrivalPicture` mutation. */
export type UpsertPsaArrivalPictureInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` to be upserted by this mutation. */
  psaArrivalPicture: PsaArrivalPictureInput;
};

/** The output of our upsert `PsaArrivalPicture` mutation. */
export type UpsertPsaArrivalPicturePayload = {
  __typename?: 'UpsertPsaArrivalPicturePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalPicture` that were upserted by this mutation. */
  psaArrivalPicture?: Maybe<PsaArrivalPicture>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalPicture`. May be used by Relay 1. */
  psaArrivalPictureEdge?: Maybe<PsaArrivalPicturesEdge>;
};


/** The output of our upsert `PsaArrivalPicture` mutation. */
export type UpsertPsaArrivalPicturePayloadPsaArrivalPictureEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalPicturesOrderBy>>;
};

/** All input for the upsert `PsaArrivalReport` mutation. */
export type UpsertPsaArrivalReportInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` to be upserted by this mutation. */
  psaArrivalReport: PsaArrivalReportInput;
};

/** The output of our upsert `PsaArrivalReport` mutation. */
export type UpsertPsaArrivalReportPayload = {
  __typename?: 'UpsertPsaArrivalReportPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaArrivalReport` that were upserted by this mutation. */
  psaArrivalReport?: Maybe<PsaArrivalReport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaArrivalReport`. May be used by Relay 1. */
  psaArrivalReportEdge?: Maybe<PsaArrivalReportsEdge>;
};


/** The output of our upsert `PsaArrivalReport` mutation. */
export type UpsertPsaArrivalReportPayloadPsaArrivalReportEdgeArgs = {
  orderBy?: Maybe<Array<PsaArrivalReportsOrderBy>>;
};

/** All input for the upsert `PsaCherryPallet` mutation. */
export type UpsertPsaCherryPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` to be upserted by this mutation. */
  psaCherryPallet: PsaCherryPalletInput;
};

/** The output of our upsert `PsaCherryPallet` mutation. */
export type UpsertPsaCherryPalletPayload = {
  __typename?: 'UpsertPsaCherryPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCherryPallet` that were upserted by this mutation. */
  psaCherryPallet?: Maybe<PsaCherryPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCherryPallet`. May be used by Relay 1. */
  psaCherryPalletEdge?: Maybe<PsaCherryPalletsEdge>;
};


/** The output of our upsert `PsaCherryPallet` mutation. */
export type UpsertPsaCherryPalletPayloadPsaCherryPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCherryPalletsOrderBy>>;
};

/** All input for the upsert `PsaCitrusPallet` mutation. */
export type UpsertPsaCitrusPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` to be upserted by this mutation. */
  psaCitrusPallet: PsaCitrusPalletInput;
};

/** The output of our upsert `PsaCitrusPallet` mutation. */
export type UpsertPsaCitrusPalletPayload = {
  __typename?: 'UpsertPsaCitrusPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaCitrusPallet` that were upserted by this mutation. */
  psaCitrusPallet?: Maybe<PsaCitrusPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaCitrusPallet`. May be used by Relay 1. */
  psaCitrusPalletEdge?: Maybe<PsaCitrusPalletsEdge>;
};


/** The output of our upsert `PsaCitrusPallet` mutation. */
export type UpsertPsaCitrusPalletPayloadPsaCitrusPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaCitrusPalletsOrderBy>>;
};

/** All input for the upsert `PsaGrapePallet` mutation. */
export type UpsertPsaGrapePalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` to be upserted by this mutation. */
  psaGrapePallet: PsaGrapePalletInput;
};

/** The output of our upsert `PsaGrapePallet` mutation. */
export type UpsertPsaGrapePalletPayload = {
  __typename?: 'UpsertPsaGrapePalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaGrapePallet` that were upserted by this mutation. */
  psaGrapePallet?: Maybe<PsaGrapePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaGrapePallet`. May be used by Relay 1. */
  psaGrapePalletEdge?: Maybe<PsaGrapePalletsEdge>;
};


/** The output of our upsert `PsaGrapePallet` mutation. */
export type UpsertPsaGrapePalletPayloadPsaGrapePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaGrapePalletsOrderBy>>;
};

/** All input for the upsert `PsaLemonPallet` mutation. */
export type UpsertPsaLemonPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` to be upserted by this mutation. */
  psaLemonPallet: PsaLemonPalletInput;
};

/** The output of our upsert `PsaLemonPallet` mutation. */
export type UpsertPsaLemonPalletPayload = {
  __typename?: 'UpsertPsaLemonPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaLemonPallet` that were upserted by this mutation. */
  psaLemonPallet?: Maybe<PsaLemonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaLemonPallet`. May be used by Relay 1. */
  psaLemonPalletEdge?: Maybe<PsaLemonPalletsEdge>;
};


/** The output of our upsert `PsaLemonPallet` mutation. */
export type UpsertPsaLemonPalletPayloadPsaLemonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaLemonPalletsOrderBy>>;
};

/** All input for the upsert `PsaPearPallet` mutation. */
export type UpsertPsaPearPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` to be upserted by this mutation. */
  psaPearPallet: PsaPearPalletInput;
};

/** The output of our upsert `PsaPearPallet` mutation. */
export type UpsertPsaPearPalletPayload = {
  __typename?: 'UpsertPsaPearPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPearPallet` that were upserted by this mutation. */
  psaPearPallet?: Maybe<PsaPearPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPearPallet`. May be used by Relay 1. */
  psaPearPalletEdge?: Maybe<PsaPearPalletsEdge>;
};


/** The output of our upsert `PsaPearPallet` mutation. */
export type UpsertPsaPearPalletPayloadPsaPearPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPearPalletsOrderBy>>;
};

/** All input for the upsert `PsaPersimmonPallet` mutation. */
export type UpsertPsaPersimmonPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` to be upserted by this mutation. */
  psaPersimmonPallet: PsaPersimmonPalletInput;
};

/** The output of our upsert `PsaPersimmonPallet` mutation. */
export type UpsertPsaPersimmonPalletPayload = {
  __typename?: 'UpsertPsaPersimmonPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPersimmonPallet` that were upserted by this mutation. */
  psaPersimmonPallet?: Maybe<PsaPersimmonPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPersimmonPallet`. May be used by Relay 1. */
  psaPersimmonPalletEdge?: Maybe<PsaPersimmonPalletsEdge>;
};


/** The output of our upsert `PsaPersimmonPallet` mutation. */
export type UpsertPsaPersimmonPalletPayloadPsaPersimmonPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPersimmonPalletsOrderBy>>;
};

/** All input for the upsert `PsaPomegranatePallet` mutation. */
export type UpsertPsaPomegranatePalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` to be upserted by this mutation. */
  psaPomegranatePallet: PsaPomegranatePalletInput;
};

/** The output of our upsert `PsaPomegranatePallet` mutation. */
export type UpsertPsaPomegranatePalletPayload = {
  __typename?: 'UpsertPsaPomegranatePalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaPomegranatePallet` that were upserted by this mutation. */
  psaPomegranatePallet?: Maybe<PsaPomegranatePallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaPomegranatePallet`. May be used by Relay 1. */
  psaPomegranatePalletEdge?: Maybe<PsaPomegranatePalletsEdge>;
};


/** The output of our upsert `PsaPomegranatePallet` mutation. */
export type UpsertPsaPomegranatePalletPayloadPsaPomegranatePalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaPomegranatePalletsOrderBy>>;
};

/** All input for the upsert `PsaStoneFruitPallet` mutation. */
export type UpsertPsaStoneFruitPalletInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` to be upserted by this mutation. */
  psaStoneFruitPallet: PsaStoneFruitPalletInput;
};

/** The output of our upsert `PsaStoneFruitPallet` mutation. */
export type UpsertPsaStoneFruitPalletPayload = {
  __typename?: 'UpsertPsaStoneFruitPalletPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PsaStoneFruitPallet` that were upserted by this mutation. */
  psaStoneFruitPallet?: Maybe<PsaStoneFruitPallet>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PsaStoneFruitPallet`. May be used by Relay 1. */
  psaStoneFruitPalletEdge?: Maybe<PsaStoneFruitPalletsEdge>;
};


/** The output of our upsert `PsaStoneFruitPallet` mutation. */
export type UpsertPsaStoneFruitPalletPayloadPsaStoneFruitPalletEdgeArgs = {
  orderBy?: Maybe<Array<PsaStoneFruitPalletsOrderBy>>;
};

/** All input for the upsert `RepackHeader` mutation. */
export type UpsertRepackHeaderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackHeader` to be upserted by this mutation. */
  repackHeader: RepackHeaderInput;
};

/** The output of our upsert `RepackHeader` mutation. */
export type UpsertRepackHeaderPayload = {
  __typename?: 'UpsertRepackHeaderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackHeader` that were upserted by this mutation. */
  repackHeader?: Maybe<RepackHeader>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackHeader`. May be used by Relay 1. */
  repackHeaderEdge?: Maybe<RepackHeadersEdge>;
};


/** The output of our upsert `RepackHeader` mutation. */
export type UpsertRepackHeaderPayloadRepackHeaderEdgeArgs = {
  orderBy?: Maybe<Array<RepackHeadersOrderBy>>;
};

/** All input for the upsert `RepackItem` mutation. */
export type UpsertRepackItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackItem` to be upserted by this mutation. */
  repackItem: RepackItemInput;
};

/** The output of our upsert `RepackItem` mutation. */
export type UpsertRepackItemPayload = {
  __typename?: 'UpsertRepackItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackItem` that were upserted by this mutation. */
  repackItem?: Maybe<RepackItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackItem`. May be used by Relay 1. */
  repackItemEdge?: Maybe<RepackItemsEdge>;
};


/** The output of our upsert `RepackItem` mutation. */
export type UpsertRepackItemPayloadRepackItemEdgeArgs = {
  orderBy?: Maybe<Array<RepackItemsOrderBy>>;
};

/** All input for the upsert `RepackQueue` mutation. */
export type UpsertRepackQueueInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackQueue` to be upserted by this mutation. */
  repackQueue: RepackQueueInput;
};

/** The output of our upsert `RepackQueue` mutation. */
export type UpsertRepackQueuePayload = {
  __typename?: 'UpsertRepackQueuePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackQueue` that were upserted by this mutation. */
  repackQueue?: Maybe<RepackQueue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackQueue`. May be used by Relay 1. */
  repackQueueEdge?: Maybe<RepackQueuesEdge>;
};


/** The output of our upsert `RepackQueue` mutation. */
export type UpsertRepackQueuePayloadRepackQueueEdgeArgs = {
  orderBy?: Maybe<Array<RepackQueuesOrderBy>>;
};

/** All input for the upsert `RepackStyle` mutation. */
export type UpsertRepackStyleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackStyle` to be upserted by this mutation. */
  repackStyle: RepackStyleInput;
};

/** The output of our upsert `RepackStyle` mutation. */
export type UpsertRepackStylePayload = {
  __typename?: 'UpsertRepackStylePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `RepackStyle` that were upserted by this mutation. */
  repackStyle?: Maybe<RepackStyle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `RepackStyle`. May be used by Relay 1. */
  repackStyleEdge?: Maybe<RepackStylesEdge>;
};


/** The output of our upsert `RepackStyle` mutation. */
export type UpsertRepackStylePayloadRepackStyleEdgeArgs = {
  orderBy?: Maybe<Array<RepackStylesOrderBy>>;
};

/** All input for the upsert `ShipperAdvance` mutation. */
export type UpsertShipperAdvanceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperAdvance` to be upserted by this mutation. */
  shipperAdvance: ShipperAdvanceInput;
};

/** The output of our upsert `ShipperAdvance` mutation. */
export type UpsertShipperAdvancePayload = {
  __typename?: 'UpsertShipperAdvancePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperAdvance` that were upserted by this mutation. */
  shipperAdvance?: Maybe<ShipperAdvance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ProductSpecies` that is related to this `ShipperAdvance`. */
  species?: Maybe<ProductSpecies>;
  /** Reads a single `Shipper` that is related to this `ShipperAdvance`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperAdvance`. May be used by Relay 1. */
  shipperAdvanceEdge?: Maybe<ShipperAdvancesEdge>;
};


/** The output of our upsert `ShipperAdvance` mutation. */
export type UpsertShipperAdvancePayloadShipperAdvanceEdgeArgs = {
  orderBy?: Maybe<Array<ShipperAdvancesOrderBy>>;
};

/** All input for the upsert `Shipper` mutation. */
export type UpsertShipperInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` to be upserted by this mutation. */
  shipper: ShipperInput;
};

/** The output of our upsert `Shipper` mutation. */
export type UpsertShipperPayload = {
  __typename?: 'UpsertShipperPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipper` that were upserted by this mutation. */
  shipper?: Maybe<Shipper>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Shipper`. */
  country?: Maybe<Country>;
  /** An edge for our `Shipper`. May be used by Relay 1. */
  shipperEdge?: Maybe<ShippersEdge>;
};


/** The output of our upsert `Shipper` mutation. */
export type UpsertShipperPayloadShipperEdgeArgs = {
  orderBy?: Maybe<Array<ShippersOrderBy>>;
};

/** All input for the upsert `ShipperPersonContact` mutation. */
export type UpsertShipperPersonContactInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` to be upserted by this mutation. */
  shipperPersonContact: ShipperPersonContactInput;
};

/** The output of our upsert `ShipperPersonContact` mutation. */
export type UpsertShipperPersonContactPayload = {
  __typename?: 'UpsertShipperPersonContactPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperPersonContact` that were upserted by this mutation. */
  shipperPersonContact?: Maybe<ShipperPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperPersonContact`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `PersonContact` that is related to this `ShipperPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `ShipperPersonContact`. May be used by Relay 1. */
  shipperPersonContactEdge?: Maybe<ShipperPersonContactsEdge>;
};


/** The output of our upsert `ShipperPersonContact` mutation. */
export type UpsertShipperPersonContactPayloadShipperPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<ShipperPersonContactsOrderBy>>;
};

/** All input for the upsert `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type UpsertShipperProgramEntryCustomerProgramEntryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntryCustomerProgramEntry` to be upserted by this mutation. */
  shipperProgramEntryCustomerProgramEntry: ShipperProgramEntryCustomerProgramEntryInput;
};

/** The output of our upsert `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type UpsertShipperProgramEntryCustomerProgramEntryPayload = {
  __typename?: 'UpsertShipperProgramEntryCustomerProgramEntryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntryCustomerProgramEntry` that were upserted by this mutation. */
  shipperProgramEntryCustomerProgramEntry?: Maybe<ShipperProgramEntryCustomerProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CustomerProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  customerProgramEntry?: Maybe<CustomerProgramEntry>;
  /** Reads a single `ShipperProgramEntry` that is related to this `ShipperProgramEntryCustomerProgramEntry`. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  /** An edge for our `ShipperProgramEntryCustomerProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryCustomerProgramEntryEdge?: Maybe<ShipperProgramEntryCustomerProgramEntriesEdge>;
};


/** The output of our upsert `ShipperProgramEntryCustomerProgramEntry` mutation. */
export type UpsertShipperProgramEntryCustomerProgramEntryPayloadShipperProgramEntryCustomerProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntryCustomerProgramEntriesOrderBy>>;
};

/** All input for the upsert `ShipperProgramEntry` mutation. */
export type UpsertShipperProgramEntryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntry` to be upserted by this mutation. */
  shipperProgramEntry: ShipperProgramEntryInput;
};

/** The output of our upsert `ShipperProgramEntry` mutation. */
export type UpsertShipperProgramEntryPayload = {
  __typename?: 'UpsertShipperProgramEntryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgramEntry` that were upserted by this mutation. */
  shipperProgramEntry?: Maybe<ShipperProgramEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProgram` that is related to this `ShipperProgramEntry`. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** An edge for our `ShipperProgramEntry`. May be used by Relay 1. */
  shipperProgramEntryEdge?: Maybe<ShipperProgramEntriesEdge>;
};


/** The output of our upsert `ShipperProgramEntry` mutation. */
export type UpsertShipperProgramEntryPayloadShipperProgramEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramEntriesOrderBy>>;
};

/** All input for the upsert `ShipperProgram` mutation. */
export type UpsertShipperProgramInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgram` to be upserted by this mutation. */
  shipperProgram: ShipperProgramInput;
};

/** The output of our upsert `ShipperProgram` mutation. */
export type UpsertShipperProgramPayload = {
  __typename?: 'UpsertShipperProgramPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProgram` that were upserted by this mutation. */
  shipperProgram?: Maybe<ShipperProgram>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProgram`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProgram`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProgram`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProgram`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Shipper` that is related to this `ShipperProgram`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Customer` that is related to this `ShipperProgram`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProgram`. May be used by Relay 1. */
  shipperProgramEdge?: Maybe<ShipperProgramsEdge>;
};


/** The output of our upsert `ShipperProgram` mutation. */
export type UpsertShipperProgramPayloadShipperProgramEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProgramsOrderBy>>;
};

/** All input for the upsert `ShipperProjectionEntry` mutation. */
export type UpsertShipperProjectionEntryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` to be upserted by this mutation. */
  shipperProjectionEntry: ShipperProjectionEntryInput;
};

/** The output of our upsert `ShipperProjectionEntry` mutation. */
export type UpsertShipperProjectionEntryPayload = {
  __typename?: 'UpsertShipperProjectionEntryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionEntry` that were upserted by this mutation. */
  shipperProjectionEntry?: Maybe<ShipperProjectionEntry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjectionVesselInfo` that is related to this `ShipperProjectionEntry`. */
  vesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Reads a single `ShipperProjectionProduct` that is related to this `ShipperProjectionEntry`. */
  product?: Maybe<ShipperProjectionProduct>;
  /** An edge for our `ShipperProjectionEntry`. May be used by Relay 1. */
  shipperProjectionEntryEdge?: Maybe<ShipperProjectionEntriesEdge>;
};


/** The output of our upsert `ShipperProjectionEntry` mutation. */
export type UpsertShipperProjectionEntryPayloadShipperProjectionEntryEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionEntriesOrderBy>>;
};

/** All input for the upsert `ShipperProjection` mutation. */
export type UpsertShipperProjectionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` to be upserted by this mutation. */
  shipperProjection: ShipperProjectionInput;
};

/** The output of our upsert `ShipperProjection` mutation. */
export type UpsertShipperProjectionPayload = {
  __typename?: 'UpsertShipperProjectionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjection` that were upserted by this mutation. */
  shipperProjection?: Maybe<ShipperProjection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjection`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjection`. May be used by Relay 1. */
  shipperProjectionEdge?: Maybe<ShipperProjectionsEdge>;
};


/** The output of our upsert `ShipperProjection` mutation. */
export type UpsertShipperProjectionPayloadShipperProjectionEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionsOrderBy>>;
};

/** All input for the upsert `ShipperProjectionProduct` mutation. */
export type UpsertShipperProjectionProductInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` to be upserted by this mutation. */
  shipperProjectionProduct: ShipperProjectionProductInput;
};

/** The output of our upsert `ShipperProjectionProduct` mutation. */
export type UpsertShipperProjectionProductPayload = {
  __typename?: 'UpsertShipperProjectionProductPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionProduct` that were upserted by this mutation. */
  shipperProjectionProduct?: Maybe<ShipperProjectionProduct>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionProduct`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `CommonSpecies` that is related to this `ShipperProjectionProduct`. */
  commonSpecies?: Maybe<CommonSpecies>;
  /** Reads a single `CommonVariety` that is related to this `ShipperProjectionProduct`. */
  commonVariety?: Maybe<CommonVariety>;
  /** Reads a single `CommonSize` that is related to this `ShipperProjectionProduct`. */
  commonSize?: Maybe<CommonSize>;
  /** Reads a single `CommonPackType` that is related to this `ShipperProjectionProduct`. */
  commonPackType?: Maybe<CommonPackType>;
  /** Reads a single `Customer` that is related to this `ShipperProjectionProduct`. */
  customer?: Maybe<Customer>;
  /** An edge for our `ShipperProjectionProduct`. May be used by Relay 1. */
  shipperProjectionProductEdge?: Maybe<ShipperProjectionProductsEdge>;
};


/** The output of our upsert `ShipperProjectionProduct` mutation. */
export type UpsertShipperProjectionProductPayloadShipperProjectionProductEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionProductsOrderBy>>;
};

/** All input for the upsert `ShipperProjectionVesselInfo` mutation. */
export type UpsertShipperProjectionVesselInfoInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVesselInfo` to be upserted by this mutation. */
  shipperProjectionVesselInfo: ShipperProjectionVesselInfoInput;
};

/** The output of our upsert `ShipperProjectionVesselInfo` mutation. */
export type UpsertShipperProjectionVesselInfoPayload = {
  __typename?: 'UpsertShipperProjectionVesselInfoPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVesselInfo` that were upserted by this mutation. */
  shipperProjectionVesselInfo?: Maybe<ShipperProjectionVesselInfo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ShipperProjection` that is related to this `ShipperProjectionVesselInfo`. */
  projection?: Maybe<ShipperProjection>;
  /** Reads a single `ShipperProjectionVessel` that is related to this `ShipperProjectionVesselInfo`. */
  vessel?: Maybe<ShipperProjectionVessel>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVesselInfo`. */
  shipper?: Maybe<Shipper>;
  /** An edge for our `ShipperProjectionVesselInfo`. May be used by Relay 1. */
  shipperProjectionVesselInfoEdge?: Maybe<ShipperProjectionVesselInfosEdge>;
};


/** The output of our upsert `ShipperProjectionVesselInfo` mutation. */
export type UpsertShipperProjectionVesselInfoPayloadShipperProjectionVesselInfoEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselInfosOrderBy>>;
};

/** All input for the upsert `ShipperProjectionVessel` mutation. */
export type UpsertShipperProjectionVesselInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` to be upserted by this mutation. */
  shipperProjectionVessel: ShipperProjectionVesselInput;
};

/** The output of our upsert `ShipperProjectionVessel` mutation. */
export type UpsertShipperProjectionVesselPayload = {
  __typename?: 'UpsertShipperProjectionVesselPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ShipperProjectionVessel` that were upserted by this mutation. */
  shipperProjectionVessel?: Maybe<ShipperProjectionVessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Shipper` that is related to this `ShipperProjectionVessel`. */
  shipper?: Maybe<Shipper>;
  /** Reads a single `Vessel` that is related to this `ShipperProjectionVessel`. */
  vessel?: Maybe<Vessel>;
  /** An edge for our `ShipperProjectionVessel`. May be used by Relay 1. */
  shipperProjectionVesselEdge?: Maybe<ShipperProjectionVesselsEdge>;
};


/** The output of our upsert `ShipperProjectionVessel` mutation. */
export type UpsertShipperProjectionVesselPayloadShipperProjectionVesselEdgeArgs = {
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
};

/** All input for the upsert `TruckLoad` mutation. */
export type UpsertTruckLoadInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckLoad` to be upserted by this mutation. */
  truckLoad: TruckLoadInput;
};

/** The output of our upsert `TruckLoad` mutation. */
export type UpsertTruckLoadPayload = {
  __typename?: 'UpsertTruckLoadPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckLoad` that were upserted by this mutation. */
  truckLoad?: Maybe<TruckLoad>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckLoad`. May be used by Relay 1. */
  truckLoadEdge?: Maybe<TruckLoadsEdge>;
};


/** The output of our upsert `TruckLoad` mutation. */
export type UpsertTruckLoadPayloadTruckLoadEdgeArgs = {
  orderBy?: Maybe<Array<TruckLoadsOrderBy>>;
};

/** All input for the upsert `TruckRateCustomer` mutation. */
export type UpsertTruckRateCustomerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRateCustomer` to be upserted by this mutation. */
  truckRateCustomer: TruckRateCustomerInput;
};

/** The output of our upsert `TruckRateCustomer` mutation. */
export type UpsertTruckRateCustomerPayload = {
  __typename?: 'UpsertTruckRateCustomerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRateCustomer` that were upserted by this mutation. */
  truckRateCustomer?: Maybe<TruckRateCustomer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TruckRate` that is related to this `TruckRateCustomer`. */
  truckRate?: Maybe<TruckRate>;
  /** Reads a single `Customer` that is related to this `TruckRateCustomer`. */
  customer?: Maybe<Customer>;
  /** An edge for our `TruckRateCustomer`. May be used by Relay 1. */
  truckRateCustomerEdge?: Maybe<TruckRateCustomersEdge>;
};


/** The output of our upsert `TruckRateCustomer` mutation. */
export type UpsertTruckRateCustomerPayloadTruckRateCustomerEdgeArgs = {
  orderBy?: Maybe<Array<TruckRateCustomersOrderBy>>;
};

/** All input for the upsert `TruckRate` mutation. */
export type UpsertTruckRateInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRate` to be upserted by this mutation. */
  truckRate: TruckRateInput;
};

/** The output of our upsert `TruckRate` mutation. */
export type UpsertTruckRatePayload = {
  __typename?: 'UpsertTruckRatePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TruckRate` that were upserted by this mutation. */
  truckRate?: Maybe<TruckRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TruckRate`. May be used by Relay 1. */
  truckRateEdge?: Maybe<TruckRatesEdge>;
};


/** The output of our upsert `TruckRate` mutation. */
export type UpsertTruckRatePayloadTruckRateEdgeArgs = {
  orderBy?: Maybe<Array<TruckRatesOrderBy>>;
};

/** All input for the upsert `Unpaid` mutation. */
export type UpsertUnpaidInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Unpaid` to be upserted by this mutation. */
  unpaid: UnpaidInput;
};

/** The output of our upsert `Unpaid` mutation. */
export type UpsertUnpaidPayload = {
  __typename?: 'UpsertUnpaidPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Unpaid` that were upserted by this mutation. */
  unpaid?: Maybe<Unpaid>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Unpaid`. May be used by Relay 1. */
  unpaidEdge?: Maybe<UnpaidsEdge>;
};


/** The output of our upsert `Unpaid` mutation. */
export type UpsertUnpaidPayloadUnpaidEdgeArgs = {
  orderBy?: Maybe<Array<UnpaidsOrderBy>>;
};

/** All input for the upsert `UserBookmark` mutation. */
export type UpsertUserBookmarkInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserBookmark` to be upserted by this mutation. */
  userBookmark: UserBookmarkInput;
};

/** The output of our upsert `UserBookmark` mutation. */
export type UpsertUserBookmarkPayload = {
  __typename?: 'UpsertUserBookmarkPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserBookmark` that were upserted by this mutation. */
  userBookmark?: Maybe<UserBookmark>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserBookmark`. */
  user?: Maybe<User>;
  /** An edge for our `UserBookmark`. May be used by Relay 1. */
  userBookmarkEdge?: Maybe<UserBookmarksEdge>;
};


/** The output of our upsert `UserBookmark` mutation. */
export type UpsertUserBookmarkPayloadUserBookmarkEdgeArgs = {
  orderBy?: Maybe<Array<UserBookmarksOrderBy>>;
};

/** All input for the upsert `User` mutation. */
export type UpsertUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` to be upserted by this mutation. */
  user: UserInput;
};

/** All input for the upsert `UserMessage` mutation. */
export type UpsertUserMessageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` to be upserted by this mutation. */
  userMessage: UserMessageInput;
};

/** The output of our upsert `UserMessage` mutation. */
export type UpsertUserMessagePayload = {
  __typename?: 'UpsertUserMessagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserMessage` that were upserted by this mutation. */
  userMessage?: Maybe<UserMessage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
  /** An edge for our `UserMessage`. May be used by Relay 1. */
  userMessageEdge?: Maybe<UserMessagesEdge>;
};


/** The output of our upsert `UserMessage` mutation. */
export type UpsertUserMessagePayloadUserMessageEdgeArgs = {
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
};

/** The output of our upsert `User` mutation. */
export type UpsertUserPayload = {
  __typename?: 'UpsertUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that were upserted by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our upsert `User` mutation. */
export type UpsertUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the upsert `UserRole` mutation. */
export type UpsertUserRoleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserRole` to be upserted by this mutation. */
  userRole: UserRoleInput;
};

/** The output of our upsert `UserRole` mutation. */
export type UpsertUserRolePayload = {
  __typename?: 'UpsertUserRolePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserRole` that were upserted by this mutation. */
  userRole?: Maybe<UserRole>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>;
  /** An edge for our `UserRole`. May be used by Relay 1. */
  userRoleEdge?: Maybe<UserRolesEdge>;
};


/** The output of our upsert `UserRole` mutation. */
export type UpsertUserRolePayloadUserRoleEdgeArgs = {
  orderBy?: Maybe<Array<UserRolesOrderBy>>;
};

/** All input for the upsert `Vendor` mutation. */
export type UpsertVendorInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` to be upserted by this mutation. */
  vendor: VendorInput;
};

/** The output of our upsert `Vendor` mutation. */
export type UpsertVendorPayload = {
  __typename?: 'UpsertVendorPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that were upserted by this mutation. */
  vendor?: Maybe<Vendor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our upsert `Vendor` mutation. */
export type UpsertVendorPayloadVendorEdgeArgs = {
  orderBy?: Maybe<Array<VendorsOrderBy>>;
};

/** All input for the upsert `VendorPersonContact` mutation. */
export type UpsertVendorPersonContactInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VendorPersonContact` to be upserted by this mutation. */
  vendorPersonContact: VendorPersonContactInput;
};

/** The output of our upsert `VendorPersonContact` mutation. */
export type UpsertVendorPersonContactPayload = {
  __typename?: 'UpsertVendorPersonContactPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VendorPersonContact` that were upserted by this mutation. */
  vendorPersonContact?: Maybe<VendorPersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Vendor` that is related to this `VendorPersonContact`. */
  vendor?: Maybe<Vendor>;
  /** Reads a single `PersonContact` that is related to this `VendorPersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `VendorPersonContact`. May be used by Relay 1. */
  vendorPersonContactEdge?: Maybe<VendorPersonContactsEdge>;
};


/** The output of our upsert `VendorPersonContact` mutation. */
export type UpsertVendorPersonContactPayloadVendorPersonContactEdgeArgs = {
  orderBy?: Maybe<Array<VendorPersonContactsOrderBy>>;
};

/** All input for the upsert `VesselControl` mutation. */
export type UpsertVesselControlInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VesselControl` to be upserted by this mutation. */
  vesselControl: VesselControlInput;
};

/** The output of our upsert `VesselControl` mutation. */
export type UpsertVesselControlPayload = {
  __typename?: 'UpsertVesselControlPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VesselControl` that were upserted by this mutation. */
  vesselControl?: Maybe<VesselControl>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VesselControl`. May be used by Relay 1. */
  vesselControlEdge?: Maybe<VesselControlsEdge>;
};


/** The output of our upsert `VesselControl` mutation. */
export type UpsertVesselControlPayloadVesselControlEdgeArgs = {
  orderBy?: Maybe<Array<VesselControlsOrderBy>>;
};

/** All input for the upsert `Vessel` mutation. */
export type UpsertVesselInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` to be upserted by this mutation. */
  vessel: VesselInput;
};

/** The output of our upsert `Vessel` mutation. */
export type UpsertVesselPayload = {
  __typename?: 'UpsertVesselPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vessel` that were upserted by this mutation. */
  vessel?: Maybe<Vessel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vessel`. May be used by Relay 1. */
  vesselEdge?: Maybe<VesselsEdge>;
};


/** The output of our upsert `Vessel` mutation. */
export type UpsertVesselPayloadVesselEdgeArgs = {
  orderBy?: Maybe<Array<VesselsOrderBy>>;
};

/** All input for the upsert `Warehouse` mutation. */
export type UpsertWarehouseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` to be upserted by this mutation. */
  warehouse: WarehouseInput;
};

/** The output of our upsert `Warehouse` mutation. */
export type UpsertWarehousePayload = {
  __typename?: 'UpsertWarehousePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that were upserted by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our upsert `Warehouse` mutation. */
export type UpsertWarehousePayloadWarehouseEdgeArgs = {
  orderBy?: Maybe<Array<WarehousesOrderBy>>;
};

/** All input for the upsert `WarehousePersonContact` mutation. */
export type UpsertWarehousePersonContactInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` to be upserted by this mutation. */
  warehousePersonContact: WarehousePersonContactInput;
};

/** The output of our upsert `WarehousePersonContact` mutation. */
export type UpsertWarehousePersonContactPayload = {
  __typename?: 'UpsertWarehousePersonContactPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WarehousePersonContact` that were upserted by this mutation. */
  warehousePersonContact?: Maybe<WarehousePersonContact>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
  /** An edge for our `WarehousePersonContact`. May be used by Relay 1. */
  warehousePersonContactEdge?: Maybe<WarehousePersonContactsEdge>;
};


/** The output of our upsert `WarehousePersonContact` mutation. */
export type UpsertWarehousePersonContactPayloadWarehousePersonContactEdgeArgs = {
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
};

/** All input for the upsert `WireRequestAccountOfSaleItem` mutation. */
export type UpsertWireRequestAccountOfSaleItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestAccountOfSaleItem` to be upserted by this mutation. */
  wireRequestAccountOfSaleItem: WireRequestAccountOfSaleItemInput;
};

/** The output of our upsert `WireRequestAccountOfSaleItem` mutation. */
export type UpsertWireRequestAccountOfSaleItemPayload = {
  __typename?: 'UpsertWireRequestAccountOfSaleItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestAccountOfSaleItem` that were upserted by this mutation. */
  wireRequestAccountOfSaleItem?: Maybe<WireRequestAccountOfSaleItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestAccountOfSaleItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestAccountOfSaleItem`. May be used by Relay 1. */
  wireRequestAccountOfSaleItemEdge?: Maybe<WireRequestAccountOfSaleItemsEdge>;
};


/** The output of our upsert `WireRequestAccountOfSaleItem` mutation. */
export type UpsertWireRequestAccountOfSaleItemPayloadWireRequestAccountOfSaleItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestAccountOfSaleItemsOrderBy>>;
};

/** All input for the upsert `WireRequest` mutation. */
export type UpsertWireRequestInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequest` to be upserted by this mutation. */
  wireRequest: WireRequestInput;
};

/** All input for the upsert `WireRequestMiscItem` mutation. */
export type UpsertWireRequestMiscItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestMiscItem` to be upserted by this mutation. */
  wireRequestMiscItem: WireRequestMiscItemInput;
};

/** The output of our upsert `WireRequestMiscItem` mutation. */
export type UpsertWireRequestMiscItemPayload = {
  __typename?: 'UpsertWireRequestMiscItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestMiscItem` that were upserted by this mutation. */
  wireRequestMiscItem?: Maybe<WireRequestMiscItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestMiscItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestMiscItem`. May be used by Relay 1. */
  wireRequestMiscItemEdge?: Maybe<WireRequestMiscItemsEdge>;
};


/** The output of our upsert `WireRequestMiscItem` mutation. */
export type UpsertWireRequestMiscItemPayloadWireRequestMiscItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestMiscItemsOrderBy>>;
};

/** All input for the upsert `WireRequestOceanFreightItem` mutation. */
export type UpsertWireRequestOceanFreightItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestOceanFreightItem` to be upserted by this mutation. */
  wireRequestOceanFreightItem: WireRequestOceanFreightItemInput;
};

/** The output of our upsert `WireRequestOceanFreightItem` mutation. */
export type UpsertWireRequestOceanFreightItemPayload = {
  __typename?: 'UpsertWireRequestOceanFreightItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestOceanFreightItem` that were upserted by this mutation. */
  wireRequestOceanFreightItem?: Maybe<WireRequestOceanFreightItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestOceanFreightItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestOceanFreightItem`. May be used by Relay 1. */
  wireRequestOceanFreightItemEdge?: Maybe<WireRequestOceanFreightItemsEdge>;
};


/** The output of our upsert `WireRequestOceanFreightItem` mutation. */
export type UpsertWireRequestOceanFreightItemPayloadWireRequestOceanFreightItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestOceanFreightItemsOrderBy>>;
};

/** The output of our upsert `WireRequest` mutation. */
export type UpsertWireRequestPayload = {
  __typename?: 'UpsertWireRequestPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequest` that were upserted by this mutation. */
  wireRequest?: Maybe<WireRequest>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `WireRequest`. May be used by Relay 1. */
  wireRequestEdge?: Maybe<WireRequestsEdge>;
};


/** The output of our upsert `WireRequest` mutation. */
export type UpsertWireRequestPayloadWireRequestEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestsOrderBy>>;
};

/** All input for the upsert `WireRequestShipperAdvanceItem` mutation. */
export type UpsertWireRequestShipperAdvanceItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestShipperAdvanceItem` to be upserted by this mutation. */
  wireRequestShipperAdvanceItem: WireRequestShipperAdvanceItemInput;
};

/** The output of our upsert `WireRequestShipperAdvanceItem` mutation. */
export type UpsertWireRequestShipperAdvanceItemPayload = {
  __typename?: 'UpsertWireRequestShipperAdvanceItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `WireRequestShipperAdvanceItem` that were upserted by this mutation. */
  wireRequestShipperAdvanceItem?: Maybe<WireRequestShipperAdvanceItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WireRequest` that is related to this `WireRequestShipperAdvanceItem`. */
  wireRequest?: Maybe<WireRequest>;
  /** An edge for our `WireRequestShipperAdvanceItem`. May be used by Relay 1. */
  wireRequestShipperAdvanceItemEdge?: Maybe<WireRequestShipperAdvanceItemsEdge>;
};


/** The output of our upsert `WireRequestShipperAdvanceItem` mutation. */
export type UpsertWireRequestShipperAdvanceItemPayloadWireRequestShipperAdvanceItemEdgeArgs = {
  orderBy?: Maybe<Array<WireRequestShipperAdvanceItemsOrderBy>>;
};

export type User = Node & {
  __typename?: 'User';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  /** Reads a single `PersonContact` that is related to this `User`. */
  personContact?: Maybe<PersonContact>;
  /** Reads and enables pagination through a set of `ContactGroup`. */
  contactGroups: ContactGroupsConnection;
  /** Reads and enables pagination through a set of `UserMessage`. */
  userMessages: UserMessagesConnection;
  /** Reads and enables pagination through a set of `UserRole`. */
  userRoles: UserRolesConnection;
  /** Reads and enables pagination through a set of `LoadNumber`. */
  loadNumbers: LoadNumbersConnection;
  /** Reads and enables pagination through a set of `UserBookmark`. */
  userBookmarks: UserBookmarksConnection;
};


export type UserContactGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ContactGroupsOrderBy>>;
  condition?: Maybe<ContactGroupCondition>;
  filter?: Maybe<ContactGroupFilter>;
};


export type UserUserMessagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserMessagesOrderBy>>;
  condition?: Maybe<UserMessageCondition>;
  filter?: Maybe<UserMessageFilter>;
};


export type UserUserRolesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserRolesOrderBy>>;
  condition?: Maybe<UserRoleCondition>;
  filter?: Maybe<UserRoleFilter>;
};


export type UserLoadNumbersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<LoadNumbersOrderBy>>;
  condition?: Maybe<LoadNumberCondition>;
  filter?: Maybe<LoadNumberFilter>;
};


export type UserUserBookmarksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserBookmarksOrderBy>>;
  condition?: Maybe<UserBookmarkCondition>;
  filter?: Maybe<UserBookmarkFilter>;
};

export type UserBookmark = Node & {
  __typename?: 'UserBookmark';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  category?: Maybe<Scalars['String']>;
  linkUrl?: Maybe<Scalars['String']>;
  linkDescription?: Maybe<Scalars['String']>;
  sortOrder: Scalars['Int'];
  userId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `UserBookmark`. */
  user?: Maybe<User>;
};

/**
 * A condition to be used against `UserBookmark` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserBookmarkCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `category` field. */
  category?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linkUrl` field. */
  linkUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `linkDescription` field. */
  linkDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `UserBookmark` object types. All fields are combined with a logical ‘and.’ */
export type UserBookmarkFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `category` field. */
  category?: Maybe<StringFilter>;
  /** Filter by the object’s `linkUrl` field. */
  linkUrl?: Maybe<StringFilter>;
  /** Filter by the object’s `linkDescription` field. */
  linkDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserBookmarkFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserBookmarkFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserBookmarkFilter>;
};

/** An input for mutations affecting `UserBookmark` */
export type UserBookmarkInput = {
  id?: Maybe<Scalars['BigInt']>;
  category?: Maybe<Scalars['String']>;
  linkUrl?: Maybe<Scalars['String']>;
  linkDescription?: Maybe<Scalars['String']>;
  sortOrder: Scalars['Int'];
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserBookmarkUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserBookmarkNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userBookmark` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserBookmarkNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userBookmark` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserBookmarkOnUserBookmarkForUserBookmarkUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `userBookmark` to look up the row to update. */
export type UserBookmarkOnUserBookmarkForUserBookmarkUserIdFkeyUsingUserBookmarkPkeyUpdate = {
  /** An object where the defined keys will be set on the `userBookmark` being updated. */
  patch: UpdateUserBookmarkOnUserBookmarkForUserBookmarkUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `UserBookmark`. Fields that are set will be updated. */
export type UserBookmarkPatch = {
  id?: Maybe<Scalars['BigInt']>;
  category?: Maybe<Scalars['String']>;
  linkUrl?: Maybe<Scalars['String']>;
  linkDescription?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserBookmarkUserIdFkeyInput>;
};

/** The fields on `userBookmark` to look up the row to connect. */
export type UserBookmarkUserBookmarkPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `userBookmark` to look up the row to delete. */
export type UserBookmarkUserBookmarkPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `user` in the `UserBookmarkInput` mutation. */
export type UserBookmarkUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<UserUserPinKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<UserUserPinKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnUserBookmarkForUserBookmarkUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<UserOnUserBookmarkForUserBookmarkUserIdFkeyUsingUserPinKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserBookmarkOnUserBookmarkForUserBookmarkUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<UserBookmarkUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `userBookmark` in the `UserInput` mutation. */
export type UserBookmarkUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `userBookmark` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `userBookmark` for the far side of the relationship. */
  connectById?: Maybe<Array<UserBookmarkUserBookmarkPkeyConnect>>;
  /** The primary key(s) for `userBookmark` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<UserBookmarkNodeIdConnect>>;
  /** The primary key(s) for `userBookmark` for the far side of the relationship. */
  deleteById?: Maybe<Array<UserBookmarkUserBookmarkPkeyDelete>>;
  /** The primary key(s) for `userBookmark` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<UserBookmarkNodeIdDelete>>;
  /** The primary key(s) and patch data for `userBookmark` for the far side of the relationship. */
  updateById?: Maybe<Array<UserBookmarkOnUserBookmarkForUserBookmarkUserIdFkeyUsingUserBookmarkPkeyUpdate>>;
  /** The primary key(s) and patch data for `userBookmark` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnUserBookmarkForUserBookmarkUserIdFkeyNodeIdUpdate>>;
  /** A `UserBookmarkInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserBookmarkUserIdFkeyUserBookmarkCreateInput>>;
};

/** The `userBookmark` to be created by this mutation. */
export type UserBookmarkUserIdFkeyUserBookmarkCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  category?: Maybe<Scalars['String']>;
  linkUrl?: Maybe<Scalars['String']>;
  linkDescription?: Maybe<Scalars['String']>;
  sortOrder: Scalars['Int'];
  userToUserId?: Maybe<UserBookmarkUserIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type UserBookmarkUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** A connection to a list of `UserBookmark` values. */
export type UserBookmarksConnection = {
  __typename?: 'UserBookmarksConnection';
  /** A list of `UserBookmark` objects. */
  nodes: Array<Maybe<UserBookmark>>;
  /** A list of edges which contains the `UserBookmark` and cursor to aid in pagination. */
  edges: Array<UserBookmarksEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserBookmark` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserBookmark` edge in the connection. */
export type UserBookmarksEdge = {
  __typename?: 'UserBookmarksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserBookmark` at the end of the edge. */
  node?: Maybe<UserBookmark>;
};

/** Methods to use when ordering `UserBookmark`. */
export enum UserBookmarksOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  LinkUrlAsc = 'LINK_URL_ASC',
  LinkUrlDesc = 'LINK_URL_DESC',
  LinkDescriptionAsc = 'LINK_DESCRIPTION_ASC',
  LinkDescriptionDesc = 'LINK_DESCRIPTION_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdPinAsc = 'USER_BY_USER_ID__PIN_ASC',
  UserByUserIdPinDesc = 'USER_BY_USER_ID__PIN_DESC',
  UserByUserIdPersonContactIdAsc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_ASC',
  UserByUserIdPersonContactIdDesc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_DESC',
  UserByUserIdUserCodeAsc = 'USER_BY_USER_ID__USER_CODE_ASC',
  UserByUserIdUserCodeDesc = 'USER_BY_USER_ID__USER_CODE_DESC',
  UserByUserIdDefaultCoastAsc = 'USER_BY_USER_ID__DEFAULT_COAST_ASC',
  UserByUserIdDefaultCoastDesc = 'USER_BY_USER_ID__DEFAULT_COAST_DESC'
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pin` field. */
  pin?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `userCode` field. */
  userCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `defaultCoast` field. */
  defaultCoast?: Maybe<Scalars['String']>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `pin` field. */
  pin?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `userCode` field. */
  userCode?: Maybe<StringFilter>;
  /** Filter by the object’s `defaultCoast` field. */
  defaultCoast?: Maybe<StringFilter>;
  /** Filter by the object’s `contactGroups` relation. */
  contactGroups?: Maybe<UserToManyContactGroupFilter>;
  /** Some related `contactGroups` exist. */
  contactGroupsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `userMessages` relation. */
  userMessages?: Maybe<UserToManyUserMessageFilter>;
  /** Some related `userMessages` exist. */
  userMessagesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `userRoles` relation. */
  userRoles?: Maybe<UserToManyUserRoleFilter>;
  /** Some related `userRoles` exist. */
  userRolesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `loadNumbers` relation. */
  loadNumbers?: Maybe<UserToManyLoadNumberFilter>;
  /** Some related `loadNumbers` exist. */
  loadNumbersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `userBookmarks` relation. */
  userBookmarks?: Maybe<UserToManyUserBookmarkFilter>;
  /** Some related `userBookmarks` exist. */
  userBookmarksExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** A related `personContact` exists. */
  personContactExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserFilter>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

export type UserMessage = Node & {
  __typename?: 'UserMessage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead: Scalars['Boolean'];
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `UserMessage`. */
  user?: Maybe<User>;
};

/**
 * A condition to be used against `UserMessage` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserMessageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `actionLink` field. */
  actionLink?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `actionText` field. */
  actionText?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `details` field. */
  details?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `header` field. */
  header?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isRead` field. */
  isRead?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `messageDate` field. */
  messageDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `UserMessage` object types. All fields are combined with a logical ‘and.’ */
export type UserMessageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `actionLink` field. */
  actionLink?: Maybe<StringFilter>;
  /** Filter by the object’s `actionText` field. */
  actionText?: Maybe<StringFilter>;
  /** Filter by the object’s `details` field. */
  details?: Maybe<StringFilter>;
  /** Filter by the object’s `header` field. */
  header?: Maybe<StringFilter>;
  /** Filter by the object’s `isRead` field. */
  isRead?: Maybe<BooleanFilter>;
  /** Filter by the object’s `messageDate` field. */
  messageDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `priority` field. */
  priority?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserMessageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserMessageFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserMessageFilter>;
};

/** An input for mutations affecting `UserMessage` */
export type UserMessageInput = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead: Scalars['Boolean'];
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserMessageNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userMessage` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserMessageNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userMessage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserMessageOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `userMessage` to look up the row to update. */
export type UserMessageOnUserMessageForUserMessageUserIdFkeyUsingUserMessagePkeyUpdate = {
  /** An object where the defined keys will be set on the `userMessage` being updated. */
  patch: UpdateUserMessageOnUserMessageForUserMessageUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `UserMessage`. Fields that are set will be updated. */
export type UserMessagePatch = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead?: Maybe<Scalars['Boolean']>;
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `UserMessageInput` mutation. */
export type UserMessageUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<UserUserPinKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<UserUserPinKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnUserMessageForUserMessageUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<UserOnUserMessageForUserMessageUserIdFkeyUsingUserPinKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserMessageOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<UserMessageUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `userMessage` in the `UserInput` mutation. */
export type UserMessageUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `userMessage` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  connectById?: Maybe<Array<UserMessageUserMessagePkeyConnect>>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<UserMessageNodeIdConnect>>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  deleteById?: Maybe<Array<UserMessageUserMessagePkeyDelete>>;
  /** The primary key(s) for `userMessage` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<UserMessageNodeIdDelete>>;
  /** The primary key(s) and patch data for `userMessage` for the far side of the relationship. */
  updateById?: Maybe<Array<UserMessageOnUserMessageForUserMessageUserIdFkeyUsingUserMessagePkeyUpdate>>;
  /** The primary key(s) and patch data for `userMessage` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate>>;
  /** A `UserMessageInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserMessageUserIdFkeyUserMessageCreateInput>>;
};

/** The `user` to be created by this mutation. */
export type UserMessageUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** The `userMessage` to be created by this mutation. */
export type UserMessageUserIdFkeyUserMessageCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead: Scalars['Boolean'];
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** The fields on `userMessage` to look up the row to connect. */
export type UserMessageUserMessagePkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `userMessage` to look up the row to delete. */
export type UserMessageUserMessagePkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `UserMessage` values. */
export type UserMessagesConnection = {
  __typename?: 'UserMessagesConnection';
  /** A list of `UserMessage` objects. */
  nodes: Array<Maybe<UserMessage>>;
  /** A list of edges which contains the `UserMessage` and cursor to aid in pagination. */
  edges: Array<UserMessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserMessage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserMessage` edge in the connection. */
export type UserMessagesEdge = {
  __typename?: 'UserMessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserMessage` at the end of the edge. */
  node?: Maybe<UserMessage>;
};

/** Methods to use when ordering `UserMessage`. */
export enum UserMessagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ActionLinkAsc = 'ACTION_LINK_ASC',
  ActionLinkDesc = 'ACTION_LINK_DESC',
  ActionTextAsc = 'ACTION_TEXT_ASC',
  ActionTextDesc = 'ACTION_TEXT_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  HeaderAsc = 'HEADER_ASC',
  HeaderDesc = 'HEADER_DESC',
  IsReadAsc = 'IS_READ_ASC',
  IsReadDesc = 'IS_READ_DESC',
  MessageDateAsc = 'MESSAGE_DATE_ASC',
  MessageDateDesc = 'MESSAGE_DATE_DESC',
  PriorityAsc = 'PRIORITY_ASC',
  PriorityDesc = 'PRIORITY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdPinAsc = 'USER_BY_USER_ID__PIN_ASC',
  UserByUserIdPinDesc = 'USER_BY_USER_ID__PIN_DESC',
  UserByUserIdPersonContactIdAsc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_ASC',
  UserByUserIdPersonContactIdDesc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_DESC',
  UserByUserIdUserCodeAsc = 'USER_BY_USER_ID__USER_CODE_ASC',
  UserByUserIdUserCodeDesc = 'USER_BY_USER_ID__USER_CODE_DESC',
  UserByUserIdDefaultCoastAsc = 'USER_BY_USER_ID__DEFAULT_COAST_ASC',
  UserByUserIdDefaultCoastDesc = 'USER_BY_USER_ID__DEFAULT_COAST_DESC'
}

/** The globally unique `ID` look up for the row to connect. */
export type UserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `user` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnContactGroupForContactGroupUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `contactGroup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `contactGroup` being updated. */
  patch: ContactGroupPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnContactGroupForContactGroupUserIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnContactGroupForContactGroupUserIdFkeyPatch;
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnContactGroupForContactGroupUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnContactGroupForContactGroupUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnLoadNumberForLoadNumberUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `loadNumber` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `loadNumber` being updated. */
  patch: LoadNumberPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnLoadNumberForLoadNumberUserIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnLoadNumberForLoadNumberUserIdFkeyPatch;
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnLoadNumberForLoadNumberUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnLoadNumberForLoadNumberUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserBookmarkForUserBookmarkUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userBookmark` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `userBookmark` being updated. */
  patch: UserBookmarkPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserBookmarkForUserBookmarkUserIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserBookmarkForUserBookmarkUserIdFkeyPatch;
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserBookmarkForUserBookmarkUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserBookmarkForUserBookmarkUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserForUserPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserForUserPersonContactIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserForUserPersonContactIdFkeyPatch;
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserForUserPersonContactIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserForUserPersonContactIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserMessageForUserMessageUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userMessage` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `userMessage` being updated. */
  patch: UserMessagePatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserMessageForUserMessageUserIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserMessageForUserMessageUserIdFkeyPatch;
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserMessageForUserMessageUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserMessageForUserMessageUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserRoleForUserRoleUserIdFkeyUsingUserPinKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserRoleForUserRoleUserIdFkeyPatch;
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserRoleForUserRoleUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserRoleForUserRoleUserIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** Input for the nested mutation of `personContact` in the `UserInput` mutation. */
export type UserPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnUserForUserPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserOnUserForUserPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<UserPersonContactIdFkeyPersonContactCreateInput>;
};

/** Input for the nested mutation of `user` in the `PersonContactInput` mutation. */
export type UserPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `user` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<Array<UserUserPkeyConnect>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<Array<UserUserPinKeyConnect>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<UserNodeIdConnect>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<Array<UserUserPkeyDelete>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<Array<UserUserPinKeyDelete>>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<UserNodeIdDelete>>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<Array<UserOnUserForUserPersonContactIdFkeyUsingUserPkeyUpdate>>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<Array<UserOnUserForUserPersonContactIdFkeyUsingUserPinKeyUpdate>>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnUserForUserPersonContactIdFkeyNodeIdUpdate>>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserPersonContactIdFkeyUserCreateInput>>;
};

/** The `personContact` to be created by this mutation. */
export type UserPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** The `user` to be created by this mutation. */
export type UserPersonContactIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

export type UserRole = {
  __typename?: 'UserRole';
  roleName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  /** Reads a single `User` that is related to this `UserRole`. */
  user?: Maybe<User>;
};

/**
 * A condition to be used against `UserRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserRoleCondition = {
  /** Checks for equality with the object’s `roleName` field. */
  roleName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `UserRole` object types. All fields are combined with a logical ‘and.’ */
export type UserRoleFilter = {
  /** Filter by the object’s `roleName` field. */
  roleName?: Maybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserRoleFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserRoleFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserRoleFilter>;
};

/** An input for mutations affecting `UserRole` */
export type UserRoleInput = {
  roleName: Scalars['String'];
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserRoleUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserRoleOnUserRoleForUserRoleUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `userRole` to look up the row to update. */
export type UserRoleOnUserRoleForUserRoleUserIdFkeyUsingUserRoleUserIdRoleNameKeyUpdate = {
  /** An object where the defined keys will be set on the `userRole` being updated. */
  patch: UpdateUserRoleOnUserRoleForUserRoleUserIdFkeyPatch;
  userId: Scalars['BigInt'];
  roleName: Scalars['String'];
};

/** Represents an update to a `UserRole`. Fields that are set will be updated. */
export type UserRolePatch = {
  roleName?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<UserRoleUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `UserRoleInput` mutation. */
export type UserRoleUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByPin?: Maybe<UserUserPinKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByPin?: Maybe<UserUserPinKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnUserRoleForUserRoleUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByPin?: Maybe<UserOnUserRoleForUserRoleUserIdFkeyUsingUserPinKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserRoleOnUserRoleForUserRoleUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<UserRoleUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `userRole` in the `UserInput` mutation. */
export type UserRoleUserIdFkeyInverseInput = {
  /** The primary key(s) for `userRole` for the far side of the relationship. */
  connectByUserIdAndRoleName?: Maybe<Array<UserRoleUserRoleUserIdRoleNameKeyConnect>>;
  /** The primary key(s) and patch data for `userRole` for the far side of the relationship. */
  updateByUserIdAndRoleName?: Maybe<Array<UserRoleOnUserRoleForUserRoleUserIdFkeyUsingUserRoleUserIdRoleNameKeyUpdate>>;
  /** A `UserRoleInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserRoleUserIdFkeyUserRoleCreateInput>>;
};

/** The `user` to be created by this mutation. */
export type UserRoleUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** The `userRole` to be created by this mutation. */
export type UserRoleUserIdFkeyUserRoleCreateInput = {
  roleName: Scalars['String'];
  userToUserId?: Maybe<UserRoleUserIdFkeyInput>;
};

/** The fields on `userRole` to look up the row to connect. */
export type UserRoleUserRoleUserIdRoleNameKeyConnect = {
  userId: Scalars['BigInt'];
  roleName: Scalars['String'];
};

/** A connection to a list of `UserRole` values. */
export type UserRolesConnection = {
  __typename?: 'UserRolesConnection';
  /** A list of `UserRole` objects. */
  nodes: Array<Maybe<UserRole>>;
  /** A list of edges which contains the `UserRole` and cursor to aid in pagination. */
  edges: Array<UserRolesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserRole` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserRole` edge in the connection. */
export type UserRolesEdge = {
  __typename?: 'UserRolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserRole` at the end of the edge. */
  node?: Maybe<UserRole>;
};

/** Methods to use when ordering `UserRole`. */
export enum UserRolesOrderBy {
  Natural = 'NATURAL',
  RoleNameAsc = 'ROLE_NAME_ASC',
  RoleNameDesc = 'ROLE_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdPinAsc = 'USER_BY_USER_ID__PIN_ASC',
  UserByUserIdPinDesc = 'USER_BY_USER_ID__PIN_DESC',
  UserByUserIdPersonContactIdAsc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_ASC',
  UserByUserIdPersonContactIdDesc = 'USER_BY_USER_ID__PERSON_CONTACT_ID_DESC',
  UserByUserIdUserCodeAsc = 'USER_BY_USER_ID__USER_CODE_ASC',
  UserByUserIdUserCodeDesc = 'USER_BY_USER_ID__USER_CODE_DESC',
  UserByUserIdDefaultCoastAsc = 'USER_BY_USER_ID__DEFAULT_COAST_ASC',
  UserByUserIdDefaultCoastDesc = 'USER_BY_USER_ID__DEFAULT_COAST_DESC'
}

/** A filter to be used against many `ContactGroup` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyContactGroupFilter = {
  /** Every related `ContactGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ContactGroupFilter>;
  /** Some related `ContactGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ContactGroupFilter>;
  /** No related `ContactGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ContactGroupFilter>;
};

/** A filter to be used against many `LoadNumber` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyLoadNumberFilter = {
  /** Every related `LoadNumber` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<LoadNumberFilter>;
  /** Some related `LoadNumber` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<LoadNumberFilter>;
  /** No related `LoadNumber` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<LoadNumberFilter>;
};

/** A filter to be used against many `UserBookmark` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserBookmarkFilter = {
  /** Every related `UserBookmark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserBookmarkFilter>;
  /** Some related `UserBookmark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserBookmarkFilter>;
  /** No related `UserBookmark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserBookmarkFilter>;
};

/** A filter to be used against many `UserMessage` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserMessageFilter = {
  /** Every related `UserMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserMessageFilter>;
  /** Some related `UserMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserMessageFilter>;
  /** No related `UserMessage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserMessageFilter>;
};

/** A filter to be used against many `UserRole` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserRoleFilter = {
  /** Every related `UserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserRoleFilter>;
  /** Some related `UserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserRoleFilter>;
  /** No related `UserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserRoleFilter>;
};

/** The fields on `user` to look up the row to connect. */
export type UserUserPinKeyConnect = {
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserPinKeyDelete = {
  pin: Scalars['String'];
};

/** The fields on `user` to look up the row to connect. */
export type UserUserPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PinAsc = 'PIN_ASC',
  PinDesc = 'PIN_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  UserCodeAsc = 'USER_CODE_ASC',
  UserCodeDesc = 'USER_CODE_DESC',
  DefaultCoastAsc = 'DEFAULT_COAST_ASC',
  DefaultCoastDesc = 'DEFAULT_COAST_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PersonContactByPersonContactIdIdAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_ASC',
  PersonContactByPersonContactIdIdDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_DESC',
  PersonContactByPersonContactIdFirstNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_ASC',
  PersonContactByPersonContactIdFirstNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_DESC',
  PersonContactByPersonContactIdLastNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_ASC',
  PersonContactByPersonContactIdLastNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_DESC',
  PersonContactByPersonContactIdIsPrimaryAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_ASC',
  PersonContactByPersonContactIdIsPrimaryDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_DESC',
  PersonContactByPersonContactIdEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_ASC',
  PersonContactByPersonContactIdEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_DESC',
  PersonContactByPersonContactIdSecondaryEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_ASC',
  PersonContactByPersonContactIdSecondaryEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_DESC',
  PersonContactByPersonContactIdHomePhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_ASC',
  PersonContactByPersonContactIdHomePhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_DESC',
  PersonContactByPersonContactIdCellPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_ASC',
  PersonContactByPersonContactIdCellPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_DESC',
  PersonContactByPersonContactIdWorkPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_ASC',
  PersonContactByPersonContactIdWorkPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_DESC',
  PersonContactByPersonContactIdWorkExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_ASC',
  PersonContactByPersonContactIdWorkExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_DESC',
  PersonContactByPersonContactIdImageSrcAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_ASC',
  PersonContactByPersonContactIdImageSrcDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_DESC',
  PersonContactByPersonContactIdIsInternalAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_ASC',
  PersonContactByPersonContactIdIsInternalDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_DESC',
  PersonContactByPersonContactIdRolesAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_ASC',
  PersonContactByPersonContactIdRolesDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_DESC',
  PersonContactByPersonContactIdHomeExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_ASC',
  PersonContactByPersonContactIdHomeExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_DESC',
  PersonContactByPersonContactIdLocationAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_ASC',
  PersonContactByPersonContactIdLocationDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_DESC',
  ContactGroupsByUserIdCountAsc = 'CONTACT_GROUPS_BY_USER_ID__COUNT_ASC',
  ContactGroupsByUserIdCountDesc = 'CONTACT_GROUPS_BY_USER_ID__COUNT_DESC',
  UserMessagesByUserIdCountAsc = 'USER_MESSAGES_BY_USER_ID__COUNT_ASC',
  UserMessagesByUserIdCountDesc = 'USER_MESSAGES_BY_USER_ID__COUNT_DESC',
  UserRolesByUserIdCountAsc = 'USER_ROLES_BY_USER_ID__COUNT_ASC',
  UserRolesByUserIdCountDesc = 'USER_ROLES_BY_USER_ID__COUNT_DESC',
  LoadNumbersByUserIdCountAsc = 'LOAD_NUMBERS_BY_USER_ID__COUNT_ASC',
  LoadNumbersByUserIdCountDesc = 'LOAD_NUMBERS_BY_USER_ID__COUNT_DESC',
  UserBookmarksByUserIdCountAsc = 'USER_BOOKMARKS_BY_USER_ID__COUNT_ASC',
  UserBookmarksByUserIdCountDesc = 'USER_BOOKMARKS_BY_USER_ID__COUNT_DESC'
}

export type Vendor = Node & {
  __typename?: 'Vendor';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  vendorName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  attention?: Maybe<Scalars['String']>;
  vendorType?: Maybe<Scalars['String']>;
  ledgerCode?: Maybe<Scalars['String']>;
  bankCode?: Maybe<Scalars['String']>;
  has1099?: Maybe<Scalars['Boolean']>;
  id1099?: Maybe<Scalars['String']>;
  isTemp?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `VendorPersonContact`. */
  vendorPersonContacts: VendorPersonContactsConnection;
  country?: Maybe<Country>;
  customer?: Maybe<Customer>;
  searchText?: Maybe<Scalars['String']>;
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `TruckRate`. */
  truckRates: TruckRatesConnection;
  warehouse?: Maybe<Warehouse>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByVendorPersonContactVendorIdAndPersonContactId: VendorPersonContactsByVendorPersonContactVendorIdAndPersonContactIdManyToManyConnection;
};


export type VendorVendorPersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VendorPersonContactsOrderBy>>;
  condition?: Maybe<VendorPersonContactCondition>;
  filter?: Maybe<VendorPersonContactFilter>;
};


export type VendorTruckRatesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<TruckRateFilter>;
};


export type VendorPersonContactsByVendorPersonContactVendorIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};

/** A condition to be used against `Vendor` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VendorCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorName` field. */
  vendorName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address1` field. */
  address1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address2` field. */
  address2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalState` field. */
  postalState?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipCode` field. */
  zipCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `attention` field. */
  attention?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorType` field. */
  vendorType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `ledgerCode` field. */
  ledgerCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bankCode` field. */
  bankCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `has1099` field. */
  has1099?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `id1099` field. */
  id1099?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isTemp` field. */
  isTemp?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
};

/** A `String` edge in the connection. */
export type VendorDistinctValueEdge = {
  __typename?: 'VendorDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type VendorDistinctValuesConnection = {
  __typename?: 'VendorDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<VendorDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A filter to be used against `Vendor` object types. All fields are combined with a logical ‘and.’ */
export type VendorFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorName` field. */
  vendorName?: Maybe<StringFilter>;
  /** Filter by the object’s `address1` field. */
  address1?: Maybe<StringFilter>;
  /** Filter by the object’s `address2` field. */
  address2?: Maybe<StringFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `postalState` field. */
  postalState?: Maybe<StringFilter>;
  /** Filter by the object’s `zipCode` field. */
  zipCode?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `attention` field. */
  attention?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorType` field. */
  vendorType?: Maybe<StringFilter>;
  /** Filter by the object’s `ledgerCode` field. */
  ledgerCode?: Maybe<StringFilter>;
  /** Filter by the object’s `bankCode` field. */
  bankCode?: Maybe<StringFilter>;
  /** Filter by the object’s `has1099` field. */
  has1099?: Maybe<BooleanFilter>;
  /** Filter by the object’s `id1099` field. */
  id1099?: Maybe<StringFilter>;
  /** Filter by the object’s `isTemp` field. */
  isTemp?: Maybe<BooleanFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorPersonContacts` relation. */
  vendorPersonContacts?: Maybe<VendorToManyVendorPersonContactFilter>;
  /** Some related `vendorPersonContacts` exist. */
  vendorPersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VendorFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VendorFilter>>;
  /** Negates the expression. */
  not?: Maybe<VendorFilter>;
};

/** An input for mutations affecting `Vendor` */
export type VendorInput = {
  id: Scalars['String'];
  vendorName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  attention?: Maybe<Scalars['String']>;
  vendorType?: Maybe<Scalars['String']>;
  ledgerCode?: Maybe<Scalars['String']>;
  bankCode?: Maybe<Scalars['String']>;
  has1099?: Maybe<Scalars['Boolean']>;
  id1099?: Maybe<Scalars['String']>;
  isTemp?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactVendorIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type VendorNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `vendor` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type VendorNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `vendor` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type VendorOnVendorPersonContactForVendorPersonContactVendorIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `vendorPersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `vendorPersonContact` being updated. */
  patch: VendorPersonContactPatch;
};

/** The fields on `vendor` to look up the row to update. */
export type VendorOnVendorPersonContactForVendorPersonContactVendorIdFkeyUsingVendorPkeyUpdate = {
  /** An object where the defined keys will be set on the `vendor` being updated. */
  patch: UpdateVendorOnVendorPersonContactForVendorPersonContactVendorIdFkeyPatch;
  id: Scalars['String'];
};

/** Represents an update to a `Vendor`. Fields that are set will be updated. */
export type VendorPatch = {
  id?: Maybe<Scalars['String']>;
  vendorName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  attention?: Maybe<Scalars['String']>;
  vendorType?: Maybe<Scalars['String']>;
  ledgerCode?: Maybe<Scalars['String']>;
  bankCode?: Maybe<Scalars['String']>;
  has1099?: Maybe<Scalars['Boolean']>;
  id1099?: Maybe<Scalars['String']>;
  isTemp?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactVendorIdFkeyInverseInput>;
};

export type VendorPersonContact = Node & {
  __typename?: 'VendorPersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `Vendor` that is related to this `VendorPersonContact`. */
  vendor?: Maybe<Vendor>;
  /** Reads a single `PersonContact` that is related to this `VendorPersonContact`. */
  personContact?: Maybe<PersonContact>;
};

/**
 * A condition to be used against `VendorPersonContact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type VendorPersonContactCondition = {
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `VendorPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type VendorPersonContactFilter = {
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vendor` relation. */
  vendor?: Maybe<VendorFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VendorPersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VendorPersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<VendorPersonContactFilter>;
};

/** An input for mutations affecting `VendorPersonContact` */
export type VendorPersonContactInput = {
  vendorId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  vendorToVendorId?: Maybe<VendorPersonContactVendorIdFkeyInput>;
  personContactToPersonContactId?: Maybe<VendorPersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type VendorPersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `vendorPersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type VendorPersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `vendorPersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type VendorPersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The fields on `vendorPersonContact` to look up the row to update. */
export type VendorPersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyUsingVendorPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `vendorPersonContact` being updated. */
  patch: UpdateVendorPersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyPatch;
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type VendorPersonContactOnVendorPersonContactForVendorPersonContactVendorIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `vendor` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `vendor` being updated. */
  patch: VendorPatch;
};

/** The fields on `vendorPersonContact` to look up the row to update. */
export type VendorPersonContactOnVendorPersonContactForVendorPersonContactVendorIdFkeyUsingVendorPersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `vendorPersonContact` being updated. */
  patch: UpdateVendorPersonContactOnVendorPersonContactForVendorPersonContactVendorIdFkeyPatch;
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** Represents an update to a `VendorPersonContact`. Fields that are set will be updated. */
export type VendorPersonContactPatch = {
  vendorId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  vendorToVendorId?: Maybe<VendorPersonContactVendorIdFkeyInput>;
  personContactToPersonContactId?: Maybe<VendorPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `VendorPersonContactInput` mutation. */
export type VendorPersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<VendorPersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<VendorPersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** Input for the nested mutation of `vendorPersonContact` in the `PersonContactInput` mutation. */
export type VendorPersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `vendorPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  connectByVendorIdAndPersonContactId?: Maybe<Array<VendorPersonContactVendorPersonContactPkeyConnect>>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<VendorPersonContactNodeIdConnect>>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  deleteByVendorIdAndPersonContactId?: Maybe<Array<VendorPersonContactVendorPersonContactPkeyDelete>>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<VendorPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `vendorPersonContact` for the far side of the relationship. */
  updateByVendorIdAndPersonContactId?: Maybe<Array<VendorPersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyUsingVendorPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `vendorPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `VendorPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<VendorPersonContactPersonContactIdFkeyVendorPersonContactCreateInput>>;
};

/** The `personContact` to be created by this mutation. */
export type VendorPersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** The `vendorPersonContact` to be created by this mutation. */
export type VendorPersonContactPersonContactIdFkeyVendorPersonContactCreateInput = {
  vendorId?: Maybe<Scalars['String']>;
  vendorToVendorId?: Maybe<VendorPersonContactVendorIdFkeyInput>;
  personContactToPersonContactId?: Maybe<VendorPersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `vendor` in the `VendorPersonContactInput` mutation. */
export type VendorPersonContactVendorIdFkeyInput = {
  /** The primary key(s) for `vendor` for the far side of the relationship. */
  connectById?: Maybe<VendorVendorPkeyConnect>;
  /** The primary key(s) for `vendor` for the far side of the relationship. */
  connectByNodeId?: Maybe<VendorNodeIdConnect>;
  /** The primary key(s) for `vendor` for the far side of the relationship. */
  deleteById?: Maybe<VendorVendorPkeyDelete>;
  /** The primary key(s) for `vendor` for the far side of the relationship. */
  deleteByNodeId?: Maybe<VendorNodeIdDelete>;
  /** The primary key(s) and patch data for `vendor` for the far side of the relationship. */
  updateById?: Maybe<VendorOnVendorPersonContactForVendorPersonContactVendorIdFkeyUsingVendorPkeyUpdate>;
  /** The primary key(s) and patch data for `vendor` for the far side of the relationship. */
  updateByNodeId?: Maybe<VendorPersonContactOnVendorPersonContactForVendorPersonContactVendorIdFkeyNodeIdUpdate>;
  /** A `VendorInput` object that will be created and connected to this object. */
  create?: Maybe<VendorPersonContactVendorIdFkeyVendorCreateInput>;
};

/** Input for the nested mutation of `vendorPersonContact` in the `VendorInput` mutation. */
export type VendorPersonContactVendorIdFkeyInverseInput = {
  /** Flag indicating whether all other `vendorPersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  connectByVendorIdAndPersonContactId?: Maybe<Array<VendorPersonContactVendorPersonContactPkeyConnect>>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<VendorPersonContactNodeIdConnect>>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  deleteByVendorIdAndPersonContactId?: Maybe<Array<VendorPersonContactVendorPersonContactPkeyDelete>>;
  /** The primary key(s) for `vendorPersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<VendorPersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `vendorPersonContact` for the far side of the relationship. */
  updateByVendorIdAndPersonContactId?: Maybe<Array<VendorPersonContactOnVendorPersonContactForVendorPersonContactVendorIdFkeyUsingVendorPersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `vendorPersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<VendorOnVendorPersonContactForVendorPersonContactVendorIdFkeyNodeIdUpdate>>;
  /** A `VendorPersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<VendorPersonContactVendorIdFkeyVendorPersonContactCreateInput>>;
};

/** The `vendor` to be created by this mutation. */
export type VendorPersonContactVendorIdFkeyVendorCreateInput = {
  id: Scalars['String'];
  vendorName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  attention?: Maybe<Scalars['String']>;
  vendorType?: Maybe<Scalars['String']>;
  ledgerCode?: Maybe<Scalars['String']>;
  bankCode?: Maybe<Scalars['String']>;
  has1099?: Maybe<Scalars['Boolean']>;
  id1099?: Maybe<Scalars['String']>;
  isTemp?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactVendorIdFkeyInverseInput>;
};

/** The `vendorPersonContact` to be created by this mutation. */
export type VendorPersonContactVendorIdFkeyVendorPersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  vendorToVendorId?: Maybe<VendorPersonContactVendorIdFkeyInput>;
  personContactToPersonContactId?: Maybe<VendorPersonContactPersonContactIdFkeyInput>;
};

/** The fields on `vendorPersonContact` to look up the row to connect. */
export type VendorPersonContactVendorPersonContactPkeyConnect = {
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The fields on `vendorPersonContact` to look up the row to delete. */
export type VendorPersonContactVendorPersonContactPkeyDelete = {
  vendorId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** A connection to a list of `PersonContact` values, with data from `VendorPersonContact`. */
export type VendorPersonContactsByVendorPersonContactVendorIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'VendorPersonContactsByVendorPersonContactVendorIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `VendorPersonContact`, and the cursor to aid in pagination. */
  edges: Array<VendorPersonContactsByVendorPersonContactVendorIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `VendorPersonContact`. */
export type VendorPersonContactsByVendorPersonContactVendorIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'VendorPersonContactsByVendorPersonContactVendorIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A connection to a list of `VendorPersonContact` values. */
export type VendorPersonContactsConnection = {
  __typename?: 'VendorPersonContactsConnection';
  /** A list of `VendorPersonContact` objects. */
  nodes: Array<Maybe<VendorPersonContact>>;
  /** A list of edges which contains the `VendorPersonContact` and cursor to aid in pagination. */
  edges: Array<VendorPersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VendorPersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VendorPersonContact` edge in the connection. */
export type VendorPersonContactsEdge = {
  __typename?: 'VendorPersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VendorPersonContact` at the end of the edge. */
  node?: Maybe<VendorPersonContact>;
};

/** Methods to use when ordering `VendorPersonContact`. */
export enum VendorPersonContactsOrderBy {
  Natural = 'NATURAL',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VendorByVendorIdIdAsc = 'VENDOR_BY_VENDOR_ID__ID_ASC',
  VendorByVendorIdIdDesc = 'VENDOR_BY_VENDOR_ID__ID_DESC',
  VendorByVendorIdVendorNameAsc = 'VENDOR_BY_VENDOR_ID__VENDOR_NAME_ASC',
  VendorByVendorIdVendorNameDesc = 'VENDOR_BY_VENDOR_ID__VENDOR_NAME_DESC',
  VendorByVendorIdAddress_1Asc = 'VENDOR_BY_VENDOR_ID__ADDRESS_1_ASC',
  VendorByVendorIdAddress_1Desc = 'VENDOR_BY_VENDOR_ID__ADDRESS_1_DESC',
  VendorByVendorIdAddress_2Asc = 'VENDOR_BY_VENDOR_ID__ADDRESS_2_ASC',
  VendorByVendorIdAddress_2Desc = 'VENDOR_BY_VENDOR_ID__ADDRESS_2_DESC',
  VendorByVendorIdCityAsc = 'VENDOR_BY_VENDOR_ID__CITY_ASC',
  VendorByVendorIdCityDesc = 'VENDOR_BY_VENDOR_ID__CITY_DESC',
  VendorByVendorIdPostalStateAsc = 'VENDOR_BY_VENDOR_ID__POSTAL_STATE_ASC',
  VendorByVendorIdPostalStateDesc = 'VENDOR_BY_VENDOR_ID__POSTAL_STATE_DESC',
  VendorByVendorIdZipCodeAsc = 'VENDOR_BY_VENDOR_ID__ZIP_CODE_ASC',
  VendorByVendorIdZipCodeDesc = 'VENDOR_BY_VENDOR_ID__ZIP_CODE_DESC',
  VendorByVendorIdPhoneAsc = 'VENDOR_BY_VENDOR_ID__PHONE_ASC',
  VendorByVendorIdPhoneDesc = 'VENDOR_BY_VENDOR_ID__PHONE_DESC',
  VendorByVendorIdAttentionAsc = 'VENDOR_BY_VENDOR_ID__ATTENTION_ASC',
  VendorByVendorIdAttentionDesc = 'VENDOR_BY_VENDOR_ID__ATTENTION_DESC',
  VendorByVendorIdVendorTypeAsc = 'VENDOR_BY_VENDOR_ID__VENDOR_TYPE_ASC',
  VendorByVendorIdVendorTypeDesc = 'VENDOR_BY_VENDOR_ID__VENDOR_TYPE_DESC',
  VendorByVendorIdLedgerCodeAsc = 'VENDOR_BY_VENDOR_ID__LEDGER_CODE_ASC',
  VendorByVendorIdLedgerCodeDesc = 'VENDOR_BY_VENDOR_ID__LEDGER_CODE_DESC',
  VendorByVendorIdBankCodeAsc = 'VENDOR_BY_VENDOR_ID__BANK_CODE_ASC',
  VendorByVendorIdBankCodeDesc = 'VENDOR_BY_VENDOR_ID__BANK_CODE_DESC',
  VendorByVendorIdHas_1099Asc = 'VENDOR_BY_VENDOR_ID__HAS_1099_ASC',
  VendorByVendorIdHas_1099Desc = 'VENDOR_BY_VENDOR_ID__HAS_1099_DESC',
  VendorByVendorIdId_1099Asc = 'VENDOR_BY_VENDOR_ID__ID_1099_ASC',
  VendorByVendorIdId_1099Desc = 'VENDOR_BY_VENDOR_ID__ID_1099_DESC',
  VendorByVendorIdIsTempAsc = 'VENDOR_BY_VENDOR_ID__IS_TEMP_ASC',
  VendorByVendorIdIsTempDesc = 'VENDOR_BY_VENDOR_ID__IS_TEMP_DESC',
  VendorByVendorIdNotesAsc = 'VENDOR_BY_VENDOR_ID__NOTES_ASC',
  VendorByVendorIdNotesDesc = 'VENDOR_BY_VENDOR_ID__NOTES_DESC',
  VendorByVendorIdCountryIdAsc = 'VENDOR_BY_VENDOR_ID__COUNTRY_ID_ASC',
  VendorByVendorIdCountryIdDesc = 'VENDOR_BY_VENDOR_ID__COUNTRY_ID_DESC',
  PersonContactByPersonContactIdIdAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_ASC',
  PersonContactByPersonContactIdIdDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_DESC',
  PersonContactByPersonContactIdFirstNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_ASC',
  PersonContactByPersonContactIdFirstNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_DESC',
  PersonContactByPersonContactIdLastNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_ASC',
  PersonContactByPersonContactIdLastNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_DESC',
  PersonContactByPersonContactIdIsPrimaryAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_ASC',
  PersonContactByPersonContactIdIsPrimaryDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_DESC',
  PersonContactByPersonContactIdEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_ASC',
  PersonContactByPersonContactIdEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_DESC',
  PersonContactByPersonContactIdSecondaryEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_ASC',
  PersonContactByPersonContactIdSecondaryEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_DESC',
  PersonContactByPersonContactIdHomePhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_ASC',
  PersonContactByPersonContactIdHomePhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_DESC',
  PersonContactByPersonContactIdCellPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_ASC',
  PersonContactByPersonContactIdCellPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_DESC',
  PersonContactByPersonContactIdWorkPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_ASC',
  PersonContactByPersonContactIdWorkPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_DESC',
  PersonContactByPersonContactIdWorkExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_ASC',
  PersonContactByPersonContactIdWorkExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_DESC',
  PersonContactByPersonContactIdImageSrcAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_ASC',
  PersonContactByPersonContactIdImageSrcDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_DESC',
  PersonContactByPersonContactIdIsInternalAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_ASC',
  PersonContactByPersonContactIdIsInternalDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_DESC',
  PersonContactByPersonContactIdRolesAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_ASC',
  PersonContactByPersonContactIdRolesDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_DESC',
  PersonContactByPersonContactIdHomeExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_ASC',
  PersonContactByPersonContactIdHomeExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_DESC',
  PersonContactByPersonContactIdLocationAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_ASC',
  PersonContactByPersonContactIdLocationDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_DESC'
}

/** A filter to be used against many `VendorPersonContact` object types. All fields are combined with a logical ‘and.’ */
export type VendorToManyVendorPersonContactFilter = {
  /** Every related `VendorPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<VendorPersonContactFilter>;
  /** Some related `VendorPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<VendorPersonContactFilter>;
  /** No related `VendorPersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<VendorPersonContactFilter>;
};

/** The fields on `vendor` to look up the row to connect. */
export type VendorVendorPkeyConnect = {
  id: Scalars['String'];
};

/** The fields on `vendor` to look up the row to delete. */
export type VendorVendorPkeyDelete = {
  id: Scalars['String'];
};

/** A connection to a list of `Vendor` values. */
export type VendorsConnection = {
  __typename?: 'VendorsConnection';
  /** A list of `Vendor` objects. */
  nodes: Array<Maybe<Vendor>>;
  /** A list of edges which contains the `Vendor` and cursor to aid in pagination. */
  edges: Array<VendorsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vendor` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Vendor` edge in the connection. */
export type VendorsEdge = {
  __typename?: 'VendorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vendor` at the end of the edge. */
  node?: Maybe<Vendor>;
};

/** Methods to use when ordering `Vendor`. */
export enum VendorsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VendorNameAsc = 'VENDOR_NAME_ASC',
  VendorNameDesc = 'VENDOR_NAME_DESC',
  Address_1Asc = 'ADDRESS_1_ASC',
  Address_1Desc = 'ADDRESS_1_DESC',
  Address_2Asc = 'ADDRESS_2_ASC',
  Address_2Desc = 'ADDRESS_2_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  PostalStateAsc = 'POSTAL_STATE_ASC',
  PostalStateDesc = 'POSTAL_STATE_DESC',
  ZipCodeAsc = 'ZIP_CODE_ASC',
  ZipCodeDesc = 'ZIP_CODE_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  AttentionAsc = 'ATTENTION_ASC',
  AttentionDesc = 'ATTENTION_DESC',
  VendorTypeAsc = 'VENDOR_TYPE_ASC',
  VendorTypeDesc = 'VENDOR_TYPE_DESC',
  LedgerCodeAsc = 'LEDGER_CODE_ASC',
  LedgerCodeDesc = 'LEDGER_CODE_DESC',
  BankCodeAsc = 'BANK_CODE_ASC',
  BankCodeDesc = 'BANK_CODE_DESC',
  Has_1099Asc = 'HAS_1099_ASC',
  Has_1099Desc = 'HAS_1099_DESC',
  Id_1099Asc = 'ID_1099_ASC',
  Id_1099Desc = 'ID_1099_DESC',
  IsTempAsc = 'IS_TEMP_ASC',
  IsTempDesc = 'IS_TEMP_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VendorPersonContactsByVendorIdCountAsc = 'VENDOR_PERSON_CONTACTS_BY_VENDOR_ID__COUNT_ASC',
  VendorPersonContactsByVendorIdCountDesc = 'VENDOR_PERSON_CONTACTS_BY_VENDOR_ID__COUNT_DESC'
}

export type Vessel = Node & {
  __typename?: 'Vessel';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselCode: Scalars['String'];
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
  preVesselCode?: Maybe<Scalars['String']>;
  invFlag?: Maybe<Scalars['Boolean']>;
  scheduleNotes?: Maybe<Scalars['String']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVessels: ShipperProjectionVesselsConnection;
  /** Reads and enables pagination through a set of `Container`. */
  containers: ContainersConnection;
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `InventoryItem`. */
  inventoryItems: InventoryItemsConnection;
  originalArrivalPort?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets: PalletsConnection;
  searchText?: Maybe<Scalars['String']>;
  warehouse?: Maybe<Warehouse>;
  /** Reads and enables pagination through a set of `Shipper`. */
  shippersByShipperProjectionVesselVesselIdAndShipperId: VesselShippersByShipperProjectionVesselVesselIdAndShipperIdManyToManyConnection;
};


export type VesselShipperProjectionVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};


export type VesselContainersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<ContainerFilter>;
};


export type VesselInventoryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<InventoryItemFilter>;
};


export type VesselPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletFilter>;
};


export type VesselShippersByShipperProjectionVesselVesselIdAndShipperIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShippersOrderBy>>;
  condition?: Maybe<ShipperCondition>;
  filter?: Maybe<ShipperFilter>;
};

/** A condition to be used against `Vessel` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VesselCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselName` field. */
  vesselName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `departureDate` field. */
  departureDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `dischargeDate` field. */
  dischargeDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `coast` field. */
  coast?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isPre` field. */
  isPre?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `preVesselCode` field. */
  preVesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invFlag` field. */
  invFlag?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `scheduleNotes` field. */
  scheduleNotes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isAvailable` field. */
  isAvailable?: Maybe<Scalars['Boolean']>;
};

export type VesselControl = Node & {
  __typename?: 'VesselControl';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  vesselCode: Scalars['String'];
  shipperId: Scalars['String'];
  approval1?: Maybe<Scalars['Boolean']>;
  approval2?: Maybe<Scalars['Boolean']>;
  dateSent?: Maybe<Scalars['Date']>;
  isLiquidated?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
  dueDate?: Maybe<Scalars['Date']>;
  /** Reads and enables pagination through a set of `Pallet`. */
  pallets: PalletsConnection;
  palletsShipped?: Maybe<Scalars['BigFloat']>;
  shipper?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `Unpaid`. */
  unpaids: UnpaidsConnection;
  vessel?: Maybe<Vessel>;
  /** Reads and enables pagination through a set of `WireRequest`. */
  wires: WireRequestsConnection;
};


export type VesselControlPalletsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<PalletFilter>;
};


export type VesselControlUnpaidsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<UnpaidFilter>;
};


export type VesselControlWiresArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  filter?: Maybe<WireRequestFilter>;
};

/**
 * A condition to be used against `VesselControl` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VesselControlCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `approval1` field. */
  approval1?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `approval2` field. */
  approval2?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `dateSent` field. */
  dateSent?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `isLiquidated` field. */
  isLiquidated?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `notes1` field. */
  notes1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes2` field. */
  notes2?: Maybe<Scalars['String']>;
};

/** A filter to be used against `VesselControl` object types. All fields are combined with a logical ‘and.’ */
export type VesselControlFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `approval1` field. */
  approval1?: Maybe<BooleanFilter>;
  /** Filter by the object’s `approval2` field. */
  approval2?: Maybe<BooleanFilter>;
  /** Filter by the object’s `dateSent` field. */
  dateSent?: Maybe<DateFilter>;
  /** Filter by the object’s `isLiquidated` field. */
  isLiquidated?: Maybe<BooleanFilter>;
  /** Filter by the object’s `notes1` field. */
  notes1?: Maybe<StringFilter>;
  /** Filter by the object’s `notes2` field. */
  notes2?: Maybe<StringFilter>;
  /** Filter by the object’s `dueDate` field. */
  dueDate?: Maybe<DateFilter>;
  /** Filter by the object’s `palletsShipped` field. */
  palletsShipped?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VesselControlFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VesselControlFilter>>;
  /** Negates the expression. */
  not?: Maybe<VesselControlFilter>;
};

/** An input for mutations affecting `VesselControl` */
export type VesselControlInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  shipperId: Scalars['String'];
  approval1?: Maybe<Scalars['Boolean']>;
  approval2?: Maybe<Scalars['Boolean']>;
  dateSent?: Maybe<Scalars['Date']>;
  isLiquidated?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
};

/** Represents an update to a `VesselControl`. Fields that are set will be updated. */
export type VesselControlPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  approval1?: Maybe<Scalars['Boolean']>;
  approval2?: Maybe<Scalars['Boolean']>;
  dateSent?: Maybe<Scalars['Date']>;
  isLiquidated?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
};

/** A connection to a list of `VesselControl` values. */
export type VesselControlsConnection = {
  __typename?: 'VesselControlsConnection';
  /** A list of `VesselControl` objects. */
  nodes: Array<Maybe<VesselControl>>;
  /** A list of edges which contains the `VesselControl` and cursor to aid in pagination. */
  edges: Array<VesselControlsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VesselControl` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `VesselControl` edge in the connection. */
export type VesselControlsEdge = {
  __typename?: 'VesselControlsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VesselControl` at the end of the edge. */
  node?: Maybe<VesselControl>;
};

/** Methods to use when ordering `VesselControl`. */
export enum VesselControlsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  Approval_1Asc = 'APPROVAL_1_ASC',
  Approval_1Desc = 'APPROVAL_1_DESC',
  Approval_2Asc = 'APPROVAL_2_ASC',
  Approval_2Desc = 'APPROVAL_2_DESC',
  DateSentAsc = 'DATE_SENT_ASC',
  DateSentDesc = 'DATE_SENT_DESC',
  IsLiquidatedAsc = 'IS_LIQUIDATED_ASC',
  IsLiquidatedDesc = 'IS_LIQUIDATED_DESC',
  Notes_1Asc = 'NOTES_1_ASC',
  Notes_1Desc = 'NOTES_1_DESC',
  Notes_2Asc = 'NOTES_2_ASC',
  Notes_2Desc = 'NOTES_2_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `Vessel` object types. All fields are combined with a logical ‘and.’ */
export type VesselFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselName` field. */
  vesselName?: Maybe<StringFilter>;
  /** Filter by the object’s `arrivalPort` field. */
  arrivalPort?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `departureDate` field. */
  departureDate?: Maybe<DateFilter>;
  /** Filter by the object’s `arrivalDate` field. */
  arrivalDate?: Maybe<DateFilter>;
  /** Filter by the object’s `dischargeDate` field. */
  dischargeDate?: Maybe<DateFilter>;
  /** Filter by the object’s `coast` field. */
  coast?: Maybe<StringFilter>;
  /** Filter by the object’s `isPre` field. */
  isPre?: Maybe<BooleanFilter>;
  /** Filter by the object’s `preVesselCode` field. */
  preVesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `invFlag` field. */
  invFlag?: Maybe<BooleanFilter>;
  /** Filter by the object’s `scheduleNotes` field. */
  scheduleNotes?: Maybe<StringFilter>;
  /** Filter by the object’s `isAvailable` field. */
  isAvailable?: Maybe<BooleanFilter>;
  /** Filter by the object’s `originalArrivalPort` field. */
  originalArrivalPort?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperProjectionVessels` relation. */
  shipperProjectionVessels?: Maybe<VesselToManyShipperProjectionVesselFilter>;
  /** Some related `shipperProjectionVessels` exist. */
  shipperProjectionVesselsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VesselFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VesselFilter>>;
  /** Negates the expression. */
  not?: Maybe<VesselFilter>;
};

/** An input for mutations affecting `Vessel` */
export type VesselInput = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode: Scalars['String'];
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
  preVesselCode?: Maybe<Scalars['String']>;
  invFlag?: Maybe<Scalars['Boolean']>;
  scheduleNotes?: Maybe<Scalars['String']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselVesselIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type VesselNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `vessel` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type VesselNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `vessel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type VesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `shipperProjectionVessel` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
  patch: ShipperProjectionVesselPatch;
};

/** The fields on `vessel` to look up the row to update. */
export type VesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyUsingVesselPkeyUpdate = {
  /** An object where the defined keys will be set on the `vessel` being updated. */
  patch: UpdateVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `Vessel`. Fields that are set will be updated. */
export type VesselPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
  preVesselCode?: Maybe<Scalars['String']>;
  invFlag?: Maybe<Scalars['Boolean']>;
  scheduleNotes?: Maybe<Scalars['String']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselVesselIdFkeyInverseInput>;
};

/** A connection to a list of `Shipper` values, with data from `ShipperProjectionVessel`. */
export type VesselShippersByShipperProjectionVesselVesselIdAndShipperIdManyToManyConnection = {
  __typename?: 'VesselShippersByShipperProjectionVesselVesselIdAndShipperIdManyToManyConnection';
  /** A list of `Shipper` objects. */
  nodes: Array<Maybe<Shipper>>;
  /** A list of edges which contains the `Shipper`, info from the `ShipperProjectionVessel`, and the cursor to aid in pagination. */
  edges: Array<VesselShippersByShipperProjectionVesselVesselIdAndShipperIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipper` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Shipper` edge in the connection, with data from `ShipperProjectionVessel`. */
export type VesselShippersByShipperProjectionVesselVesselIdAndShipperIdManyToManyEdge = {
  __typename?: 'VesselShippersByShipperProjectionVesselVesselIdAndShipperIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipper` at the end of the edge. */
  node?: Maybe<Shipper>;
  /** Reads and enables pagination through a set of `ShipperProjectionVessel`. */
  shipperProjectionVessels: ShipperProjectionVesselsConnection;
};


/** A `Shipper` edge in the connection, with data from `ShipperProjectionVessel`. */
export type VesselShippersByShipperProjectionVesselVesselIdAndShipperIdManyToManyEdgeShipperProjectionVesselsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ShipperProjectionVesselsOrderBy>>;
  condition?: Maybe<ShipperProjectionVesselCondition>;
  filter?: Maybe<ShipperProjectionVesselFilter>;
};

/** A filter to be used against many `ShipperProjectionVessel` object types. All fields are combined with a logical ‘and.’ */
export type VesselToManyShipperProjectionVesselFilter = {
  /** Every related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ShipperProjectionVesselFilter>;
  /** Some related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ShipperProjectionVesselFilter>;
  /** No related `ShipperProjectionVessel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ShipperProjectionVesselFilter>;
};

/** The fields on `vessel` to look up the row to connect. */
export type VesselVesselPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `vessel` to look up the row to delete. */
export type VesselVesselPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `Vessel` values. */
export type VesselsConnection = {
  __typename?: 'VesselsConnection';
  /** A list of `Vessel` objects. */
  nodes: Array<Maybe<Vessel>>;
  /** A list of edges which contains the `Vessel` and cursor to aid in pagination. */
  edges: Array<VesselsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vessel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Vessel` edge in the connection. */
export type VesselsEdge = {
  __typename?: 'VesselsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vessel` at the end of the edge. */
  node?: Maybe<Vessel>;
};

/** Methods to use when ordering `Vessel`. */
export enum VesselsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  VesselNameAsc = 'VESSEL_NAME_ASC',
  VesselNameDesc = 'VESSEL_NAME_DESC',
  ArrivalPortAsc = 'ARRIVAL_PORT_ASC',
  ArrivalPortDesc = 'ARRIVAL_PORT_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  DepartureDateAsc = 'DEPARTURE_DATE_ASC',
  DepartureDateDesc = 'DEPARTURE_DATE_DESC',
  ArrivalDateAsc = 'ARRIVAL_DATE_ASC',
  ArrivalDateDesc = 'ARRIVAL_DATE_DESC',
  DischargeDateAsc = 'DISCHARGE_DATE_ASC',
  DischargeDateDesc = 'DISCHARGE_DATE_DESC',
  CoastAsc = 'COAST_ASC',
  CoastDesc = 'COAST_DESC',
  IsPreAsc = 'IS_PRE_ASC',
  IsPreDesc = 'IS_PRE_DESC',
  PreVesselCodeAsc = 'PRE_VESSEL_CODE_ASC',
  PreVesselCodeDesc = 'PRE_VESSEL_CODE_DESC',
  InvFlagAsc = 'INV_FLAG_ASC',
  InvFlagDesc = 'INV_FLAG_DESC',
  ScheduleNotesAsc = 'SCHEDULE_NOTES_ASC',
  ScheduleNotesDesc = 'SCHEDULE_NOTES_DESC',
  IsAvailableAsc = 'IS_AVAILABLE_ASC',
  IsAvailableDesc = 'IS_AVAILABLE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipperProjectionVesselsByVesselIdCountAsc = 'SHIPPER_PROJECTION_VESSELS_BY_VESSEL_ID__COUNT_ASC',
  ShipperProjectionVesselsByVesselIdCountDesc = 'SHIPPER_PROJECTION_VESSELS_BY_VESSEL_ID__COUNT_DESC'
}

export type Warehouse = Node & {
  __typename?: 'Warehouse';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  /** Reads a single `Country` that is related to this `Warehouse`. */
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `WarehousePersonContact`. */
  warehousePersonContacts: WarehousePersonContactsConnection;
  searchText?: Maybe<Scalars['String']>;
  vendor?: Maybe<Vendor>;
  /** Reads and enables pagination through a set of `PersonContact`. */
  personContactsByWarehousePersonContactWarehouseIdAndPersonContactId: WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyConnection;
};


export type WarehouseWarehousePersonContactsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WarehousePersonContactsOrderBy>>;
  condition?: Maybe<WarehousePersonContactCondition>;
  filter?: Maybe<WarehousePersonContactFilter>;
};


export type WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PersonContactsOrderBy>>;
  condition?: Maybe<PersonContactCondition>;
  filter?: Maybe<PersonContactFilter>;
};

/**
 * A condition to be used against `Warehouse` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WarehouseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `warehouseName` field. */
  warehouseName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address1` field. */
  address1?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address2` field. */
  address2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address3` field. */
  address3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `postalState` field. */
  postalState?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `zipCode` field. */
  zipCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outQueue` field. */
  outQueue?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stateTaxCode` field. */
  stateTaxCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countyTaxCode` field. */
  countyTaxCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `cityTaxCode` field. */
  cityTaxCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `miscTaxCode` field. */
  miscTaxCode?: Maybe<Scalars['String']>;
};

/** The `country` to be created by this mutation. */
export type WarehouseCountryIdFkeyCountryCreateInput = {
  id: Scalars['String'];
  countryName: Scalars['String'];
  cmbId?: Maybe<Scalars['String']>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `country` in the `WarehouseInput` mutation. */
export type WarehouseCountryIdFkeyInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryCountryPkeyConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryCountryPkeyDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnWarehouseForWarehouseCountryIdFkeyUsingCountryPkeyUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<WarehouseOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<WarehouseCountryIdFkeyCountryCreateInput>;
};

/** Input for the nested mutation of `warehouse` in the `CountryInput` mutation. */
export type WarehouseCountryIdFkeyInverseInput = {
  /** Flag indicating whether all other `warehouse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectById?: Maybe<Array<WarehouseWarehousePkeyConnect>>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WarehouseNodeIdConnect>>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteById?: Maybe<Array<WarehouseWarehousePkeyDelete>>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WarehouseNodeIdDelete>>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateById?: Maybe<Array<WarehouseOnWarehouseForWarehouseCountryIdFkeyUsingWarehousePkeyUpdate>>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate>>;
  /** A `WarehouseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WarehouseCountryIdFkeyWarehouseCreateInput>>;
};

/** The `warehouse` to be created by this mutation. */
export type WarehouseCountryIdFkeyWarehouseCreateInput = {
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** A `String` edge in the connection. */
export type WarehouseDistinctValueEdge = {
  __typename?: 'WarehouseDistinctValueEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** A connection to a list of `String` values. */
export type WarehouseDistinctValuesConnection = {
  __typename?: 'WarehouseDistinctValuesConnection';
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<WarehouseDistinctValueEdge>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A filter to be used against `Warehouse` object types. All fields are combined with a logical ‘and.’ */
export type WarehouseFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<StringFilter>;
  /** Filter by the object’s `warehouseName` field. */
  warehouseName?: Maybe<StringFilter>;
  /** Filter by the object’s `address1` field. */
  address1?: Maybe<StringFilter>;
  /** Filter by the object’s `address2` field. */
  address2?: Maybe<StringFilter>;
  /** Filter by the object’s `address3` field. */
  address3?: Maybe<StringFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `postalState` field. */
  postalState?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<StringFilter>;
  /** Filter by the object’s `zipCode` field. */
  zipCode?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `outQueue` field. */
  outQueue?: Maybe<StringFilter>;
  /** Filter by the object’s `stateTaxCode` field. */
  stateTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `countyTaxCode` field. */
  countyTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `cityTaxCode` field. */
  cityTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `miscTaxCode` field. */
  miscTaxCode?: Maybe<StringFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `warehousePersonContacts` relation. */
  warehousePersonContacts?: Maybe<WarehouseToManyWarehousePersonContactFilter>;
  /** Some related `warehousePersonContacts` exist. */
  warehousePersonContactsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** A related `country` exists. */
  countryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WarehouseFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WarehouseFilter>>;
  /** Negates the expression. */
  not?: Maybe<WarehouseFilter>;
};

/** An input for mutations affecting `Warehouse` */
export type WarehouseInput = {
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WarehouseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `warehouse` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WarehouseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `warehouse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type WarehouseOnWarehouseForWarehouseCountryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** The fields on `warehouse` to look up the row to update. */
export type WarehouseOnWarehouseForWarehouseCountryIdFkeyUsingWarehousePkeyUpdate = {
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: UpdateWarehouseOnWarehouseForWarehouseCountryIdFkeyPatch;
  id: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: WarehousePersonContactPatch;
};

/** The fields on `warehouse` to look up the row to update. */
export type WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePkeyUpdate = {
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: UpdateWarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch;
  id: Scalars['String'];
};

/** Represents an update to a `Warehouse`. Fields that are set will be updated. */
export type WarehousePatch = {
  id?: Maybe<Scalars['String']>;
  warehouseName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

export type WarehousePersonContact = Node & {
  __typename?: 'WarehousePersonContact';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
  /** Reads a single `Warehouse` that is related to this `WarehousePersonContact`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `PersonContact` that is related to this `WarehousePersonContact`. */
  personContact?: Maybe<PersonContact>;
};

/**
 * A condition to be used against `WarehousePersonContact` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type WarehousePersonContactCondition = {
  /** Checks for equality with the object’s `warehouseId` field. */
  warehouseId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `personContactId` field. */
  personContactId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `WarehousePersonContact` object types. All fields are combined with a logical ‘and.’ */
export type WarehousePersonContactFilter = {
  /** Filter by the object’s `warehouseId` field. */
  warehouseId?: Maybe<StringFilter>;
  /** Filter by the object’s `personContactId` field. */
  personContactId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `warehouse` relation. */
  warehouse?: Maybe<WarehouseFilter>;
  /** Filter by the object’s `personContact` relation. */
  personContact?: Maybe<PersonContactFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WarehousePersonContactFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WarehousePersonContactFilter>>;
  /** Negates the expression. */
  not?: Maybe<WarehousePersonContactFilter>;
};

/** An input for mutations affecting `WarehousePersonContact` */
export type WarehousePersonContactInput = {
  warehouseId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WarehousePersonContactNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WarehousePersonContactNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `warehousePersonContact` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `personContact` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `personContact` being updated. */
  patch: PersonContactPatch;
};

/** The fields on `warehousePersonContact` to look up the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingWarehousePersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `warehouse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `warehouse` being updated. */
  patch: WarehousePatch;
};

/** The fields on `warehousePersonContact` to look up the row to update. */
export type WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePersonContactPkeyUpdate = {
  /** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
  patch: UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch;
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** Represents an update to a `WarehousePersonContact`. Fields that are set will be updated. */
export type WarehousePersonContactPatch = {
  warehouseId?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `personContact` in the `WarehousePersonContactInput` mutation. */
export type WarehousePersonContactPersonContactIdFkeyInput = {
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectById?: Maybe<PersonContactPersonContactPkeyConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<PersonContactNodeIdConnect>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteById?: Maybe<PersonContactPersonContactPkeyDelete>;
  /** The primary key(s) for `personContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PersonContactNodeIdDelete>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateById?: Maybe<PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingPersonContactPkeyUpdate>;
  /** The primary key(s) and patch data for `personContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate>;
  /** A `PersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<WarehousePersonContactPersonContactIdFkeyPersonContactCreateInput>;
};

/** Input for the nested mutation of `warehousePersonContact` in the `PersonContactInput` mutation. */
export type WarehousePersonContactPersonContactIdFkeyInverseInput = {
  /** Flag indicating whether all other `warehousePersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WarehousePersonContactNodeIdConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyDelete>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WarehousePersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyUsingWarehousePersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyNodeIdUpdate>>;
  /** A `WarehousePersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WarehousePersonContactPersonContactIdFkeyWarehousePersonContactCreateInput>>;
};

/** The `personContact` to be created by this mutation. */
export type WarehousePersonContactPersonContactIdFkeyPersonContactCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  isPrimary: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal: Scalars['Boolean'];
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** The `warehousePersonContact` to be created by this mutation. */
export type WarehousePersonContactPersonContactIdFkeyWarehousePersonContactCreateInput = {
  warehouseId?: Maybe<Scalars['String']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** Input for the nested mutation of `warehouse` in the `WarehousePersonContactInput` mutation. */
export type WarehousePersonContactWarehouseIdFkeyInput = {
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectById?: Maybe<WarehouseWarehousePkeyConnect>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  connectByNodeId?: Maybe<WarehouseNodeIdConnect>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteById?: Maybe<WarehouseWarehousePkeyDelete>;
  /** The primary key(s) for `warehouse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<WarehouseNodeIdDelete>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateById?: Maybe<WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePkeyUpdate>;
  /** The primary key(s) and patch data for `warehouse` for the far side of the relationship. */
  updateByNodeId?: Maybe<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate>;
  /** A `WarehouseInput` object that will be created and connected to this object. */
  create?: Maybe<WarehousePersonContactWarehouseIdFkeyWarehouseCreateInput>;
};

/** Input for the nested mutation of `warehousePersonContact` in the `WarehouseInput` mutation. */
export type WarehousePersonContactWarehouseIdFkeyInverseInput = {
  /** Flag indicating whether all other `warehousePersonContact` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WarehousePersonContactNodeIdConnect>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactWarehousePersonContactPkeyDelete>>;
  /** The primary key(s) for `warehousePersonContact` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WarehousePersonContactNodeIdDelete>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByWarehouseIdAndPersonContactId?: Maybe<Array<WarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyUsingWarehousePersonContactPkeyUpdate>>;
  /** The primary key(s) and patch data for `warehousePersonContact` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<WarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyNodeIdUpdate>>;
  /** A `WarehousePersonContactInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WarehousePersonContactWarehouseIdFkeyWarehousePersonContactCreateInput>>;
};

/** The `warehouse` to be created by this mutation. */
export type WarehousePersonContactWarehouseIdFkeyWarehouseCreateInput = {
  id: Scalars['String'];
  warehouseName: Scalars['String'];
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** The `warehousePersonContact` to be created by this mutation. */
export type WarehousePersonContactWarehouseIdFkeyWarehousePersonContactCreateInput = {
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** The fields on `warehousePersonContact` to look up the row to connect. */
export type WarehousePersonContactWarehousePersonContactPkeyConnect = {
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** The fields on `warehousePersonContact` to look up the row to delete. */
export type WarehousePersonContactWarehousePersonContactPkeyDelete = {
  warehouseId: Scalars['String'];
  personContactId: Scalars['BigInt'];
};

/** A connection to a list of `PersonContact` values, with data from `WarehousePersonContact`. */
export type WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyConnection = {
  __typename?: 'WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyConnection';
  /** A list of `PersonContact` objects. */
  nodes: Array<Maybe<PersonContact>>;
  /** A list of edges which contains the `PersonContact`, info from the `WarehousePersonContact`, and the cursor to aid in pagination. */
  edges: Array<WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PersonContact` edge in the connection, with data from `WarehousePersonContact`. */
export type WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyEdge = {
  __typename?: 'WarehousePersonContactsByWarehousePersonContactWarehouseIdAndPersonContactIdManyToManyEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PersonContact` at the end of the edge. */
  node?: Maybe<PersonContact>;
};

/** A connection to a list of `WarehousePersonContact` values. */
export type WarehousePersonContactsConnection = {
  __typename?: 'WarehousePersonContactsConnection';
  /** A list of `WarehousePersonContact` objects. */
  nodes: Array<Maybe<WarehousePersonContact>>;
  /** A list of edges which contains the `WarehousePersonContact` and cursor to aid in pagination. */
  edges: Array<WarehousePersonContactsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WarehousePersonContact` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `WarehousePersonContact` edge in the connection. */
export type WarehousePersonContactsEdge = {
  __typename?: 'WarehousePersonContactsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WarehousePersonContact` at the end of the edge. */
  node?: Maybe<WarehousePersonContact>;
};

/** Methods to use when ordering `WarehousePersonContact`. */
export enum WarehousePersonContactsOrderBy {
  Natural = 'NATURAL',
  WarehouseIdAsc = 'WAREHOUSE_ID_ASC',
  WarehouseIdDesc = 'WAREHOUSE_ID_DESC',
  PersonContactIdAsc = 'PERSON_CONTACT_ID_ASC',
  PersonContactIdDesc = 'PERSON_CONTACT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WarehouseByWarehouseIdIdAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__ID_ASC',
  WarehouseByWarehouseIdIdDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__ID_DESC',
  WarehouseByWarehouseIdWarehouseNameAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__WAREHOUSE_NAME_ASC',
  WarehouseByWarehouseIdWarehouseNameDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__WAREHOUSE_NAME_DESC',
  WarehouseByWarehouseIdAddress_1Asc = 'WAREHOUSE_BY_WAREHOUSE_ID__ADDRESS_1_ASC',
  WarehouseByWarehouseIdAddress_1Desc = 'WAREHOUSE_BY_WAREHOUSE_ID__ADDRESS_1_DESC',
  WarehouseByWarehouseIdAddress_2Asc = 'WAREHOUSE_BY_WAREHOUSE_ID__ADDRESS_2_ASC',
  WarehouseByWarehouseIdAddress_2Desc = 'WAREHOUSE_BY_WAREHOUSE_ID__ADDRESS_2_DESC',
  WarehouseByWarehouseIdAddress_3Asc = 'WAREHOUSE_BY_WAREHOUSE_ID__ADDRESS_3_ASC',
  WarehouseByWarehouseIdAddress_3Desc = 'WAREHOUSE_BY_WAREHOUSE_ID__ADDRESS_3_DESC',
  WarehouseByWarehouseIdCityAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__CITY_ASC',
  WarehouseByWarehouseIdCityDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__CITY_DESC',
  WarehouseByWarehouseIdPostalStateAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__POSTAL_STATE_ASC',
  WarehouseByWarehouseIdPostalStateDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__POSTAL_STATE_DESC',
  WarehouseByWarehouseIdCountryIdAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__COUNTRY_ID_ASC',
  WarehouseByWarehouseIdCountryIdDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__COUNTRY_ID_DESC',
  WarehouseByWarehouseIdZipCodeAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__ZIP_CODE_ASC',
  WarehouseByWarehouseIdZipCodeDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__ZIP_CODE_DESC',
  WarehouseByWarehouseIdPhoneAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__PHONE_ASC',
  WarehouseByWarehouseIdPhoneDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__PHONE_DESC',
  WarehouseByWarehouseIdOutQueueAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__OUT_QUEUE_ASC',
  WarehouseByWarehouseIdOutQueueDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__OUT_QUEUE_DESC',
  WarehouseByWarehouseIdStateTaxCodeAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__STATE_TAX_CODE_ASC',
  WarehouseByWarehouseIdStateTaxCodeDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__STATE_TAX_CODE_DESC',
  WarehouseByWarehouseIdCountyTaxCodeAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__COUNTY_TAX_CODE_ASC',
  WarehouseByWarehouseIdCountyTaxCodeDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__COUNTY_TAX_CODE_DESC',
  WarehouseByWarehouseIdCityTaxCodeAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__CITY_TAX_CODE_ASC',
  WarehouseByWarehouseIdCityTaxCodeDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__CITY_TAX_CODE_DESC',
  WarehouseByWarehouseIdMiscTaxCodeAsc = 'WAREHOUSE_BY_WAREHOUSE_ID__MISC_TAX_CODE_ASC',
  WarehouseByWarehouseIdMiscTaxCodeDesc = 'WAREHOUSE_BY_WAREHOUSE_ID__MISC_TAX_CODE_DESC',
  PersonContactByPersonContactIdIdAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_ASC',
  PersonContactByPersonContactIdIdDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ID_DESC',
  PersonContactByPersonContactIdFirstNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_ASC',
  PersonContactByPersonContactIdFirstNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__FIRST_NAME_DESC',
  PersonContactByPersonContactIdLastNameAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_ASC',
  PersonContactByPersonContactIdLastNameDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LAST_NAME_DESC',
  PersonContactByPersonContactIdIsPrimaryAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_ASC',
  PersonContactByPersonContactIdIsPrimaryDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_PRIMARY_DESC',
  PersonContactByPersonContactIdEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_ASC',
  PersonContactByPersonContactIdEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__EMAIL_DESC',
  PersonContactByPersonContactIdSecondaryEmailAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_ASC',
  PersonContactByPersonContactIdSecondaryEmailDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__SECONDARY_EMAIL_DESC',
  PersonContactByPersonContactIdHomePhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_ASC',
  PersonContactByPersonContactIdHomePhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_PHONE_DESC',
  PersonContactByPersonContactIdCellPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_ASC',
  PersonContactByPersonContactIdCellPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__CELL_PHONE_DESC',
  PersonContactByPersonContactIdWorkPhoneAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_ASC',
  PersonContactByPersonContactIdWorkPhoneDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_PHONE_DESC',
  PersonContactByPersonContactIdWorkExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_ASC',
  PersonContactByPersonContactIdWorkExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__WORK_EXTENSION_DESC',
  PersonContactByPersonContactIdImageSrcAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_ASC',
  PersonContactByPersonContactIdImageSrcDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IMAGE_SRC_DESC',
  PersonContactByPersonContactIdIsInternalAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_ASC',
  PersonContactByPersonContactIdIsInternalDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__IS_INTERNAL_DESC',
  PersonContactByPersonContactIdRolesAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_ASC',
  PersonContactByPersonContactIdRolesDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__ROLES_DESC',
  PersonContactByPersonContactIdHomeExtensionAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_ASC',
  PersonContactByPersonContactIdHomeExtensionDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__HOME_EXTENSION_DESC',
  PersonContactByPersonContactIdLocationAsc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_ASC',
  PersonContactByPersonContactIdLocationDesc = 'PERSON_CONTACT_BY_PERSON_CONTACT_ID__LOCATION_DESC'
}

/** A filter to be used against many `WarehousePersonContact` object types. All fields are combined with a logical ‘and.’ */
export type WarehouseToManyWarehousePersonContactFilter = {
  /** Every related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WarehousePersonContactFilter>;
  /** Some related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WarehousePersonContactFilter>;
  /** No related `WarehousePersonContact` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WarehousePersonContactFilter>;
};

/** The fields on `warehouse` to look up the row to connect. */
export type WarehouseWarehousePkeyConnect = {
  id: Scalars['String'];
};

/** The fields on `warehouse` to look up the row to delete. */
export type WarehouseWarehousePkeyDelete = {
  id: Scalars['String'];
};

/** A connection to a list of `Warehouse` values. */
export type WarehousesConnection = {
  __typename?: 'WarehousesConnection';
  /** A list of `Warehouse` objects. */
  nodes: Array<Maybe<Warehouse>>;
  /** A list of edges which contains the `Warehouse` and cursor to aid in pagination. */
  edges: Array<WarehousesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Warehouse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Warehouse` edge in the connection. */
export type WarehousesEdge = {
  __typename?: 'WarehousesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Warehouse` at the end of the edge. */
  node?: Maybe<Warehouse>;
};

/** Methods to use when ordering `Warehouse`. */
export enum WarehousesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  WarehouseNameAsc = 'WAREHOUSE_NAME_ASC',
  WarehouseNameDesc = 'WAREHOUSE_NAME_DESC',
  Address_1Asc = 'ADDRESS_1_ASC',
  Address_1Desc = 'ADDRESS_1_DESC',
  Address_2Asc = 'ADDRESS_2_ASC',
  Address_2Desc = 'ADDRESS_2_DESC',
  Address_3Asc = 'ADDRESS_3_ASC',
  Address_3Desc = 'ADDRESS_3_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  PostalStateAsc = 'POSTAL_STATE_ASC',
  PostalStateDesc = 'POSTAL_STATE_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  ZipCodeAsc = 'ZIP_CODE_ASC',
  ZipCodeDesc = 'ZIP_CODE_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  OutQueueAsc = 'OUT_QUEUE_ASC',
  OutQueueDesc = 'OUT_QUEUE_DESC',
  StateTaxCodeAsc = 'STATE_TAX_CODE_ASC',
  StateTaxCodeDesc = 'STATE_TAX_CODE_DESC',
  CountyTaxCodeAsc = 'COUNTY_TAX_CODE_ASC',
  CountyTaxCodeDesc = 'COUNTY_TAX_CODE_DESC',
  CityTaxCodeAsc = 'CITY_TAX_CODE_ASC',
  CityTaxCodeDesc = 'CITY_TAX_CODE_DESC',
  MiscTaxCodeAsc = 'MISC_TAX_CODE_ASC',
  MiscTaxCodeDesc = 'MISC_TAX_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdCountryNameAsc = 'COUNTRY_BY_COUNTRY_ID__COUNTRY_NAME_ASC',
  CountryByCountryIdCountryNameDesc = 'COUNTRY_BY_COUNTRY_ID__COUNTRY_NAME_DESC',
  CountryByCountryIdCmbIdAsc = 'COUNTRY_BY_COUNTRY_ID__CMB_ID_ASC',
  CountryByCountryIdCmbIdDesc = 'COUNTRY_BY_COUNTRY_ID__CMB_ID_DESC',
  WarehousePersonContactsByWarehouseIdCountAsc = 'WAREHOUSE_PERSON_CONTACTS_BY_WAREHOUSE_ID__COUNT_ASC',
  WarehousePersonContactsByWarehouseIdCountDesc = 'WAREHOUSE_PERSON_CONTACTS_BY_WAREHOUSE_ID__COUNT_DESC'
}

export type WireRequest = Node & {
  __typename?: 'WireRequest';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  bankId: Scalars['String'];
  vendorId: Scalars['String'];
  wireNumber?: Maybe<Scalars['String']>;
  requestDate: Scalars['Date'];
  wireDate: Scalars['Date'];
  wireType: Scalars['String'];
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode: Scalars['String'];
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  /** Reads and enables pagination through a set of `WireRequestOceanFreightItem`. */
  wireRequestOceanFreightItems: WireRequestOceanFreightItemsConnection;
  /** Reads and enables pagination through a set of `WireRequestShipperAdvanceItem`. */
  wireRequestShipperAdvanceItems: WireRequestShipperAdvanceItemsConnection;
  /** Reads and enables pagination through a set of `WireRequestAccountOfSaleItem`. */
  wireRequestAccountOfSaleItems: WireRequestAccountOfSaleItemsConnection;
  /** Reads and enables pagination through a set of `WireRequestMiscItem`. */
  wireRequestMiscItems: WireRequestMiscItemsConnection;
  approvalUser?: Maybe<User>;
  checkHeader?: Maybe<CheckHeader>;
  requestUser?: Maybe<User>;
  searchText?: Maybe<Scalars['String']>;
  vendor?: Maybe<Vendor>;
};


export type WireRequestWireRequestOceanFreightItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestOceanFreightItemsOrderBy>>;
  condition?: Maybe<WireRequestOceanFreightItemCondition>;
  filter?: Maybe<WireRequestOceanFreightItemFilter>;
};


export type WireRequestWireRequestShipperAdvanceItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestShipperAdvanceItemsOrderBy>>;
  condition?: Maybe<WireRequestShipperAdvanceItemCondition>;
  filter?: Maybe<WireRequestShipperAdvanceItemFilter>;
};


export type WireRequestWireRequestAccountOfSaleItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestAccountOfSaleItemsOrderBy>>;
  condition?: Maybe<WireRequestAccountOfSaleItemCondition>;
  filter?: Maybe<WireRequestAccountOfSaleItemFilter>;
};


export type WireRequestWireRequestMiscItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<WireRequestMiscItemsOrderBy>>;
  condition?: Maybe<WireRequestMiscItemCondition>;
  filter?: Maybe<WireRequestMiscItemFilter>;
};

export type WireRequestAccountOfSaleItem = Node & {
  __typename?: 'WireRequestAccountOfSaleItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  wireRequestId: Scalars['BigInt'];
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  /** Reads a single `WireRequest` that is related to this `WireRequestAccountOfSaleItem`. */
  wireRequest?: Maybe<WireRequest>;
  vessel?: Maybe<Vessel>;
};

/**
 * A condition to be used against `WireRequestAccountOfSaleItem` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type WireRequestAccountOfSaleItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `billOfLading` field. */
  billOfLading?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
};

/** A filter to be used against `WireRequestAccountOfSaleItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestAccountOfSaleItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `billOfLading` field. */
  billOfLading?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `wireRequest` relation. */
  wireRequest?: Maybe<WireRequestFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WireRequestAccountOfSaleItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WireRequestAccountOfSaleItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<WireRequestAccountOfSaleItemFilter>;
};

/** An input for mutations affecting `WireRequestAccountOfSaleItem` */
export type WireRequestAccountOfSaleItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  wireRequestToWireRequestId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WireRequestAccountOfSaleItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `wireRequestAccountOfSaleItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WireRequestAccountOfSaleItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `wireRequestAccountOfSaleItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type WireRequestAccountOfSaleItemOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequest` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: WireRequestPatch;
};

/** The fields on `wireRequestAccountOfSaleItem` to look up the row to update. */
export type WireRequestAccountOfSaleItemOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyUsingWireRequestAccountOfSaleItemPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequestAccountOfSaleItem` being updated. */
  patch: UpdateWireRequestAccountOfSaleItemOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `WireRequestAccountOfSaleItem`. Fields that are set will be updated. */
export type WireRequestAccountOfSaleItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  billOfLading?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  wireRequestToWireRequestId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInput>;
};

/** The fields on `wireRequestAccountOfSaleItem` to look up the row to connect. */
export type WireRequestAccountOfSaleItemWireRequestAccountOfSaleItemPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `wireRequestAccountOfSaleItem` to look up the row to delete. */
export type WireRequestAccountOfSaleItemWireRequestAccountOfSaleItemPkeyDelete = {
  id: Scalars['BigInt'];
};

/** Input for the nested mutation of `wireRequest` in the `WireRequestAccountOfSaleItemInput` mutation. */
export type WireRequestAccountOfSaleItemWireRequestIdFkeyInput = {
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectById?: Maybe<WireRequestWireRequestPkeyConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectByNodeId?: Maybe<WireRequestNodeIdConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteById?: Maybe<WireRequestWireRequestPkeyDelete>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteByNodeId?: Maybe<WireRequestNodeIdDelete>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateById?: Maybe<WireRequestOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyUsingWireRequestPkeyUpdate>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateByNodeId?: Maybe<WireRequestAccountOfSaleItemOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyNodeIdUpdate>;
  /** A `WireRequestInput` object that will be created and connected to this object. */
  create?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyWireRequestCreateInput>;
};

/** Input for the nested mutation of `wireRequestAccountOfSaleItem` in the `WireRequestInput` mutation. */
export type WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput = {
  /** Flag indicating whether all other `wireRequestAccountOfSaleItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `wireRequestAccountOfSaleItem` for the far side of the relationship. */
  connectById?: Maybe<Array<WireRequestAccountOfSaleItemWireRequestAccountOfSaleItemPkeyConnect>>;
  /** The primary key(s) for `wireRequestAccountOfSaleItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WireRequestAccountOfSaleItemNodeIdConnect>>;
  /** The primary key(s) for `wireRequestAccountOfSaleItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<WireRequestAccountOfSaleItemWireRequestAccountOfSaleItemPkeyDelete>>;
  /** The primary key(s) for `wireRequestAccountOfSaleItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WireRequestAccountOfSaleItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `wireRequestAccountOfSaleItem` for the far side of the relationship. */
  updateById?: Maybe<Array<WireRequestAccountOfSaleItemOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyUsingWireRequestAccountOfSaleItemPkeyUpdate>>;
  /** The primary key(s) and patch data for `wireRequestAccountOfSaleItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<WireRequestOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyNodeIdUpdate>>;
  /** A `WireRequestAccountOfSaleItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WireRequestAccountOfSaleItemWireRequestIdFkeyWireRequestAccountOfSaleItemCreateInput>>;
};

/** The `wireRequestAccountOfSaleItem` to be created by this mutation. */
export type WireRequestAccountOfSaleItemWireRequestIdFkeyWireRequestAccountOfSaleItemCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  wireRequestToWireRequestId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInput>;
};

/** The `wireRequest` to be created by this mutation. */
export type WireRequestAccountOfSaleItemWireRequestIdFkeyWireRequestCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  bankId: Scalars['String'];
  vendorId: Scalars['String'];
  wireNumber?: Maybe<Scalars['String']>;
  requestDate: Scalars['Date'];
  wireDate: Scalars['Date'];
  wireType: Scalars['String'];
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode: Scalars['String'];
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** A connection to a list of `WireRequestAccountOfSaleItem` values. */
export type WireRequestAccountOfSaleItemsConnection = {
  __typename?: 'WireRequestAccountOfSaleItemsConnection';
  /** A list of `WireRequestAccountOfSaleItem` objects. */
  nodes: Array<Maybe<WireRequestAccountOfSaleItem>>;
  /** A list of edges which contains the `WireRequestAccountOfSaleItem` and cursor to aid in pagination. */
  edges: Array<WireRequestAccountOfSaleItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WireRequestAccountOfSaleItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `WireRequestAccountOfSaleItem` edge in the connection. */
export type WireRequestAccountOfSaleItemsEdge = {
  __typename?: 'WireRequestAccountOfSaleItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WireRequestAccountOfSaleItem` at the end of the edge. */
  node?: Maybe<WireRequestAccountOfSaleItem>;
};

/** Methods to use when ordering `WireRequestAccountOfSaleItem`. */
export enum WireRequestAccountOfSaleItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  WireRequestIdAsc = 'WIRE_REQUEST_ID_ASC',
  WireRequestIdDesc = 'WIRE_REQUEST_ID_DESC',
  BillOfLadingAsc = 'BILL_OF_LADING_ASC',
  BillOfLadingDesc = 'BILL_OF_LADING_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WireRequestByWireRequestIdIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_ASC',
  WireRequestByWireRequestIdIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_DESC',
  WireRequestByWireRequestIdBankIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_ASC',
  WireRequestByWireRequestIdBankIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_DESC',
  WireRequestByWireRequestIdVendorIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_ASC',
  WireRequestByWireRequestIdVendorIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_DESC',
  WireRequestByWireRequestIdWireNumberAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_ASC',
  WireRequestByWireRequestIdWireNumberDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_DESC',
  WireRequestByWireRequestIdRequestDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_ASC',
  WireRequestByWireRequestIdRequestDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_DESC',
  WireRequestByWireRequestIdWireDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_ASC',
  WireRequestByWireRequestIdWireDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_DESC',
  WireRequestByWireRequestIdWireTypeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_ASC',
  WireRequestByWireRequestIdWireTypeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_DESC',
  WireRequestByWireRequestIdApprovalUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_ASC',
  WireRequestByWireRequestIdApprovalUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_DESC',
  WireRequestByWireRequestIdApprovalDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_ASC',
  WireRequestByWireRequestIdApprovalDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_DESC',
  WireRequestByWireRequestIdRequestUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_ASC',
  WireRequestByWireRequestIdRequestUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_DESC',
  WireRequestByWireRequestIdIsVerifiedAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_ASC',
  WireRequestByWireRequestIdIsVerifiedDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_DESC',
  WireRequestByWireRequestIdSentDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_ASC',
  WireRequestByWireRequestIdSentDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_DESC'
}

/**
 * A condition to be used against `WireRequest` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WireRequestCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `bankId` field. */
  bankId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vendorId` field. */
  vendorId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `wireNumber` field. */
  wireNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `requestDate` field. */
  requestDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `wireDate` field. */
  wireDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `wireType` field. */
  wireType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `approvalUserCode` field. */
  approvalUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `approvalDate` field. */
  approvalDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `requestUserCode` field. */
  requestUserCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `sentDate` field. */
  sentDate?: Maybe<Scalars['Date']>;
};

/** A filter to be used against `WireRequest` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `bankId` field. */
  bankId?: Maybe<StringFilter>;
  /** Filter by the object’s `vendorId` field. */
  vendorId?: Maybe<StringFilter>;
  /** Filter by the object’s `wireNumber` field. */
  wireNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `requestDate` field. */
  requestDate?: Maybe<DateFilter>;
  /** Filter by the object’s `wireDate` field. */
  wireDate?: Maybe<DateFilter>;
  /** Filter by the object’s `wireType` field. */
  wireType?: Maybe<StringFilter>;
  /** Filter by the object’s `approvalUserCode` field. */
  approvalUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `approvalDate` field. */
  approvalDate?: Maybe<DateFilter>;
  /** Filter by the object’s `requestUserCode` field. */
  requestUserCode?: Maybe<StringFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: Maybe<BooleanFilter>;
  /** Filter by the object’s `sentDate` field. */
  sentDate?: Maybe<DateFilter>;
  /** Filter by the object’s `searchText` field. */
  searchText?: Maybe<StringFilter>;
  /** Filter by the object’s `wireRequestOceanFreightItems` relation. */
  wireRequestOceanFreightItems?: Maybe<WireRequestToManyWireRequestOceanFreightItemFilter>;
  /** Some related `wireRequestOceanFreightItems` exist. */
  wireRequestOceanFreightItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `wireRequestShipperAdvanceItems` relation. */
  wireRequestShipperAdvanceItems?: Maybe<WireRequestToManyWireRequestShipperAdvanceItemFilter>;
  /** Some related `wireRequestShipperAdvanceItems` exist. */
  wireRequestShipperAdvanceItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `wireRequestAccountOfSaleItems` relation. */
  wireRequestAccountOfSaleItems?: Maybe<WireRequestToManyWireRequestAccountOfSaleItemFilter>;
  /** Some related `wireRequestAccountOfSaleItems` exist. */
  wireRequestAccountOfSaleItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `wireRequestMiscItems` relation. */
  wireRequestMiscItems?: Maybe<WireRequestToManyWireRequestMiscItemFilter>;
  /** Some related `wireRequestMiscItems` exist. */
  wireRequestMiscItemsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WireRequestFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WireRequestFilter>>;
  /** Negates the expression. */
  not?: Maybe<WireRequestFilter>;
};

/** An input for mutations affecting `WireRequest` */
export type WireRequestInput = {
  id?: Maybe<Scalars['BigInt']>;
  bankId: Scalars['String'];
  vendorId: Scalars['String'];
  wireNumber?: Maybe<Scalars['String']>;
  requestDate: Scalars['Date'];
  wireDate: Scalars['Date'];
  wireType: Scalars['String'];
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode: Scalars['String'];
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

export type WireRequestMiscItem = Node & {
  __typename?: 'WireRequestMiscItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  wireRequestId: Scalars['BigInt'];
  itemDescription: Scalars['String'];
  itemAmount: Scalars['BigFloat'];
  /** Reads a single `WireRequest` that is related to this `WireRequestMiscItem`. */
  wireRequest?: Maybe<WireRequest>;
};

/**
 * A condition to be used against `WireRequestMiscItem` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type WireRequestMiscItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `itemDescription` field. */
  itemDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `itemAmount` field. */
  itemAmount?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `WireRequestMiscItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestMiscItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `itemDescription` field. */
  itemDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `itemAmount` field. */
  itemAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `wireRequest` relation. */
  wireRequest?: Maybe<WireRequestFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WireRequestMiscItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WireRequestMiscItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<WireRequestMiscItemFilter>;
};

/** An input for mutations affecting `WireRequestMiscItem` */
export type WireRequestMiscItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  itemDescription: Scalars['String'];
  itemAmount: Scalars['BigFloat'];
  wireRequestToWireRequestId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WireRequestMiscItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `wireRequestMiscItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WireRequestMiscItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `wireRequestMiscItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type WireRequestMiscItemOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequest` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: WireRequestPatch;
};

/** The fields on `wireRequestMiscItem` to look up the row to update. */
export type WireRequestMiscItemOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyUsingWireRequestMiscItemPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequestMiscItem` being updated. */
  patch: UpdateWireRequestMiscItemOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `WireRequestMiscItem`. Fields that are set will be updated. */
export type WireRequestMiscItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  itemDescription?: Maybe<Scalars['String']>;
  itemAmount?: Maybe<Scalars['BigFloat']>;
  wireRequestToWireRequestId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInput>;
};

/** Input for the nested mutation of `wireRequest` in the `WireRequestMiscItemInput` mutation. */
export type WireRequestMiscItemWireRequestIdFkeyInput = {
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectById?: Maybe<WireRequestWireRequestPkeyConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectByNodeId?: Maybe<WireRequestNodeIdConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteById?: Maybe<WireRequestWireRequestPkeyDelete>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteByNodeId?: Maybe<WireRequestNodeIdDelete>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateById?: Maybe<WireRequestOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyUsingWireRequestPkeyUpdate>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateByNodeId?: Maybe<WireRequestMiscItemOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyNodeIdUpdate>;
  /** A `WireRequestInput` object that will be created and connected to this object. */
  create?: Maybe<WireRequestMiscItemWireRequestIdFkeyWireRequestCreateInput>;
};

/** Input for the nested mutation of `wireRequestMiscItem` in the `WireRequestInput` mutation. */
export type WireRequestMiscItemWireRequestIdFkeyInverseInput = {
  /** Flag indicating whether all other `wireRequestMiscItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `wireRequestMiscItem` for the far side of the relationship. */
  connectById?: Maybe<Array<WireRequestMiscItemWireRequestMiscItemPkeyConnect>>;
  /** The primary key(s) for `wireRequestMiscItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WireRequestMiscItemNodeIdConnect>>;
  /** The primary key(s) for `wireRequestMiscItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<WireRequestMiscItemWireRequestMiscItemPkeyDelete>>;
  /** The primary key(s) for `wireRequestMiscItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WireRequestMiscItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `wireRequestMiscItem` for the far side of the relationship. */
  updateById?: Maybe<Array<WireRequestMiscItemOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyUsingWireRequestMiscItemPkeyUpdate>>;
  /** The primary key(s) and patch data for `wireRequestMiscItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<WireRequestOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyNodeIdUpdate>>;
  /** A `WireRequestMiscItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WireRequestMiscItemWireRequestIdFkeyWireRequestMiscItemCreateInput>>;
};

/** The `wireRequest` to be created by this mutation. */
export type WireRequestMiscItemWireRequestIdFkeyWireRequestCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  bankId: Scalars['String'];
  vendorId: Scalars['String'];
  wireNumber?: Maybe<Scalars['String']>;
  requestDate: Scalars['Date'];
  wireDate: Scalars['Date'];
  wireType: Scalars['String'];
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode: Scalars['String'];
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** The `wireRequestMiscItem` to be created by this mutation. */
export type WireRequestMiscItemWireRequestIdFkeyWireRequestMiscItemCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  itemDescription: Scalars['String'];
  itemAmount: Scalars['BigFloat'];
  wireRequestToWireRequestId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInput>;
};

/** The fields on `wireRequestMiscItem` to look up the row to connect. */
export type WireRequestMiscItemWireRequestMiscItemPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `wireRequestMiscItem` to look up the row to delete. */
export type WireRequestMiscItemWireRequestMiscItemPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `WireRequestMiscItem` values. */
export type WireRequestMiscItemsConnection = {
  __typename?: 'WireRequestMiscItemsConnection';
  /** A list of `WireRequestMiscItem` objects. */
  nodes: Array<Maybe<WireRequestMiscItem>>;
  /** A list of edges which contains the `WireRequestMiscItem` and cursor to aid in pagination. */
  edges: Array<WireRequestMiscItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WireRequestMiscItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `WireRequestMiscItem` edge in the connection. */
export type WireRequestMiscItemsEdge = {
  __typename?: 'WireRequestMiscItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WireRequestMiscItem` at the end of the edge. */
  node?: Maybe<WireRequestMiscItem>;
};

/** Methods to use when ordering `WireRequestMiscItem`. */
export enum WireRequestMiscItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  WireRequestIdAsc = 'WIRE_REQUEST_ID_ASC',
  WireRequestIdDesc = 'WIRE_REQUEST_ID_DESC',
  ItemDescriptionAsc = 'ITEM_DESCRIPTION_ASC',
  ItemDescriptionDesc = 'ITEM_DESCRIPTION_DESC',
  ItemAmountAsc = 'ITEM_AMOUNT_ASC',
  ItemAmountDesc = 'ITEM_AMOUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WireRequestByWireRequestIdIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_ASC',
  WireRequestByWireRequestIdIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_DESC',
  WireRequestByWireRequestIdBankIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_ASC',
  WireRequestByWireRequestIdBankIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_DESC',
  WireRequestByWireRequestIdVendorIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_ASC',
  WireRequestByWireRequestIdVendorIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_DESC',
  WireRequestByWireRequestIdWireNumberAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_ASC',
  WireRequestByWireRequestIdWireNumberDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_DESC',
  WireRequestByWireRequestIdRequestDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_ASC',
  WireRequestByWireRequestIdRequestDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_DESC',
  WireRequestByWireRequestIdWireDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_ASC',
  WireRequestByWireRequestIdWireDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_DESC',
  WireRequestByWireRequestIdWireTypeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_ASC',
  WireRequestByWireRequestIdWireTypeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_DESC',
  WireRequestByWireRequestIdApprovalUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_ASC',
  WireRequestByWireRequestIdApprovalUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_DESC',
  WireRequestByWireRequestIdApprovalDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_ASC',
  WireRequestByWireRequestIdApprovalDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_DESC',
  WireRequestByWireRequestIdRequestUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_ASC',
  WireRequestByWireRequestIdRequestUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_DESC',
  WireRequestByWireRequestIdIsVerifiedAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_ASC',
  WireRequestByWireRequestIdIsVerifiedDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_DESC',
  WireRequestByWireRequestIdSentDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_ASC',
  WireRequestByWireRequestIdSentDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_DESC'
}

/** The globally unique `ID` look up for the row to connect. */
export type WireRequestNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `wireRequest` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WireRequestNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `wireRequest` to be deleted. */
  nodeId: Scalars['ID'];
};

export type WireRequestOceanFreightItem = Node & {
  __typename?: 'WireRequestOceanFreightItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  wireRequestId: Scalars['BigInt'];
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  shipperId: Scalars['String'];
  palletCount: Scalars['BigFloat'];
  freightAmount: Scalars['BigFloat'];
  receivedDate: Scalars['Date'];
  /** Reads a single `WireRequest` that is related to this `WireRequestOceanFreightItem`. */
  wireRequest?: Maybe<WireRequest>;
  shipper?: Maybe<Shipper>;
  vessel?: Maybe<Vessel>;
};

/**
 * A condition to be used against `WireRequestOceanFreightItem` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type WireRequestOceanFreightItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `billOfLading` field. */
  billOfLading?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shipperId` field. */
  shipperId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `palletCount` field. */
  palletCount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `freightAmount` field. */
  freightAmount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `receivedDate` field. */
  receivedDate?: Maybe<Scalars['Date']>;
};

/** A filter to be used against `WireRequestOceanFreightItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestOceanFreightItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `billOfLading` field. */
  billOfLading?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `shipperId` field. */
  shipperId?: Maybe<StringFilter>;
  /** Filter by the object’s `palletCount` field. */
  palletCount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `freightAmount` field. */
  freightAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `receivedDate` field. */
  receivedDate?: Maybe<DateFilter>;
  /** Filter by the object’s `wireRequest` relation. */
  wireRequest?: Maybe<WireRequestFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WireRequestOceanFreightItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WireRequestOceanFreightItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<WireRequestOceanFreightItemFilter>;
};

/** An input for mutations affecting `WireRequestOceanFreightItem` */
export type WireRequestOceanFreightItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  shipperId: Scalars['String'];
  palletCount: Scalars['BigFloat'];
  freightAmount: Scalars['BigFloat'];
  receivedDate: Scalars['Date'];
  wireRequestToWireRequestId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WireRequestOceanFreightItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `wireRequestOceanFreightItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WireRequestOceanFreightItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `wireRequestOceanFreightItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type WireRequestOceanFreightItemOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequest` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: WireRequestPatch;
};

/** The fields on `wireRequestOceanFreightItem` to look up the row to update. */
export type WireRequestOceanFreightItemOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyUsingWireRequestOceanFreightItemPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequestOceanFreightItem` being updated. */
  patch: UpdateWireRequestOceanFreightItemOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `WireRequestOceanFreightItem`. Fields that are set will be updated. */
export type WireRequestOceanFreightItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  billOfLading?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  freightAmount?: Maybe<Scalars['BigFloat']>;
  receivedDate?: Maybe<Scalars['Date']>;
  wireRequestToWireRequestId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInput>;
};

/** Input for the nested mutation of `wireRequest` in the `WireRequestOceanFreightItemInput` mutation. */
export type WireRequestOceanFreightItemWireRequestIdFkeyInput = {
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectById?: Maybe<WireRequestWireRequestPkeyConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectByNodeId?: Maybe<WireRequestNodeIdConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteById?: Maybe<WireRequestWireRequestPkeyDelete>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteByNodeId?: Maybe<WireRequestNodeIdDelete>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateById?: Maybe<WireRequestOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyUsingWireRequestPkeyUpdate>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateByNodeId?: Maybe<WireRequestOceanFreightItemOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyNodeIdUpdate>;
  /** A `WireRequestInput` object that will be created and connected to this object. */
  create?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyWireRequestCreateInput>;
};

/** Input for the nested mutation of `wireRequestOceanFreightItem` in the `WireRequestInput` mutation. */
export type WireRequestOceanFreightItemWireRequestIdFkeyInverseInput = {
  /** Flag indicating whether all other `wireRequestOceanFreightItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `wireRequestOceanFreightItem` for the far side of the relationship. */
  connectById?: Maybe<Array<WireRequestOceanFreightItemWireRequestOceanFreightItemPkeyConnect>>;
  /** The primary key(s) for `wireRequestOceanFreightItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WireRequestOceanFreightItemNodeIdConnect>>;
  /** The primary key(s) for `wireRequestOceanFreightItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<WireRequestOceanFreightItemWireRequestOceanFreightItemPkeyDelete>>;
  /** The primary key(s) for `wireRequestOceanFreightItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WireRequestOceanFreightItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `wireRequestOceanFreightItem` for the far side of the relationship. */
  updateById?: Maybe<Array<WireRequestOceanFreightItemOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyUsingWireRequestOceanFreightItemPkeyUpdate>>;
  /** The primary key(s) and patch data for `wireRequestOceanFreightItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<WireRequestOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyNodeIdUpdate>>;
  /** A `WireRequestOceanFreightItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WireRequestOceanFreightItemWireRequestIdFkeyWireRequestOceanFreightItemCreateInput>>;
};

/** The `wireRequest` to be created by this mutation. */
export type WireRequestOceanFreightItemWireRequestIdFkeyWireRequestCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  bankId: Scalars['String'];
  vendorId: Scalars['String'];
  wireNumber?: Maybe<Scalars['String']>;
  requestDate: Scalars['Date'];
  wireDate: Scalars['Date'];
  wireType: Scalars['String'];
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode: Scalars['String'];
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** The `wireRequestOceanFreightItem` to be created by this mutation. */
export type WireRequestOceanFreightItemWireRequestIdFkeyWireRequestOceanFreightItemCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  shipperId: Scalars['String'];
  palletCount: Scalars['BigFloat'];
  freightAmount: Scalars['BigFloat'];
  receivedDate: Scalars['Date'];
  wireRequestToWireRequestId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInput>;
};

/** The fields on `wireRequestOceanFreightItem` to look up the row to connect. */
export type WireRequestOceanFreightItemWireRequestOceanFreightItemPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `wireRequestOceanFreightItem` to look up the row to delete. */
export type WireRequestOceanFreightItemWireRequestOceanFreightItemPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `WireRequestOceanFreightItem` values. */
export type WireRequestOceanFreightItemsConnection = {
  __typename?: 'WireRequestOceanFreightItemsConnection';
  /** A list of `WireRequestOceanFreightItem` objects. */
  nodes: Array<Maybe<WireRequestOceanFreightItem>>;
  /** A list of edges which contains the `WireRequestOceanFreightItem` and cursor to aid in pagination. */
  edges: Array<WireRequestOceanFreightItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WireRequestOceanFreightItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `WireRequestOceanFreightItem` edge in the connection. */
export type WireRequestOceanFreightItemsEdge = {
  __typename?: 'WireRequestOceanFreightItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WireRequestOceanFreightItem` at the end of the edge. */
  node?: Maybe<WireRequestOceanFreightItem>;
};

/** Methods to use when ordering `WireRequestOceanFreightItem`. */
export enum WireRequestOceanFreightItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  WireRequestIdAsc = 'WIRE_REQUEST_ID_ASC',
  WireRequestIdDesc = 'WIRE_REQUEST_ID_DESC',
  BillOfLadingAsc = 'BILL_OF_LADING_ASC',
  BillOfLadingDesc = 'BILL_OF_LADING_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  ShipperIdAsc = 'SHIPPER_ID_ASC',
  ShipperIdDesc = 'SHIPPER_ID_DESC',
  PalletCountAsc = 'PALLET_COUNT_ASC',
  PalletCountDesc = 'PALLET_COUNT_DESC',
  FreightAmountAsc = 'FREIGHT_AMOUNT_ASC',
  FreightAmountDesc = 'FREIGHT_AMOUNT_DESC',
  ReceivedDateAsc = 'RECEIVED_DATE_ASC',
  ReceivedDateDesc = 'RECEIVED_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WireRequestByWireRequestIdIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_ASC',
  WireRequestByWireRequestIdIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_DESC',
  WireRequestByWireRequestIdBankIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_ASC',
  WireRequestByWireRequestIdBankIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_DESC',
  WireRequestByWireRequestIdVendorIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_ASC',
  WireRequestByWireRequestIdVendorIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_DESC',
  WireRequestByWireRequestIdWireNumberAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_ASC',
  WireRequestByWireRequestIdWireNumberDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_DESC',
  WireRequestByWireRequestIdRequestDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_ASC',
  WireRequestByWireRequestIdRequestDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_DESC',
  WireRequestByWireRequestIdWireDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_ASC',
  WireRequestByWireRequestIdWireDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_DESC',
  WireRequestByWireRequestIdWireTypeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_ASC',
  WireRequestByWireRequestIdWireTypeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_DESC',
  WireRequestByWireRequestIdApprovalUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_ASC',
  WireRequestByWireRequestIdApprovalUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_DESC',
  WireRequestByWireRequestIdApprovalDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_ASC',
  WireRequestByWireRequestIdApprovalDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_DESC',
  WireRequestByWireRequestIdRequestUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_ASC',
  WireRequestByWireRequestIdRequestUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_DESC',
  WireRequestByWireRequestIdIsVerifiedAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_ASC',
  WireRequestByWireRequestIdIsVerifiedDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_DESC',
  WireRequestByWireRequestIdSentDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_ASC',
  WireRequestByWireRequestIdSentDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_DESC'
}

/** The globally unique `ID` look up for the row to update. */
export type WireRequestOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequestAccountOfSaleItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequestAccountOfSaleItem` being updated. */
  patch: WireRequestAccountOfSaleItemPatch;
};

/** The fields on `wireRequest` to look up the row to update. */
export type WireRequestOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyUsingWireRequestPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: UpdateWireRequestOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type WireRequestOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequestMiscItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequestMiscItem` being updated. */
  patch: WireRequestMiscItemPatch;
};

/** The fields on `wireRequest` to look up the row to update. */
export type WireRequestOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyUsingWireRequestPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: UpdateWireRequestOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type WireRequestOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequestOceanFreightItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequestOceanFreightItem` being updated. */
  patch: WireRequestOceanFreightItemPatch;
};

/** The fields on `wireRequest` to look up the row to update. */
export type WireRequestOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyUsingWireRequestPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: UpdateWireRequestOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** The globally unique `ID` look up for the row to update. */
export type WireRequestOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequestShipperAdvanceItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequestShipperAdvanceItem` being updated. */
  patch: WireRequestShipperAdvanceItemPatch;
};

/** The fields on `wireRequest` to look up the row to update. */
export type WireRequestOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyUsingWireRequestPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: UpdateWireRequestOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `WireRequest`. Fields that are set will be updated. */
export type WireRequestPatch = {
  id?: Maybe<Scalars['BigInt']>;
  bankId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  wireNumber?: Maybe<Scalars['String']>;
  requestDate?: Maybe<Scalars['Date']>;
  wireDate?: Maybe<Scalars['Date']>;
  wireType?: Maybe<Scalars['String']>;
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode?: Maybe<Scalars['String']>;
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

export type WireRequestShipperAdvanceItem = Node & {
  __typename?: 'WireRequestShipperAdvanceItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  wireRequestId: Scalars['BigInt'];
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  speciesId: Scalars['String'];
  boxAmount: Scalars['BigFloat'];
  /** Reads a single `WireRequest` that is related to this `WireRequestShipperAdvanceItem`. */
  wireRequest?: Maybe<WireRequest>;
  species?: Maybe<ProductSpecies>;
  vessel?: Maybe<Vessel>;
};

/**
 * A condition to be used against `WireRequestShipperAdvanceItem` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type WireRequestShipperAdvanceItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `billOfLading` field. */
  billOfLading?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `vesselCode` field. */
  vesselCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `speciesId` field. */
  speciesId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `boxAmount` field. */
  boxAmount?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `WireRequestShipperAdvanceItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestShipperAdvanceItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<BigIntFilter>;
  /** Filter by the object’s `wireRequestId` field. */
  wireRequestId?: Maybe<BigIntFilter>;
  /** Filter by the object’s `billOfLading` field. */
  billOfLading?: Maybe<StringFilter>;
  /** Filter by the object’s `vesselCode` field. */
  vesselCode?: Maybe<StringFilter>;
  /** Filter by the object’s `speciesId` field. */
  speciesId?: Maybe<StringFilter>;
  /** Filter by the object’s `boxAmount` field. */
  boxAmount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `wireRequest` relation. */
  wireRequest?: Maybe<WireRequestFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<WireRequestShipperAdvanceItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<WireRequestShipperAdvanceItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<WireRequestShipperAdvanceItemFilter>;
};

/** An input for mutations affecting `WireRequestShipperAdvanceItem` */
export type WireRequestShipperAdvanceItemInput = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  speciesId: Scalars['String'];
  boxAmount: Scalars['BigFloat'];
  wireRequestToWireRequestId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type WireRequestShipperAdvanceItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `wireRequestShipperAdvanceItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type WireRequestShipperAdvanceItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `wireRequestShipperAdvanceItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type WireRequestShipperAdvanceItemOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `wireRequest` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `wireRequest` being updated. */
  patch: WireRequestPatch;
};

/** The fields on `wireRequestShipperAdvanceItem` to look up the row to update. */
export type WireRequestShipperAdvanceItemOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyUsingWireRequestShipperAdvanceItemPkeyUpdate = {
  /** An object where the defined keys will be set on the `wireRequestShipperAdvanceItem` being updated. */
  patch: UpdateWireRequestShipperAdvanceItemOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyPatch;
  id: Scalars['BigInt'];
};

/** Represents an update to a `WireRequestShipperAdvanceItem`. Fields that are set will be updated. */
export type WireRequestShipperAdvanceItemPatch = {
  id?: Maybe<Scalars['BigInt']>;
  wireRequestId?: Maybe<Scalars['BigInt']>;
  billOfLading?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  boxAmount?: Maybe<Scalars['BigFloat']>;
  wireRequestToWireRequestId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInput>;
};

/** Input for the nested mutation of `wireRequest` in the `WireRequestShipperAdvanceItemInput` mutation. */
export type WireRequestShipperAdvanceItemWireRequestIdFkeyInput = {
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectById?: Maybe<WireRequestWireRequestPkeyConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  connectByNodeId?: Maybe<WireRequestNodeIdConnect>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteById?: Maybe<WireRequestWireRequestPkeyDelete>;
  /** The primary key(s) for `wireRequest` for the far side of the relationship. */
  deleteByNodeId?: Maybe<WireRequestNodeIdDelete>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateById?: Maybe<WireRequestOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyUsingWireRequestPkeyUpdate>;
  /** The primary key(s) and patch data for `wireRequest` for the far side of the relationship. */
  updateByNodeId?: Maybe<WireRequestShipperAdvanceItemOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyNodeIdUpdate>;
  /** A `WireRequestInput` object that will be created and connected to this object. */
  create?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyWireRequestCreateInput>;
};

/** Input for the nested mutation of `wireRequestShipperAdvanceItem` in the `WireRequestInput` mutation. */
export type WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput = {
  /** Flag indicating whether all other `wireRequestShipperAdvanceItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `wireRequestShipperAdvanceItem` for the far side of the relationship. */
  connectById?: Maybe<Array<WireRequestShipperAdvanceItemWireRequestShipperAdvanceItemPkeyConnect>>;
  /** The primary key(s) for `wireRequestShipperAdvanceItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<WireRequestShipperAdvanceItemNodeIdConnect>>;
  /** The primary key(s) for `wireRequestShipperAdvanceItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<WireRequestShipperAdvanceItemWireRequestShipperAdvanceItemPkeyDelete>>;
  /** The primary key(s) for `wireRequestShipperAdvanceItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<WireRequestShipperAdvanceItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `wireRequestShipperAdvanceItem` for the far side of the relationship. */
  updateById?: Maybe<Array<WireRequestShipperAdvanceItemOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyUsingWireRequestShipperAdvanceItemPkeyUpdate>>;
  /** The primary key(s) and patch data for `wireRequestShipperAdvanceItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<WireRequestOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyNodeIdUpdate>>;
  /** A `WireRequestShipperAdvanceItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<WireRequestShipperAdvanceItemWireRequestIdFkeyWireRequestShipperAdvanceItemCreateInput>>;
};

/** The `wireRequest` to be created by this mutation. */
export type WireRequestShipperAdvanceItemWireRequestIdFkeyWireRequestCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  bankId: Scalars['String'];
  vendorId: Scalars['String'];
  wireNumber?: Maybe<Scalars['String']>;
  requestDate: Scalars['Date'];
  wireDate: Scalars['Date'];
  wireType: Scalars['String'];
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode: Scalars['String'];
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** The `wireRequestShipperAdvanceItem` to be created by this mutation. */
export type WireRequestShipperAdvanceItemWireRequestIdFkeyWireRequestShipperAdvanceItemCreateInput = {
  id?: Maybe<Scalars['BigInt']>;
  billOfLading: Scalars['String'];
  vesselCode: Scalars['String'];
  speciesId: Scalars['String'];
  boxAmount: Scalars['BigFloat'];
  wireRequestToWireRequestId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInput>;
};

/** The fields on `wireRequestShipperAdvanceItem` to look up the row to connect. */
export type WireRequestShipperAdvanceItemWireRequestShipperAdvanceItemPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `wireRequestShipperAdvanceItem` to look up the row to delete. */
export type WireRequestShipperAdvanceItemWireRequestShipperAdvanceItemPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `WireRequestShipperAdvanceItem` values. */
export type WireRequestShipperAdvanceItemsConnection = {
  __typename?: 'WireRequestShipperAdvanceItemsConnection';
  /** A list of `WireRequestShipperAdvanceItem` objects. */
  nodes: Array<Maybe<WireRequestShipperAdvanceItem>>;
  /** A list of edges which contains the `WireRequestShipperAdvanceItem` and cursor to aid in pagination. */
  edges: Array<WireRequestShipperAdvanceItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WireRequestShipperAdvanceItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `WireRequestShipperAdvanceItem` edge in the connection. */
export type WireRequestShipperAdvanceItemsEdge = {
  __typename?: 'WireRequestShipperAdvanceItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WireRequestShipperAdvanceItem` at the end of the edge. */
  node?: Maybe<WireRequestShipperAdvanceItem>;
};

/** Methods to use when ordering `WireRequestShipperAdvanceItem`. */
export enum WireRequestShipperAdvanceItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  WireRequestIdAsc = 'WIRE_REQUEST_ID_ASC',
  WireRequestIdDesc = 'WIRE_REQUEST_ID_DESC',
  BillOfLadingAsc = 'BILL_OF_LADING_ASC',
  BillOfLadingDesc = 'BILL_OF_LADING_DESC',
  VesselCodeAsc = 'VESSEL_CODE_ASC',
  VesselCodeDesc = 'VESSEL_CODE_DESC',
  SpeciesIdAsc = 'SPECIES_ID_ASC',
  SpeciesIdDesc = 'SPECIES_ID_DESC',
  BoxAmountAsc = 'BOX_AMOUNT_ASC',
  BoxAmountDesc = 'BOX_AMOUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WireRequestByWireRequestIdIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_ASC',
  WireRequestByWireRequestIdIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__ID_DESC',
  WireRequestByWireRequestIdBankIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_ASC',
  WireRequestByWireRequestIdBankIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__BANK_ID_DESC',
  WireRequestByWireRequestIdVendorIdAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_ASC',
  WireRequestByWireRequestIdVendorIdDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__VENDOR_ID_DESC',
  WireRequestByWireRequestIdWireNumberAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_ASC',
  WireRequestByWireRequestIdWireNumberDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_NUMBER_DESC',
  WireRequestByWireRequestIdRequestDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_ASC',
  WireRequestByWireRequestIdRequestDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_DATE_DESC',
  WireRequestByWireRequestIdWireDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_ASC',
  WireRequestByWireRequestIdWireDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_DATE_DESC',
  WireRequestByWireRequestIdWireTypeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_ASC',
  WireRequestByWireRequestIdWireTypeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__WIRE_TYPE_DESC',
  WireRequestByWireRequestIdApprovalUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_ASC',
  WireRequestByWireRequestIdApprovalUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_USER_CODE_DESC',
  WireRequestByWireRequestIdApprovalDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_ASC',
  WireRequestByWireRequestIdApprovalDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__APPROVAL_DATE_DESC',
  WireRequestByWireRequestIdRequestUserCodeAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_ASC',
  WireRequestByWireRequestIdRequestUserCodeDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__REQUEST_USER_CODE_DESC',
  WireRequestByWireRequestIdIsVerifiedAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_ASC',
  WireRequestByWireRequestIdIsVerifiedDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__IS_VERIFIED_DESC',
  WireRequestByWireRequestIdSentDateAsc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_ASC',
  WireRequestByWireRequestIdSentDateDesc = 'WIRE_REQUEST_BY_WIRE_REQUEST_ID__SENT_DATE_DESC'
}

/** A filter to be used against many `WireRequestAccountOfSaleItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestToManyWireRequestAccountOfSaleItemFilter = {
  /** Every related `WireRequestAccountOfSaleItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WireRequestAccountOfSaleItemFilter>;
  /** Some related `WireRequestAccountOfSaleItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WireRequestAccountOfSaleItemFilter>;
  /** No related `WireRequestAccountOfSaleItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WireRequestAccountOfSaleItemFilter>;
};

/** A filter to be used against many `WireRequestMiscItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestToManyWireRequestMiscItemFilter = {
  /** Every related `WireRequestMiscItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WireRequestMiscItemFilter>;
  /** Some related `WireRequestMiscItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WireRequestMiscItemFilter>;
  /** No related `WireRequestMiscItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WireRequestMiscItemFilter>;
};

/** A filter to be used against many `WireRequestOceanFreightItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestToManyWireRequestOceanFreightItemFilter = {
  /** Every related `WireRequestOceanFreightItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WireRequestOceanFreightItemFilter>;
  /** Some related `WireRequestOceanFreightItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WireRequestOceanFreightItemFilter>;
  /** No related `WireRequestOceanFreightItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WireRequestOceanFreightItemFilter>;
};

/** A filter to be used against many `WireRequestShipperAdvanceItem` object types. All fields are combined with a logical ‘and.’ */
export type WireRequestToManyWireRequestShipperAdvanceItemFilter = {
  /** Every related `WireRequestShipperAdvanceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<WireRequestShipperAdvanceItemFilter>;
  /** Some related `WireRequestShipperAdvanceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<WireRequestShipperAdvanceItemFilter>;
  /** No related `WireRequestShipperAdvanceItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<WireRequestShipperAdvanceItemFilter>;
};

/** The fields on `wireRequest` to look up the row to connect. */
export type WireRequestWireRequestPkeyConnect = {
  id: Scalars['BigInt'];
};

/** The fields on `wireRequest` to look up the row to delete. */
export type WireRequestWireRequestPkeyDelete = {
  id: Scalars['BigInt'];
};

/** A connection to a list of `WireRequest` values. */
export type WireRequestsConnection = {
  __typename?: 'WireRequestsConnection';
  /** A list of `WireRequest` objects. */
  nodes: Array<Maybe<WireRequest>>;
  /** A list of edges which contains the `WireRequest` and cursor to aid in pagination. */
  edges: Array<WireRequestsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WireRequest` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `WireRequest` edge in the connection. */
export type WireRequestsEdge = {
  __typename?: 'WireRequestsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WireRequest` at the end of the edge. */
  node?: Maybe<WireRequest>;
};

/** Methods to use when ordering `WireRequest`. */
export enum WireRequestsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BankIdAsc = 'BANK_ID_ASC',
  BankIdDesc = 'BANK_ID_DESC',
  VendorIdAsc = 'VENDOR_ID_ASC',
  VendorIdDesc = 'VENDOR_ID_DESC',
  WireNumberAsc = 'WIRE_NUMBER_ASC',
  WireNumberDesc = 'WIRE_NUMBER_DESC',
  RequestDateAsc = 'REQUEST_DATE_ASC',
  RequestDateDesc = 'REQUEST_DATE_DESC',
  WireDateAsc = 'WIRE_DATE_ASC',
  WireDateDesc = 'WIRE_DATE_DESC',
  WireTypeAsc = 'WIRE_TYPE_ASC',
  WireTypeDesc = 'WIRE_TYPE_DESC',
  ApprovalUserCodeAsc = 'APPROVAL_USER_CODE_ASC',
  ApprovalUserCodeDesc = 'APPROVAL_USER_CODE_DESC',
  ApprovalDateAsc = 'APPROVAL_DATE_ASC',
  ApprovalDateDesc = 'APPROVAL_DATE_DESC',
  RequestUserCodeAsc = 'REQUEST_USER_CODE_ASC',
  RequestUserCodeDesc = 'REQUEST_USER_CODE_DESC',
  IsVerifiedAsc = 'IS_VERIFIED_ASC',
  IsVerifiedDesc = 'IS_VERIFIED_DESC',
  SentDateAsc = 'SENT_DATE_ASC',
  SentDateDesc = 'SENT_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WireRequestOceanFreightItemsByWireRequestIdCountAsc = 'WIRE_REQUEST_OCEAN_FREIGHT_ITEMS_BY_WIRE_REQUEST_ID__COUNT_ASC',
  WireRequestOceanFreightItemsByWireRequestIdCountDesc = 'WIRE_REQUEST_OCEAN_FREIGHT_ITEMS_BY_WIRE_REQUEST_ID__COUNT_DESC',
  WireRequestShipperAdvanceItemsByWireRequestIdCountAsc = 'WIRE_REQUEST_SHIPPER_ADVANCE_ITEMS_BY_WIRE_REQUEST_ID__COUNT_ASC',
  WireRequestShipperAdvanceItemsByWireRequestIdCountDesc = 'WIRE_REQUEST_SHIPPER_ADVANCE_ITEMS_BY_WIRE_REQUEST_ID__COUNT_DESC',
  WireRequestAccountOfSaleItemsByWireRequestIdCountAsc = 'WIRE_REQUEST_ACCOUNT_OF_SALE_ITEMS_BY_WIRE_REQUEST_ID__COUNT_ASC',
  WireRequestAccountOfSaleItemsByWireRequestIdCountDesc = 'WIRE_REQUEST_ACCOUNT_OF_SALE_ITEMS_BY_WIRE_REQUEST_ID__COUNT_DESC',
  WireRequestMiscItemsByWireRequestIdCountAsc = 'WIRE_REQUEST_MISC_ITEMS_BY_WIRE_REQUEST_ID__COUNT_ASC',
  WireRequestMiscItemsByWireRequestIdCountDesc = 'WIRE_REQUEST_MISC_ITEMS_BY_WIRE_REQUEST_ID__COUNT_DESC'
}

/** An object where the defined keys will be set on the `commonCategory` being updated. */
export type UpdateCommonCategoryOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  categoryDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackType` being updated. */
export type UpdateCommonPackTypeOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackType` being updated. */
export type UpdateCommonPackTypeOnCommonPackTypeForCommonPackTypePackMasterIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackType` being updated. */
export type UpdateCommonPackTypeOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackType` being updated. */
export type UpdateCommonPackTypeOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackType` being updated. */
export type UpdateCommonPackTypeOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackType` being updated. */
export type UpdateCommonPackTypeOnShipperProgramForShipperProgramCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackType` being updated. */
export type UpdateCommonPackTypeOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packTypeName?: Maybe<Scalars['String']>;
  packTypeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigInt']>;
  repackStyleId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInverseInput>;
  commonPackTypeTagsUsingId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonPackTypePackMaster` being updated. */
export type UpdateCommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  packMasterId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonPackTypePackMaster` being updated. */
export type UpdateCommonPackTypePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypePackMasterCommonPackTypeIdFkeyInput>;
  packMasterToPackMasterId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonPackTypeTag` being updated. */
export type UpdateCommonPackTypeTagOnCommonPackTypeTagForCommonPackTypeTagCommonPackTypeIdFkeyPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonPackTypeToCommonPackTypeId?: Maybe<CommonPackTypeTagCommonPackTypeIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonSize` being updated. */
export type UpdateCommonSizeOnCommonSizeForCommonSizeCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSize` being updated. */
export type UpdateCommonSizeOnCommonSizeForCommonSizeProductSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSize` being updated. */
export type UpdateCommonSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSize` being updated. */
export type UpdateCommonSizeOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSize` being updated. */
export type UpdateCommonSizeOnCustomerProgramForCustomerProgramCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSize` being updated. */
export type UpdateCommonSizeOnShipperProgramForShipperProgramCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSize` being updated. */
export type UpdateCommonSizeOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sizeDescription?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSizeCommonSpeciesIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInverseInput>;
  commonSizeTagsUsingId?: Maybe<CommonSizeTagCommonSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSizeIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSizeProductSize` being updated. */
export type UpdateCommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  productSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonSizeProductSize` being updated. */
export type UpdateCommonSizeProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeProductSizeCommonSizeIdFkeyInput>;
  productSizeToProductSizeId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonSizeTag` being updated. */
export type UpdateCommonSizeTagOnCommonSizeTagForCommonSizeTagCommonSizeIdFkeyPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonSizeToCommonSizeId?: Maybe<CommonSizeTagCommonSizeIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCommonPackTypeForCommonPackTypeCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCommonSizeForCommonSizeCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCommonSpeciesForCommonSpeciesCommonCategoryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnShipperProgramForShipperProgramCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpecies` being updated. */
export type UpdateCommonSpeciesOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesName?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonCategoryId?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  commonCategoryToCommonCategoryId?: Maybe<CommonSpeciesCommonCategoryIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInverseInput>;
  commonVarietiesUsingId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInverseInput>;
  commonSizesUsingId?: Maybe<CommonSizeCommonSpeciesIdFkeyInverseInput>;
  commonPackTypesUsingId?: Maybe<CommonPackTypeCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesTagsUsingId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonSpeciesProductSpecies` being updated. */
export type UpdateCommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  productSpeciesId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonSpeciesProductSpecies` being updated. */
export type UpdateCommonSpeciesProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesProductSpeciesCommonSpeciesIdFkeyInput>;
  productSpeciesToProductSpeciesId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonSpeciesTag` being updated. */
export type UpdateCommonSpeciesTagOnCommonSpeciesTagForCommonSpeciesTagCommonSpeciesIdFkeyPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonSpeciesTagCommonSpeciesIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonVariety` being updated. */
export type UpdateCommonVarietyOnCommonVarietyForCommonVarietyCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonVariety` being updated. */
export type UpdateCommonVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonVariety` being updated. */
export type UpdateCommonVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonVariety` being updated. */
export type UpdateCommonVarietyOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonVariety` being updated. */
export type UpdateCommonVarietyOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonVariety` being updated. */
export type UpdateCommonVarietyOnShipperProgramForShipperProgramCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonVariety` being updated. */
export type UpdateCommonVarietyOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  varietyName?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  uiColor?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  defaultInvSortKey?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CommonVarietyCommonSpeciesIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyIdFkeyInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInverseInput>;
  commonVarietyTagsUsingId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCommonVarietyIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCommonVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `commonVarietyProductVariety` being updated. */
export type UpdateCommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  productVarietyId?: Maybe<Scalars['String']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonVarietyProductVariety` being updated. */
export type UpdateCommonVarietyProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyProductVarietyCommonVarietyIdFkeyInput>;
  productVarietyToProductVarietyId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInput>;
};

/** An object where the defined keys will be set on the `commonVarietyTag` being updated. */
export type UpdateCommonVarietyTagOnCommonVarietyTagForCommonVarietyTagCommonVarietyIdFkeyPatch = {
  tagText?: Maybe<Scalars['String']>;
  commonVarietyToCommonVarietyId?: Maybe<CommonVarietyTagCommonVarietyIdFkeyInput>;
};

/** An object where the defined keys will be set on the `contactGroup` being updated. */
export type UpdateContactGroupOnContactGroupForContactGroupUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription?: Maybe<Scalars['String']>;
  groupName?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `contactGroup` being updated. */
export type UpdateContactGroupOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  groupDescription?: Maybe<Scalars['String']>;
  groupName?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['BigInt']>;
  userToUserId?: Maybe<ContactGroupUserIdFkeyInput>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactGroupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
export type UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactGroupIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `contactGroupPersonContact` being updated. */
export type UpdateContactGroupPersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch = {
  groupId?: Maybe<Scalars['BigInt']>;
  contactGroupToGroupId?: Maybe<ContactGroupPersonContactGroupIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `container` being updated. */
export type UpdateContainerOnContainerTreatmentForContainerTreatmentContainerIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  warehouseId?: Maybe<Scalars['String']>;
  containerDescription?: Maybe<Scalars['String']>;
  releaseDate?: Maybe<Scalars['Date']>;
  releaseConfirmed?: Maybe<Scalars['Boolean']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  dischargeConfirmed?: Maybe<Scalars['Boolean']>;
  notes1?: Maybe<Scalars['String']>;
  notes2?: Maybe<Scalars['String']>;
  notes3?: Maybe<Scalars['String']>;
  sentConfirmed?: Maybe<Scalars['Boolean']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  isNew?: Maybe<Scalars['Boolean']>;
  isSchedule?: Maybe<Scalars['Boolean']>;
  containerTreatmentsUsingId?: Maybe<ContainerTreatmentContainerIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `containerTreatment` being updated. */
export type UpdateContainerTreatmentOnContainerTreatmentForContainerTreatmentContainerIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  treatmentDate?: Maybe<Scalars['Date']>;
  treatmentConfirmed?: Maybe<Scalars['Boolean']>;
  treatmentResult?: Maybe<Scalars['String']>;
  treatmentType?: Maybe<Scalars['String']>;
  treatmentNotes?: Maybe<Scalars['String']>;
  containerToContainerId?: Maybe<ContainerTreatmentContainerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnShipperForShipperCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  countryName?: Maybe<Scalars['String']>;
  cmbId?: Maybe<Scalars['String']>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnWarehouseForWarehouseCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  countryName?: Maybe<Scalars['String']>;
  cmbId?: Maybe<Scalars['String']>;
  shippersUsingId?: Maybe<ShipperCountryIdFkeyInverseInput>;
  warehousesUsingId?: Maybe<WarehouseCountryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnCustomerProgramForCustomerProgramCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnShipperProgramForShipperProgramCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  salesUserCode?: Maybe<Scalars['String']>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductCustomerIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactCustomerIdFkeyInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramCustomerIdFkeyInverseInput>;
  customerProgramsUsingId?: Maybe<CustomerProgramCustomerIdFkeyInverseInput>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerCustomerIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerPersonContact` being updated. */
export type UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactCustomerIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `customerPersonContact` being updated. */
export type UpdateCustomerPersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch = {
  customerId?: Maybe<Scalars['String']>;
  customerToCustomerId?: Maybe<CustomerPersonContactCustomerIdFkeyInput>;
  personContactToPersonContactId?: Maybe<CustomerPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `customerProgramEntry` being updated. */
export type UpdateCustomerProgramEntryOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  isAdWeek?: Maybe<Scalars['Boolean']>;
  customerProgramToCustomerProgramId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerProgramEntry` being updated. */
export type UpdateCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramId?: Maybe<Scalars['BigInt']>;
  isAdWeek?: Maybe<Scalars['Boolean']>;
  customerProgramToCustomerProgramId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerProgram` being updated. */
export type UpdateCustomerProgramOnCustomerProgramEntryForCustomerProgramEntryCustomerProgramIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerProgram` being updated. */
export type UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerProgram` being updated. */
export type UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerProgram` being updated. */
export type UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerProgram` being updated. */
export type UpdateCustomerProgramOnCustomerProgramForCustomerProgramCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `customerProgram` being updated. */
export type UpdateCustomerProgramOnCustomerProgramForCustomerProgramCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<CustomerProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<CustomerProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<CustomerProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<CustomerProgramCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<CustomerProgramCustomerIdFkeyInput>;
  customerProgramEntriesUsingId?: Maybe<CustomerProgramEntryCustomerProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `loadNumber` being updated. */
export type UpdateLoadNumberOnLoadNumberForLoadNumberUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<LoadNumberUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `orderEntryItem` being updated. */
export type UpdateOrderEntryItemOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryToOrderEntryId?: Maybe<OrderEntryItemOrderEntryIdFkeyInput>;
  orderEntryReviewItemsUsingId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `orderEntryItem` being updated. */
export type UpdateOrderEntryItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  orderEntryId?: Maybe<Scalars['BigInt']>;
  lineId?: Maybe<Scalars['BigFloat']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  unitSellPrice?: Maybe<Scalars['BigFloat']>;
  deliveryCharge?: Maybe<Scalars['BigFloat']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryToOrderEntryId?: Maybe<OrderEntryItemOrderEntryIdFkeyInput>;
  orderEntryReviewItemsUsingId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `orderEntry` being updated. */
export type UpdateOrderEntryOnOrderEntryItemForOrderEntryItemOrderEntryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  backOrderId?: Maybe<Scalars['BigFloat']>;
  truckLoadId?: Maybe<Scalars['String']>;
  fob?: Maybe<Scalars['Boolean']>;
  billingCustomerId?: Maybe<Scalars['String']>;
  salesUserCode?: Maybe<Scalars['String']>;
  customerPo?: Maybe<Scalars['String']>;
  fobDate?: Maybe<Scalars['Date']>;
  deliveredDate?: Maybe<Scalars['Date']>;
  orderDate?: Maybe<Scalars['Datetime']>;
  reviewUserCode?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  orderId?: Maybe<Scalars['BigFloat']>;
  reviewDate?: Maybe<Scalars['Datetime']>;
  submittedByUserCode?: Maybe<Scalars['String']>;
  orderEntryItemsUsingId?: Maybe<OrderEntryItemOrderEntryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `orderEntryReviewItem` being updated. */
export type UpdateOrderEntryReviewItemOnOrderEntryReviewItemForOrderEntryReviewItemOrderEntryItemIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  locationId?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  countryOfOrigin?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  boxCount?: Maybe<Scalars['BigFloat']>;
  palletWeight?: Maybe<Scalars['BigFloat']>;
  orderEntryItemToOrderEntryItemId?: Maybe<OrderEntryReviewItemOrderEntryItemIdFkeyInput>;
};

/** An object where the defined keys will be set on the `packMaster` being updated. */
export type UpdatePackMasterOnCommonPackTypeForCommonPackTypePackMasterIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  commonPackTypesUsingId?: Maybe<CommonPackTypePackMasterIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `packMaster` being updated. */
export type UpdatePackMasterOnCommonPackTypePackMasterForCommonPackTypePackMasterPackMasterIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  labelCodeId?: Maybe<Scalars['String']>;
  customerCodeId?: Maybe<Scalars['String']>;
  boxTypeId?: Maybe<Scalars['String']>;
  boxStyleId?: Maybe<Scalars['String']>;
  packStyleId?: Maybe<Scalars['String']>;
  outCodeId?: Maybe<Scalars['String']>;
  outQuantity?: Maybe<Scalars['String']>;
  outWeight?: Maybe<Scalars['String']>;
  productionCodeId?: Maybe<Scalars['String']>;
  treeRipeId?: Maybe<Scalars['String']>;
  gradeCodeId?: Maybe<Scalars['String']>;
  maCodeId?: Maybe<Scalars['String']>;
  linerCodeId?: Maybe<Scalars['String']>;
  netWeightContents?: Maybe<Scalars['BigFloat']>;
  netWeightBox?: Maybe<Scalars['BigFloat']>;
  boxLength?: Maybe<Scalars['BigFloat']>;
  boxWidth?: Maybe<Scalars['BigFloat']>;
  boxHeight?: Maybe<Scalars['BigFloat']>;
  palletTypeId?: Maybe<Scalars['String']>;
  defaultPalletQuantity?: Maybe<Scalars['BigFloat']>;
  pluUpcCode?: Maybe<Scalars['String']>;
  destinationCodeId?: Maybe<Scalars['String']>;
  oldPackCode?: Maybe<Scalars['String']>;
  oldLabelCode?: Maybe<Scalars['String']>;
  jvPackCode?: Maybe<Scalars['String']>;
  packDescription?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  holdCodeId?: Maybe<Scalars['String']>;
  commonPackTypesUsingId?: Maybe<CommonPackTypePackMasterIdFkeyInverseInput>;
  commonPackTypePackMastersUsingId?: Maybe<CommonPackTypePackMasterPackMasterIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnContactGroupPersonContactForContactGroupPersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnCustomerPersonContactForCustomerPersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnUserForUserPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `personContact` being updated. */
export type UpdatePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  isPrimary?: Maybe<Scalars['Boolean']>;
  email?: Maybe<Scalars['String']>;
  secondaryEmail?: Maybe<Scalars['String']>;
  homePhone?: Maybe<Scalars['String']>;
  cellPhone?: Maybe<Scalars['String']>;
  workPhone?: Maybe<Scalars['String']>;
  workExtension?: Maybe<Scalars['String']>;
  imageSrc?: Maybe<Scalars['String']>;
  isInternal?: Maybe<Scalars['Boolean']>;
  roles?: Maybe<Scalars['String']>;
  homeExtension?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  contactGroupPersonContactsUsingId?: Maybe<ContactGroupPersonContactPersonContactIdFkeyInverseInput>;
  usersUsingId?: Maybe<UserPersonContactIdFkeyInverseInput>;
  customerPersonContactsUsingId?: Maybe<CustomerPersonContactPersonContactIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactPersonContactIdFkeyInverseInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactPersonContactIdFkeyInverseInput>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactPersonContactIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `peruDepartureInspection` being updated. */
export type UpdatePeruDepartureInspectionOnPeruDepartureInspectionPalletForFkContainerPatch = {
  avgBunchesPerBox?: Maybe<Scalars['BigFloat']>;
  avgNetWeight?: Maybe<Scalars['BigFloat']>;
  bagsPerBox?: Maybe<Scalars['BigFloat']>;
  bagType?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  brixAvg?: Maybe<Scalars['BigFloat']>;
  brixMax?: Maybe<Scalars['BigFloat']>;
  brixMin?: Maybe<Scalars['BigFloat']>;
  category?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  departureWeek?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  exporter?: Maybe<Scalars['String']>;
  inspectionDate?: Maybe<Scalars['Date']>;
  packingDate?: Maybe<Scalars['Date']>;
  packingHouse?: Maybe<Scalars['String']>;
  packingMaterial?: Maybe<Scalars['String']>;
  presentation?: Maybe<Scalars['String']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  variety?: Maybe<Scalars['String']>;
  peruDepartureInspectionPalletsUsingContainerId?: Maybe<FkContainerInverseInput>;
};

/** An object where the defined keys will be set on the `peruDepartureInspectionPallet` being updated. */
export type UpdatePeruDepartureInspectionPalletOnPeruDepartureInspectionPalletForFkContainerPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletId?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  netWeight?: Maybe<Scalars['BigFloat']>;
  openingScore?: Maybe<Scalars['BigFloat']>;
  colorScore?: Maybe<Scalars['BigFloat']>;
  stemScore?: Maybe<Scalars['BigFloat']>;
  textureScore?: Maybe<Scalars['BigFloat']>;
  bunchesPerBox?: Maybe<Scalars['BigFloat']>;
  brix?: Maybe<Scalars['BigFloat']>;
  qualityScore?: Maybe<Scalars['BigFloat']>;
  conditionScore?: Maybe<Scalars['BigFloat']>;
  stragglyTightPct?: Maybe<Scalars['BigFloat']>;
  surfaceDiscPct?: Maybe<Scalars['BigFloat']>;
  russetScarsPct?: Maybe<Scalars['BigFloat']>;
  sunburnPct?: Maybe<Scalars['BigFloat']>;
  undersizedBunchesPct?: Maybe<Scalars['BigFloat']>;
  otherDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalQualityDefectsPct?: Maybe<Scalars['BigFloat']>;
  stemDehyPct?: Maybe<Scalars['BigFloat']>;
  glassyWeakPct?: Maybe<Scalars['BigFloat']>;
  decayPct?: Maybe<Scalars['BigFloat']>;
  splitCrushedPct?: Maybe<Scalars['BigFloat']>;
  drySplitPct?: Maybe<Scalars['BigFloat']>;
  wetStickyPct?: Maybe<Scalars['BigFloat']>;
  waterberriesPct?: Maybe<Scalars['BigFloat']>;
  shatterPct?: Maybe<Scalars['BigFloat']>;
  totalConditionDefectsPct?: Maybe<Scalars['BigFloat']>;
  totalDefectsPct?: Maybe<Scalars['BigFloat']>;
  peruDepartureInspectionToContainerId?: Maybe<FkContainerInput>;
};

/** An object where the defined keys will be set on the `priceCategory` being updated. */
export type UpdatePriceCategoryOnPriceProductForPriceProductCategoryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductsUsingId?: Maybe<PriceProductCategoryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `priceEntry` being updated. */
export type UpdatePriceEntryOnPriceEntryForPriceEntrySizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  entryDate?: Maybe<Scalars['Date']>;
  entryDescription?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  highlight?: Maybe<Scalars['Boolean']>;
  priceSizeToSizeId?: Maybe<PriceEntrySizeIdFkeyInput>;
};

/** An object where the defined keys will be set on the `priceProduct` being updated. */
export type UpdatePriceProductOnPriceProductForPriceProductCategoryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  color?: Maybe<Scalars['String']>;
  productName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `priceProduct` being updated. */
export type UpdatePriceProductOnPriceSizeForPriceSizeProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  categoryId?: Maybe<Scalars['BigInt']>;
  color?: Maybe<Scalars['String']>;
  productName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceCategoryToCategoryId?: Maybe<PriceProductCategoryIdFkeyInput>;
  priceSizesUsingId?: Maybe<PriceSizeProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `priceSize` being updated. */
export type UpdatePriceSizeOnPriceEntryForPriceEntrySizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  productId?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `priceSize` being updated. */
export type UpdatePriceSizeOnPriceSizeForPriceSizeProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  sizeName?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  priceProductToProductId?: Maybe<PriceSizeProductIdFkeyInput>;
  priceEntriesUsingId?: Maybe<PriceEntrySizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `productSize` being updated. */
export type UpdateProductSizeOnCommonSizeForCommonSizeProductSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSizesUsingId?: Maybe<CommonSizeProductSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `productSize` being updated. */
export type UpdateProductSizeOnCommonSizeProductSizeForCommonSizeProductSizeProductSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  speciesId?: Maybe<Scalars['String']>;
  varietyId?: Maybe<Scalars['String']>;
  jvCode?: Maybe<Scalars['String']>;
  jvDescription?: Maybe<Scalars['String']>;
  shipperCode?: Maybe<Scalars['String']>;
  shipperDescription?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  combineDescription?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSizesUsingId?: Maybe<CommonSizeProductSizeIdFkeyInverseInput>;
  commonSizeProductSizesUsingId?: Maybe<CommonSizeProductSizeProductSizeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `productSpecies` being updated. */
export type UpdateProductSpeciesOnCommonSpeciesForCommonSpeciesProductSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `productSpecies` being updated. */
export type UpdateProductSpeciesOnCommonSpeciesProductSpeciesForCommonSpeciesProductSpeciesProductSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `productSpecies` being updated. */
export type UpdateProductSpeciesOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  speciesDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  fdaProductCode?: Maybe<Scalars['String']>;
  fdaIndustryCode?: Maybe<Scalars['String']>;
  defaultTemperature?: Maybe<Scalars['String']>;
  commonSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesIdFkeyInverseInput>;
  commonSpeciesProductSpeciesUsingId?: Maybe<CommonSpeciesProductSpeciesProductSpeciesIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceSpeciesIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `productVariety` being updated. */
export type UpdateProductVarietyOnCommonVarietyForCommonVarietyProductVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  commonVarietiesUsingId?: Maybe<CommonVarietyProductVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `productVariety` being updated. */
export type UpdateProductVarietyOnCommonVarietyProductVarietyForCommonVarietyProductVarietyProductVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  varietyDescription?: Maybe<Scalars['String']>;
  secondaryDescription?: Maybe<Scalars['String']>;
  customerLetterSequence?: Maybe<Scalars['String']>;
  summaryCode?: Maybe<Scalars['String']>;
  varietyGroup?: Maybe<Scalars['String']>;
  combineWith?: Maybe<Scalars['String']>;
  commonVarietiesUsingId?: Maybe<CommonVarietyProductVarietyIdFkeyInverseInput>;
  commonVarietyProductVarietiesUsingId?: Maybe<CommonVarietyProductVarietyProductVarietyIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperAdvance` being updated. */
export type UpdateShipperAdvanceOnShipperAdvanceForShipperAdvanceShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  advanceAmount?: Maybe<Scalars['BigFloat']>;
  speciesId?: Maybe<Scalars['String']>;
  productSpeciesToSpeciesId?: Maybe<ShipperAdvanceSpeciesIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperAdvanceShipperIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipperAdvance` being updated. */
export type UpdateShipperAdvanceOnShipperAdvanceForShipperAdvanceSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  advanceAmount?: Maybe<Scalars['BigFloat']>;
  shipperId?: Maybe<Scalars['String']>;
  productSpeciesToSpeciesId?: Maybe<ShipperAdvanceSpeciesIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperAdvanceShipperIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperAdvanceForShipperAdvanceShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperForShipperCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProgramForShipperProgramShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProjectionForShipperProjectionShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipper` being updated. */
export type UpdateShipperOnShipperProjectionVesselInfoForFkShipperIdPatch = {
  id?: Maybe<Scalars['String']>;
  shipperName?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  groupId?: Maybe<Scalars['String']>;
  logoSrc?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sendProjectionRequest?: Maybe<Scalars['Boolean']>;
  projectionRequestStartDate?: Maybe<Scalars['Date']>;
  projectionRequestEndDate?: Maybe<Scalars['Date']>;
  vesselControlDaysUntilDue?: Maybe<Scalars['BigFloat']>;
  psaShipperId?: Maybe<Scalars['String']>;
  commissionRate?: Maybe<Scalars['BigFloat']>;
  countryToCountryId?: Maybe<ShipperCountryIdFkeyInput>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselShipperIdFkeyInverseInput>;
  shipperProjectionProductsUsingId?: Maybe<ShipperProjectionProductShipperIdFkeyInverseInput>;
  shipperProjectionsUsingId?: Maybe<ShipperProjectionShipperIdFkeyInverseInput>;
  shipperPersonContactsUsingId?: Maybe<ShipperPersonContactShipperIdFkeyInverseInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<FkShipperIdInverseInput>;
  shipperProgramsUsingId?: Maybe<ShipperProgramShipperIdFkeyInverseInput>;
  shipperAdvancesUsingId?: Maybe<ShipperAdvanceShipperIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
export type UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactPersonContactIdFkeyPatch = {
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipperPersonContact` being updated. */
export type UpdateShipperPersonContactOnShipperPersonContactForShipperPersonContactShipperIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperPersonContactShipperIdFkeyInput>;
  personContactToPersonContactId?: Maybe<ShipperPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipperProgramEntryCustomerProgramEntry` being updated. */
export type UpdateShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramEntryId?: Maybe<Scalars['BigInt']>;
  customerProgramEntryToCustomerProgramEntryId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInput>;
  shipperProgramEntryToShipperProgramEntryId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipperProgramEntryCustomerProgramEntry` being updated. */
export type UpdateShipperProgramEntryCustomerProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  customerProgramEntryId?: Maybe<Scalars['BigInt']>;
  customerProgramEntryToCustomerProgramEntryId?: Maybe<ShipperProgramEntryCustomerPCustomerProgramEntryIdFkeyInput>;
  shipperProgramEntryToShipperProgramEntryId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipperProgramEntry` being updated. */
export type UpdateShipperProgramEntryOnShipperProgramEntryCustomerProgramEntryForShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramId?: Maybe<Scalars['BigInt']>;
  shipperProgramToShipperProgramId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgramEntry` being updated. */
export type UpdateShipperProgramEntryOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  notes?: Maybe<Scalars['String']>;
  programDate?: Maybe<Scalars['Date']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  shipperProgramToShipperProgramId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInput>;
  shipperProgramEntryCustomerProgramEntriesUsingId?: Maybe<ShipperProgramEntryCustomerPrShipperProgramEntryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgram` being updated. */
export type UpdateShipperProgramOnShipperProgramEntryForShipperProgramEntryShipperProgramIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgram` being updated. */
export type UpdateShipperProgramOnShipperProgramForShipperProgramCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgram` being updated. */
export type UpdateShipperProgramOnShipperProgramForShipperProgramCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgram` being updated. */
export type UpdateShipperProgramOnShipperProgramForShipperProgramCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgram` being updated. */
export type UpdateShipperProgramOnShipperProgramForShipperProgramCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgram` being updated. */
export type UpdateShipperProgramOnShipperProgramForShipperProgramCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProgram` being updated. */
export type UpdateShipperProgramOnShipperProgramForShipperProgramShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  arrivalPort?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  customerId?: Maybe<Scalars['String']>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProgramCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProgramCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProgramCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProgramCommonPackTypeIdFkeyInput>;
  shipperToShipperId?: Maybe<ShipperProgramShipperIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProgramCustomerIdFkeyInput>;
  shipperProgramEntriesUsingId?: Maybe<ShipperProgramEntryShipperProgramIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
export type UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  vesselInfoId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselInfoToVesselInfoId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionEntry` being updated. */
export type UpdateShipperProjectionEntryOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  productId?: Maybe<Scalars['BigInt']>;
  shipperProjectionVesselInfoToVesselInfoId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInput>;
  shipperProjectionProductToProductId?: Maybe<ShipperProjectionEntryProductIdFkeyInput>;
};

/** An object where the defined keys will be set on the `shipperProjection` being updated. */
export type UpdateShipperProjectionOnShipperProjectionForShipperProjectionShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  submittedAt?: Maybe<Scalars['Datetime']>;
  shipperComments?: Maybe<Scalars['String']>;
  jvComments?: Maybe<Scalars['String']>;
  approvedAt?: Maybe<Scalars['Datetime']>;
  rejectedAt?: Maybe<Scalars['Datetime']>;
  reviewStatus?: Maybe<Scalars['Int']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjection` being updated. */
export type UpdateShipperProjectionOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  submittedAt?: Maybe<Scalars['Datetime']>;
  shipperComments?: Maybe<Scalars['String']>;
  jvComments?: Maybe<Scalars['String']>;
  approvedAt?: Maybe<Scalars['Datetime']>;
  rejectedAt?: Maybe<Scalars['Datetime']>;
  shipperId?: Maybe<Scalars['String']>;
  reviewStatus?: Maybe<Scalars['Int']>;
  shipperToShipperId?: Maybe<ShipperProjectionShipperIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionEntryForShipperProjectionEntryProductIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonPackTypeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSizeIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonSpeciesIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCommonVarietyIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductCustomerIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionProduct` being updated. */
export type UpdateShipperProjectionProductOnShipperProjectionProductForShipperProjectionProductShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  species?: Maybe<Scalars['String']>;
  variety?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  packType?: Maybe<Scalars['String']>;
  plu?: Maybe<Scalars['String']>;
  commonSpeciesId?: Maybe<Scalars['BigInt']>;
  commonVarietyId?: Maybe<Scalars['BigInt']>;
  commonSizeId?: Maybe<Scalars['BigInt']>;
  commonPackTypeId?: Maybe<Scalars['BigInt']>;
  customerId?: Maybe<Scalars['String']>;
  customerValue?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionProductShipperIdFkeyInput>;
  commonSpeciesToCommonSpeciesId?: Maybe<ShipperProjectionProductCommonSpeciesIdFkeyInput>;
  commonVarietyToCommonVarietyId?: Maybe<ShipperProjectionProductCommonVarietyIdFkeyInput>;
  commonSizeToCommonSizeId?: Maybe<ShipperProjectionProductCommonSizeIdFkeyInput>;
  commonPackTypeToCommonPackTypeId?: Maybe<ShipperProjectionProductCommonPackTypeIdFkeyInput>;
  customerToCustomerId?: Maybe<ShipperProjectionProductCustomerIdFkeyInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryProductIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
export type UpdateShipperProjectionVesselInfoOnShipperProjectionEntryForShipperProjectionEntryVesselInfoIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
export type UpdateShipperProjectionVesselInfoOnShipperProjectionVesselInfoForFkShipperIdPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
export type UpdateShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoProjectionIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionVesselInfo` being updated. */
export type UpdateShipperProjectionVesselInfoOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselName?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  arrivalPort?: Maybe<Scalars['String']>;
  vesselStatus?: Maybe<Scalars['String']>;
  projectionId?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperProjectionToProjectionId?: Maybe<ShipperProjectionVesselInfoProjectionIdFkeyInput>;
  shipperProjectionVesselToVesselId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInput>;
  shipperToShipperId?: Maybe<FkShipperIdInput>;
  shipperProjectionEntriesUsingId?: Maybe<ShipperProjectionEntryVesselInfoIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
export type UpdateShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselShipperIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselId?: Maybe<Scalars['BigInt']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
export type UpdateShipperProjectionVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `shipperProjectionVessel` being updated. */
export type UpdateShipperProjectionVesselOnShipperProjectionVesselInfoForShipperProjectionVesselInfoVesselIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  shipperId?: Maybe<Scalars['String']>;
  shipperToShipperId?: Maybe<ShipperProjectionVesselShipperIdFkeyInput>;
  vesselToVesselId?: Maybe<ShipperProjectionVesselVesselIdFkeyInput>;
  shipperProjectionVesselInfosUsingId?: Maybe<ShipperProjectionVesselInfoVesselIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `truckRateCustomer` being updated. */
export type UpdateTruckRateCustomerOnTruckRateCustomerForTruckRateCustomerCustomerIdFkeyPatch = {
  truckRateId?: Maybe<Scalars['BigInt']>;
  truckRateToTruckRateId?: Maybe<TruckRateCustomerTruckRateIdFkeyInput>;
  customerToCustomerId?: Maybe<TruckRateCustomerCustomerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `truckRateCustomer` being updated. */
export type UpdateTruckRateCustomerOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyPatch = {
  customerId?: Maybe<Scalars['String']>;
  truckRateToTruckRateId?: Maybe<TruckRateCustomerTruckRateIdFkeyInput>;
  customerToCustomerId?: Maybe<TruckRateCustomerCustomerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `truckRate` being updated. */
export type UpdateTruckRateOnTruckRateCustomerForTruckRateCustomerTruckRateIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  locationDescription?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  isDefault?: Maybe<Scalars['Boolean']>;
  fullLoadRate?: Maybe<Scalars['BigFloat']>;
  palletRate1?: Maybe<Scalars['BigFloat']>;
  palletRate2?: Maybe<Scalars['BigFloat']>;
  palletRate3?: Maybe<Scalars['BigFloat']>;
  palletRate4?: Maybe<Scalars['BigFloat']>;
  palletRate5?: Maybe<Scalars['BigFloat']>;
  palletRate6?: Maybe<Scalars['BigFloat']>;
  palletRate7?: Maybe<Scalars['BigFloat']>;
  palletRate8?: Maybe<Scalars['BigFloat']>;
  palletRate9?: Maybe<Scalars['BigFloat']>;
  palletRate10?: Maybe<Scalars['BigFloat']>;
  palletRate11?: Maybe<Scalars['BigFloat']>;
  palletRate12?: Maybe<Scalars['BigFloat']>;
  palletRate13?: Maybe<Scalars['BigFloat']>;
  palletRate14?: Maybe<Scalars['BigFloat']>;
  palletRate15?: Maybe<Scalars['BigFloat']>;
  notes?: Maybe<Scalars['String']>;
  truckRateCustomersUsingId?: Maybe<TruckRateCustomerTruckRateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `userBookmark` being updated. */
export type UpdateUserBookmarkOnUserBookmarkForUserBookmarkUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  category?: Maybe<Scalars['String']>;
  linkUrl?: Maybe<Scalars['String']>;
  linkDescription?: Maybe<Scalars['String']>;
  sortOrder?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<UserBookmarkUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `userMessage` being updated. */
export type UpdateUserMessageOnUserMessageForUserMessageUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  actionLink?: Maybe<Scalars['String']>;
  actionText?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  isRead?: Maybe<Scalars['Boolean']>;
  messageDate?: Maybe<Scalars['Datetime']>;
  priority?: Maybe<Scalars['BigFloat']>;
  userToUserId?: Maybe<UserMessageUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnContactGroupForContactGroupUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnLoadNumberForLoadNumberUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserBookmarkForUserBookmarkUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserForUserPersonContactIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserMessageForUserMessageUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserRoleForUserRoleUserIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  pin?: Maybe<Scalars['String']>;
  personContactId?: Maybe<Scalars['BigInt']>;
  userCode?: Maybe<Scalars['String']>;
  defaultCoast?: Maybe<Scalars['String']>;
  personContactToPersonContactId?: Maybe<UserPersonContactIdFkeyInput>;
  contactGroupsUsingId?: Maybe<ContactGroupUserIdFkeyInverseInput>;
  userMessagesUsingId?: Maybe<UserMessageUserIdFkeyInverseInput>;
  userRolesUsingId?: Maybe<UserRoleUserIdFkeyInverseInput>;
  loadNumbersUsingId?: Maybe<LoadNumberUserIdFkeyInverseInput>;
  userBookmarksUsingId?: Maybe<UserBookmarkUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `userRole` being updated. */
export type UpdateUserRoleOnUserRoleForUserRoleUserIdFkeyPatch = {
  roleName?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<UserRoleUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `vendor` being updated. */
export type UpdateVendorOnVendorPersonContactForVendorPersonContactVendorIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  vendorName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  attention?: Maybe<Scalars['String']>;
  vendorType?: Maybe<Scalars['String']>;
  ledgerCode?: Maybe<Scalars['String']>;
  bankCode?: Maybe<Scalars['String']>;
  has1099?: Maybe<Scalars['Boolean']>;
  id1099?: Maybe<Scalars['String']>;
  isTemp?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  vendorPersonContactsUsingId?: Maybe<VendorPersonContactVendorIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `vendorPersonContact` being updated. */
export type UpdateVendorPersonContactOnVendorPersonContactForVendorPersonContactPersonContactIdFkeyPatch = {
  vendorId?: Maybe<Scalars['String']>;
  vendorToVendorId?: Maybe<VendorPersonContactVendorIdFkeyInput>;
  personContactToPersonContactId?: Maybe<VendorPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `vendorPersonContact` being updated. */
export type UpdateVendorPersonContactOnVendorPersonContactForVendorPersonContactVendorIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  vendorToVendorId?: Maybe<VendorPersonContactVendorIdFkeyInput>;
  personContactToPersonContactId?: Maybe<VendorPersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `vessel` being updated. */
export type UpdateVesselOnShipperProjectionVesselForShipperProjectionVesselVesselIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  vesselCode?: Maybe<Scalars['String']>;
  vesselName?: Maybe<Scalars['String']>;
  arrivalPort?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  departureDate?: Maybe<Scalars['Date']>;
  arrivalDate?: Maybe<Scalars['Date']>;
  dischargeDate?: Maybe<Scalars['Date']>;
  coast?: Maybe<Scalars['String']>;
  isPre?: Maybe<Scalars['Boolean']>;
  preVesselCode?: Maybe<Scalars['String']>;
  invFlag?: Maybe<Scalars['Boolean']>;
  scheduleNotes?: Maybe<Scalars['String']>;
  isAvailable?: Maybe<Scalars['Boolean']>;
  shipperProjectionVesselsUsingId?: Maybe<ShipperProjectionVesselVesselIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `warehouse` being updated. */
export type UpdateWarehouseOnWarehouseForWarehouseCountryIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  warehouseName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `warehouse` being updated. */
export type UpdateWarehouseOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch = {
  id?: Maybe<Scalars['String']>;
  warehouseName?: Maybe<Scalars['String']>;
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  address3?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postalState?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  outQueue?: Maybe<Scalars['String']>;
  stateTaxCode?: Maybe<Scalars['String']>;
  countyTaxCode?: Maybe<Scalars['String']>;
  cityTaxCode?: Maybe<Scalars['String']>;
  miscTaxCode?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<WarehouseCountryIdFkeyInput>;
  warehousePersonContactsUsingId?: Maybe<WarehousePersonContactWarehouseIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
export type UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactPersonContactIdFkeyPatch = {
  warehouseId?: Maybe<Scalars['String']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `warehousePersonContact` being updated. */
export type UpdateWarehousePersonContactOnWarehousePersonContactForWarehousePersonContactWarehouseIdFkeyPatch = {
  personContactId?: Maybe<Scalars['BigInt']>;
  warehouseToWarehouseId?: Maybe<WarehousePersonContactWarehouseIdFkeyInput>;
  personContactToPersonContactId?: Maybe<WarehousePersonContactPersonContactIdFkeyInput>;
};

/** An object where the defined keys will be set on the `wireRequestAccountOfSaleItem` being updated. */
export type UpdateWireRequestAccountOfSaleItemOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  billOfLading?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  wireRequestToWireRequestId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInput>;
};

/** An object where the defined keys will be set on the `wireRequestMiscItem` being updated. */
export type UpdateWireRequestMiscItemOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  itemDescription?: Maybe<Scalars['String']>;
  itemAmount?: Maybe<Scalars['BigFloat']>;
  wireRequestToWireRequestId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInput>;
};

/** An object where the defined keys will be set on the `wireRequestOceanFreightItem` being updated. */
export type UpdateWireRequestOceanFreightItemOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  billOfLading?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  shipperId?: Maybe<Scalars['String']>;
  palletCount?: Maybe<Scalars['BigFloat']>;
  freightAmount?: Maybe<Scalars['BigFloat']>;
  receivedDate?: Maybe<Scalars['Date']>;
  wireRequestToWireRequestId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInput>;
};

/** An object where the defined keys will be set on the `wireRequest` being updated. */
export type UpdateWireRequestOnWireRequestAccountOfSaleItemForWireRequestAccountOfSaleItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  bankId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  wireNumber?: Maybe<Scalars['String']>;
  requestDate?: Maybe<Scalars['Date']>;
  wireDate?: Maybe<Scalars['Date']>;
  wireType?: Maybe<Scalars['String']>;
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode?: Maybe<Scalars['String']>;
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `wireRequest` being updated. */
export type UpdateWireRequestOnWireRequestMiscItemForWireRequestMiscItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  bankId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  wireNumber?: Maybe<Scalars['String']>;
  requestDate?: Maybe<Scalars['Date']>;
  wireDate?: Maybe<Scalars['Date']>;
  wireType?: Maybe<Scalars['String']>;
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode?: Maybe<Scalars['String']>;
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `wireRequest` being updated. */
export type UpdateWireRequestOnWireRequestOceanFreightItemForWireRequestOceanFreightItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  bankId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  wireNumber?: Maybe<Scalars['String']>;
  requestDate?: Maybe<Scalars['Date']>;
  wireDate?: Maybe<Scalars['Date']>;
  wireType?: Maybe<Scalars['String']>;
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode?: Maybe<Scalars['String']>;
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `wireRequest` being updated. */
export type UpdateWireRequestOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  bankId?: Maybe<Scalars['String']>;
  vendorId?: Maybe<Scalars['String']>;
  wireNumber?: Maybe<Scalars['String']>;
  requestDate?: Maybe<Scalars['Date']>;
  wireDate?: Maybe<Scalars['Date']>;
  wireType?: Maybe<Scalars['String']>;
  approvalUserCode?: Maybe<Scalars['String']>;
  approvalDate?: Maybe<Scalars['Date']>;
  requestUserCode?: Maybe<Scalars['String']>;
  isVerified?: Maybe<Scalars['Boolean']>;
  sentDate?: Maybe<Scalars['Date']>;
  wireRequestOceanFreightItemsUsingId?: Maybe<WireRequestOceanFreightItemWireRequestIdFkeyInverseInput>;
  wireRequestShipperAdvanceItemsUsingId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInverseInput>;
  wireRequestAccountOfSaleItemsUsingId?: Maybe<WireRequestAccountOfSaleItemWireRequestIdFkeyInverseInput>;
  wireRequestMiscItemsUsingId?: Maybe<WireRequestMiscItemWireRequestIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `wireRequestShipperAdvanceItem` being updated. */
export type UpdateWireRequestShipperAdvanceItemOnWireRequestShipperAdvanceItemForWireRequestShipperAdvanceItemWireRequestIdFkeyPatch = {
  id?: Maybe<Scalars['BigInt']>;
  billOfLading?: Maybe<Scalars['String']>;
  vesselCode?: Maybe<Scalars['String']>;
  speciesId?: Maybe<Scalars['String']>;
  boxAmount?: Maybe<Scalars['BigFloat']>;
  wireRequestToWireRequestId?: Maybe<WireRequestShipperAdvanceItemWireRequestIdFkeyInput>;
};
